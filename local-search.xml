<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>unicorn原理浅析</title>
    <link href="/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="unicorn是什么？"><a href="#unicorn是什么？" class="headerlink" title="unicorn是什么？"></a>unicorn是什么？</h1><p><strong>Unicorn</strong> 是一个基于 QEMU 的轻量级 CPU 仿真框架，用于模拟多种架构（如 ARM、x86、MIPS 等）的指令执行和状态变化。其本质是通过 <strong>动态二进制翻译</strong> (Dynamic Binary Translation) 将目标架构的指令翻译为宿主架构可执行代码，并在宿主机运行。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ul><li><strong>多架构支持</strong>：支持 ARM、x86、MIPS 等主流架构及模式（如 ARM&#x2F;Thumb）。</li><li><strong>指令仿真</strong>：精准模拟 CPU 指令行为（如跳转、寄存器操作、内存访问等）。</li><li><strong>内存与寄存器仿真</strong>：用户可自定义虚拟内存布局及操作寄存器。</li><li><strong>钩子机制</strong>：支持拦截指令、内存访问等，便于监控和调试。</li></ul><h3 id="本质特点"><a href="#本质特点" class="headerlink" title="本质特点"></a><strong>本质特点</strong></h3><ul><li><strong>动态翻译</strong>：基于 QEMU 的 TCG 技术，直接在宿主机运行目标指令，高效快捷。</li><li><strong>模块化</strong>：仅关注 CPU 指令仿真，易用、灵活，适合安全研究、逆向工程和嵌入式开发。</li></ul><h1 id="ARM64的体系架构"><a href="#ARM64的体系架构" class="headerlink" title="ARM64的体系架构"></a>ARM64的体系架构</h1><p>见上篇文章：ARM64架构</p><h1 id="unicorn怎么运行起来的？"><a href="#unicorn怎么运行起来的？" class="headerlink" title="unicorn怎么运行起来的？"></a>unicorn怎么运行起来的？</h1><p>CPU的运行，本质上就是：从内存中读取指令，并运行指令（包括输出结果，到对应内存地址或寄存器）</p><p>Unicorn要模拟的是CPU的运行。所以也就（只）是，把代码放到对应的地址上，Unicorn开始运行，去对应地址：<strong>读取指令</strong>，（解析并）<strong>执行指令</strong>，而解析和运行该指令的结果，往往是，本身就是，写入计算后的结果到对应的寄存器或内存而已。</p><p>而在指令执行期间的所需要的其他内容，比如后续会涉及到的函数参数、Stack栈、Heap堆等等，则都是为了：确保Unicorn模拟CPU的结果，和真实的代码执行的结果，要（完全）一致，才有价值，才能真正得到的希望的输出的结果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">指令<span class="hljs-operator">=</span>instruction <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 代码<span class="hljs-operator">=</span>code <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 操作码<span class="hljs-operator">=</span>opcode <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 二进制(数据) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> binary (data)<br></code></pre></td></tr></table></figure><h2 id="怎么模拟出内存等结构的？"><a href="#怎么模拟出内存等结构的？" class="headerlink" title="怎么模拟出内存等结构的？"></a>怎么模拟出内存等结构的？</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p><img src="https://s2.loli.net/2024/12/17/kpMjRTFBOX3Qv2V.png" alt="image-20241217103506135"></p><p>一个常见的内存布局如下：</p><table><thead><tr><th><strong>内存区域</strong></th><th><strong>起始地址</strong></th><th><strong>大小</strong></th><th><strong>权限</strong></th></tr></thead><tbody><tr><td>代码段</td><td><code>0x40000</code></td><td>2 MB</td><td>可读可执行（RX）</td></tr><tr><td>数据段</td><td><code>0x42000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆区</td><td><code>0x60000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆栈段</td><td><code>0x7FFF0000</code></td><td>1 MB（向下增长）</td><td>可读可写（RW）</td></tr></tbody></table><p><strong>代码段</strong>：</p><ul><li>通常映射在较低的地址区域，如 <code>0x40000</code>，用来存储程序的指令。</li><li>设置为可读可执行权限（<code>UC_PROT_READ | UC_PROT_EXEC</code>）。</li></ul><p><strong>数据段</strong>：</p><ul><li>紧邻代码段，用来存储全局变量、静态变量等。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>堆区</strong>：</p><ul><li>用于动态分配内存，可以根据程序运行时的需求调整大小。</li><li>通过自定义的内存管理器或直接扩展区域实现。</li></ul><p><strong>堆栈段</strong>：</p><ul><li>通常放在高地址区域（如 <code>0x7FFF0000</code>），并从高地址向低地址增长。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>Unicorn 的内存设置是它自己模拟的，而不是由操作系统直接管理的</strong>。Unicorn 作为一个用户态的 CPU 仿真框架，模拟了目标架构的 CPU 和内存系统。Unicorn 将内存的虚拟地址（如 <code>0x40000</code> 或 <code>0x7FFF0000</code>）完全作为目标架构的地址模拟，与主机的虚拟地址无关。主机操作系统只负责分配 Unicorn 运行本身需要的资源（如 CPU 时间和主机内存），但不会干涉 Unicorn 模拟的内存布局。</p><p>值得注意的是：</p><p>Unicorn 本身并不会主动区分“特殊用途”地址和“普通地址”，但它的执行逻辑可能依赖用户分配的地址。但如果你在 <code>0x0 - 0xFFFF</code> 范围内映射代码或数据，可能会导致以下问题：</p><ol><li><strong>Unicorn 的初始化数据</strong>：某些架构可能会默认初始化特定的寄存器或内存区域到低地址，用户手动操作的地址可能与这些区域冲突。</li><li><strong>调试和兼容性问题</strong>：许多调试工具或调试器（如 GDB）默认会将低地址区域视为不可用的保留空间。如果代码被放置在低地址区域，调试时可能导致断点设置失败或程序崩溃。</li></ol><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>写入内容（代码，数据）到内存中之前，要注意先确认<code>字节序</code>&#x3D;<code>endian</code>是<code>大端</code>还是<code>小端</code></p><p>ARM中，默认是<code>小端</code>&#x3D;<code>UC_MODE_LITTLE_ENDIAN</code></p><p>除非特殊需要，才会设置为<code>大端</code>&#x3D;<code>UC_MODE_BIG_ENDIAN</code></p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><table><thead><tr><th><strong>部分</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>(1) 动态二进制翻译（Dynamic Binary Translation）</strong></td><td></td></tr><tr><td><strong>翻译机制</strong></td><td>- 通过 QEMU 的 TCG（Tiny Code Generator）实现动态翻译。- 将目标架构的指令翻译为宿主架构的中间表示（IR, Intermediate Representation）。- 翻译后的代码缓存在 <strong>Translation Block Cache (TLB)</strong> 中。</td></tr><tr><td><strong>执行流程</strong></td><td>1. 解析目标架构指令。2. 使用 TCG 将指令翻译为宿主架构的中间代码（IR）。3. 中间代码再翻译为宿主机的原生机器指令，并直接运行。</td></tr><tr><td><strong>性能特点</strong></td><td>- 比解释型模拟（如 Bochs）快得多。- 动态翻译存在一定开销，但重复执行时利用 TLB 提升效率。</td></tr><tr><td><strong>(2) 指令的分发与仿真</strong></td><td></td></tr><tr><td><strong>指令获取</strong></td><td>- 从当前 <strong>PC（Program Counter）</strong> 所指向的地址读取目标内存中的指令。- 内存管理由 Unicorn 的虚拟内存模型负责，需通过 <strong><code>uc_mem_map</code></strong> 等接口预先映射内存。</td></tr><tr><td><strong>指令解析与翻译</strong></td><td>- 根据架构解码指令，提取操作码和操作数。示例：- <strong>ARM</strong>：解析指令类型（如分支 <code>BL</code>、数据处理 <code>ADD</code>、内存访问 <code>LDR</code>）。- <strong>x86</strong>：解析指令（如 <code>MOV</code>、<code>CALL</code>、<code>JMP</code>）。</td></tr><tr><td><strong>指令执行</strong></td><td>- 将解析的指令翻译为宿主机代码并执行。- 例如模拟内存访问、条件跳转、异常处理等。</td></tr><tr><td><strong>状态更新</strong></td><td>- 根据指令执行结果更新模拟状态（寄存器、内存等）。</td></tr><tr><td><strong>(3) 内存与寄存器仿真</strong></td><td></td></tr><tr><td><strong>内存仿真</strong></td><td>- Unicorn 使用虚拟内存模型模拟目标架构内存。- 用户通过 <strong><code>uc_mem_map</code></strong> 定义虚拟内存布局。- 所有内存访问都经 Unicorn 的内存管理层检查。</td></tr><tr><td><strong>寄存器仿真</strong></td><td>- 不同架构有各自的寄存器模型：    - <strong>x86</strong>：<code>EIP</code>、<code>ESP</code> 等。    - <strong>ARM</strong>：<code>R0-R15</code>、<code>PC</code>、<code>LR</code> 等。- 用户通过 <strong><code>uc_reg_read</code></strong> 和 <strong><code>uc_reg_write</code></strong> 接口操作寄存器。</td></tr><tr><td><strong>(4) 钩子机制（Hooking Mechanism）</strong></td><td></td></tr><tr><td><strong>代码钩子</strong></td><td>- 拦截特定指令或地址范围的执行。</td></tr><tr><td><strong>内存钩子</strong></td><td>- 拦截内存读写访问，用于监控或修改操作。</td></tr><tr><td><strong>异常钩子</strong></td><td>- 捕获未定义指令、未映射内存访问等异常。</td></tr><tr><td><strong>(5) 架构和模式切换</strong></td><td></td></tr><tr><td><strong>支持的架构</strong></td><td><strong>x86、x86_64、ARM、ARM64、MIPS、SPARC、PowerPC</strong></td></tr><tr><td><strong>模式切换</strong></td><td>- <strong>x86</strong>：支持 32 位和 64 位模式切换。- <strong>ARM</strong>：支持 ARM 模式和 Thumb 模式切换（通过 <code>BLX</code> 等指令）。- 用户初始化时通过 <code>Uc(UC_ARCH_ARM, UC_MODE_THUMB)</code> 指定模式，模拟中可根据指令动态切换。</td></tr></tbody></table><h1 id="unicorn使用的基本思想？"><a href="#unicorn使用的基本思想？" class="headerlink" title="unicorn使用的基本思想？"></a>unicorn使用的基本思想？</h1><h2 id="运行前初始化"><a href="#运行前初始化" class="headerlink" title="运行前初始化"></a>运行前初始化</h2><p>主要是对内存布局，比如：堆，栈等一些设置，注意对需要模拟的函数参数<strong>提前写入寄存器</strong>，其他一些特殊情况中，要给特定内存地址写入特定地址，供后续代码模拟时调用。</p><h2 id="运行中Hook"><a href="#运行中Hook" class="headerlink" title="运行中Hook"></a>运行中Hook</h2><p>开始运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mu.emu_start(ADDRESS, ADDRESS + <span class="hljs-built_in">len</span>(ARM_CODE))<br></code></pre></td></tr></table></figure><ul><li>ADDRESS：最开始映射的代码的最初位置</li><li>ADDRESS + len(ARM_CODE)：映射的代码起始位置，加上对应代码长度后的，结束位置</li></ul><blockquote><p>为了用Unicorn模拟代码运行，调试出我们希望搞懂的函数的逻辑，往往期间需要很多额外的调试内容</p></blockquote><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>Unicorn模拟期间，常需要去搞懂底层正在发生的细节，查看对应的寄存器、内存的值等等，此时，就可以用到Unicorn所提供的机制：hook。</p><p>其中比较常用的一些hook是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">- hook代码<br>- hook特定指令<br>- hook内存<br>- hook异常<br>- hook其他<br></code></pre></td></tr></table></figure><p>关于Unicorn支持的hook的全部种类是：</p><p>指令执行类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_INTR`<br>- `UC_HOOK_INSN`<br>- `UC_HOOK_CODE`<br>- `UC_HOOK_BLOCK`<br></code></pre></td></tr></table></figure><p>内存访问类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_PROT`<br>- `UC_HOOK_MEM_WRITE_PROT`<br>- `UC_HOOK_MEM_FETCH_PROT`<br>- `UC_HOOK_MEM_READ`<br>- `UC_HOOK_MEM_WRITE`<br>- `UC_HOOK_MEM_FETCH`<br>- `UC_HOOK_MEM_READ_AFTER`<br></code></pre></td></tr></table></figure><p>异常处理类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_UNMAPPED`<br>- `UC_HOOK_MEM_WRITE_UNMAPPED`<br>- `UC_HOOK_MEM_FETCH_UNMAPPED`<br>- `UC_HOOK_INSN_INVALID`<br></code></pre></td></tr></table></figure><p>其他</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_EDGE_GENERATED`<br>- `UC_HOOK_TCG_OPCODE`<br></code></pre></td></tr></table></figure><p>Hook的设置，在运行中逐指令进行对比，当符合设置的内容时，触发钩子函数进行处理</p><h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>引入外部的反汇编器disassembler，比如<code>Capstone</code>，自己去把二进制翻译为对应指令</p><h2 id="运行后获取结果"><a href="#运行后获取结果" class="headerlink" title="运行后获取结果"></a>运行后获取结果</h2><h3 id="停止运行"><a href="#停止运行" class="headerlink" title="停止运行"></a>停止运行</h3><p>对于Unicorn来说，就是模拟CPU运行，模拟去读取指令和运行指令而已。</p><p>所以，换句话说，如果你的给code代码的地址空间写入了代码后，如果没有额外的跳转等复杂逻辑，则：</p><ul><li><strong>Unicorn会一直运行下去</strong></li></ul><p>如果没有合适的触发时机，去让其停下来，那就变成了死循环，永远不结束了。</p><p>而我们的目标是：模拟代码，尤其是函数的逻辑，希望代码运行完毕，输出结果的。</p><p>所以，此处往往选择一个合适的时机去触发其让Unicorn停下来。</p><p>这个时机，一般都是：<code>ret</code>指令，即，当发现正在运行的指令是<code>ret</code>指令，则就会调用<code>emu_stop</code>去停下来。</p><p><strong>在<code>hook_code</code>中，借助<code>Capstone</code>反编译出当前指令，其中<code>mnemonic</code>就是指令名称，当发现是<code>ret</code>指令时</strong></p><p>注：对于arm64e来说，还有更多的PAC相关ret指令：<code>retaa</code>、<code>retab</code>等，所以此处用<code>re</code>正则去判断指令名称是否匹配，而不是直接判断和<code>ret</code>是否相等。</p><p>就去调用<code>emu_stop()</code>去停止Unicorn的继续运行。</p><p><strong>这里也是借助Hook进行的</strong></p><h3 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h3><p>通过读取寄存器中的值来获取结果</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://book.crifan.org/books/cpu_emulator_unicorn/website/how_use/background/core_logic/cpu_logic.html">CPU的核心逻辑 · CPU模拟利器：Unicorn</a></p>]]></content>
    
    
    <categories>
      
      <category>逆向(android)</category>
      
      <category>符号/模拟执行</category>
      
      <category>unicorn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angr原理浅析</title>
    <link href="/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p><strong>约束条件（Constraints）</strong> 是对问题求解空间的限制或规定，它规定了哪些解是允许的，哪些解是不允许的。在数学、计算机科学、逻辑学等领域，约束条件通常用于描述某个问题的限制条件，目的是让我们能够从所有可能的解中筛选出符合特定规则或要求的解。</p><p>在数学中，约束条件通常是一些方程或不等式，定义了一个问题的解集。例如，约束条件 <code>x + y ≤ 10</code> 就表示在求解时，变量 <code>x</code> 和 <code>y</code> 的和不能超过 10。</p><p>在计算机科学，约束条件常常是对程序状态的描述，表示程序在某一时刻满足的条件或限制。例如，假设有一个条件 <code>if (x &lt; 10)</code>，那么在程序的执行过程中，<code>x &lt; 10</code> 就是一个约束条件。</p><h2 id="什么是Z3"><a href="#什么是Z3" class="headerlink" title="什么是Z3"></a>什么是Z3</h2><p><a href="https://github.com/Z3Prover/z3">Z3 solver</a> 是由微软开发的 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），用于检查逻辑表达式的可满足性，并可以找到一组约束中的其中一个可行解（无法找出所有的可行解）。</p><p>不深入研究的话，这里可以简单理解为：<strong>解方程</strong>，当然他还有很多应用场景比如：</p><ul><li><strong>布尔逻辑</strong>：可以处理布尔表达式，求解SAT（布尔可满足性）问题。</li><li><strong>线性算术</strong>：能够处理整数和实数的线性约束。</li><li><strong>非线性算术</strong>：支持非线性算术运算的求解。</li><li><strong>数组、集合、图结构</strong>：支持复杂的数据结构。</li><li><strong>符号执行</strong>：结合符号执行技术，Z3能对程序的执行路径进行分析和求解。</li><li><strong>程序验证</strong>：通过将程序的行为转化为约束，Z3可以帮助验证程序是否满足特定的安全性或功能性要求。</li><li><strong>自动化定理证明</strong>：Z3可以用来证明数学定理或逻辑公式的有效性。</li></ul><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> Solver, Real, sat<br><br><span class="hljs-comment"># 创建符号变量 x</span><br>x = Real(<span class="hljs-string">&#x27;x&#x27;</span>)<br><br><span class="hljs-comment"># 创建方程：x^2 - 3x + 2 = 0</span><br>equation = x**<span class="hljs-number">2</span> - <span class="hljs-number">3</span>*x + <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 创建一个求解器</span><br>solver = Solver()<br><br><span class="hljs-comment"># 将方程添加到求解器</span><br>solver.add(equation)<br><br><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">if</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方程无解&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/5rTdVqvCSa6zQtP.png" alt="image-20241219153257642" style="zoom:50%;" /></p><p>而不是：x &#x3D; 1和x &#x3D; 2</p><p>这是因为Z3 在求解方程时，默认情况下只返回第一个找到的解。这是因为 Z3 是一个 <strong>满足性求解器</strong>（Satisfiability Solver），它的目标是检查约束是否可满足，并返回其中一个满足约束的解，而不是所有可能的解。</p><p>通过进一步添加约束条件可以得到所有解（即排除已经找到的解）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">while</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 排除当前解，继续寻找下一个解</span><br>    solver.add(x != model[x])<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/mJYOACvKk2acpsj.png" alt="image-20241219153642676" style="zoom:50%;" /></p><h1 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h1><h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><img src="https://s2.loli.net/2024/12/19/u3ez9CtglaXyJNk.png" alt="220430bodvqhbod4pty8zv"></p><p>符号执行是一种程序分析技术，它通过将程序中的某些变量替换为符号变量（而不是具体值），来模拟程序的执行。符号变量代表任意值，并通过符号计算来追踪程序的执行路径和计算结果。与传统的测试方法不同，它并不是通过具体的输入值来执行程序，而是通过符号表示的输入值来执行程序，并尝试探索程序中所有可能的执行路径。</p><h3 id="符号执行流程"><a href="#符号执行流程" class="headerlink" title="符号执行流程"></a>符号执行流程</h3><p><strong>符号变量</strong>： 在符号执行中，输入变量（例如函数参数、内存内容等）被替换为符号变量（symbolic variables），这些符号变量表示可以取任意值。与传统的实际值（如整数、字符串）不同，符号变量没有固定的值，而是代表一个值的集合或范围。</p><p><strong>路径探索</strong>： 符号执行通过模拟程序的控制流来探索不同的路径。每当程序遇到条件判断（例如 <code>if</code> 语句）时，它会根据符号变量的约束来分裂路径。符号执行引擎会为每条路径维护一组条件约束，表示该路径的执行条件。</p><p><strong>约束收集与求解</strong>： 在执行过程中，每当遇到条件判断时（例如 <code>if</code> 语句），符号执行引擎会根据条件生成约束（例如 <code>x &lt; 10</code> 或 <code>x &gt;= 10</code>）。这些约束随着路径的推进被累积。最后，使用约束求解器（如 Z3）来检查是否存在解，即判断某条路径是否可行。如果求解器找到了满足这些约束的具体输入值，那么符号执行就能沿着这条路径继续模拟执行。</p><h2 id="什么是angr"><a href="#什么是angr" class="headerlink" title="什么是angr?"></a>什么是angr?</h2><p><strong>angr</strong> 是一个基于 Python 的 <strong>二进制分析框架</strong>，专门用于分析二进制程序。它提供了一个强大的工具集，用于执行分析任务，如符号执行（Symbolic Execution）、路径探索（Path Exploration）、漏洞挖掘、逆向工程、静态分析等。</p><h2 id="angr的工作原理？"><a href="#angr的工作原理？" class="headerlink" title="angr的工作原理？"></a>angr的工作原理？</h2><ol><li><strong>加载二进制</strong>：<ul><li>使用 angr 加载目标二进制文件（例如 ELF、PE 格式的可执行文件）。</li></ul></li><li><strong>符号执行与路径探索</strong>：<ul><li>angr 会在二进制程序的某些地方插入符号（symbolic variables），并从程序入口点（例如 <code>main</code> 函数）开始执行。每执行一步，angr 会模拟程序的行为并生成新的约束条件。</li></ul></li><li><strong>生成约束</strong>：<ul><li>在符号执行过程中，程序的条件分支会根据符号变量的取值生成约束（例如：<code>x &lt; 10</code>）。这些约束会被加入到当前路径的状态中。</li></ul></li><li><strong>路径分裂</strong>：<ul><li>当遇到条件分支时，angr 会将程序的执行路径分裂成多个子路径。例如，<code>if (x &lt; 10)</code> 会导致两个路径，一个路径满足 <code>x &lt; 10</code>，另一个路径满足 <code>x &gt;= 10</code>。</li></ul></li><li><strong>求解与回溯</strong>：<ul><li>每条路径都会产生约束，angr 会通过求解器（如 Z3）来判断某条路径是否可行。如果路径不可行，angr 会将其丢弃。如果路径可行，它将继续沿着该路径执行，直到达到目标或出现漏洞。</li></ul></li></ol><p>可以看出同unicorn只能走一个分支相比，angr在运行的过程中，从给定的一个state(程序状态，程序的寄存器值，内存的不同都可以作为程序状态的不同)开始执行，每个state维护着一个约束条件的集合(比如i&lt;10,i!&#x3D;0)，通过收集约束，进行遍历，最终angr理论上可以遍历到程序的所有可能控制流，当angr运行到目标状态时，就可以调用求解器(z3等)对一路上收集到的约束进行求解，最终得到某个符号能够到达当前状态的值。</p><p><img src="https://s2.loli.net/2024/12/19/pwKVfMPCjUbX95v.jpg" alt="215918bnzmvv6wzoqingwv"></p><p>值得注意的是：同传统的静态符号执行(unicorn引擎)相比，<strong>angr使用的是混合执行技术，合并了静态符号执行，和动态具体执行两种技术</strong></p><p>动态符号执行（concolic execution）维持了两个状态。一种是实际变量的状态，另一种是符号化的状态。实际状态将随机生成值映射到变量中，而符号化状态将变量进行符号化。concolic首先将实际状态运行，并收集实际运行时该路径的变量符号化的约束式，i求解。并将约束式取反，获取另一条路径的约束式并求解。过程不断重复，知道路径被探索完，或者达到用户设置的限制。</p><p>具体的例子可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 路径1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 路径2</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      <span class="hljs-comment">// 路径3</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="动态执行过程"><a href="#动态执行过程" class="headerlink" title="动态执行过程"></a>动态执行过程</h3><ol><li><strong>实际状态</strong>：随机初始化输入，例如 <code>x = 15</code>。</li><li><strong>符号化状态</strong>：将 <code>x</code> 表示为符号变量 <code>X</code>。</li></ol><hr><h4 id="步骤1：运行实际状态并收集约束"><a href="#步骤1：运行实际状态并收集约束" class="headerlink" title="步骤1：运行实际状态并收集约束"></a><strong>步骤1：运行实际状态并收集约束</strong></h4><ol><li><p><strong>实际运行</strong>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">15</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>1</code>，对应<strong>路径1</strong>。</p></li><li><p><strong>符号化执行</strong>：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt; <span class="hljs-number">10</span>  (路径<span class="hljs-number">1</span>)<br>X &lt; <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>将这些条件存入符号约束集。</p></li></ol><hr><h4 id="步骤2：生成新路径（约束取反）"><a href="#步骤2：生成新路径（约束取反）" class="headerlink" title="步骤2：生成新路径（约束取反）"></a><strong>步骤2：生成新路径（约束取反）</strong></h4><ol><li><p>从约束集中取反条件：</p><p>原路径约束为 <code>X &gt; 10 &amp;&amp; X &lt; 20</code>。</p><p>取反约束为 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>即：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span> || X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择其中一条路径：<code>X &lt;= 10</code>**。</p><p>求解约束 <code>X &lt;= 10</code>，求解器可能返回 <code>X = 5</code>。</p></li></ol><hr><h4 id="步骤3：探索新路径"><a href="#步骤3：探索新路径" class="headerlink" title="步骤3：探索新路径"></a><strong>步骤3：探索新路径</strong></h4><ol><li><p>使用新值 <code>x = 5</code> 实际运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">5</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &gt; <span class="hljs-number">10</span>) &#123;           // 条件不成立<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>3</code>，对应<strong>路径3</strong>。</p></li><li><p>收集符号化约束：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span>  (路径<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="步骤4：继续探索未覆盖的路径"><a href="#步骤4：继续探索未覆盖的路径" class="headerlink" title="步骤4：继续探索未覆盖的路径"></a><strong>步骤4：继续探索未覆盖的路径</strong></h4><ol><li><p>再次从约束集中取反条件：</p><p>已探索的路径约束为：</p><p>​     路径1：<code>X &gt; 10 &amp;&amp; X &lt; 20</code></p><p>​     路径3：<code>X &lt;= 10</code></p><p>合并取反条件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>) &amp;&amp; !(X &lt;= <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>简化后为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择路径：<code>X &gt;= 20</code>**。</p><p>求解约束 <code>X &gt;= 20</code>，求解器可能返回 <code>X = 25</code>。</p></li><li><p>使用新值 <code>x = 25</code> 实际运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>执行路径为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件不成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>2</code>，对应<strong>路径2</strong>。</p></li></ol><hr><h4 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a><strong>终止条件</strong></h4><p>动态符号执行会重复上述过程：</p><ol><li>实际运行一个具体值。</li><li>收集符号化约束。</li><li>取反约束生成新路径。</li><li>继续探索未覆盖的路径。</li></ol><p>直到：</p><ul><li><strong>所有路径都被探索</strong>：程序的逻辑分支全部覆盖。</li><li><strong>达到用户设定的限制</strong>：例如最大路径数量、最大求解时间等。</li></ul><h2 id="angr的不足"><a href="#angr的不足" class="headerlink" title="angr的不足"></a>angr的不足</h2><h3 id="未约束导致路径爆炸"><a href="#未约束导致路径爆炸" class="headerlink" title="未约束导致路径爆炸"></a>未约束导致路径爆炸</h3><p>在符号执行中，如果函数的输入变量或状态没有被有效约束（即没有设定足够的条件），Angr 等工具会把这些变量当作符号值进行推理和执行。而未约束的变量可能会导致两方面的问题：</p><ol><li><strong>不确定的输入</strong>： 如果输入没有约束（例如，函数的参数没有指定具体的值或者范围），那么每次执行到某个条件判断时，就会有多个可能的选择。例如，假设你有一个函数，其中某个参数 <code>x</code> 的值没有明确的限制，那么在 <code>if</code> 语句中对 <code>x</code> 的判断就可能导致多个分支，每个分支都有不同的路径。</li><li><strong>无限循环</strong>： 当未约束的变量影响到循环条件时，符号执行就无法准确预测循环何时结束，因为它并不知道循环的终止条件何时成立。例如，某个循环的退出条件可能是 <code>x == 0</code>，但 <code>x</code> 是一个未约束的符号变量，Angr 并不知道 <code>x</code> 什么时候会变为 0。因此，符号执行引擎就可能会一直在这个循环中进行模拟，导致路径在循环内无限增长。</li></ol><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">void foo(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果我们给定一个具体的值，例如 <code>x = 10</code>，程序会在 10 次迭代后退出。</li><li>但是如果 <code>x</code> 是一个未约束的符号变量（例如，Angr 看到 <code>x</code> 是一个符号值），它就不能确定 <code>x</code> 会在什么时候达到 0，或者是否有可能永远不为 0。</li></ul><p>在符号执行中，Angr 会尝试探索所有可能的路径。在这种情况下，由于 <code>x</code> 没有约束，符号执行引擎无法推断出 <code>x</code> 何时会变为 0，因此它可能会认为该循环将永远执行下去，导致<strong>路径爆炸</strong>。</p><h4 id="路径爆炸与无限循环的关系"><a href="#路径爆炸与无限循环的关系" class="headerlink" title="路径爆炸与无限循环的关系"></a><strong>路径爆炸与无限循环的关系</strong></h4><p>路径爆炸指的是，随着未约束变量的增加，符号执行的路径数量呈指数级增长，导致无法有效地探索所有路径。无限循环是路径爆炸的一种特殊情况，通常发生在没有足够约束的情况下，符号执行无法判断循环是否终止，从而导致执行路径无法终止。</p><p>例如，当未约束的循环变量 <code>x</code> 不断变化，且影响循环的终止条件时，Angr 可能会不断生成新的路径，每个路径代表不同的 <code>x</code> 值和不同的循环迭代次数，最终导致路径数量迅速膨胀，系统无法有效处理这些路径，从而导致“卡死”。</p><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> func(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x = x - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>x</code> 没有任何约束，Angr 会将其视为符号变量，可能会生成多条路径来探索 <code>x</code> 可能的值。每条路径都会尝试模拟 <code>x</code> 在每次循环中的变化，直到达到退出条件 <code>x &lt;= 0</code>。</p><p>在符号执行的过程中，Angr 会对每次 <code>x = x - 1</code> 做出决策，并生成新的路径。</p><p>如果没有足够的约束（例如，限制 <code>x</code> 的值或设置循环的最大迭代次数），Angr 可能会生成大量的路径来模拟不同的 <code>x</code> 值和循环次数，导致路径数目激增，甚至无法终止。</p><h3 id="误报"><a href="#误报" class="headerlink" title="误报"></a>误报</h3><p>事实上angr是基于符号执行来遍历程序的所有路径，它是否能遍历所有路径其实取决于其约束求解引擎是否强大，这里采用的是z3<br>当它能明确发现这个条件是无法满足的时候就不会走向这个路径，我们可以称之为虚假控制流。<br>但是如果程序本身的逻辑中存在一个条件是非常难以满足的，或者说超出了约束求解引擎的能力，那么则有可能到达不了这个路径，就会被误标记为虚假的控制流，实际中是很少出现的。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">[动若脱兔:深入浅出angr--初步理解符号执行以及angr架构 - 0xJDchen - 博客园](https://www.cnblogs.com/0xJDchen/p/9291335.html)<br><br>[利用angr去除混淆的优势，不足与实践 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1484714-1-1.html)<br><br>[angr_ctf——从0学习angr（一）：angr简介与核心概念 - Uiharu - 博客园](https://www.cnblogs.com/level5uiharu/p/16925991.html)<br><br>[angr - CTF Wiki](https://ctf-wiki.org/reverse/tools/simulate-execution/angr/)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>逆向(android)</category>
      
      <category>符号/模拟执行</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>So加载和链接(linker)</title>
    <link href="/2024/05/25/So%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5(linker)/"/>
    <url>/2024/05/25/So%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5(linker)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文以android 9源码进行分析</p></blockquote><h1 id="命名空间-namespace机制"><a href="#命名空间-namespace机制" class="headerlink" title="命名空间(namespace机制)"></a>命名空间(namespace机制)</h1><p>主要参考<a href="https://www.cnblogs.com/ztguang/p/12644484.html">Android 8.0 - 基于命名空间的动态链接—— 隔离 Android 中应用程序和系统的本地库 - 张同光 - 博客园</a>总结来说：</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>命名空间是为了在 Android 操作系统中管理动态链接库（so 库）的加载和共享，确保系统和应用程序的本地库（so 库）得到有效的隔离和管理。这项机制的核心目标是提高系统的安全性、稳定性，并防止应用程序滥用系统资源，特别是访问或修改不应该访问的库。</p><table><thead><tr><th><strong>概念</strong></th><th><strong>描述</strong></th><th><strong>作用</strong></th><th><strong>相关命名空间</strong></th></tr></thead><tbody><tr><td><strong>隔离</strong></td><td>每个命名空间中的库被隔离，防止它们之间的冲突和无意间的相互干扰。</td><td>确保每个命名空间只加载所需的库，应用程序库与系统库相互隔离，避免不必要的干扰。</td><td>系统命名空间、应用程序命名空间、VNDK 命名空间、sphal 命名空间等</td></tr><tr><td><strong>共享</strong></td><td>通过命名空间链接，不同命名空间之间可以共享某些库，但共享是经过控制的。</td><td>仅允许特定的库（如公共系统库）在多个命名空间之间共享，减少重复加载的开销，确保安全性和稳定性。</td><td>系统命名空间与应用程序命名空间、VNDK 命名空间、sphal 命名空间等</td></tr><tr><td><strong>灰名单（Greylist）</strong></td><td>允许应用访问系统的私有库，但这种访问是受限制的，且带有性能和安全风险。</td><td>应用可以访问一些被标记为不安全或过时的库，但这种访问受到限制，且会增加内存开销和潜在安全风险。</td><td>系统命名空间、应用程序命名空间</td></tr><tr><td><strong>VNDK 命名空间</strong></td><td>用于管理供应商提供的本地库，隔离供应商层的库与系统框架库。</td><td>确保供应商库与系统库隔离，减少不同版本的供应商库与系统框架库之间的冲突，提升系统的稳定性和兼容性。</td><td>VNDK 命名空间</td></tr><tr><td><strong>sphal 命名空间</strong></td><td>用于管理硬件抽象层（HAL）相关的库，提供系统与供应商的硬件接口。</td><td>管理硬件抽象层库，允许系统与供应商之间的硬件接口正确交互，同时与其他命名空间隔离，避免冲突。</td><td>sphal 命名空间</td></tr></tbody></table><h2 id="应用要加载-SO-库的流程"><a href="#应用要加载-SO-库的流程" class="headerlink" title="应用要加载 SO 库的流程"></a>应用要加载 SO 库的流程</h2><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th><th><strong>关键函数</strong></th></tr></thead><tbody><tr><td><strong>1. 查找共享库文件</strong></td><td>系统系统根据指定的路径查找库文件，包括应用的私有库路径和系统库路径。</td><td><code>load_library()</code></td></tr><tr><td><strong>2. 映射库到内存</strong></td><td>使用 <code>mmap</code> 或类似技术将库映射到内存中。</td><td><code>load_library()</code></td></tr><tr><td><strong>3. 创建 <code>soinfo</code> 结构体</strong></td><td>为每个加载的库创建并初始化 <code>soinfo</code> 结构体，存储库的基本信息、动态段、符号表等。</td><td><code>soinfo</code></td></tr><tr><td><strong>4. 解析动态段</strong></td><td>读取 ELF 文件的动态段（<code>dynamic</code>），解析动态符号、重定位信息等。</td><td><code>link_image()</code></td></tr><tr><td><strong>5. 符号解析</strong></td><td>查找并解析库中的符号（函数、变量等），处理符号依赖关系。</td><td><code>dlsym()</code></td></tr><tr><td><strong>6. 重定位</strong></td><td>根据重定位表（<code>rel</code>）更新符号地址。</td><td><code>relocate()</code></td></tr><tr><td><strong>7. 执行库初始化</strong></td><td>执行库中的初始化代码，例如 <code>_init</code> 或构造函数。</td><td><code>call_constructors()</code></td></tr></tbody></table><h2 id="命名空间类型"><a href="#命名空间类型" class="headerlink" title="命名空间类型"></a>命名空间类型</h2><table><thead><tr><th><strong>命名空间类别</strong></th><th><strong>描述</strong></th><th><strong>用途</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>系统命名空间</strong></td><td>默认命名空间，包含所有系统共享的库。</td><td>加载操作系统和框架的共享库，供系统进程和应用程序使用。</td><td><code>libc.so</code>、<code>libm.so</code>、<code>libandroid.so</code> 等</td></tr><tr><td><strong>应用程序命名空间</strong></td><td>每个 Android 应用程序的私有命名空间。</td><td>加载应用程序自己的共享库，确保库的隔离和应用私有性。</td><td>应用程序的私有 <code>.so</code> 库</td></tr><tr><td><strong>VNDK 命名空间</strong></td><td>用于管理供应商库（Vendor Native Development Kit）。</td><td>隔离供应商代码和框架代码，确保系统稳定性，兼容性。</td><td><code>libhidl.so</code>、<code>libstagefright.so</code> 等供应商库</td></tr><tr><td><strong>SPHAL 命名空间</strong></td><td>系统与供应商之间的硬件抽象层库。</td><td>管理硬件抽象层（HAL）库，允许系统与供应商硬件库正确交互。</td><td><code>libhwbinder.so</code> 等 HAL 相关库</td></tr><tr><td><strong>Greylist 命名空间</strong></td><td>包含灰名单库，允许有限制地访问某些私有或过时的库。</td><td>允许应用访问某些系统库（灰名单库），但访问受限制，通常用于过时或即将弃用的功能。</td><td>被标记为灰名单的系统库（如特定版本的 <code>libc</code>）</td></tr><tr><td><strong>供应商命名空间</strong></td><td>用于管理设备供应商特定的库。</td><td>供应商层的库，仅在供应商定制化的代码中使用。</td><td>硬件解码库、传感器库等硬件特定的库</td></tr></tbody></table><h1 id="JAVA层调用SO"><a href="#JAVA层调用SO" class="headerlink" title="JAVA层调用SO"></a>JAVA层调用SO</h1><p>Android 应用程序通过 <code>System.loadLibrary()</code> 或 <code>Runtime.loadLibrary()</code> 加载本地库。这些本地库通常是 <code>.so</code> 文件，它们包含了通过 JNI 与 Java 代码交互的本地方法。Android 的类加载机制和虚拟机（ART）会负责解析这些库，并将其加载到内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    System.loadLibrary(<span class="hljs-string">&quot;native-lib&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LoadLibrary"><a href="#LoadLibrary" class="headerlink" title="LoadLibrary()"></a>LoadLibrary()</h2><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/System.java#1651">http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/System.java#1651</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/22/98lLUWaV6qd5XAn.png" alt="image-20241222112316647"></p><p>在 Java 中，<code>Runtime</code> 是一个代表当前 Java 应用程序运行时环境的类。它提供了与 Java 虚拟机（JVM）进行交互的多种功能，如内存管理、运行时参数管理、执行系统命令等。</p><p>**<code>loadLibrary0</code>**：</p><ul><li>这是 <code>Runtime</code> 类的一个本地方法，实际上是通过 JNI (Java Native Interface) 调用底层操作系统的功能来加载共享库。在 <code>Runtime.getRuntime().loadLibrary0()</code> 中，<code>loadLibrary0</code> 负责执行具体的库加载工作，通常由 JVM 实现和操作系统平台提供支持。</li></ul><p>**<code>VMStack.getCallingClassLoader()</code>**：</p><ul><li>这个方法返回调用当前方法的类加载器（<code>ClassLoader</code>）。类加载器负责加载类和资源，而 <code>VMStack.getCallingClassLoader()</code> 是获取调用当前方法的类加载器。该加载器通常是调用 <code>loadLibrary</code> 方法的类的 <code>ClassLoader</code>。在 Android 中，<code>VMStack.getCallingClassLoader()</code> 通过获取调用当前方法的类加载器来确定在当前上下文中加载共享库的路径。Android 中的类加载器负责加载 Java 类，并且在加载库时，会根据不同的 <code>ClassLoader</code> 来决定如何查找本地库（包括从 <code>lib</code> 目录、<code>apk</code> 文件中等）。</li></ul><p>这里的getRuntime()只是Runtime的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> currentRuntime;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="LoadLibrary0"><a href="#LoadLibrary0" class="headerlink" title="LoadLibrary0()"></a>LoadLibrary0()</h3><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/Runtime.java#58">http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/Runtime.java#58</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadLibrary0</span><span class="hljs-params">(ClassLoader loader, String libname)</span> &#123;<br>    <span class="hljs-comment">// 检查库名中是否包含路径分隔符</span><br>    <span class="hljs-keyword">if</span> (libname.indexOf((<span class="hljs-type">int</span>)File.separatorChar) != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(<br>            <span class="hljs-string">&quot;Directory separator should not appear in library name: &quot;</span> + libname);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">libraryName</span> <span class="hljs-operator">=</span> libname;<br>    <span class="hljs-comment">// 如果提供了类加载器（ClassLoader），尝试通过该加载器查找库文件</span><br>    <span class="hljs-keyword">if</span> (loader != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> loader.findLibrary(libraryName);  <span class="hljs-comment">// 通过类加载器查找库文件</span><br>        <span class="hljs-keyword">if</span> (filename == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果找不到库文件，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(loader + <span class="hljs-string">&quot; couldn&#x27;t find \&quot;&quot;</span> +<br>                                            System.mapLibraryName(libraryName) + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 尝试加载库</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> nativeLoad(filename, loader);<br>        <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果加载失败，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(error);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 成功加载库，退出方法</span><br>    &#125;<br>    <span class="hljs-comment">// 如果没有类加载器，直接构造库文件的完整名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> System.mapLibraryName(libraryName);<br>    <span class="hljs-comment">// 用于保存尝试加载库的所有路径候选</span><br>    List&lt;String&gt; candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">lastError</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 遍历可能的库路径目录，尝试加载库</span><br>    <span class="hljs-keyword">for</span> (String directory : getLibPaths()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> directory + filename;  <span class="hljs-comment">// 拼接完整路径</span><br>        candidates.add(candidate);<br><br>        <span class="hljs-comment">// 如果可以读取该文件，则尝试加载</span><br>        <span class="hljs-keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> nativeLoad(candidate, loader);<br>            <span class="hljs-keyword">if</span> (error == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 成功加载库，退出方法</span><br>            &#125;<br>            lastError = error;  <span class="hljs-comment">// 记录加载失败的错误信息</span><br>        &#125;<br><br>    <span class="hljs-comment">// 如果所有路径尝试加载失败，抛出最后的错误信息</span><br>    <span class="hljs-keyword">if</span> (lastError != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(lastError);<br>    &#125;<br>    <span class="hljs-comment">// 如果都没有找到库，抛出异常并列出所有尝试的路径</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(<span class="hljs-string">&quot;Library &quot;</span> + libraryName + <span class="hljs-string">&quot; not found; tried &quot;</span> + candidates);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的nativeLoad()是native层方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">nativeLoad</span><span class="hljs-params">(String filename, ClassLoader loader)</span>;<br></code></pre></td></tr></table></figure><h1 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h1><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/native/Runtime.c">http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/native/Runtime.c</a></p></blockquote><p>这段代码通过 JNI 接口获取库名和类加载器，然后将它们传递给 JVM 的底层函数 <code>JVM_NativeLoad</code>，由该函数负责实际的库加载工作。</p><p><img src="https://s2.loli.net/2024/12/22/LBp16Sm7YTcROdw.png" alt="image-20241222113855201"></p><p>**<code>JNIEnv env</code>**：这是指向 Java 环境的指针，提供与 Java 虚拟机交互的接口。所有 JNI 函数调用都需要这个环境对象。native调用java层方法的接口</p><p>**<code>jobject javaLoader</code>**：这是调用 <code>loadLibrary</code> 的 Java 类加载器（<code>ClassLoader</code> 对象）。该加载器用于查找和加载库文件。</p><blockquote><p>JVM 底层的代码是 <code>native</code>，这意味着它是用 C 或 C++ 等底层语言编写的，而不是 Java 语言。JVM（Java虚拟机）本身的实现与 Java 层的代码通过 Java Native Interface（JNI）进行交互。</p></blockquote><h2 id="JVM-NativeLoad"><a href="#JVM-NativeLoad" class="headerlink" title="JVM_NativeLoad()"></a>JVM_NativeLoad()</h2><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/art/openjdkjvm/OpenjdkJvm.cc#323">http://androidxref.com/9.0.0_r3/xref/art/openjdkjvm/OpenjdkJvm.cc#323</a></p></blockquote><p>这部分是 JNI 函数的定义。<code>JNIEXPORT</code> 是 JNI 中用于声明函数的关键字，<code>jstring</code> 表示返回类型是一个 Java 字符串。<code>env</code> 是一个指向 <code>JNIEnv</code> 结构体的指针，它提供了与 JVM 交互的接口，<code>javaFilename</code> 和 <code>javaLoader</code> 是传入的 Java 字符串和 Java 对象。</p><p><img src="https://s2.loli.net/2024/12/22/PDnfB2tOzc1Whqy.png" alt="image-20241222113823277"></p><p><code>ScopedUtfChars</code> 是一个辅助类，它将传入的 <code>jstring</code> (<code>javaFilename</code>) 转换为 UTF-8 编码的 C 字符串。<code>filename</code> 现在是 <code>javaFilename</code> 对应的 UTF-8 编码字符串。</p><p><code>filename.c_str()</code> 返回 C 风格的字符串。如果转换失败（即 <code>filename</code> 为 <code>NULL</code>），则直接返回 <code>NULL</code>。</p><p>这里获取当前 Java 虚拟机实例 <code>vm</code>，<code>art::JavaVMExt</code> 是 Android 运行时（ART）的 JavaVM 类，<code>art::Runtime::Current()</code> 获取当前 ART 运行时实例。</p><p><code>GetJavaVM()</code> 方法返回当前的 Java 虚拟机。</p><p>调用 <code>LoadNativeLibrary</code> 函数加载本地库。</p><h3 id="LoadNativeLibrary"><a href="#LoadNativeLibrary" class="headerlink" title="LoadNativeLibrary()"></a>LoadNativeLibrary()</h3><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/art/runtime/java_vm_ext.cc#854">http://androidxref.com/9.0.0_r3/xref/art/runtime/java_vm_ext.cc#854</a></p></blockquote><table><thead><tr><th>步骤</th><th>描述</th></tr></thead><tbody><tr><td><strong>1. 检查库是否已加载</strong></td><td>函数首先检查是否已经加载该库。如果库已加载，并且类加载器相同，则返回成功；如果类加载器不同，生成错误信息并返回 <code>false</code>。</td></tr><tr><td><strong>2. 解码类加载器</strong></td><td>解码传入的类加载器对象，并检查是否为 <code>BootClassLoader</code>。如果是，设置为 <code>nullptr</code>，否则获取类加载器的分配器。</td></tr><tr><td><strong>3. 打开共享库</strong></td><td>调用 <code>android::OpenNativeLibrary</code> 使用 <code>dlopen</code> 加载共享库。如果加载失败，返回 <code>false</code>，并在 <code>error_msg</code> 中记录错误。</td></tr><tr><td><strong>4. 创建共享库对象</strong></td><td>创建 <code>SharedLibrary</code> 对象表示已加载的库，并通过加锁保证线程安全，将库添加到全局库列表中。</td></tr><tr><td><strong>5. 调用 <code>JNI_OnLoad</code></strong></td><td>检查库中是否包含 <code>JNI_OnLoad</code> 函数，如果有，调用它进行初始化。如果返回错误版本，记录错误信息；否则标记为成功。</td></tr><tr><td><strong>6. 返回加载结果</strong></td><td>设置共享库的加载结果并返回是否成功。</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/12/22/r9iqlag2IOxf4RG.png" alt="image-20241222121528343"></p><h4 id="OpenNativeLibrary"><a href="#OpenNativeLibrary" class="headerlink" title="OpenNativeLibrary()"></a>OpenNativeLibrary()</h4><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/system/core/libnativeloader/native_loader.cpp#637">http://androidxref.com/9.0.0_r3/xref/system/core/libnativeloader/native_loader.cpp#637</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/22/yXWOYAcgw7QZkj4.png" alt="image-20241222121435312"></p><h5 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen()"></a>dlopen()</h5><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/bionic/libdl/libdl.cpp">http://androidxref.com/9.0.0_r3/xref/bionic/libdl/libdl.cpp</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">int</span> flag)</span> &#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">void</span>* caller_addr = __builtin_return_address(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> __loader_dlopen(filename, flag, caller_addr);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>**<code>__builtin_return_address(0)</code>**：</p><ul><li>这是一个 GCC 提供的内建函数，用来获取当前函数的调用者的返回地址。</li><li>传入的参数 <code>0</code> 表示获取当前函数的调用者的返回地址。如果传入 <code>1</code>，则表示获取当前调用者的调用者的返回地址。</li><li>该返回地址可以用来了解调用栈的位置，通常用于调试或记录调用路径。</li></ul><p>**<code>__loader_dlopen</code>**：</p><ul><li>这是 <code>dlopen</code> 的底层实现，负责加载共享库。通过传递 <code>caller_addr</code>，它可能会记录加载请求的调用源，或者用于进一步的调试&#x2F;分析。</li><li><code>__loader_dlopen</code> 可能是一个与操作系统或具体实现相关的自定义函数，通常用于封装 <code>dlopen</code> 的实际底层操作。</li></ul><p>**<code>dlopen</code>**：</p><ul><li><code>dlopen</code> 是动态库加载的标准函数，用于加载共享库（.so 文件）到当前进程的内存空间中。</li><li><code>filename</code> 是共享库的路径，<code>flag</code> 用于指定加载的方式（例如：是否立即绑定符号，是否允许卸载等）。</li></ul><h6 id="do-dlopen"><a href="#do-dlopen" class="headerlink" title="do_dlopen()"></a>do_dlopen()</h6><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/bionic/linker/dlfcn.cpp#dlopen_ext">http://androidxref.com/9.0.0_r3/xref/bionic/linker/dlfcn.cpp#dlopen_ext</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/22/9dlAX3xyU2JjpGD.png" alt="image-20241222121214603"></p><h4 id="FindSymbol-—调用JNI-OnLoad"><a href="#FindSymbol-—调用JNI-OnLoad" class="headerlink" title="FindSymbol()—调用JNI_OnLoad"></a>FindSymbol()—调用JNI_OnLoad</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* sym = library-&gt;FindSymbol(<span class="hljs-string">&quot;JNI_OnLoad&quot;</span>, nullptr);<br><span class="hljs-keyword">if</span> (sym == nullptr) &#123;<br>  VLOG(jni) &lt;&lt; <span class="hljs-string">&quot;[No JNI_OnLoad found in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot;]&quot;</span>;<br>  was_successful = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dlsym"><a href="#dlsym" class="headerlink" title="dlsym()"></a>dlsym()</h5><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/art/runtime/ti/agent.cc#154">http://androidxref.com/9.0.0_r3/xref/art/runtime/ti/agent.cc#154</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span>* <span class="hljs-title function_">Agent::FindSymbol</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name)</span> <span class="hljs-type">const</span> &#123;<br>  CHECK(dlopen_handle_ != nullptr) &lt;&lt; <span class="hljs-string">&quot;Cannot find symbols in an unloaded agent library &quot;</span> &lt;&lt; this;<br>  <span class="hljs-keyword">return</span> dlsym(dlopen_handle_, name.c_str());<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Android 和 Linux 系统中，<code>dlsym()</code> 是一个用于动态获取共享库中符号地址的函数，它是 POSIX 标准的一部分，主要用于在运行时动态加载共享库并解析其中的符号（函数或变量）。并返回该符号的地址。这通常用于在程序运行时动态加载库，并通过符号名称调用库中的函数或访问库中的变量。</p><p><code>dlsym()</code> 查找符号时，并不直接支持 C++ 命名空间。也就是说，如果一个符号在 C++ 中被定义在某个命名空间中，<code>dlsym()</code> 需要使用符号的完全限定名称来查找。比如：<code>mynamespace::my_function</code> 来查找符号。这通常是因为 C++ 编译器会将符号的名称进行修饰（name mangling）以区分同名的符号</p><h1 id="Liner入口"><a href="#Liner入口" class="headerlink" title="Liner入口"></a>Liner入口</h1><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/bionic/linker/linker.cpp">http://androidxref.com/9.0.0_r3/xref/bionic/linker/linker.cpp</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/23/qfZOGA8maJD3sMk.png" alt="image-20241223160431041"></p><p>根据传入的地址查找该地址所属的共享库。它通过遍历共享库链表，并检查每个共享库的内存地址范围来判断地址是否属于某个共享库。如果找到了，返回对应的 <code>soinfo</code>；否则返回 <code>nullptr</code>。</p><p>有必要看一看soinfo是什么？</p><p><img src="https://s2.loli.net/2024/12/27/JGLOySqPtNAc6Mu.png" alt="image-20241227122804586"></p><p>还有很多，简化一下就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">soinfo</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;              <span class="hljs-comment">// 库的名称</span><br>    <span class="hljs-type">void</span>* base;                    <span class="hljs-comment">// 库的基地址</span><br>    <span class="hljs-type">size_t</span> size;                   <span class="hljs-comment">// 库的大小</span><br>    Elf32_Dyn* dynamic;            <span class="hljs-comment">// 动态段表</span><br>    Elf32_Sym* symtab;             <span class="hljs-comment">// 符号表</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* strtab;            <span class="hljs-comment">// 字符串表</span><br>    Elf32_Rel* rel;                <span class="hljs-comment">// 重定位表</span><br>    Elf32_Rela* rela;              <span class="hljs-comment">// 带有附加信息的重定位表</span><br>    <span class="hljs-type">unsigned</span> flags;                <span class="hljs-comment">// 标志位</span><br>    soinfo* next;                  <span class="hljs-comment">// 指向下一个 soinfo 结构体的指针</span><br>    <span class="hljs-comment">// 其他与共享库相关的信息</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>soinfo</code> 结构体定义了与共享库相关的各种信息，包括库的名称、路径、状态、符号表、动态链接表等。它用于动态链接器中管理加载的共享库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">soinfo* <span class="hljs-title function_">find_containing_library</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* p)</span> &#123;<br>    <span class="hljs-comment">// 将传入的地址 &#x27;p&#x27; 转换为适当的类型（ElfW(Addr)）</span><br>    ElfW(Addr) address = reinterpret_cast&lt;ElfW(Addr)&gt;(p);<br>    <span class="hljs-comment">// 遍历共享库链表，从头开始</span><br>    <span class="hljs-keyword">for</span> (soinfo* si = solist_get_head(); si != nullptr; si = si-&gt;next) &#123;<br>        <span class="hljs-comment">// 检查地址是否位于当前共享库的地址范围内</span><br>        <span class="hljs-keyword">if</span> (address &gt;= si-&gt;base &amp;&amp; address - si-&gt;base &lt; si-&gt;size) &#123;<br>            <span class="hljs-comment">// 如果是，返回该共享库信息</span><br>            <span class="hljs-keyword">return</span> si;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有找到，返回 nullptr</span><br>    <span class="hljs-keyword">return</span> nullptr;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="find-libratry"><a href="#find-libratry" class="headerlink" title="find_libratry()"></a>find_libratry()</h2><p><img src="https://s2.loli.net/2024/12/23/OBLKityonI4sZWx.png" alt="image-20241223160507460"></p><p><img src="https://s2.loli.net/2024/12/23/k3DrPJKXstvMQil.png" alt="image-20241223160815792"></p><h3 id="find-libraries"><a href="#find-libraries" class="headerlink" title="find_libraries()"></a>find_libraries()</h3><p>先了解一下<code>LoadTask</code> 类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadTask</span> &#123;</span><br><span class="hljs-comment">// 1. deleter_t: 自定义析构器</span><br><span class="hljs-comment">// 用于销毁 LoadTask 对象并释放内存。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deleter_t</span> &#123;</span><br>  <span class="hljs-type">void</span> <span class="hljs-title function_">operator</span><span class="hljs-params">()</span><span class="hljs-params">(LoadTask* t)</span> &#123;<br>    t-&gt;~LoadTask();  <span class="hljs-comment">// 调用析构函数</span><br>    TypeBasedAllocator&lt;LoadTask&gt;::<span class="hljs-built_in">free</span>(t);  <span class="hljs-comment">// 释放内存</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 2. create() 方法: 工厂方法</span><br><span class="hljs-comment">// 用于创建并初始化一个 LoadTask 对象，分配内存并构造对象。</span><br><span class="hljs-type">static</span> LoadTask* <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span><br><span class="hljs-params">                        soinfo* needed_by,</span><br><span class="hljs-params">                        <span class="hljs-type">android_namespace_t</span>* start_from,</span><br><span class="hljs-params">                        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-type">const</span> soinfo*, ElfReader&gt;* readers_map)</span> &#123;<br>  LoadTask* ptr = TypeBasedAllocator&lt;LoadTask&gt;::alloc();  <span class="hljs-comment">// 分配内存</span><br>  <span class="hljs-keyword">return</span> new (ptr) LoadTask(name, needed_by, start_from, readers_map);  <span class="hljs-comment">// 在分配的内存上构造 LoadTask 对象</span><br>&#125;<br><br><span class="hljs-comment">// 3. getter 和 setter 方法</span><br><span class="hljs-comment">// 提供访问 LoadTask 对象各个成员变量的方法，供外部使用。</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">get_name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> name_; &#125;<br>soinfo* <span class="hljs-title function_">get_needed_by</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> needed_by_; &#125;<br>soinfo* <span class="hljs-title function_">get_soinfo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> si_; &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">set_soinfo</span><span class="hljs-params">(soinfo* si)</span> &#123; si_ = si; &#125;<br><span class="hljs-comment">// 其他 getter 和 setter 方法用于访问和修改成员变量。</span><br><br><span class="hljs-comment">// 4. get_elf_reader() 方法</span><br><span class="hljs-comment">// 返回与当前 soinfo 对象相关联的 ElfReader 对象，用于读取 ELF 文件。</span><br><span class="hljs-type">const</span> ElfReader&amp; <span class="hljs-title function_">get_elf_reader</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123;<br>  CHECK(si_ != nullptr);  <span class="hljs-comment">// 确保 si_ 不为空</span><br>  <span class="hljs-keyword">return</span> (*elf_readers_map_)[si_];  <span class="hljs-comment">// 获取 ElfReader 对象</span><br>&#125;<br><br>ElfReader&amp; <span class="hljs-title function_">get_elf_reader</span><span class="hljs-params">()</span> &#123;<br>  CHECK(si_ != nullptr);  <span class="hljs-comment">// 确保 si_ 不为空</span><br>  <span class="hljs-keyword">return</span> (*elf_readers_map_)[si_];  <span class="hljs-comment">// 获取 ElfReader 对象</span><br>&#125;<br><br><span class="hljs-comment">// 5. read() 方法</span><br><span class="hljs-comment">// 使用 ElfReader 读取指定的 ELF 文件。</span><br><span class="hljs-comment">// 参数: realpath（文件路径）、file_size（文件大小）</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* realpath, <span class="hljs-type">off64_t</span> file_size)</span> &#123;<br>  ElfReader&amp; elf_reader = get_elf_reader();  <span class="hljs-comment">// 获取 ElfReader 对象</span><br>  <span class="hljs-keyword">return</span> elf_reader.Read(realpath, fd_, file_offset_, file_size);  <span class="hljs-comment">// 调用 ElfReader 的 Read 方法</span><br>&#125;<br><br><span class="hljs-comment">// 6. load() 方法</span><br><span class="hljs-comment">// 使用 ElfReader 加载 ELF 文件并将加载的信息填充到 soinfo 结构体中。</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">load</span><span class="hljs-params">()</span> &#123;<br>  ElfReader&amp; elf_reader = get_elf_reader();  <span class="hljs-comment">// 获取 ElfReader 对象</span><br>  <span class="hljs-keyword">if</span> (!elf_reader.Load(extinfo_)) &#123;  <span class="hljs-comment">// 调用 Load 方法加载 ELF 文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 加载失败</span><br>  &#125;<br><br>  <span class="hljs-comment">// 填充 soinfo 结构体</span><br>  si_-&gt;base = elf_reader.load_start();  <span class="hljs-comment">// 设置库基地址</span><br>  si_-&gt;size = elf_reader.load_size();  <span class="hljs-comment">// 设置库大小</span><br>  si_-&gt;set_mapped_by_caller(elf_reader.is_mapped_by_caller());  <span class="hljs-comment">// 是否由调用者映射</span><br>  si_-&gt;load_bias = elf_reader.load_bias();  <span class="hljs-comment">// 加载偏移</span><br>  si_-&gt;phnum = elf_reader.phdr_count();  <span class="hljs-comment">// 段表数量</span><br>  si_-&gt;phdr = elf_reader.loaded_phdr();  <span class="hljs-comment">// 段表指针</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 加载成功</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>LoadTask</code> 类管理了一个库的加载过程，其中包括：</p><ol><li>**<code>create()</code>**：通过工厂方法创建 <code>LoadTask</code> 实例。</li><li>**<code>read()</code>**：读取 ELF 文件的内容。</li><li>**<code>load()</code>**：加载 ELF 文件到内存，并填充相关的库信息（如基地址、大小等）。</li><li>通过 <code>ElfReader</code> 类来处理 ELF 格式文件的加载和解析。</li></ol><p>下文的task就是<code>LoadTask</code> 类的实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//Step 0: 准备工作</span><br><span class="hljs-comment">//初始化必要的数据结构，包括库读取器 readers_map 和加载任务列表 load_tasks。</span><br>std::unordered_map&lt;<span class="hljs-type">const</span> soinfo*, ElfReader&gt; readers_map;<br>LoadTaskList load_tasks;<br><br><span class="hljs-comment">//Step 1: 扩展加载任务</span><br><span class="hljs-comment">//根据传入的库名称，创建对应的加载任务，并将这些任务添加到 load_tasks 列表中。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; library_names_count; ++i) &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = library_names[i];<br>  load_tasks.<span class="hljs-built_in">push_back</span>(LoadTask::<span class="hljs-built_in">create</span>(name, start_with, ns, &amp;readers_map));<br>&#125;<br><span class="hljs-comment">//Step 2: 处理 soinfos 数组</span><br><span class="hljs-comment">//如果 soinfos 为空，则动态分配一个大小为库数量的数组。</span><br><span class="hljs-keyword">if</span> (soinfos == <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-type">size_t</span> soinfos_size = <span class="hljs-built_in">sizeof</span>(soinfo*) * library_names_count;<br>  soinfos = reinterpret<br>      _cast&lt;soinfo**&gt;(<span class="hljs-built_in">alloca</span>(soinfos_size));<br>  <span class="hljs-built_in">memset</span>(soinfos, <span class="hljs-number">0</span>, soinfos_size);<br>&#125;<br><span class="hljs-comment">//Step 3: 加载库</span><br><span class="hljs-comment">//将所有的加载任务遍历一次，更新每个库的加载信息，设置是否需要从当前库加载更多的依赖库。然后开始调用 find_library_internal 来实际加载库。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; load_tasks.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>  LoadTask* task = load_tasks[i];<br>  soinfo* needed_by = task-&gt;<span class="hljs-built_in">get_needed_by</span>();<br>  <span class="hljs-type">bool</span> is_dt_needed = needed_by != <span class="hljs-literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);<br>  task-&gt;<span class="hljs-built_in">set_extinfo</span>(is_dt_needed ? <span class="hljs-literal">nullptr</span> : extinfo);<br>  task-&gt;<span class="hljs-built_in">set_dt_needed</span>(is_dt_needed);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">find_library_internal</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">android_namespace_t</span>*&gt;(task-&gt;<span class="hljs-built_in">get_start_from</span>()),<br>                             task,<br>                             &amp;zip_archive_cache,<br>                             &amp;load_tasks,<br>                             rtld_flags,<br>                             search_linked_namespaces || is_dt_needed)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//Step 4: 预加载库</span><br><span class="hljs-comment">//如果 ld_preloads 不为空，则将预加载的库添加到该列表中，并保证它们正确加载。</span><br><span class="hljs-keyword">if</span> (ld_preloads != <span class="hljs-literal">nullptr</span> &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;<br>  ld_preloads-&gt;<span class="hljs-built_in">push_back</span>(si);<br>&#125;<br>  LoadTaskList load_list;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; task : load_tasks) &#123;<br>    soinfo* si = task-&gt;<span class="hljs-built_in">get_soinfo</span>();<br>    <span class="hljs-keyword">auto</span> pred = [&amp;](<span class="hljs-type">const</span> LoadTask* t) &#123;<br>      <span class="hljs-keyword">return</span> t-&gt;<span class="hljs-built_in">get_soinfo</span>() == si;<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> (!si-&gt;<span class="hljs-built_in">is_linked</span>() &amp;&amp;<br>        std::<span class="hljs-built_in">find_if</span>(load_list.<span class="hljs-built_in">begin</span>(), load_list.<span class="hljs-built_in">end</span>(), pred) == load_list.<span class="hljs-built_in">end</span>() ) &#123;<br>      load_list.<span class="hljs-built_in">push_back</span>(task);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//随机打乱加载顺序以避免依赖关系的问题（如 b/24047022 错误）。</span><br>  <span class="hljs-built_in">shuffle</span>(&amp;load_list);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; task : load_list) &#123;<br>    <span class="hljs-keyword">if</span> (!task-&gt;<span class="hljs-built_in">load</span>()) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">//Step 5: 预链接所有 DT_NEEDED 库</span><br><span class="hljs-comment">//预先链接所有 DT_NEEDED 库，确保它们可以顺利链接。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; task : load_tasks) &#123;<br>  soinfo* si = task-&gt;<span class="hljs-built_in">get_soinfo</span>();<br>  <span class="hljs-keyword">if</span> (!si-&gt;<span class="hljs-built_in">is_linked</span>() &amp;&amp; !si-&gt;<span class="hljs-built_in">prelink_image</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//Step 6: 构建全局组</span><br><span class="hljs-comment">//在加载所有库后，处理全局库组，包括为预加载的库强制设置 DF_1_GLOBAL 标志，并将其加入到全局组中。</span><br><span class="hljs-keyword">if</span> (ld_preloads != <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; si : *ld_preloads) &#123;<br>    si-&gt;<span class="hljs-built_in">set_dt_flags_1</span>(si-&gt;<span class="hljs-built_in">get_dt_flags_1</span>() | DF_1_GLOBAL);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//Step 7: 链接跨命名空间的库</span><br><span class="hljs-comment">//在库链接时，可能会跨命名空间边界，需要收集这些库的根节点，并进行分组链接。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; task : load_tasks) &#123;<br>  soinfo* si = task-&gt;<span class="hljs-built_in">get_soinfo</span>();<br>  soinfo* needed_by = task-&gt;<span class="hljs-built_in">get_needed_by</span>();<br>  <span class="hljs-type">bool</span> is_dt_needed = needed_by != <span class="hljs-literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);<br>  <span class="hljs-type">android_namespace_t</span>* needed_by_ns =<br>      is_dt_needed ? needed_by-&gt;<span class="hljs-built_in">get_primary_namespace</span>() : ns;<br><br>  <span class="hljs-keyword">if</span> (!si-&gt;<span class="hljs-built_in">is_linked</span>() &amp;&amp; si-&gt;<span class="hljs-built_in">get_primary_namespace</span>() != needed_by_ns) &#123;<br>    local_group_roots.<span class="hljs-built_in">push_back</span>(si);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//Step 8: 链接本地组</span><br><span class="hljs-comment">//对所有本地库组进行链接，确保它们能够顺利链接，且不会跨命名空间错误。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> root : local_group_roots) &#123;<br>  <span class="hljs-type">soinfo_list_t</span> local_group;<br>  <span class="hljs-type">android_namespace_t</span>* local_group_ns = root-&gt;<span class="hljs-built_in">get_primary_namespace</span>();<br>  <span class="hljs-built_in">walk_dependencies_tree</span>(root, [&amp;](soinfo* si) &#123;<br>    <span class="hljs-keyword">if</span> (local_group_ns-&gt;<span class="hljs-built_in">is_accessible</span>(si)) &#123;<br>      local_group.<span class="hljs-built_in">push_back</span>(si);<br>      <span class="hljs-keyword">return</span> kWalkContinue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> kWalkSkip;<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-comment">//Step 9: 增加引用计数并标记链接</span><br><span class="hljs-comment">//标记所有加载的库为“已链接”，并更新引用计数，确保库之间的依赖关系得到正确处理。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; task : load_tasks) &#123;<br>  soinfo* si = task-&gt;<span class="hljs-built_in">get_soinfo</span>();<br>  si-&gt;<span class="hljs-built_in">set_linked</span>();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; task : load_tasks) &#123;<br>  soinfo* si = task-&gt;<span class="hljs-built_in">get_soinfo</span>();<br>  soinfo* needed_by = task-&gt;<span class="hljs-built_in">get_needed_by</span>();<br>  <span class="hljs-keyword">if</span> (needed_by != <span class="hljs-literal">nullptr</span> &amp;&amp;<br>      needed_by != start_with &amp;&amp;<br>      needed_by-&gt;<span class="hljs-built_in">get_local_group_root</span>() != si-&gt;<span class="hljs-built_in">get_local_group_root</span>()) &#123;<br>    si-&gt;<span class="hljs-built_in">increment_ref_count</span>();<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>加载库</strong>是动态加载、解决依赖关系的过程，通常在运行时进行；而<strong>预加载库</strong>是在程序启动时提前加载，确保一些库在程序启动时就已经准备好，避免后续的延迟和重复加载。</p></blockquote><h4 id="Step-3-加载库–find-library-internal"><a href="#Step-3-加载库–find-library-internal" class="headerlink" title="Step 3: 加载库–find_library_internal()"></a>Step 3: 加载库–find_library_internal()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//查找已加载的库：(通过 find_loaded_library_by_soname 函数检查库是否已经在当前命名空间或关联的命名空间中加载。如果找到已经加载的库，直接将其 soinfo 设置到 task 中并返回 true。)</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">find_loaded_library_by_soname</span>(ns, task-&gt;<span class="hljs-built_in">get_name</span>(), search_linked_namespaces, &amp;candidate)) &#123;<br>    task-&gt;<span class="hljs-built_in">set_soinfo</span>(candidate);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//如果库尚未加载，则调用 load_library 尝试加载该库。如果加载成功，返回 true。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">load_library</span>(ns, task, zip_archive_cache, load_tasks, rtld_flags, search_linked_namespaces)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//如果库未在当前命名空间找到，并且设置了 search_linked_namespaces 为 true，则会在当前命名空间的所有关联命名空间中查找该库。这是跨命名空间查找库的过程。</span><br><span class="hljs-keyword">if</span> (search_linked_namespaces) &#123;<br>    DlErrorRestorer dlerror_restorer;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; linked_namespace : ns-&gt;<span class="hljs-built_in">linked_namespaces</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find_library_in_linked_namespace</span>(linked_namespace, task)) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如果库在关联命名空间中找到，且该库未加载，系统会尝试在该命名空间中加载库。false 表示不再搜索其他关联命名空间。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">load_library</span>(linked_namespace.<span class="hljs-built_in">linked_namespace</span>(), task, zip_archive_cache, load_tasks, rtld_flags, <span class="hljs-literal">false</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//如果库已经加载（通过 find_library_in_linked_namespace 找到并已设置 soinfo），则直接返回 true。</span><br><span class="hljs-keyword">if</span> (task-&gt;<span class="hljs-built_in">get_soinfo</span>() == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//如果在当前命名空间及所有关联命名空间中都未找到该库，则返回 false。</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>这个函数执行流程为：</p><ol><li>使用find_load_library函数在已经加载的动态链接库链表里面查找该动态库，如果找到了，就返回该动态库的soinfo，否则第二步</li><li>此时，说明指定的动态链接库还没有被加载，就使用load_library函数来加载该动态库。</li></ol><h5 id="load-library"><a href="#load-library" class="headerlink" title="load_library()"></a>load_library()</h5><p>加载一个共享库，并通过一系列步骤来处理库的路径、文件描述符（FD）、偏移量等信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//提取任务中的信息：name：获取任务所需的库的名称。</span><br><span class="hljs-comment">//needed_by：获取该库被哪个库依赖。</span><br><span class="hljs-comment">//extinfo：获取扩展信息，包含额外的加载配置，如库的文件描述符等。</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = task-&gt;<span class="hljs-built_in">get_name</span>();<br>soinfo* needed_by = task-&gt;<span class="hljs-built_in">get_needed_by</span>();<br><span class="hljs-type">const</span> android_dlextinfo* extinfo = task-&gt;<span class="hljs-built_in">get_extinfo</span>();<br><span class="hljs-comment">//如果 extinfo 中包含 ANDROID_DLEXT_USE_LIBRARY_FD 标志，表示通过文件描述符来加载库。文件描述符可能是由调用者提供的，可以用来直接访问库文件。</span><br><span class="hljs-comment">//file_offset 会根据扩展信息中的偏移量来设置。如果 ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET 被设置，则会使用提供的 library_fd_offset。</span><br><span class="hljs-comment">//如果无法通过 realpath_fd 获取库的实际路径，则使用库的名称作为路径。</span><br><span class="hljs-comment">//然后，将文件描述符和文件偏移量设置到任务中，并递归调用 load_library 来加载库。</span><br><span class="hljs-keyword">if</span> (extinfo != <span class="hljs-literal">nullptr</span> &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) != <span class="hljs-number">0</span>) &#123;<br>    file_offset = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != <span class="hljs-number">0</span>) &#123;<br>        file_offset = extinfo-&gt;library_fd_offset;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">realpath_fd</span>(extinfo-&gt;library_fd, &amp;realpath)) &#123;<br>        <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;warning: unable to get realpath for the library \&quot;%s\&quot; by extinfo-&gt;library_fd. &quot;</span><br>              <span class="hljs-string">&quot;Will use given name.&quot;</span>, name);<br>        realpath = name;<br>    &#125;<br>    task-&gt;<span class="hljs-built_in">set_fd</span>(extinfo-&gt;library_fd, <span class="hljs-literal">false</span>);<br>    task-&gt;<span class="hljs-built_in">set_file_offset</span>(file_offset);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">load_library</span>(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);<br>&#125;<br><span class="hljs-comment">//如果没有通过文件描述符加载库，代码会尝试通过调用 open_library 打开库文件。</span><br><span class="hljs-comment">//如果打开失败，返回 false 并打印错误信息。</span><br><span class="hljs-type">int</span> fd = <span class="hljs-built_in">open_library</span>(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;library \&quot;%s\&quot; not found&quot;</span>, name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//如果成功打开库文件，将文件描述符和偏移量设置到 task 中。</span><br>task-&gt;<span class="hljs-built_in">set_fd</span>(fd, <span class="hljs-literal">true</span>);<br>task-&gt;<span class="hljs-built_in">set_file_offset</span>(file_offset);<br><span class="hljs-comment">//调用 load_library，传入库的实际路径 realpath，继续加载库。</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">load_library</span>(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);<br><br></code></pre></td></tr></table></figure><h5 id="load-library-重载"><a href="#load-library-重载" class="headerlink" title="load_library(重载)"></a>load_library(重载)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">load_library</span><span class="hljs-params">(<span class="hljs-type">android_namespace_t</span>* ns,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1189</span>                         LoadTask* task,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1190</span>                         LoadTaskList* load_tasks,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1191</span>                         <span class="hljs-type">int</span> rtld_flags,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1192</span>                         <span class="hljs-type">const</span> std::string&amp; realpath,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">1193</span>                         <span class="hljs-type">bool</span> search_linked_namespaces)</span> </span>&#123;<br>    <span class="hljs-comment">//文件偏移检查：加载共享库时，文件偏移必须是页面对齐的 (file_offset % PAGE_SIZE == 0)。</span><br><span class="hljs-comment">//负值检查：如果文件偏移为负数，也会返回错误。</span><br><span class="hljs-number">1194</span>  <span class="hljs-type">off64_t</span> file_offset = task-&gt;<span class="hljs-built_in">get_file_offset</span>();<br><span class="hljs-number">1195</span>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = task-&gt;<span class="hljs-built_in">get_name</span>();<br><span class="hljs-number">1196</span>  <span class="hljs-type">const</span> android_dlextinfo* extinfo = task-&gt;<span class="hljs-built_in">get_extinfo</span>();<br><span class="hljs-number">1197</span><span class="hljs-comment">//获取文件信息：通过 fstat 获取库文件的大小、权限等信息，确保文件偏移没有超出文件大小。</span><br><span class="hljs-number">1198</span>  <span class="hljs-keyword">if</span> ((file_offset % PAGE_SIZE) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">1199</span>    <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;file offset for the library \&quot;%s\&quot; is not page-aligned: %&quot;</span> PRId64, name, file_offset);<br><span class="hljs-number">1200</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1201</span>  &#125;<br><span class="hljs-number">1202</span>  <span class="hljs-keyword">if</span> (file_offset &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">1203</span>    <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;file offset for the library \&quot;%s\&quot; is negative: %&quot;</span> PRId64, name, file_offset);<br><span class="hljs-number">1204</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1205</span>  &#125;<br><span class="hljs-number">1206</span><br><span class="hljs-number">1207</span>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> file_stat;<br><span class="hljs-number">1208</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fstat</span>(task-&gt;<span class="hljs-built_in">get_fd</span>(), &amp;file_stat)) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">1209</span>    <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;unable to stat file for the library \&quot;%s\&quot;: %s&quot;</span>, name, <span class="hljs-built_in">strerror</span>(errno));<br><span class="hljs-number">1210</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1211</span>  &#125;<br><span class="hljs-number">1212</span>  <span class="hljs-keyword">if</span> (file_offset &gt;= file_stat.st_size) &#123;<br><span class="hljs-number">1213</span>    <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;file offset for the library \&quot;%s\&quot; &gt;= file size: %&quot;</span> PRId64 <span class="hljs-string">&quot; &gt;= %&quot;</span> PRId64,<br><span class="hljs-number">1214</span>        name, file_offset, file_stat.st_size);<br><span class="hljs-number">1215</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1216</span>  &#125;<br><span class="hljs-number">1217</span><br><span class="hljs-comment">//如果扩展信息没有设置 ANDROID_DLEXT_FORCE_LOAD 标志，函数会检查库是否已加载。如果库已经加载，并且与当前路径不同，则直接返回已加载的 soinfo 对象。</span><br><span class="hljs-number">1220</span>  <span class="hljs-keyword">if</span> (extinfo == <span class="hljs-literal">nullptr</span> || (extinfo-&gt;flags &amp; ANDROID_DLEXT_FORCE_LOAD) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">1221</span>    soinfo* si = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-number">1222</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find_loaded_library_by_inode</span>(ns, file_stat, file_offset, search_linked_namespaces, &amp;si)) &#123;<br><span class="hljs-number">1223</span>      <span class="hljs-built_in">TRACE</span>(<span class="hljs-string">&quot;library \&quot;%s\&quot; is already loaded under different name/path \&quot;%s\&quot; - &quot;</span><br><span class="hljs-number">1224</span>            <span class="hljs-string">&quot;will return existing soinfo&quot;</span>, name, si-&gt;<span class="hljs-built_in">get_realpath</span>());<br><span class="hljs-number">1225</span>      task-&gt;<span class="hljs-built_in">set_soinfo</span>(si);<br><span class="hljs-number">1226</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-number">1227</span>    &#125;<br><span class="hljs-number">1228</span>  &#125;<br><span class="hljs-number">1229</span><span class="hljs-comment">//RTLD_NOLOAD：如果设置了 RTLD_NOLOAD 标志，表示不加载库，因此会检查是否应该加载。</span><br><span class="hljs-number">1230</span>  <span class="hljs-keyword">if</span> ((rtld_flags &amp; RTLD_NOLOAD) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">1231</span>    <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;library \&quot;%s\&quot; wasn&#x27;t loaded and RTLD_NOLOAD prevented it&quot;</span>, name);<br><span class="hljs-number">1232</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1233</span>  &#125;<br><span class="hljs-number">1234</span><span class="hljs-comment">//通过 fstatfs 获取文件系统的类型，用于判断文件是否在某些特殊文件系统（如 tmpfs）中。</span><br><span class="hljs-number">1235</span>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">statfs</span> fs_stat;<br><span class="hljs-number">1236</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TEMP_FAILURE_RETRY</span>(<span class="hljs-built_in">fstatfs</span>(task-&gt;<span class="hljs-built_in">get_fd</span>(), &amp;fs_stat)) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">1237</span>    <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;unable to fstatfs file for the library \&quot;%s\&quot;: %s&quot;</span>, name, <span class="hljs-built_in">strerror</span>(errno));<br><span class="hljs-number">1238</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1239</span>  &#125;<br><span class="hljs-number">1240</span><br><span class="hljs-comment">//访问性检查：如果文件系统类型不是 tmpfs，则检查库的实际路径是否对指定的命名空间可访问。如果不可访问，会返回错误。</span><br><span class="hljs-number">1243</span>  <span class="hljs-keyword">if</span> ((fs_stat.f_type != TMPFS_MAGIC) &amp;&amp; (!ns-&gt;<span class="hljs-built_in">is_accessible</span>(realpath))) &#123;<br><span class="hljs-number">1248</span>    <span class="hljs-type">const</span> soinfo* needed_by = task-&gt;<span class="hljs-built_in">is_dt_needed</span>() ? task-&gt;<span class="hljs-built_in">get_needed_by</span>() : <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">//灰名单：如果库在灰名单中，表示该库的访问受限。在某些情况下，会输出警告。</span><br><span class="hljs-number">1249</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_greylisted</span>(ns, name, needed_by)) &#123;<br><span class="hljs-number">1251</span>      <span class="hljs-keyword">if</span> (needed_by == <span class="hljs-literal">nullptr</span> || !<span class="hljs-built_in">is_system_library</span>(needed_by-&gt;<span class="hljs-built_in">get_realpath</span>())) &#123;<br><span class="hljs-number">1252</span>        <span class="hljs-type">const</span> soinfo* needed_or_dlopened_by = task-&gt;<span class="hljs-built_in">get_needed_by</span>();<br><span class="hljs-number">1253</span>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sopath = needed_or_dlopened_by == <span class="hljs-literal">nullptr</span> ? <span class="hljs-string">&quot;(unknown)&quot;</span> :<br><span class="hljs-number">1254</span>                                                      needed_or_dlopened_by-&gt;<span class="hljs-built_in">get_realpath</span>();<br><span class="hljs-number">1255</span>        <span class="hljs-built_in">DL_WARN_documented_change</span>(__ANDROID_API_N__,<br><span class="hljs-number">1256</span>                                  <span class="hljs-string">&quot;private-api-enforced-for-api-level-24&quot;</span>,<br><span class="hljs-number">1257</span>                                  <span class="hljs-string">&quot;library \&quot;%s\&quot; (\&quot;%s\&quot;) needed or dlopened by \&quot;%s\&quot; &quot;</span><br><span class="hljs-number">1258</span>                                  <span class="hljs-string">&quot;is not accessible by namespace \&quot;%s\&quot;&quot;</span>,<br><span class="hljs-number">1259</span>                                  name, realpath.<span class="hljs-built_in">c_str</span>(), sopath, ns-&gt;<span class="hljs-built_in">get_name</span>());<br><span class="hljs-number">1260</span>        <span class="hljs-built_in">add_dlwarning</span>(sopath, <span class="hljs-string">&quot;unauthorized access to&quot;</span>,  name);<br><span class="hljs-number">1261</span>      &#125;<br><span class="hljs-number">1262</span>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">1263</span>      <span class="hljs-comment">// do not load libraries if they are not accessible for the specified namespace.</span><br><span class="hljs-number">1264</span>      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* needed_or_dlopened_by = task-&gt;<span class="hljs-built_in">get_needed_by</span>() == <span class="hljs-literal">nullptr</span> ?<br><span class="hljs-number">1265</span>                                          <span class="hljs-string">&quot;(unknown)&quot;</span> :<br><span class="hljs-number">1266</span>                                          task-&gt;<span class="hljs-built_in">get_needed_by</span>()-&gt;<span class="hljs-built_in">get_realpath</span>();<br><span class="hljs-number">1267</span><br><span class="hljs-number">1268</span>      <span class="hljs-built_in">DL_ERR</span>(<span class="hljs-string">&quot;library \&quot;%s\&quot; needed or dlopened by \&quot;%s\&quot; is not accessible for the namespace \&quot;%s\&quot;&quot;</span>,<br><span class="hljs-number">1269</span>             name, needed_or_dlopened_by, ns-&gt;<span class="hljs-built_in">get_name</span>());<br><span class="hljs-number">1270</span><br><span class="hljs-number">1271</span>      <span class="hljs-comment">// do not print this if a library is in the list of shared libraries for linked namespaces</span><br><span class="hljs-number">1272</span>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">maybe_accessible_via_namespace_links</span>(ns, name)) &#123;<br><span class="hljs-number">1273</span>        <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;library \&quot;%s\&quot; (\&quot;%s\&quot;) needed or dlopened by \&quot;%s\&quot; is not accessible for the&quot;</span><br><span class="hljs-number">1274</span>              <span class="hljs-string">&quot; namespace: [name=\&quot;%s\&quot;, ld_library_paths=\&quot;%s\&quot;, default_library_paths=\&quot;%s\&quot;,&quot;</span><br><span class="hljs-number">1275</span>              <span class="hljs-string">&quot; permitted_paths=\&quot;%s\&quot;]&quot;</span>,<br><span class="hljs-number">1276</span>              name, realpath.<span class="hljs-built_in">c_str</span>(),<br><span class="hljs-number">1277</span>              needed_or_dlopened_by,<br><span class="hljs-number">1278</span>              ns-&gt;<span class="hljs-built_in">get_name</span>(),<br><span class="hljs-number">1279</span>              android::base::<span class="hljs-built_in">Join</span>(ns-&gt;<span class="hljs-built_in">get_ld_library_paths</span>(), <span class="hljs-string">&#x27;:&#x27;</span>).<span class="hljs-built_in">c_str</span>(),<br><span class="hljs-number">1280</span>              android::base::<span class="hljs-built_in">Join</span>(ns-&gt;<span class="hljs-built_in">get_default_library_paths</span>(), <span class="hljs-string">&#x27;:&#x27;</span>).<span class="hljs-built_in">c_str</span>(),<br><span class="hljs-number">1281</span>              android::base::<span class="hljs-built_in">Join</span>(ns-&gt;<span class="hljs-built_in">get_permitted_paths</span>(), <span class="hljs-string">&#x27;:&#x27;</span>).<span class="hljs-built_in">c_str</span>());<br><span class="hljs-number">1282</span>      &#125;<br><span class="hljs-number">1283</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1284</span>    &#125;<br><span class="hljs-number">1285</span>  &#125;<br><span class="hljs-number">1286</span><span class="hljs-comment">//库分配和 ELF 解析：调用 soinfo_alloc 分配 soinfo 对象，并读取 ELF 文件头部信息。如果读取失败，释放资源并返回错误。</span><br><span class="hljs-number">1287</span>  soinfo* si = <span class="hljs-built_in">soinfo_alloc</span>(ns, realpath.<span class="hljs-built_in">c_str</span>(), &amp;file_stat, file_offset, rtld_flags);<br><span class="hljs-number">1288</span>  <span class="hljs-keyword">if</span> (si == <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-number">1289</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1290</span>  &#125;<br><span class="hljs-number">1291</span><br><span class="hljs-number">1292</span>  task-&gt;<span class="hljs-built_in">set_soinfo</span>(si);<br><span class="hljs-number">1293</span><br><span class="hljs-number">1294</span>  <span class="hljs-comment">// Read the ELF header and some of the segments.</span><br><span class="hljs-number">1295</span>  <span class="hljs-keyword">if</span> (!task-&gt;<span class="hljs-built_in">read</span>(realpath.<span class="hljs-built_in">c_str</span>(), file_stat.st_size)) &#123;<br><span class="hljs-number">1296</span>    <span class="hljs-built_in">soinfo_free</span>(si);<br><span class="hljs-number">1297</span>    task-&gt;<span class="hljs-built_in">set_soinfo</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-number">1298</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">1299</span>  &#125;<br><span class="hljs-number">1300</span><br><span class="hljs-comment">//解析 ELF 动态表：从 ELF 文件的动态段中提取 DT_RUNPATH 和 DT_SONAME，并将其设置到 soinfo 对象中。</span><br><span class="hljs-number">1305</span>  <span class="hljs-type">const</span> ElfReader&amp; elf_reader = task-&gt;<span class="hljs-built_in">get_elf_reader</span>();<br><span class="hljs-number">1306</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-built_in">ElfW</span>(Dyn)* d = elf_reader.<span class="hljs-built_in">dynamic</span>(); d-&gt;d_tag != DT_NULL; ++d) &#123;<br><span class="hljs-number">1307</span>    <span class="hljs-keyword">if</span> (d-&gt;d_tag == DT_RUNPATH) &#123;<br><span class="hljs-number">1308</span>      si-&gt;<span class="hljs-built_in">set_dt_runpath</span>(elf_reader.<span class="hljs-built_in">get_string</span>(d-&gt;d_un.d_val));<br><span class="hljs-number">1309</span>    &#125;<br><span class="hljs-number">1310</span>    <span class="hljs-keyword">if</span> (d-&gt;d_tag == DT_SONAME) &#123;<br><span class="hljs-number">1311</span>      si-&gt;<span class="hljs-built_in">set_soname</span>(elf_reader.<span class="hljs-built_in">get_string</span>(d-&gt;d_un.d_val));<br><span class="hljs-number">1312</span>    &#125;<br><span class="hljs-number">1313</span>  &#125;<br><span class="hljs-comment">//加载所需库：根据 ELF 文件中的 DT_NEEDED 动态段，递归地加载其他依赖的库。</span><br><span class="hljs-number">1315</span>  for_each_dt_needed(task-&gt;<span class="hljs-built_in">get_elf_reader</span>(), [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name) &#123;<br><span class="hljs-number">1316</span>    load_tasks-&gt;<span class="hljs-built_in">push_back</span>(LoadTask::<span class="hljs-built_in">create</span>(name, si, ns, task-&gt;<span class="hljs-built_in">get_readers_map</span>()));<br><span class="hljs-number">1317</span>  &#125;);<br><span class="hljs-number">1318</span><br><span class="hljs-number">1319</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-number">1320</span>&#125;<br></code></pre></td></tr></table></figure><p>load_library函数的执行过程可以概括如下：</p><ol><li>使用open_library函数打开指定so文件</li><li>创建ElfReader类对象，并通过该对象的read()方法，读取elf文件头，然后通过分析elf文件来加载各个segments</li><li>使用soinfo_alloc函数分配soinfo结构体，并为这个结构体中的各个成员赋值</li></ol><h6 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h6><p><img src="https://s2.loli.net/2024/12/23/oKMnOLaRYrkSiVz.png" alt="image-20241223163156598"></p><p>此函数依次调用ReadRlfHeader，verifyHeader，ReadProgramHeader()，ReserveAddressSpace()等等函数。本质就是读取解析ELF文件。</p><h4 id="Step-4-预加载库–task-load"><a href="#Step-4-预加载库–task-load" class="headerlink" title="Step 4: 预加载库–task-&gt;load()"></a>Step 4: 预加载库–task-&gt;load()</h4><p>加载ELF文件中的可加载segments：</p><p><img src="https://s2.loli.net/2024/12/23/BweX9okmyKROQ2M.png" alt="image-20241223162604211"></p><p><img src="https://s2.loli.net/2024/12/23/buw8SDLqKTrYWA9.png" alt="image-20241223162707657"></p><h5 id="LoadSegments"><a href="#LoadSegments" class="headerlink" title="LoadSegments"></a>LoadSegments</h5><p>现在就开始加载ELF文件中的可加载segments：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ElfReader::LoadSegments</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; phdr_num_; ++i) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-title function_">ElfW</span><span class="hljs-params">(Phdr)</span>* phdr = &amp;phdr_table_[i];<br><br>    <span class="hljs-keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Segment addresses in memory.</span><br>    ElfW(Addr) seg_start = phdr-&gt;p_vaddr + load_bias_;<br>    ElfW(Addr) seg_end   = seg_start + phdr-&gt;p_memsz;<br><br>    ElfW(Addr) seg_page_start = PAGE_START(seg_start);<br>    ElfW(Addr) seg_page_end   = PAGE_END(seg_end);<br><br>    ElfW(Addr) seg_file_end   = seg_start + phdr-&gt;p_filesz;<br>    <span class="hljs-comment">// File offsets.</span><br>    ElfW(Addr) file_start = phdr-&gt;p_offset;<br>    ElfW(Addr) file_end   = file_start + phdr-&gt;p_filesz;<br><br>    ElfW(Addr) file_page_start = PAGE_START(file_start);<br>    ElfW(Addr) file_length = file_end - file_page_start;<br><br>    <span class="hljs-keyword">if</span> (file_length != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">void</span>* seg_addr = mmap(reinterpret_cast&lt;<span class="hljs-type">void</span>*&gt;(seg_page_start),<br>                            file_length, <span class="hljs-comment">//是以文件大小为参照，而非内存大小</span><br>                            PFLAGS_TO_PROT(phdr-&gt;p_flags),<br>                            MAP_FIXED|MAP_PRIVATE,<br>                            fd_,<br>                            file_page_start);<br>      <span class="hljs-keyword">if</span> (seg_addr == MAP_FAILED) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;couldn&#x27;t map \&quot;%s\&quot; segment %zd: %s&quot;</span>, name_, i, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*如果segments可写，并且该segments的实际结束地址不在某一页的边界的话，就将该segments实际结束地址到此页的边界之间的内存全置为0*/</span><br>    <span class="hljs-keyword">if</span> ((phdr-&gt;p_flags &amp; PF_W) != <span class="hljs-number">0</span> &amp;&amp; PAGE_OFFSET(seg_file_end) &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">memset</span>(reinterpret_cast&lt;<span class="hljs-type">void</span>*&gt;(seg_file_end), <span class="hljs-number">0</span>, PAGE_SIZE - PAGE_OFFSET(seg_file_end));<br>    &#125;<br><br>    seg_file_end = PAGE_END(seg_file_end);<br><br>    <span class="hljs-comment">// seg_file_end is now the first page address after the file</span><br>    <span class="hljs-comment">// content. If seg_end is larger, we need to zero anything</span><br>    <span class="hljs-comment">// between them. This is done by using a private anonymous</span><br>    <span class="hljs-comment">// map for all extra pages.</span><br>    <span class="hljs-keyword">if</span> (seg_page_end &gt; seg_file_end) &#123;<br>      <span class="hljs-type">void</span>* zeromap = mmap(reinterpret_cast&lt;<span class="hljs-type">void</span>*&gt;(seg_file_end),<br>                           seg_page_end - seg_file_end,<br>                           PFLAGS_TO_PROT(phdr-&gt;p_flags),<br>                           MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,<br>                           <span class="hljs-number">-1</span>,<br>                           <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span> (zeromap == MAP_FAILED) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;couldn&#x27;t zero fill \&quot;%s\&quot; gap: %s&quot;</span>, name_, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>此部分功能很简单，就是将ELF中的可加载segments依次映射到内存中，并进行一些辅助扫尾工作</p><h5 id="FindPhdr"><a href="#FindPhdr" class="headerlink" title="FindPhdr"></a>FindPhdr</h5><p>返回程序头部表在内存中的地址，这与phdr_table_是不同的，后者是一个临时的，在so被重定位之前会为释放的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ElfReader::FindPhdr</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-title function_">ElfW</span><span class="hljs-params">(Phdr)</span>* phdr_limit = phdr_table_ + phdr_num_;<br><br>  <span class="hljs-comment">//如果段类型是 PT_PHDR, 那么我们就直接使用该段的地址.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> ElfW(Phdr)* phdr = phdr_table_; phdr &lt; phdr_limit; ++phdr) &#123;<br>    <span class="hljs-keyword">if</span> (phdr-&gt;p_type == PT_PHDR) &#123;<br>      <span class="hljs-keyword">return</span> CheckPhdr(load_bias_ + phdr-&gt;p_vaddr);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//否则，我们就检查第一个可加载段。如果该段的文件偏移值为0，那么就表示它是以ELF头开始的，我们就可以通过它来找到程序头表加载到内存的地址(虽然过程有点繁琐)。</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> ElfW(Phdr)* phdr = phdr_table_; phdr &lt; phdr_limit; ++phdr) &#123;<br>    <span class="hljs-keyword">if</span> (phdr-&gt;p_type == PT_LOAD) &#123;<br>      <span class="hljs-keyword">if</span> (phdr-&gt;p_offset == <span class="hljs-number">0</span>) &#123;<br>        ElfW(Addr)  elf_addr = load_bias_ + phdr-&gt;p_vaddr;<br>        <span class="hljs-type">const</span> <span class="hljs-title function_">ElfW</span><span class="hljs-params">(Ehdr)</span>* ehdr = reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-title function_">ElfW</span><span class="hljs-params">(Ehdr)</span>*&gt;<span class="hljs-params">(elf_addr)</span>;<br>        ElfW(Addr)  offset = ehdr-&gt;e_phoff;<br>        <span class="hljs-keyword">return</span> CheckPhdr((ElfW(Addr))ehdr + offset);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  DL_ERR(<span class="hljs-string">&quot;can&#x27;t find loaded phdr for \&quot;%s\&quot;&quot;</span>, name_);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此so文件的读取，加载工作就分析完毕了，可以发现，Android对so的加载操作只是以段为单位，跟section完全没有关系，另外，通过查看verifyElfheader的代码，我们还可以发现，android系统仅仅对ELF文件头的e_ident，e_type，e_version，e_machine进行验证（当然，e_phnum也是不能错的）所以，这就解释了为什么有些加壳so文件头的section相关字段可以任意修改，系统也不会报错了。</p><h4 id="Step-5-预链接所有-DT-NEEDED-库–si-prelink-image"><a href="#Step-5-预链接所有-DT-NEEDED-库–si-prelink-image" class="headerlink" title="Step 5: 预链接所有 DT_NEEDED 库–si-&gt;prelink_image()"></a>Step 5: 预链接所有 DT_NEEDED 库–si-&gt;prelink_image()</h4><p>如果一个目标文件参与动态链接，它的程序头部表将包含类型的PT_DYNAMIC的元素，此段包含.dynamic节区（这个节区是一个数组）。该节区采用一个特殊符号_DYNAMIC来标记，其中包含如下结构的数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <br>Elf32_Sword d_tag; <br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span> <br>Elf32_Word d_val; <br>Elf32_Addr d_ptr; <br>&#125; d_un; <br>&#125; Elf32_Dyn; <br><span class="hljs-keyword">extern</span> Elf32_Dyn _DYNAMIC[]; <span class="hljs-comment">//注意这里是一个数组</span><br><span class="hljs-comment">/*注意:</span><br><span class="hljs-comment">对每个这种类型的对象，d_tag控制d_un的解释含义： </span><br><span class="hljs-comment">d_val 此 Elf32_Word 对象表示一个整数值，可以有多种解释。</span><br><span class="hljs-comment">d_ptr 此 Elf32_Addr 对象代表程序的虚拟地址。</span><br><span class="hljs-comment">关于d_tag的值、该值的意义，及其与d_un的关系，可查看ELF.PDF*/</span><br><br></code></pre></td></tr></table></figure><p>该Elf32_Dyn数组就是soinfo结构体中的dynamic成员，在上面介绍的load_library函数中发现，si-&gt;dynamic被赋值为null，这就说明，在加载阶段是不需要此值的，只有在链接阶段才需要，android的动态库的链接工作是由linker完成，主要代码就是在linker.cpp的prelink_image(find_library_internal方法中调用),此函数的代码相当多，我们来分块分析；</p><blockquote><p><a href="http://androidxref.com/8.1.0_r33/xref/bionic/linker/linker.cpp#2864">http://androidxref.com/8.1.0_r33/xref/bionic/linker/linker.cpp#2864</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1. 提取动态节信息</span><br><span class="hljs-comment">// 调用 phdr_table_get_dynamic_section() 提取动态节 (DT_DYNAMIC)，并检查相关标志。</span><br>ElfW(Word) dynamic_flags = <span class="hljs-number">0</span>;<br>phdr_table_get_dynamic_section(phdr, phnum, load_bias, &amp;dynamic, &amp;dynamic_flags);<br><br><span class="hljs-comment">// 2. 打印信息（如果不是链接器的重定位过程）</span><br><span class="hljs-comment">// 如果当前操作不是重定位链接器，打印一些调试信息。</span><br><span class="hljs-type">bool</span> relocating_linker = (flags_ &amp; FLAG_LINKER) != <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!relocating_linker) &#123;<br>  INFO(<span class="hljs-string">&quot;[ Linking \&quot;%s\&quot; ]&quot;</span>, get_realpath());<br>  DEBUG(<span class="hljs-string">&quot;si-&gt;base = %p si-&gt;flags = 0x%08x&quot;</span>, reinterpret_cast&lt;<span class="hljs-type">void</span>*&gt;(base), flags_);<br>&#125;<br><br><span class="hljs-comment">// 3. 检查动态节是否存在</span><br><span class="hljs-comment">// 如果动态节为空，输出错误信息（非重定位链接器时），并返回 false。</span><br><span class="hljs-keyword">if</span> (dynamic == nullptr) &#123;<br>  <span class="hljs-keyword">if</span> (!relocating_linker) &#123;<br>    DL_ERR(<span class="hljs-string">&quot;missing PT_DYNAMIC in \&quot;%s\&quot;&quot;</span>, get_realpath());<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">if</span> (!relocating_linker) &#123;<br>    DEBUG(<span class="hljs-string">&quot;dynamic = %p&quot;</span>, dynamic);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 4. ARM 特定处理</span><br><span class="hljs-comment">// 如果是 ARM 架构，获取 ARM 异常处理信息。</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__arm__)</span><br>(<span class="hljs-type">void</span>) phdr_table_get_arm_exidx(phdr, phnum, load_bias,<br>                                &amp;ARM_exidx, &amp;ARM_exidx_count);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 5. 解析动态节中的信息</span><br><span class="hljs-comment">// 动态节中的条目可以按照任意顺序出现，除了 DT_NEEDED 元素的相对顺序。</span><br><span class="hljs-comment">// 这里处理了动态节中的每个条目，根据不同的 d_tag 类型进行解析。</span><br><span class="hljs-type">uint32_t</span> needed_count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (ElfW(Dyn)* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;<br>  DEBUG(<span class="hljs-string">&quot;d = %p, d[0](tag) = %p d[1](val) = %p&quot;</span>,<br>        d, reinterpret_cast&lt;<span class="hljs-type">void</span>*&gt;(d-&gt;d_tag), reinterpret_cast&lt;<span class="hljs-type">void</span>*&gt;(d-&gt;d_un.d_val));<br><br>  <span class="hljs-keyword">switch</span> (d-&gt;d_tag) &#123;<br>    <span class="hljs-comment">// 6. 处理 DT_SONAME (共享对象名称)</span><br>    <span class="hljs-keyword">case</span> DT_SONAME:<br>      <span class="hljs-comment">// 解析后将使用 strtab 初始化</span><br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 7. 处理哈希表相关信息</span><br>    <span class="hljs-keyword">case</span> DT_HASH:<br>      nbucket_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="hljs-number">0</span>];<br>      nchain_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="hljs-number">1</span>];<br>      bucket_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="hljs-number">8</span>);<br>      chain_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="hljs-number">8</span> + nbucket_ * <span class="hljs-number">4</span>);<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 8. 处理 GNU 哈希表信息</span><br>    <span class="hljs-keyword">case</span> DT_GNU_HASH:<br>      gnu_nbucket_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="hljs-number">0</span>];<br>      gnu_maskwords_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="hljs-number">2</span>];<br>      gnu_shift2_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="hljs-number">3</span>];<br>      gnu_bloom_filter_ = reinterpret_cast&lt;ElfW(Addr)*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="hljs-number">16</span>);<br>      gnu_bucket_ = reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(gnu_bloom_filter_ + gnu_maskwords_);<br>      gnu_chain_ = gnu_bucket_ + gnu_nbucket_ -<br>                   reinterpret_cast&lt;<span class="hljs-type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="hljs-number">1</span>];<br><br>      <span class="hljs-comment">// 检查是否为 2 的幂</span><br>      <span class="hljs-keyword">if</span> (!powerof2(gnu_maskwords_)) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;invalid maskwords for gnu_hash = 0x%x, in \&quot;%s\&quot; expecting power to two&quot;</span>,<br>               gnu_maskwords_, get_realpath());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      --gnu_maskwords_;  <span class="hljs-comment">// 修正掩码数目</span><br>      flags_ |= FLAG_GNU_HASH;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 9. 处理符号表、字符串表等信息</span><br>    <span class="hljs-keyword">case</span> DT_STRTAB:<br>      strtab_ = reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_STRSZ:<br>      strtab_size_ = d-&gt;d_un.d_val;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_SYMTAB:<br>      symtab_ = reinterpret_cast&lt;ElfW(Sym)*&gt;(load_bias + d-&gt;d_un.d_ptr);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_SYMENT:<br>      <span class="hljs-keyword">if</span> (d-&gt;d_un.d_val != <span class="hljs-keyword">sizeof</span>(ElfW(Sym))) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;invalid DT_SYMENT: %zd in \&quot;%s\&quot;&quot;</span>, static_cast&lt;<span class="hljs-type">size_t</span>&gt;(d-&gt;d_un.d_val), get_realpath());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 10. 处理 PLT 相关信息</span><br>    <span class="hljs-keyword">case</span> DT_PLTREL:<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USE_RELA)</span><br>      <span class="hljs-keyword">if</span> (d-&gt;d_un.d_val != DT_RELA) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;unsupported DT_PLTREL in \&quot;%s\&quot;; expected DT_RELA&quot;</span>, get_realpath());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-keyword">if</span> (d-&gt;d_un.d_val != DT_REL) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;unsupported DT_PLTREL in \&quot;%s\&quot;; expected DT_REL&quot;</span>, get_realpath());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 11. 处理跳转表（PLT）相关信息</span><br>    <span class="hljs-keyword">case</span> DT_JMPREL:<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USE_RELA)</span><br>      plt_rela_ = reinterpret_cast&lt;ElfW(Rela)*&gt;(load_bias + d-&gt;d_un.d_ptr);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      plt_rel_ = reinterpret_cast&lt;ElfW(Rel)*&gt;(load_bias + d-&gt;d_un.d_ptr);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 12. 处理 PLT 跳转表大小</span><br>    <span class="hljs-keyword">case</span> DT_PLTRELSZ:<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USE_RELA)</span><br>      plt_rela_count_ = d-&gt;d_un.d_val / <span class="hljs-keyword">sizeof</span>(ElfW(Rela));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      plt_rel_count_ = d-&gt;d_un.d_val / <span class="hljs-keyword">sizeof</span>(ElfW(Rel));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 13. 忽略某些动态节条目</span><br>    <span class="hljs-keyword">case</span> DT_ANDROID_REL:<br>    <span class="hljs-keyword">case</span> DT_ANDROID_RELSZ:<br>    <span class="hljs-keyword">case</span> DT_RELCOUNT:<br>    <span class="hljs-keyword">case</span> DT_RELA:<br>    <span class="hljs-keyword">case</span> DT_RELASZ:<br>    <span class="hljs-keyword">case</span> DT_RELAENT:<br>      DL_ERR(<span class="hljs-string">&quot;unsupported DT_ANDROID_REL in \&quot;%s\&quot;&quot;</span>, get_realpath());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 14. 处理初始化函数、构造函数数组等信息</span><br>    <span class="hljs-keyword">case</span> DT_INIT:<br>      init_func_ = reinterpret_cast&lt;<span class="hljs-type">linker_ctor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);<br>      DEBUG(<span class="hljs-string">&quot;%s constructors (DT_INIT) found at %p&quot;</span>, get_realpath(), init_func_);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_FINI:<br>      fini_func_ = reinterpret_cast&lt;<span class="hljs-type">linker_dtor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);<br>      DEBUG(<span class="hljs-string">&quot;%s destructors (DT_FINI) found at %p&quot;</span>, get_realpath(), fini_func_);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_INIT_ARRAY:<br>      init_array_ = reinterpret_cast&lt;<span class="hljs-type">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);<br>      DEBUG(<span class="hljs-string">&quot;%s constructors (DT_INIT_ARRAY) found at %p&quot;</span>, get_realpath(), init_array_);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_INIT_ARRAYSZ:<br>      init_array_count_ = static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="hljs-keyword">sizeof</span>(ElfW(Addr));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_FINI_ARRAY:<br>      fini_array_ = reinterpret_cast&lt;<span class="hljs-type">linker_dtor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);<br>      DEBUG(<span class="hljs-string">&quot;%s destructors (DT_FINI_ARRAY) found at %p&quot;</span>, get_realpath(), fini_array_);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_FINI_ARRAYSZ:<br>      fini_array_count_ = static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="hljs-keyword">sizeof</span>(ElfW(Addr));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_PREINIT_ARRAY:<br>      preinit_array_ = reinterpret_cast&lt;<span class="hljs-type">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);<br>      DEBUG(<span class="hljs-string">&quot;%s constructors (DT_PREINIT_ARRAY) found at %p&quot;</span>, get_realpath(), preinit_array_);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DT_PREINIT_ARRAYSZ:<br>      preinit_array_count_ = static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="hljs-keyword">sizeof</span>(ElfW(Addr));<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 15. 处理文本重定位（DT_TEXTREL）</span><br>    <span class="hljs-keyword">case</span> DT_TEXTREL:<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__LP64__)</span><br>      DL_ERR(<span class="hljs-string">&quot;\&quot;%s\&quot; has text relocations&quot;</span>, get_realpath());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      has_text_relocations = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 16. 标记 DT_SYMBOLIC</span><br>    <span class="hljs-keyword">case</span> DT_SYMBOLIC:<br>      has_DT_SYMBOLIC = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 17. 处理 DT_NEEDED 条目（共享对象依赖）</span><br>    <span class="hljs-keyword">case</span> DT_NEEDED:<br>      ++needed_count;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 18. 处理动态标志（DT_FLAGS, DT_FLAGS_1）</span><br>    <span class="hljs-keyword">case</span> DT_FLAGS:<br>      <span class="hljs-keyword">if</span> (d-&gt;d_un.d_val &amp; DF_TEXTREL) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__</span><br>          .......<br><br></code></pre></td></tr></table></figure><p>完成dynamic数组的遍历后，就说明我们已经获取了其中的有用信息了，那么现在就需要根据这些信息进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*in function soinfo_link_image */</span> <br><br>    <span class="hljs-comment">//再检测一遍，这种做法总是明智的</span><br>    <span class="hljs-keyword">if</span> (relocating_linker &amp;&amp; needed_count != <span class="hljs-number">0</span>) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;linker cannot have DT_NEEDED dependencies on other libraries&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (si-&gt;nbucket == <span class="hljs-number">0</span>) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;empty/missing DT_HASH in \&quot;%s\&quot; (built with --hash-style=gnu?)&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (si-&gt;strtab == <span class="hljs-number">0</span>) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;empty/missing DT_STRTAB in \&quot;%s\&quot;&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (si-&gt;symtab == <span class="hljs-number">0</span>) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;empty/missing DT_SYMTAB in \&quot;%s\&quot;&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// If this is the main executable, then load all of the libraries from LD_PRELOAD now.</span><br>    <span class="hljs-comment">//如果是main可执行文件，那么就根据LD_PRELOAD信息来加载所有相关的库</span><br>    <span class="hljs-comment">//这里面涉及到的gLdPreloadNames变量，我们知道在前面的整个分析过程中均没有涉及，这是因为，对于可执行文件而言，它的起始函数并不是dlopen，而是系统内核的execv函数，通过层层调用之后才会执行到linker的linker_init_post_ralocation函数，在这个函数中调用parse_LD_PRELOAD函数完成 gLdPreloadNames变量的赋值</span><br>    <span class="hljs-keyword">if</span> (si-&gt;flags &amp; FLAG_EXE) &#123;<br>        <span class="hljs-built_in">memset</span>(gLdPreloads, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(gLdPreloads));<br>        <span class="hljs-type">size_t</span> preload_count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; gLdPreloadNames[i] != <span class="hljs-literal">NULL</span>; i++) &#123;<br>            soinfo* lsi = find_library(gLdPreloadNames[i]);<br>            <span class="hljs-keyword">if</span> (lsi != <span class="hljs-literal">NULL</span>) &#123;<br>                gLdPreloads[preload_count++] = lsi;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ........<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//分配一个soinfo*[]指针数组，用于存放本so库需要的外部so库的soinfo指针</span><br>    soinfo** needed = reinterpret_cast&lt;soinfo**&gt;(alloca((<span class="hljs-number">1</span> + needed_count) * <span class="hljs-keyword">sizeof</span>(soinfo*)));<br>    soinfo** pneeded = needed;<br>    <span class="hljs-comment">//依次获取dynamic数组中定义的每一个外部so库soinfo</span><br>    <span class="hljs-keyword">for</span> (ElfW(Dyn)* d = si-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;<br>        <span class="hljs-keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* library_name = si-&gt;strtab + d-&gt;d_un.d_val; <span class="hljs-comment">//根据index值获取所需库的名字</span><br>            DEBUG(<span class="hljs-string">&quot;%s needs %s&quot;</span>, si-&gt;name, library_name);<br>            soinfo* lsi = find_library(library_name);  <span class="hljs-comment">//获取该库的soinfo</span><br>            <span class="hljs-keyword">if</span> (lsi == <span class="hljs-literal">NULL</span>) &#123;<br>                ........<br>            &#125;<br>            *pneeded++ = lsi;<br>        &#125;<br>    &#125;<br>    *pneeded = <span class="hljs-literal">NULL</span>; <br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(__LP64__)</span><br>    <span class="hljs-keyword">if</span> (si-&gt;has_text_relocations) &#123;<br>        <span class="hljs-comment">// Make segments writable to allow text relocations to work properly. We will later call</span><br>        <span class="hljs-comment">// phdr_table_protect_segments() after all of them are applied and all constructors are run.</span><br>        DL_WARN(<span class="hljs-string">&quot;%s has text relocations. This is wasting memory and prevents &quot;</span><br>                <span class="hljs-string">&quot;security hardening. Please fix.&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">if</span> (phdr_table_unprotect_segments(si-&gt;phdr, si-&gt;phnum, si-&gt;load_bias) &lt; <span class="hljs-number">0</span>) &#123;<br>            DL_ERR(<span class="hljs-string">&quot;can&#x27;t unprotect loadable segments for \&quot;%s\&quot;: %s&quot;</span>,<br>                   si-&gt;name, strerror(errno));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(USE_RELA)</span><br>    <span class="hljs-keyword">if</span> (si-&gt;plt_rela != <span class="hljs-literal">NULL</span>) &#123;<br>        DEBUG(<span class="hljs-string">&quot;[ relocating %s plt ]\n&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">if</span> (soinfo_relocate(si, si-&gt;plt_rela, si-&gt;plt_rela_count, needed)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (si-&gt;rela != <span class="hljs-literal">NULL</span>) &#123;<br>        DEBUG(<span class="hljs-string">&quot;[ relocating %s ]\n&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">if</span> (soinfo_relocate(si, si-&gt;rela, si-&gt;rela_count, needed)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (si-&gt;plt_rel != <span class="hljs-literal">NULL</span>) &#123;<br>        DEBUG(<span class="hljs-string">&quot;[ relocating %s plt ]&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">if</span> (soinfo_relocate(si, si-&gt;plt_rel, si-&gt;plt_rel_count, needed)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (si-&gt;rel != <span class="hljs-literal">NULL</span>) &#123;<br>        DEBUG(<span class="hljs-string">&quot;[ relocating %s ]&quot;</span>, si-&gt;name);<br>        <span class="hljs-keyword">if</span> (soinfo_relocate(si, si-&gt;rel, si-&gt;rel_count, needed)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__mips__)</span><br>    <span class="hljs-keyword">if</span> (!mips_relocate_got(si, needed)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    si-&gt;flags |= FLAG_LINKED;<br>    DEBUG(<span class="hljs-string">&quot;[ finished linking %s ]&quot;</span>, si-&gt;name);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(__LP64__)</span><br>    <span class="hljs-keyword">if</span> (si-&gt;has_text_relocations) &#123;<br>        <span class="hljs-comment">// All relocations are done, we can protect our segments back to read-only.</span><br>        <span class="hljs-keyword">if</span> (phdr_table_protect_segments(si-&gt;phdr, si-&gt;phnum, si-&gt;load_bias) &lt; <span class="hljs-number">0</span>) &#123;<br>            DL_ERR(<span class="hljs-string">&quot;can&#x27;t protect segments for \&quot;%s\&quot;: %s&quot;</span>,<br>                   si-&gt;name, strerror(errno));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* We can also turn on GNU RELRO protection */</span><br>    <span class="hljs-keyword">if</span> (phdr_table_protect_gnu_relro(si-&gt;phdr, si-&gt;phnum, si-&gt;load_bias) &lt; <span class="hljs-number">0</span>) &#123;<br>        DL_ERR(<span class="hljs-string">&quot;can&#x27;t enable GNU RELRO protection for \&quot;%s\&quot;: %s&quot;</span>,<br>               si-&gt;name, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    notify_gdb_of_load(si);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="执行so文件"><a href="#执行so文件" class="headerlink" title="执行so文件"></a>执行so文件</h1><p>上面的find_library_internal函数中prelink_image的函数执行后就返回到上层函数find_library中，然后进一步返回到do_dlopen函数：</p><h2 id="do-dlopen-1"><a href="#do-dlopen-1" class="headerlink" title="do_dlopen"></a>do_dlopen</h2><p>如果获取的si不为空，就说明so的加载和链接操作正确完成，那么就可以执行so的初始化构造函数了：</p><p><img src="https://s2.loli.net/2024/12/27/VnSPedL7pKXB4z5.png" alt="image-20241227125905659"></p><h3 id="call-constructors"><a href="#call-constructors" class="headerlink" title="call_constructors"></a>call_constructors</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">soinfo::call_constructors</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果构造函数已经被调用过，则直接返回，避免重复调用。</span><br>    <span class="hljs-keyword">if</span> (constructors_called) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 标记构造函数已经被调用，防止递归调用</span><br>    constructors_called = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 如果当前库不是主执行文件，并且存在 DT_PREINIT_ARRAY，则打印警告</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_main_executable</span>() &amp;&amp; preinit_array_ != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// GNU 动态链接器会忽略这些构造函数，但这里打印警告提醒开发者</span><br>        <span class="hljs-built_in">PRINT</span>(<span class="hljs-string">&quot;\&quot;%s\&quot;: ignoring DT_PREINIT_ARRAY in shared library!&quot;</span>, <span class="hljs-built_in">get_realpath</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历当前库的所有子库，递归调用它们的构造函数</span><br>    <span class="hljs-built_in">get_children</span>().for_each([] (soinfo* si) &#123;<br>        si-&gt;<span class="hljs-built_in">call_constructors</span>();<br>    &#125;);<br><br>    <span class="hljs-comment">// 如果当前库不是链接器，则开始追踪构造函数调用过程</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_linker</span>()) &#123;<br>        <span class="hljs-built_in">bionic_trace_begin</span>((std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;calling constructors: &quot;</span>) + <span class="hljs-built_in">get_realpath</span>()).<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 调用 DT_INIT 函数，初始化库</span><br>    <span class="hljs-comment">// 注意，DT_INIT 函数应该在 DT_INIT_ARRAY 之前调用</span><br>    <span class="hljs-built_in">call_function</span>(<span class="hljs-string">&quot;DT_INIT&quot;</span>, init_func_, <span class="hljs-built_in">get_realpath</span>());<br><br>    <span class="hljs-comment">// 如果存在 DT_INIT_ARRAY，则调用数组中的所有构造函数</span><br>    <span class="hljs-built_in">call_array</span>(<span class="hljs-string">&quot;DT_INIT_ARRAY&quot;</span>, init_array_, init_array_count_, <span class="hljs-literal">false</span>, <span class="hljs-built_in">get_realpath</span>());<br><br>    <span class="hljs-comment">// 如果当前库不是链接器，则结束追踪构造函数调用过程</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_linker</span>()) &#123;<br>        <span class="hljs-built_in">bionic_trace_end</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于我们只分析so库，所以只需要关心CallArray(“DT_INIT_ARRAY”, init_array, init_array_count, false)函数即可：</p><h3 id="CallArray"><a href="#CallArray" class="headerlink" title="CallArray"></a>CallArray</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">call_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* array_name __unused,</span><br><span class="hljs-params">                       F* functions,</span><br><span class="hljs-params">                       <span class="hljs-type">size_t</span> count,</span><br><span class="hljs-params">                       <span class="hljs-type">bool</span> reverse,</span><br><span class="hljs-params">                       <span class="hljs-type">const</span> <span class="hljs-type">char</span>* realpath)</span> &#123;<br>    <span class="hljs-comment">// 如果传入的函数数组为空，直接返回</span><br>    <span class="hljs-keyword">if</span> (functions == nullptr) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印调用函数数组的开始信息，显示数组名称、大小、指针地址和真实路径</span><br>    TRACE(<span class="hljs-string">&quot;[ Calling %s (size %zd) @ %p for &#x27;%s&#x27; ]&quot;</span>, array_name, count, functions, realpath);<br><br>    <span class="hljs-comment">// 根据是否反向遍历（reverse），设置开始索引、结束索引和步长</span><br>    <span class="hljs-type">int</span> begin = reverse ? (count - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end = reverse ? <span class="hljs-number">-1</span> : count;<br>    <span class="hljs-type">int</span> step = reverse ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 遍历函数数组，并调用每个函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin; i != end; i += step) &#123;<br>        <span class="hljs-comment">// 打印当前调用的函数信息</span><br>        TRACE(<span class="hljs-string">&quot;[ %s[%d] == %p ]&quot;</span>, array_name, i, functions[i]);<br>        <span class="hljs-comment">// 调用函数</span><br>        call_function(<span class="hljs-string">&quot;function&quot;</span>, functions[i], realpath);<br>    &#125;<br><br>    <span class="hljs-comment">// 打印完成调用数组的结束信息</span><br>    TRACE(<span class="hljs-string">&quot;[ Done calling %s for &#x27;%s&#x27; ]&quot;</span>, array_name, realpath);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要对init_array节区的结构和作用加以说明<br>首先是init_array节区的数据结构。该节中包含指针，这些指针指向了一些初始化代码。这些初始化代码一般是在main函数之前执行的。在C++程序中，这些代码用来运行静态构造函数。另外一个用途就是有时候用来初始化C库中的一些IO系统。使用IDA查看具有init_array节区的so库文件就可以找到如下数据：</p><p><img src="https://s2.loli.net/2024/12/27/A5Li8pzubdH1OJP.png" alt="28a0d3f7bea7f027cc2dc4308500c552"></p><p>这里共三个函数指针，每个指针指向一个函数地址。值得注意的是，上图中每个函数指针的值都加了1，这是因为地址的最后1位置1表明需要使得处理器由ARM转为Thumb状态来处理Thumb指令。将目标地址处的代码解释为Thumb代码来执行。</p><p>然后再来看CallFunction的具体实现：</p><h4 id="CallFunction"><a href="#CallFunction" class="headerlink" title="CallFunction"></a>CallFunction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">soinfo::CallFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* function_name UNUSED, <span class="hljs-type">linker_function_t</span> function)</span> &#123;<br>  <span class="hljs-comment">//如果函数地址为空或者为-1就直接退出。</span><br>  <span class="hljs-keyword">if</span> (function == <span class="hljs-literal">NULL</span> || reinterpret_cast&lt;<span class="hljs-type">uintptr_t</span>&gt;(function) == static_cast&lt;<span class="hljs-type">uintptr_t</span>&gt;(<span class="hljs-number">-1</span>)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ........<br>  function(); <span class="hljs-comment">//执行该指针所指定的函数</span><br>  <span class="hljs-comment">// The function may have called dlopen(3) or dlclose(3), so we need to ensure our data structures</span><br>  <span class="hljs-comment">// are still writable. This happens with our debug malloc (see http://b/7941716).</span><br>  set_soinfo_pool_protection(PROT_READ | PROT_WRITE);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此，整个Android so的linker机制就分析完毕了！</p>]]></content>
    
    
    <categories>
      
      <category>逆向(android)</category>
      
      <category>文件格式/装载链接运行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向(android)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JNI机制分析</title>
    <link href="/2024/01/08/Android-JNI%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <url>/2024/01/08/Android-JNI%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>关于android中的Jni机制，在前面的文章中都或多或少介绍过。</p><p>比如在<a href="https://wangxiaobai08.github.io/2022/08/21/%E5%88%9D%E8%AF%86JVM/">初识JVM - The Peak Tower</a>我们谈到JNI的基本概念【JNI作为连接Java世界和C&#x2F;C++世界的桥梁】和调用大致过程还有java层调用的本地代码在本地C实现的函数命名规则,</p><p>在<a href="https://wangxiaobai08.github.io/2024/01/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">android系统启动流程 - The Peak Tower</a>中谈到了Android系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C&#x2F;C++的进程，即Zygote进程。Zygote启动过程中会<code>AndroidRuntime.cpp</code>中的<code>startVm</code>创建虚拟机，VM创建完成后，紧接着调用<code>startReg</code>完成虚拟机中的JNI方法注册。接着在register_jni_procs(gRegJNI, NELEM(gRegJNI), env)方法中循环调用<code>gRegJNI</code>数组成员所对应的方法。而<code>gRegJNI</code>数组，有100多个成员变量，每个成员都代表一个类文件的jni映射，其中REG_JNI是一个宏定义，在<a href="http://gityuan.com/2016/02/13/android-zygote">Zygote</a>中介绍过，该宏的作用就是调用相应的方法。</p><p>在<a href="https://wangxiaobai08.github.io/2024/05/25/So%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5(linker)/#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace%E6%9C%BA%E5%88%B6">So加载和链接(linker) - The Peak Tower</a>中我们介绍了用户定义的so如何被加载运行但一笔带过了FindSymbol调用JNI_Load</p><p>今天这篇文章将着重了解JNI的底层实现原理。</p><h1 id="JNI原理分析"><a href="#JNI原理分析" class="headerlink" title="JNI原理分析"></a>JNI原理分析</h1><h2 id="JNI注册"><a href="#JNI注册" class="headerlink" title="JNI注册"></a>JNI注册</h2><h3 id="注册时机"><a href="#注册时机" class="headerlink" title="注册时机"></a>注册时机</h3><ul><li>Android系统启动过程中Zygote注册，可通过查询AndroidRuntime.cpp中的gRegJNI，看看是否存在对应的register方法；</li><li>调用System.loadLibrary()方式注册。</li></ul><h3 id="注册方法"><a href="#注册方法" class="headerlink" title="注册方法"></a>注册方法</h3><h4 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1. 静态注册"></a><strong>1. 静态注册</strong></h4><p><strong>静态注册</strong>是通过在 Java 类的静态代码块中调用本地方法进行注册，并且通常使用 <code>JNI_OnLoad</code> 方法进行初始化。</p><p><strong>静态注册过程：</strong></p><ol><li><p><strong>在 Java 层声明 <code>native</code> 方法</strong>：</p><ul><li>使用 <code>native</code> 关键字声明一个本地方法，表示该方法将由 C&#x2F;C++ 层实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-comment">// 声明一个 native 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 加载本地库</span><br>        System.loadLibrary(<span class="hljs-string">&quot;example&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在本地代码中实现 <code>native</code> 方法</strong>：</p><ul><li>本地代码中实现与 Java 层 <code>native</code> 方法相对应的函数。函数名根据 JNI 命名规范进行命名。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT jint JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_example_Example_add</span><span class="hljs-params">(JNIEnv* env, jobject thiz, jint a, jint b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在本地代码中注册方法</strong>：</p><ul><li>在 <code>JNI_OnLoad</code> 函数中，通过 <code>RegisterNatives</code> 函数静态注册本地方法。<code>JNI_OnLoad</code> 是在本地库加载时调用的一个特殊函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> JNINativeMethod gMethods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;(II)I&quot;</span>, (<span class="hljs-type">void</span>*) Java_com_example_Example_add&#125;<br>&#125;;<br><br><span class="hljs-function">JNIEXPORT jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-type">void</span>* reserved)</span> </span>&#123;<br>    JNIEnv* env;<br>    <span class="hljs-keyword">if</span> (vm-&gt;<span class="hljs-built_in">GetEnv</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;<br>        <span class="hljs-keyword">return</span> JNI_ERR;<br>    &#125;<br><br>    jclass clazz = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;com/example/Example&quot;</span>);<br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> JNI_ERR;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">RegisterNatives</span>(clazz, gMethods, <span class="hljs-built_in">sizeof</span>(gMethods) / <span class="hljs-built_in">sizeof</span>(gMethods[<span class="hljs-number">0</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> JNI_ERR;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> JNI_VERSION_1_6;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>优点：</strong></p><ul><li><strong>简洁性</strong>：方法注册和本地代码绑定在 <code>JNI_OnLoad</code> 中一次性完成，结构较为简单。</li><li><strong>性能</strong>：静态注册是通过本地库加载时一次性注册所有方法，性能上相对较好。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>不够灵活</strong>：方法必须在本地库加载时进行注册，动态修改注册内容比较困难。</li><li><strong>不能在运行时修改或增加本地方法</strong>，只能在库加载时一次性注册。</li></ul><hr><h4 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2. 动态注册"></a><strong>2. 动态注册</strong></h4><p><strong>动态注册</strong>是通过 Java 层的某个方法手动调用 <code>RegisterNatives</code> 来注册本地方法。这通常是用来在程序运行时决定是否注册特定的本地方法。</p><p><strong>动态注册过程：</strong></p><ol><li><p><strong>在 Java 层声明 <code>native</code> 方法</strong>：</p><ul><li>与静态注册一样，在 Java 层声明本地方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在本地代码中实现 <code>native</code> 方法</strong>：</p><ul><li>本地代码中实现对应的 <code>native</code> 方法。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT jint JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_example_Example_add</span><span class="hljs-params">(JNIEnv* env, jobject thiz, jint a, jint b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在 Java 层手动加载库和注册方法</strong>：</p><ul><li>使用 <code>System.loadLibrary</code> 加载本地库。</li><li>在 Java 类的静态初始化代码中调用 <code>registerNativeMethods</code> 进行动态注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    System.loadLibrary(<span class="hljs-string">&quot;example&quot;</span>);<br>    registerNativeMethods();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerNativeMethods</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>在本地代码中实现方法注册</strong>：</p><ul><li>本地代码中实现 <code>registerNativeMethods</code> 函数，手动注册 <code>native</code> 方法。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_example_Example_registerNativeMethods</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> JNINativeMethod methods[] = &#123;<br>        &#123;<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;(II)I&quot;</span>, (<span class="hljs-type">void</span>*)Java_com_example_Example_add&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">RegisterNatives</span>(clazz, methods, <span class="hljs-built_in">sizeof</span>(methods) / <span class="hljs-built_in">sizeof</span>(methods[<span class="hljs-number">0</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 注册失败，处理错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>优点：</strong></p><ul><li><strong>灵活性</strong>：方法可以在运行时注册，适用于根据条件选择性注册方法。</li><li><strong>可以在多个地方调用</strong>：可以在应用运行过程中根据需要多次注册不同的本地方法。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>复杂性</strong>：相较于静态注册，动态注册需要手动调用注册函数，增加了代码复杂度。</li><li><strong>性能</strong>：每次注册都需要手动调用 <code>RegisterNatives</code>，如果频繁调用，可能对性能产生影响。</li></ul><hr><h4 id="静态注册与动态注册的对比"><a href="#静态注册与动态注册的对比" class="headerlink" title="静态注册与动态注册的对比"></a><strong>静态注册与动态注册的对比</strong></h4><table><thead><tr><th>特性</th><th>静态注册</th><th>动态注册</th></tr></thead><tbody><tr><td><strong>注册时机</strong></td><td>本地库加载时（通过 <code>JNI_OnLoad</code>）</td><td>在 Java 代码中手动注册（通过 <code>registerNativeMethods</code>）</td></tr><tr><td><strong>方法注册方式</strong></td><td>一次性注册所有方法</td><td>可以根据需要在运行时动态注册特定方法</td></tr><tr><td><strong>灵活性</strong></td><td>低，方法必须在加载时全部注册</td><td>高，支持运行时注册和修改</td></tr><tr><td><strong>性能</strong></td><td>较好，注册一次，性能开销较小</td><td>可能稍差，如果频繁注册，可能增加开销</td></tr><tr><td><strong>使用场景</strong></td><td>一般用于方法数量固定、不变的情况</td><td>适用于需要根据条件注册不同方法的情况</td></tr></tbody></table><blockquote><p>注意：方法的参数是JNIEnv指针，其中JNIEnv是重点，它<strong>代表Native世界中Java环境的代表，通过JNIEnv* 指针可以在Native世界访问Java世界的代码</strong>，进行操作，它只在创建它的线程中有效，不能跨线程传递。</p></blockquote><p>在中间的流程不多介绍，具体可看<a href="https://wangxiaobai08.github.io/2024/05/25/So%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5(linker)/#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace%E6%9C%BA%E5%88%B6">So加载和链接(linker) - The Peak Tower</a>我们就续这这篇文章中的调用JNI_Load开始说起</p><blockquote><p>这里以提供系统服务与Native层的桥接。</p><p>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;jni&#x2F;为例，源码地址：</p><p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/jni/com_android_server_SystemServer.cpp">Cross Reference: &#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;jni&#x2F;com_android_server_SystemServer.cpp</a></p></blockquote><h2 id="jniRegisterNativeMethods"><a href="#jniRegisterNativeMethods" class="headerlink" title="jniRegisterNativeMethods"></a>jniRegisterNativeMethods</h2><p><img src="https://s2.loli.net/2024/12/30/Ocau4SzJw5EXQhk.png" alt="image-20241230110810313"></p><p><code>JNINativeMethod</code> 是 Android JNI 中用于描述 Java 层方法和本地 C&#x2F;C++ 实现之间映射关系的结构体。</p><ul><li><p>**<code>name</code>**：Java方法的名称，例如 <code>startSensorService</code>。</p></li><li><p><code>signature</code>方法的签名，用于标识方法的参数和返回值类型。这里 “()V”</p><p> 表示方法无参数且无返回值。</p><ul><li><code>&quot;()&quot;</code>：括号内是参数列表（无参数）。</li><li><code>&quot;V&quot;</code>：返回值类型（<code>V</code> 表示 <code>void</code>）。</li></ul></li><li><p>**<code>funcPtr</code>**：指向 C&#x2F;C++ 实现函数的指针。</p></li></ul><p>jniRegisterNativeMethods是 Android 提供的工具函数，用于将 JNINativeMethod</p><p> 中定义的本地方法注册到指定的 Java 类。</p><ul><li>参数说明：<ul><li><code>env</code>：JNI 环境指针。</li><li><code>&quot;com/android/server/SystemServer&quot;</code>：Java 层类的全限定名称。</li><li><code>gMethods</code>：包含本地方法信息的数组。</li><li><code>NELEM(gMethods)</code>：计算数组元素个数，用于告知方法数量。</li></ul></li><li><strong>作用：</strong> 将本地方法和 Java 方法绑定，Java 层调用 <code>startSensorService</code> 或 <code>startHidlServices</code> 方法时，会执行对应的 C&#x2F;C++ 实现函数。</li></ul><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/AndroidRuntime.cpp#292">Cross Reference: &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</a></p></blockquote><h3 id="AndroidRuntime-registerNativeMethods"><a href="#AndroidRuntime-registerNativeMethods" class="headerlink" title="AndroidRuntime::registerNativeMethods"></a>AndroidRuntime::registerNativeMethods</h3><p><img src="https://s2.loli.net/2024/12/30/TLUzhwkuGFg91Jv.png" alt="image-20241230111331181"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 静态函数，用于注册JNI本地方法。该函数是对jniRegisterNativeMethods的简单封装。</span><br><span class="hljs-comment"> * 通过提供JNI环境指针（env）、Java类名（className）、本地方法数组（gMethods）及方法数量（numMethods），</span><br><span class="hljs-comment"> * 将C/C++实现的本地方法绑定到对应的Java类。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AndroidRuntime::registerNativeMethods</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* className, <span class="hljs-type">const</span> JNINativeMethod* gMethods, <span class="hljs-type">int</span> numMethods)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * jniRegisterNativeMethods 是 Android 系统提供的工具函数，</span><br><span class="hljs-comment">     * 用于将本地方法数组注册到特定 Java 类，完成 Java 层与 Native 层方法的绑定。</span><br><span class="hljs-comment">     * 返回值为注册结果：JNI_OK 表示成功。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">jniRegisterNativeMethods</span>(env, className, gMethods, numMethods);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="jniRegisterNativeMethods-1"><a href="#jniRegisterNativeMethods-1" class="headerlink" title="jniRegisterNativeMethods"></a>jniRegisterNativeMethods</h4><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/libnativehelper/JNIHelp.cpp#124">Cross Reference: &#x2F;libnativehelper&#x2F;JNIHelp.cpp</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * jniRegisterNativeMethods</span><br><span class="hljs-comment"> * 这是一个用于注册本地方法的函数，将指定的本地方法数组与Java类绑定。</span><br><span class="hljs-comment"> * 如果出现错误，会调用 `FatalError` 终止程序运行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jniRegisterNativeMethods</span><span class="hljs-params">(C_JNIEnv* env, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* className,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> JNINativeMethod* gMethods, <span class="hljs-type">int</span> numMethods)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 将 C_JNIEnv* 转换为 JNIEnv*，以便使用标准 JNI 函数。</span><br><span class="hljs-comment">     * C_JNIEnv 是 Android 的自定义封装，兼容不同的运行时。</span><br><span class="hljs-comment">     */</span><br>    JNIEnv* e = <span class="hljs-built_in">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);<br><br>    <span class="hljs-comment">// 打印调试信息，指示正在注册的方法数量和目标类。</span><br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Registering %s&#x27;s %d native methods...&quot;</span>, className, numMethods);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 通过 scoped_local_ref 自动管理 Java 类引用，避免内存泄漏。</span><br><span class="hljs-comment">     * 使用 findClass 函数在 JVM 中查找目标 Java 类。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">scoped_local_ref&lt;jclass&gt; <span class="hljs-title">c</span><span class="hljs-params">(env, findClass(env, className))</span></span>;<br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">get</span>() == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 如果未找到目标类</span><br>        <span class="hljs-type">char</span>* tmp;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg;<br>        <span class="hljs-comment">// 使用 asprintf 生成错误消息，提示类未找到。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">asprintf</span>(&amp;tmp,<br>                     <span class="hljs-string">&quot;Native registration unable to find class &#x27;%s&#x27;; aborting...&quot;</span>,<br>                     className) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-comment">// 如果分配失败，使用默认错误消息。</span><br>            msg = <span class="hljs-string">&quot;Native registration unable to find class; aborting...&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg = tmp;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 调用 FatalError 终止程序运行，并打印错误信息。</span><br><span class="hljs-comment">         * 通常发生在系统关键模块加载失败的情况下。</span><br><span class="hljs-comment">         */</span><br>        e-&gt;<span class="hljs-built_in">FatalError</span>(msg);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用 JNI 的 RegisterNatives 函数，将本地方法数组与目标类绑定。</span><br><span class="hljs-comment">     * 如果绑定失败（返回值 &lt; 0），生成错误信息并终止程序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> ((*env)-&gt;<span class="hljs-built_in">RegisterNatives</span>(e, c.<span class="hljs-built_in">get</span>(), gMethods, numMethods) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span>* tmp;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg;<br>        <span class="hljs-comment">// 使用 asprintf 生成错误消息，提示绑定失败。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">asprintf</span>(&amp;tmp, <span class="hljs-string">&quot;RegisterNatives failed for &#x27;%s&#x27;; aborting...&quot;</span>, className) == <span class="hljs-number">-1</span>) &#123;<br>            msg = <span class="hljs-string">&quot;RegisterNatives failed; aborting...&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg = tmp;<br>        &#125;<br>        <span class="hljs-comment">// 调用 FatalError 打印错误并终止程序。</span><br>        e-&gt;<span class="hljs-built_in">FatalError</span>(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// 注册成功，返回 0。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="RegisterNatives"><a href="#RegisterNatives" class="headerlink" title="RegisterNatives"></a>RegisterNatives</h5><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/libnativehelper/include_jni/jni.h#976">Cross Reference: &#x2F;libnativehelper&#x2F;include_jni&#x2F;jni.h</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/30/dCaeLAfRw4blyDQ.png" alt="image-20241230112145879"></p><p> <code>RegisterNatives</code>将本地方法数组（<code>methods</code>）注册到指定的 Java 类（<code>clazz</code>）。是 JNI 提供的核心接口，用于完成 Java 层和 Native 层方法的绑定。</p><hr><p><strong>参数说明</strong></p><p><strong>jclass clazz：</strong></p><ul><li>要绑定本地方法的 Java 类。</li><li>必须是一个有效的 Java 类对象（<code>jclass</code> 类型）。</li></ul><p><strong>const JNINativeMethod* methods：</strong></p><p>一个数组，包含 Java 层方法与 Native 层方法的映射。每个元素是一个 JNINativeMethod结构体，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JNINativeMethod</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;       <span class="hljs-comment">// Java 方法名</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* signature;  <span class="hljs-comment">// Java 方法的 JNI 签名</span><br>    <span class="hljs-type">void</span>* fnPtr;            <span class="hljs-comment">// 对应的本地方法函数指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> JNINativeMethod gMethods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;nativeMethodName&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, (<span class="hljs-type">void</span>*)nativeMethodImplementation&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong><code>jint nMethods</code>：</strong><code>methods</code> 数组中方法的数量。而</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span> functions-&gt;<span class="hljs-built_in">RegisterNatives</span>(<span class="hljs-keyword">this</span>, clazz, methods, nMethods);<br></code></pre></td></tr></table></figure><p><code>functions</code>：</p><ul><li>一个指向 <code>JNIInvokeInterface</code> 或 <code>JNINativeInterface</code> 的函数表结构体。</li><li>它定义了 JNI 提供的所有接口函数，包括 <code>RegisterNatives</code>。</li></ul><p><code>functions-&gt;RegisterNatives</code>：</p><ul><li>实际执行本地方法注册的底层实现。</li><li>通过当前 <code>JNIEnv</code>（<code>this</code>）调用，确保方法绑定到正确的虚拟机实例。</li></ul><hr><h6 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h6><p><img src="https://s2.loli.net/2024/12/30/bc89DhJ3pWVgrS1.png" alt="image-20241230112602261"></p><p>functions是指向<code>JNINativeInterface</code>结构体指针，也就是将调用下面方法：</p><h6 id="JNINativeInterface"><a href="#JNINativeInterface" class="headerlink" title="JNINativeInterface"></a>JNINativeInterface</h6><p>它是 JNI 的核心函数表，定义了所有 JNI 提供的函数接口。每个函数指针对应一个具体的 JNI 方法实现。包含指向 JNI 方法的函数指针。 这是 JNI 环境与 Java 虚拟机（JVM）交互的核心接口。</p><p><img src="https://s2.loli.net/2024/12/30/7zFrgxaTc83HIhj.png" alt="image-20241230112801648"></p><p>再往下深入就到了虚拟机内部吧，这里就不再往下深入了。 总之，这个过程完成了<code>gMethods</code>数组中的方法的映射关系，比如java层的native_init()方法，映射到native层的android_media_MediaPlayer_native_init()方法。</p><p>虚拟机相关的变量中有两个非常重要的量JavaVM和JNIEnv:</p><ul><li><code>JavaVM</code>：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例</li><li><code>JNIEnv</code>：是指线程上下文环境，每个线程有且只有一个JNIEnv实例，</li></ul><h2 id="JNI资源"><a href="#JNI资源" class="headerlink" title="JNI资源"></a>JNI资源</h2><p>JNINativeMethod结构体中有一个字段为signature(签名)，再介绍signature格式之前需要掌握各种数据类型在Java层、Native层以及签名所采用的签名格式。</p><p>以下是 <strong>Java层、Native层</strong> 和 <strong>签名格式</strong> 对应关系的表格：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>Java 层类型</strong></th><th><strong>Native 层类型</strong></th><th><strong>签名格式（Signature）</strong></th></tr></thead><tbody><tr><td><strong>基本数据类型</strong></td><td></td><td></td><td></td></tr><tr><td><code>boolean</code></td><td><code>boolean</code></td><td><code>jboolean</code> (unsigned char)</td><td><code>Z</code></td></tr><tr><td><code>byte</code></td><td><code>byte</code></td><td><code>jbyte</code> (signed char)</td><td><code>B</code></td></tr><tr><td><code>char</code></td><td><code>char</code></td><td><code>jchar</code> (unsigned short)</td><td><code>C</code></td></tr><tr><td><code>short</code></td><td><code>short</code></td><td><code>jshort</code> (short)</td><td><code>S</code></td></tr><tr><td><code>int</code></td><td><code>int</code></td><td><code>jint</code> (int)</td><td><code>I</code></td></tr><tr><td><code>long</code></td><td><code>long</code></td><td><code>jlong</code> (long long)</td><td><code>J</code></td></tr><tr><td><code>float</code></td><td><code>float</code></td><td><code>jfloat</code> (float)</td><td><code>F</code></td></tr><tr><td><code>double</code></td><td><code>double</code></td><td><code>jdouble</code> (double)</td><td><code>D</code></td></tr><tr><td><code>void</code></td><td><code>void</code></td><td><code>void</code></td><td><code>V</code></td></tr><tr><td><strong>引用类型</strong></td><td></td><td></td><td></td></tr><tr><td><code>String</code></td><td><code>java.lang.String</code></td><td><code>jstring</code></td><td><code>Ljava/lang/String;</code></td></tr><tr><td><code>Object</code></td><td><code>java.lang.Object</code></td><td><code>jobject</code></td><td><code>Ljava/lang/Object;</code></td></tr><tr><td><code>Class</code></td><td><code>java.lang.Class</code></td><td><code>jclass</code></td><td><code>Ljava/lang/Class;</code></td></tr><tr><td><code>Throwable</code></td><td><code>java.lang.Throwable</code></td><td><code>jthrowable</code></td><td><code>Ljava/lang/Throwable;</code></td></tr><tr><td><strong>数组类型</strong></td><td></td><td></td><td></td></tr><tr><td><code>boolean[]</code></td><td><code>boolean[]</code></td><td><code>jbooleanArray</code></td><td><code>[Z</code></td></tr><tr><td><code>byte[]</code></td><td><code>byte[]</code></td><td><code>jbyteArray</code></td><td><code>[B</code></td></tr><tr><td><code>char[]</code></td><td><code>char[]</code></td><td><code>jcharArray</code></td><td><code>[C</code></td></tr><tr><td><code>short[]</code></td><td><code>short[]</code></td><td><code>jshortArray</code></td><td><code>[S</code></td></tr><tr><td><code>int[]</code></td><td><code>int[]</code></td><td><code>jintArray</code></td><td><code>[I</code></td></tr><tr><td><code>long[]</code></td><td><code>long[]</code></td><td><code>jlongArray</code></td><td><code>[J</code></td></tr><tr><td><code>float[]</code></td><td><code>float[]</code></td><td><code>jfloatArray</code></td><td><code>[F</code></td></tr><tr><td><code>double[]</code></td><td><code>double[]</code></td><td><code>jdoubleArray</code></td><td><code>[D</code></td></tr><tr><td><code>Object[]</code></td><td><code>Object[]</code></td><td><code>jobjectArray</code></td><td><code>[Ljava/lang/Object;</code></td></tr><tr><td><strong>特殊类型</strong></td><td></td><td></td><td></td></tr><tr><td><code>void</code> (方法返回值)</td><td><code>void</code> (无返回值方法)</td><td>无对应类型</td><td><code>V</code></td></tr></tbody></table><hr><h3 id="签名格式规则"><a href="#签名格式规则" class="headerlink" title="签名格式规则"></a><strong>签名格式规则</strong></h3><ol><li><strong>基本数据类型</strong><ul><li>单个字符表示类型（如 <code>I</code> 表示 <code>int</code>，<code>D</code> 表示 <code>double</code>）。</li></ul></li><li><strong>引用类型</strong><ul><li>格式为：<code>L&lt;类全限定名&gt;;</code>。</li><li>例如，<code>java.lang.String</code> 的签名为 <code>Ljava/lang/String;</code>。</li></ul></li><li><strong>数组类型</strong><ul><li>格式为：<code>[&lt;元素类型&gt;</code>。</li><li>例如，<code>int[]</code> 的签名为 <code>[I</code>，<code>String[]</code> 的签名为 <code>[Ljava/lang/String;</code>。</li></ul></li><li><strong>方法签名</strong><ul><li>格式为：<code>(&lt;参数签名列表&gt;)&lt;返回值签名&gt;</code>。</li><li>例如：<ul><li><code>int add(int a, int b)</code> 的签名为：<code>(II)I</code>。</li><li><code>void print(String message)</code> 的签名为：<code>(Ljava/lang/String;)V</code>。</li></ul></li></ul></li></ol><hr><h4 id="示例：JNINativeMethod-中的签名"><a href="#示例：JNINativeMethod-中的签名" class="headerlink" title="示例：JNINativeMethod 中的签名"></a><strong>示例：JNINativeMethod 中的签名</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> JNINativeMethod gMethods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;nativeAdd&quot;</span>, <span class="hljs-string">&quot;(II)I&quot;</span>, (<span class="hljs-type">void</span>*)nativeAdd&#125;,       <span class="hljs-comment">// 参数为两个 int，返回值为 int</span><br>    &#123;<span class="hljs-string">&quot;nativePrint&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)V&quot;</span>, (<span class="hljs-type">void</span>*)nativePrint&#125;, <span class="hljs-comment">// 参数为 String，返回值为 void</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Andorid源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APP安装到启动流程大体概览</title>
    <link href="/2024/01/08/APP%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E8%BF%90%E8%A1%8C%E5%85%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/01/08/APP%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E8%BF%90%E8%A1%8C%E5%85%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>先做浅显了解，以后有机会逐步完善。可参考博客</p></blockquote><h1 id="APP的安装流程"><a href="#APP的安装流程" class="headerlink" title="APP的安装流程"></a>APP的安装流程</h1><p><img src="https://s2.loli.net/2024/10/10/4HXtJhebOwPIGcf.png" alt="image-20241010214711282"></p><h2 id="第一阶段：复制文件"><a href="#第一阶段：复制文件" class="headerlink" title="第一阶段：复制文件"></a>第一阶段：复制文件</h2><p><img src="https://s2.loli.net/2024/10/10/DhXGCjs3KOZ2BHi.png" alt="9362993e232c6af3891ce6829de2aef2"></p><p>在此阶段，Android系统会将应用的APK文件复制到设备的文件系统中。具体流程如下：</p><ul><li><p><strong>APK文件获取</strong>：用户通过应用商店、下载链接或其他方式获取APK文件。</p></li><li><p><strong>存储到设备</strong>：APK文件被存储在设备的文件系统中，通常是在 &#x2F;data&#x2F;app&#x2F;</p><p>目录下。该目录会有一个对应的应用包名的文件夹，用来存放已经解压后的APK文件内容。</p></li><li><p><strong>文件权限</strong>：系统会为这个APK文件设置适当的文件权限，确保只有系统和相关的进程可以读取和执行该文件。</p></li></ul><h2 id="第二阶段：装载程序"><a href="#第二阶段：装载程序" class="headerlink" title="第二阶段：装载程序"></a>第二阶段：装载程序</h2><p><img src="https://s2.loli.net/2024/10/10/WvRmIbhPVsTgnZ3.png" alt="package-install"></p><p>复制文件阶段完成之后，下一步是“装载程序”。这一步涉及到加载APK的内容、解析并执行它。：</p><ol><li><strong>解析APK文件</strong>：Android系统会对APK进行解压和解析。APK文件实际上是一个ZIP压缩包，里面包含了所有的资源文件、代码文件、配置文件等。主要的内容包括：</li><li><ul><li><code>AndroidManifest.xml</code>：应用的配置文件，包含了应用的组件声明（如Activity、Service等）、权限声明等。</li><li><code>classes.dex</code>：应用的字节码文件，Android运行时需要将它转化为能够在设备上运行的代码。</li><li>资源文件：如图片、布局、字符串等。</li></ul></li><li><strong>安装应用的DEX文件</strong>：系统会将应用的 <code>.dex</code> 文件（即Dalvik Executable文件，包含了应用的字节码）加载到Android Runtime（ART）中。ART会将这些DEX文件转化为设备能够执行的机器码。</li><li><strong>创建应用环境</strong>：系统会为应用分配一个虚拟机环境，通常是由ART或以前的Dalvik虚拟机提供。ART是Android 5.0（Lollipop）引入的替代Dalvik虚拟机的运行时环境。</li><li><strong>执行Manifest中的内容</strong>：根据<code>AndroidManifest.xml</code>中的配置，系统会启动应用的主要组件（通常是一个<code>Activity</code>）来初始化应用并显示给用户。</li><li><strong>权限校验</strong>：如果应用请求了特定的权限（如访问网络、存储等），系统会根据用户的设置进行权限检查。</li></ol><h1 id="APP的点击流程"><a href="#APP的点击流程" class="headerlink" title="APP的点击流程"></a>APP的点击流程</h1><p><img src="https://s2.loli.net/2024/10/04/JcLIRkvzVSKoq4E.png" alt="android系统启动"></p><p><img src="https://s2.loli.net/2024/10/04/nsUo3r4utRji1Fm.png" alt="app启动流程"></p><p><img src="https://s2.loli.net/2024/10/05/GPKZUFqgTaydYw5.png" alt="image-20241005211526117"></p><p><img src="https://s2.loli.net/2024/10/05/uQyat9Kbm2Hqoe4.png" alt="image-20241005212311099"></p><p><img src="https://s2.loli.net/2024/10/05/HMOEJP1lsGp86Vd.png" alt="image-20241005213207355"></p><p><img src="https://s2.loli.net/2024/10/06/jg4soyz5nPrXQ8f.png" alt="image-20241006103407540"></p><p><img src="https://s2.loli.net/2024/10/06/5gaTJ7GdwMbhQUx.png" alt="image-20241006103501500"></p><p><img src="https://s2.loli.net/2024/10/06/Y5X9stNqvQOoKCz.png" alt="image-20241006103758437"></p><p><img src="https://s2.loli.net/2024/10/06/AOVEzW6TrMQdRJY.png" alt="image-20241006110642344"></p><p><img src="https://s2.loli.net/2024/10/06/CTr9KchqPs5ypab.png" alt="image-20241006111849730"></p><p>IApplicationThread是一个Binder接口,它继承自IInterface.ApplicationThread是继承了IApplicationThread.Stub,实现了IApplicationThread的,所以可以转成IApplicationThread.</p><p>然后就是获取AMS实例,调用AMS的startActivity方法.</p><p><img src="https://s2.loli.net/2024/10/06/EVWZXzm7NfKqsRY.png" alt="image-20241006112345684"></p><p><img src="https://s2.loli.net/2024/10/06/M9rjhUaIDdsbkEc.png" alt="image-20241006120744848"></p><p>AMS的startActivity方法会调用AMS的startActivityAsUser方法,然后又调用另一个startActivityAsUser方法.最后来了一串链式调用,最后会来到ActivityStarter的execute方法.</p><p><img src="https://s2.loli.net/2024/10/06/wf7g3a5eDOAIdMS.png" alt="image-20241006121821413"></p><p><img src="https://s2.loli.net/2024/10/06/AtuXoPJ23V5c6iH.png" alt="image-20241006122621849"></p><p>**<code>startActivity()</code>**：负责启动 <code>Activity</code> 的主要逻辑。它会调用 <code>startActivityUnchecked()</code> 来执行大部分实际工作，并确保在操作完成后进行适当的资源管理和清理操作。</p><p>**<code>startActivityUnchecked()</code>**：负责不经过任何外部校验的启动逻辑，它会设置 <code>Activity</code> 的初始状态和启动标志，然后通过后续方法计算启动 <code>Activity</code> 的任务栈标志。</p><p>resumeTopActivityUncheckedLocked</p><p>resumeTopActivityInnerLocked</p><p>startSpecificActivityLocked</p><p><img src="https://s2.loli.net/2024/10/06/AbQBX7SOg2HVJ9C.png" alt="image-20241006123519451"></p><p><strong>检查应用是否已在运行</strong>：通过查找进程记录，确认 <code>Activity</code> 所属的应用进程是否已经存在。</p><p>**启动已存在的进程中的 <code>Activity</code>**：如果应用进程已经存在，则直接通过 <code>realStartActivityLocked()</code> 启动目标 <code>Activity</code>。</p><p><strong>进程不存在时启动新进程</strong>：如果目标应用进程不存在，则通过 <code>startProcessLocked()</code> 启动一个新的进程。</p><p>调用AMS的startProcessLocked方法.</p><p><code>startProcessLocked</code> 是核心的一部分，用于在系统中管理应用的生命周期，包括启动新的进程或重启崩溃的进程。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>启动或重启指定的应用进程。</li><li>提供了各种控制参数，例如进程名、应用信息、是否在启动时允许等。</li><li>处理多种进程类型（如普通进程和隔离进程）。</li></ul><p>这里AMS调用了很多层startProcessLocked,最终都会调用startProcess方法,然后通过Process调用<a href="https://zhida.zhihu.com/search?content_id=103118005&content_type=Article&match_order=1&q=start%E6%96%B9%E6%B3%95&zhida_source=entity">start方法</a>.</p><p><img src="https://s2.loli.net/2024/10/06/6AtS3DX5LsRnyhU.png" alt="image-20241006124412870"></p><p><strong>启动新进程</strong>：根据给定的参数启动应用的进程，支持多种类型的进程（如普通应用进程和 WebView 服务进程）。</p><p><strong>性能跟踪</strong>：使用 <code>Trace</code> 对进程启动过程进行性能跟踪。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> ProcessStartResult <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">String</span> processClass,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> niceName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> gid, <span class="hljs-type">int</span>[] gids,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">int</span> runtimeFlags, <span class="hljs-type">int</span> mountExternal,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">int</span> targetSdkVersion,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">String</span> seInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">String</span> abi,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">String</span> instructionSet,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">String</span> appDataDir,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">String</span> invokeWith,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">String</span>[] zygoteArgs)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> zygoteProcess.<span class="hljs-built_in">start</span>(processClass, niceName, uid, gid, gids,<br>                   runtimeFlags, mountExternal, targetSdkVersion, seInfo,<br>                   abi, instructionSet, appDataDir, invokeWith, zygoteArgs);<br>   &#125;<br>   <br>   <br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/10/06/Yxd7U6kRlqtv8Qs.png" alt="image-20241006125216381"></p><p><img src="https://s2.loli.net/2024/10/06/tvoz36g5CRu2dKq.png" alt="image-20241006125453498"></p><p><img src="https://s2.loli.net/2024/10/06/rZiTwfmoRycJ29v.png" alt="image-20241006125414902"></p><h1 id="APP的启动流程"><a href="#APP的启动流程" class="headerlink" title="APP的启动流程"></a>APP的启动流程</h1><p><code>ActivityThread</code> 类的 <code>main</code> 方法的实现，它是应用程序主线程的入口点，负责初始化主线程的 Looper 和消息处理机制，以及启动应用程序的运行环境。<code>ActivityThread</code> 是应用程序的主线程类，负责管理应用程序中的 <code>Activity</code>、<code>Service</code> 和其他组件的生命周期</p><p><img src="https://s2.loli.net/2024/12/31/HQ48ireTIMojn3b.png" alt="image-20241006155346116"></p><p><img src="https://s2.loli.net/2024/12/31/zaM35RnKSpUoCvh.png" alt="image-20241006160438743"></p><p><img src="https://s2.loli.net/2024/10/06/EitbQSNx5Ve4amZ.png" alt="image-20241006160929830"></p><p><code>attachApplication</code> 方法的核心作用是将应用程序的主线程与 AMS 绑定，完成必要的权限切换和身份恢复操作。</p><p>它首先获取调用进程和用户的身份信息，然后清除这些身份，以系统权限执行关键的绑定操作，最后恢复原来的身份信息，确保不会影响后续操作。</p><p><img src="https://s2.loli.net/2024/12/31/dwHK56FGsbyQZRn.png" alt="image-20241006161725576"></p><p><img src="https://s2.loli.net/2024/12/31/LR9gSnzar4KcXtU.png" alt="image-20241006161822049"></p><h2 id="Application启动流程"><a href="#Application启动流程" class="headerlink" title="Application启动流程"></a>Application启动流程</h2><p><code>bindApplication</code> 方法的实现，它是应用程序启动过程中的重要部分，负责将应用的初始化数据传递给 <code>ActivityThread</code> 以启动应用程序</p><p><img src="https://s2.loli.net/2024/12/31/hdX9YZWqNcCBU62.png" alt="image-20241006163024448"></p><p><img src="https://s2.loli.net/2024/10/06/wmp4dD3rJHBxQyX.png" alt="image-20241006163111527"></p><p><img src="https://s2.loli.net/2024/12/31/fDRCxLWhkqFA7b5.png" alt="image-20241006163448500"></p><p><code>sendMessage</code> 是在 <code>ActivityThread</code> 类中用于向消息处理器（<code>Handler</code>）发送消息的，它能够将不同的任务或操作调度到主线程执行。</p><p>这个 <code>H</code> 类是 Android 框架中 <code>ActivityThread</code> 的内部类之一，继承自 <code>Handler</code>。它主要负责处理发送到主线程的消息，并根据消息的类型执行相应的操作。不同的消息类型通过整型常量来定义，每个常量对应一种具体的操作。</p><p><img src="https://s2.loli.net/2024/12/31/WHwpoQ7ez1BROK8.png" alt="image-20241006163950896"></p><p><img src="https://s2.loli.net/2024/12/31/QgP65f3rFYdREis.png" alt="image-20241006164314519"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> &#123;<br><br>    <span class="hljs-comment">// Continue loading instrumentation.</span><br>    <span class="hljs-keyword">if</span> (ii != <span class="hljs-literal">null</span>) &#123;<br>        ApplicationInfo instrApp;<br>        instrApp = getPackageManager().getApplicationInfo(ii.packageName, <span class="hljs-number">0</span>,<br>                UserHandle.myUserId());<br>        <span class="hljs-comment">//构建ContextImpl</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">instrContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, pi);<br>        <span class="hljs-comment">//获取其classLoader</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> instrContext.getClassLoader();<br>        <span class="hljs-comment">//构建Instrumentation </span><br>        mInstrumentation = (Instrumentation)<br>            cl.loadClass(data.instrumentationName.getClassName()).newInstance();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mInstrumentation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Instrumentation</span>();<br>        mInstrumentation.basicInit(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    Application app;<br>    <span class="hljs-comment">// If the app is being launched for full backup or restore, bring it up in</span><br>    <span class="hljs-comment">// a restricted environment with the base application class.</span><br>    <span class="hljs-comment">//构建Application</span><br>    app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-comment">//调用Application的onCreate方法</span><br>    mInstrumentation.callApplicationOnCreate(app);<br>&#125;<br><br><span class="hljs-comment">//sources/android-28/android/app/LoadedApk.java#makeApplication</span><br><span class="hljs-keyword">public</span> Application <span class="hljs-title function_">makeApplication</span><span class="hljs-params">(<span class="hljs-type">boolean</span> forceDefaultAppClass,</span><br><span class="hljs-params">        Instrumentation instrumentation)</span> &#123;<br>    <span class="hljs-comment">//注意,如果Application已经初始化,那么就不重新初始化了  </span><br>    <span class="hljs-keyword">if</span> (mApplication != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> mApplication;<br>    &#125;<br><br>    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">appClass</span> <span class="hljs-operator">=</span> mApplicationInfo.className;<br>    <span class="hljs-keyword">if</span> (forceDefaultAppClass || (appClass == <span class="hljs-literal">null</span>)) &#123;<br>        appClass = <span class="hljs-string">&quot;android.app.Application&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//构建Application</span><br>    app = mActivityThread.mInstrumentation.newApplication(<br>            cl, appClass, appContext);<br>    appContext.setOuterContext(app);<br><br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br><span class="hljs-comment">//sources/android-28/android/app/Instrumentation.java#newApplication</span><br><span class="hljs-keyword">public</span> Application <span class="hljs-title function_">newApplication</span><span class="hljs-params">(ClassLoader cl, String className, Context context)</span><br>        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, <br>        ClassNotFoundException &#123;<br>    <span class="hljs-comment">//通过反射构建Application</span><br>    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> getFactory(context.getPackageName())<br>            .instantiateApplication(cl, className);<br>    <span class="hljs-comment">//赋值Context</span><br>    app.attach(context);<br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> Application <span class="hljs-title function_">instantiateApplication</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ClassLoader cl,</span><br><span class="hljs-params">        <span class="hljs-meta">@NonNull</span> String className)</span><br>        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> (Application) cl.loadClass(className).newInstance();<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241006171843020.png" alt="image-20241006171843020"></p><p>在H这个Handler中处理BIND_APPLICATION这个消息,首先是通过ClassLoader加载构建Instrumentation对象,然后通过LoadedApk调用Instrumentation的newApplication 方法(这里有点奇怪,为什么不用构建出来的mInstrumentation直接调用newApplication方法..),通过loadClass的方式将Application对象创建出来,然后调用Application的onCreate生命周期方法.</p><h2 id="创建Activity"><a href="#创建Activity" class="headerlink" title="创建Activity"></a>创建Activity</h2><p>怎么衔接上的？</p><p>将应用程序附加到正在运行的活动上，确保活动的正确启动和管理。具体来说，它在 Android 的 ActivityManager 中实现了应用程序的绑定过程，以便让该应用程序能够与系统中的活动交互。</p><p><img src="https://s2.loli.net/2024/12/31/ihLBnHqClMVTdxa.png" alt="image-20241006170553900"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r, ProcessRecord app,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> andResume, <span class="hljs-type">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    ......<br>    <span class="hljs-comment">// Create activity launch transaction.</span><br>    <span class="hljs-comment">//创建活动启动事务。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">clientTransaction</span> <span class="hljs-operator">=</span> ClientTransaction.obtain(app.thread,<br>            r.appToken);<br>    <span class="hljs-comment">//构建LaunchActivityItem对象,并传入clientTransaction中,用作callback</span><br>    clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(r.intent),<br>            System.identityHashCode(r), r.info,<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Have this take the merged configuration instead of separate global</span><br>            <span class="hljs-comment">// and override configs.</span><br>            mergedConfiguration.getGlobalConfiguration(),<br>            mergedConfiguration.getOverrideConfiguration(), r.compat,<br>            r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,<br>            r.persistentState, results, newIntents, mService.isNextTransitionForward(),<br>            profilerInfo));<br><br>    <span class="hljs-comment">// Schedule transaction.</span><br>    <span class="hljs-comment">//执行事务  这里getLifecycleManager获取的是ClientLifecycleManager</span><br>    mService.getLifecycleManager().scheduleTransaction(clientTransaction);<br>    ......<br>&#125;<br><br><span class="hljs-comment">//ClientLifecycleManager#scheduleTransaction</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    <span class="hljs-comment">//继续深入</span><br>    transaction.schedule();<br>&#125;<br><br><span class="hljs-comment">//ClientTransaction#schedule</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    <span class="hljs-comment">//这里的mClient是ApplicationThread</span><br>    mClient.scheduleTransaction(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">//ApplicationThread#scheduleTransaction</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    <span class="hljs-comment">//ActivityThread是继承自ClientTransactionHandler的,scheduleTransaction方法在ClientTransactionHandler里面</span><br>    ActivityThread.<span class="hljs-built_in">this</span>.scheduleTransaction(transaction);<br>&#125;<br><br><span class="hljs-comment">//ClientTransactionHandler#scheduleTransaction</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>    transaction.preExecute(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//注意啦,这里向ActivityThread里面的H这个Handler发送了一个EXECUTE_TRANSACTION的消息,并且将ClientTransaction对象也传了进去</span><br>    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);<br>&#125;<br><span class="hljs-comment">//ClientTransactionHandler#sendMessage   这个方法是抽象方法,是在ActivityThread里面实现的,当然是给H这个Handler发消息啦</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> what, Object obj)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread里面的H  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TransactionExecutor</span> <span class="hljs-variable">mTransactionExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionExecutor</span>(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//这里传入的是ClientTransactionHandler对象(即ActivityThread),ClientTransactionHandler是ActivityThread的父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:<br>                <span class="hljs-comment">//首先取出ClientTransaction对象</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> (ClientTransaction) msg.obj;<br>                <span class="hljs-comment">//将ClientTransaction传入execute方法</span><br>                mTransactionExecutor.execute(transaction);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//TransactionExecutor#execute</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">IBinder</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> transaction.getActivityToken();<br>    log(<span class="hljs-string">&quot;Start resolving transaction for client: &quot;</span> + mTransactionHandler + <span class="hljs-string">&quot;, token: &quot;</span> + token);<br><br>    executeCallbacks(transaction);<br><br>    executeLifecycleState(transaction);<br>    mPendingActions.clear();<br>    log(<span class="hljs-string">&quot;End resolving transaction&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//TransactionExecutor#executeCallbacks</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCallbacks</span><span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>    <span class="hljs-comment">//取出ClientTransaction对象里面的callback,即上面的LaunchActivityItem</span><br>    <span class="hljs-keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> callbacks.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransactionItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> callbacks.get(i);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">postExecutionState</span> <span class="hljs-operator">=</span> item.getPostExecutionState();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">closestPreExecutionState</span> <span class="hljs-operator">=</span> mHelper.getClosestPreExecutionState(r,<br>                item.getPostExecutionState());<br><br>        item.execute(mTransactionHandler, token, mPendingActions);<br>        item.postExecute(mTransactionHandler, token, mPendingActions);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//LaunchActivityItem#execute</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ClientTransactionHandler client, IBinder token,</span><br><span class="hljs-params">        PendingTransactionActions pendingActions)</span> &#123;<br>    <span class="hljs-comment">//调用ActivityThread的handleLaunchActivity方法</span><br>    client.handleLaunchActivity(r, pendingActions, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread#handleLaunchActivity</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Activity <span class="hljs-title function_">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r,</span><br><span class="hljs-params">        PendingTransactionActions pendingActions, Intent customIntent)</span> &#123;<br>    .....<br>    <span class="hljs-comment">//终于要开始调用performLaunchActivity这个熟悉的方法了</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Activity</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> performLaunchActivity(r, customIntent);<br>    ......<br>&#125;<br><br><span class="hljs-comment">//ActivityThread#performLaunchActivity</span><br><span class="hljs-keyword">private</span> Activity <span class="hljs-title function_">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> &#123;<br>    ......<br>    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> createBaseContextForActivity(r);<br>    <span class="hljs-type">Activity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//获取ClassLoader</span><br>    java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> appContext.getClassLoader();<br><br>    <span class="hljs-comment">//通过(Activity) cl.loadClass(className).newInstance()创建</span><br>    <span class="hljs-comment">//重点来啦:Activity是在ActivityThread的performLaunchActivity方法中用ClassLoader类加载器创建出来的。</span><br>    activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br><br>    <span class="hljs-comment">//底层也是通过反射构建Application,如果已经构建则不会重复构建,毕竟一个进程只能有一个Application</span><br>    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> r.packageInfo.makeApplication(<span class="hljs-literal">false</span>, mInstrumentation);<br><br>    <span class="hljs-keyword">if</span> (activity != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Window</span> <span class="hljs-variable">window</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        appContext.setOuterContext(activity);<br>        <span class="hljs-comment">//在这里实例化了PhoneWindow,并将该Activity设置为PhoneWindow的Callback回调,还初始化了WindowManager</span><br>        activity.attach(appContext, <span class="hljs-built_in">this</span>, getInstrumentation(), r.token,<br>                r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>                r.embeddedID, r.lastNonConfigurationInstances, config,<br>                r.referrer, r.voiceInteractor, window, r.configCallback);<br><br>        <span class="hljs-comment">//间接调用了Activity的performCreate方法,间接调用了Activity的onCreate方法.</span><br>        mInstrumentation.callActivityOnCreate(activity, r.state);<br><br>        <span class="hljs-comment">//这里和上面onCreate过程差不多,调用Activity的onStart方法</span><br>        <span class="hljs-keyword">if</span> (!r.activity.mFinished) &#123;<br>            activity.performStart();<br>            r.stopped = <span class="hljs-literal">false</span>;<br>        &#125;<br>        ....<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> activity;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个流程就比较熟悉了,重点是: <strong>Activity是在ActivityThread的performLaunchActivity方法中用ClassLoader类加载器创建出来的。</strong> 创建出来之后就会调用Activity的onCreate方法和onStart方法.</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/xfhy_/article/details/90270630">死磕Android_View工作原理你需要知道的一切_android view 背景 前景-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/67451239">死磕Android_App 启动过程（含 Activity 启动过程） - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/Joooook/p/18415261#438-%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90">安卓整体加壳（一代壳）原理及实践 - Joooook - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/lijie2664989/article/details/113090596">深入Android系统（十）PMS-3-应用安装过程_installstart-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhourui_1021/article/details/118465753">Android 11.0 PackageManagerService（三）APK的安装过程_android 11 packagemanager parse activity-CSDN博客</a></p><p><a href="https://www.kancloud.cn/digest/androidframeworks/127788">APK安装过程及原理详解 · android源码解析 · 看云 (kancloud.cn)</a></p><p><a href="https://blog.csdn.net/tkwxty/article/details/113137052">PackageManagerService启动详解(一)之整体流程分析_packagemanagerservice.java-CSDN博客</a></p><p><a href="https://androidbeyond.github.io/2020/05/26/PKMS%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">Android10 PKMS启动过程分析 - 獨孤碼農的博客|coderman Blog (androidbeyond.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Andorid源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android系统启动流程</title>
    <link href="/2024/01/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/01/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="android整体架构图"><a href="#android整体架构图" class="headerlink" title="android整体架构图"></a>android整体架构图</h1><p><img src="https://s2.loli.net/2024/12/20/NiF83nBS4sItpYR.png" alt="android整体架构"></p><p>可以看出android系统是基于底层linux构建的。也正因如此，android系统启动的起点在linux启动后的用户空间的第一个进程init，进程号为1.当bootloader启动后，启动kernel，kernel启动完后，在用户空间启动init进程。</p><p>倘若再往上走就是linux启动过程，具体可自行百度linux启动流程。</p><ul><li><strong>1.引导加载程序（Bootloader）启动</strong>： 当设备上电或者重启时，首先会由引导加载程序负责启动。引导加载程序通常存储在设备的固件中，它的主要任务是初始化硬件，并加载并启动操作系统内核。引导加载程序会首先运行自身的初始化代码，然后加载操作系统内核到内存中。</li><li><strong>2.内核加载</strong>： 引导加载程序会根据预定义的配置从设备存储中加载操作系统内核。在Android设备中，通常使用的是Linux内核。引导加载程序将内核加载到内存中的指定位置。</li><li><strong>3.内核初始化</strong>： 一旦内核加载到内存中，引导加载程序会将控制权转交给内核。内核开始执行初始化过程，包括对硬件进行初始化、建立虚拟文件系统、创建进程和线程等。</li><li><strong>4.启动 init 进程</strong>： 内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。</li></ul><h1 id="Init进程"><a href="#Init进程" class="headerlink" title="Init进程"></a>Init进程</h1><p><img src="https://s2.loli.net/2024/10/08/3YcVQto2GbqMzCN.png" alt="Android系统启动流程"></p><p>根据不同的入参，响应init不同阶段、处理不同业务逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(basename(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;ueventd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> ueventd_main(argc, argv);<br>    &#125;<br>    <span class="hljs-comment">////watchdogd俗称看门狗，用于系统出问题时重启系统</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(basename(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;watchdogd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> watchdogd_main(argc, argv);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;subcontext&quot;</span>)) &#123;<br>        InitKernelLogging(argv);<br>        <span class="hljs-type">const</span> BuiltinFunctionMap function_map;<br>        <span class="hljs-keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);<br>    &#125;<br>    <span class="hljs-comment">//如果设置了 REBOOT_BOOTLOADER_ON_PANIC，则安装重启信号处理器，确保在系统崩溃时能够重启进入 bootloader 模式。</span><br>    <span class="hljs-keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;<br>        InstallRebootSignalHandlers();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><ol><li>挂载文件系统并创建目录</li><li>初始化日志输出、挂载分区设备</li><li>启用SELinux安全策略</li><li>开始第二阶段前的准备</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    ...<br>    <span class="hljs-type">bool</span> is_first_stage = (getenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>) == nullptr);<br>    <span class="hljs-comment">// 在第一阶段，初始化基本的文件系统，并创建和挂载必要的系统目录</span><br>    <span class="hljs-keyword">if</span> (is_first_stage) &#123;<br>        boot_clock::time_point start_time = boot_clock::now();<br>        umask(<span class="hljs-number">0</span>);<br>        clearenv();<br>        mount(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>);<br>        mkdir(<span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-number">0755</span>);<br>        mkdir(<span class="hljs-string">&quot;/dev/socket&quot;</span>, <span class="hljs-number">0755</span>);<br>        mount(<span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_STR(x) __STRING(x)</span><br>        mount(<span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-string">&quot;/proc&quot;</span>, <span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC));<br>        chmod(<span class="hljs-string">&quot;/proc/cmdline&quot;</span>, <span class="hljs-number">0440</span>);<br>        <span class="hljs-type">gid_t</span> groups[] = &#123; AID_READPROC &#125;;<br>        setgroups(arraysize(groups), groups);<br>        mount(<span class="hljs-string">&quot;sysfs&quot;</span>, <span class="hljs-string">&quot;/sys&quot;</span>, <span class="hljs-string">&quot;sysfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        mount(<span class="hljs-string">&quot;selinuxfs&quot;</span>, <span class="hljs-string">&quot;/sys/fs/selinux&quot;</span>, <span class="hljs-string">&quot;selinuxfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        mknod(<span class="hljs-string">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class="hljs-number">0600</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>));<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_">constexpr</span> <span class="hljs-params">(WORLD_WRITABLE_KMSG)</span> &#123;<br>            mknod(<span class="hljs-string">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class="hljs-number">0622</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>));<br>        &#125;<br>        <span class="hljs-comment">//创建 /dev/kmsg、/dev/random、/dev/urandom 等设备节点，用于日志和随机数生成。</span><br>        mknod(<span class="hljs-string">&quot;/dev/random&quot;</span>, S_IFCHR | <span class="hljs-number">0666</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<br>        mknod(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class="hljs-number">0666</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>));<br>        mount(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/mnt&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>        mkdir(<span class="hljs-string">&quot;/mnt/vendor&quot;</span>, <span class="hljs-number">0755</span>);<br>        <span class="hljs-comment">//初始化log系统并打印</span><br>        InitKernelLogging(argv);<br>        ......<br>        <span class="hljs-comment">//初始化Android的安全框架Android Verified Boot</span><br>        SetInitAvbVersionInRecovery();<br>        global_seccomp();<br>        ...<br>        <span class="hljs-comment">// Set up SELinux, loading the SELinux policy.</span><br>        <span class="hljs-comment">//为第二阶段启动加载安全策略(安全策略：一个Linux内核模块和安全架构，旨在提供更细粒度的访问控制)</span><br>        SelinuxSetupKernelLogging();<br>        SelinuxInitialize();<br>        ...<br>        <span class="hljs-comment">//设置第二阶段开关</span><br>        setenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">static</span> constexpr <span class="hljs-type">uint32_t</span> kNanosecondsPerMillisecond = <span class="hljs-number">1e6</span>;<br>        <span class="hljs-type">uint64_t</span> start_ms = start_time.time_since_epoch().count() / kNanosecondsPerMillisecond;<br><br><span class="hljs-comment">//设置环境变量 INIT_SECOND_STAGE 并重新执行 init 进程，进入第二阶段。</span><br>        setenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>, <span class="hljs-built_in">std</span>::to_string(start_ms).c_str(), <span class="hljs-number">1</span>);<br>        <span class="hljs-type">char</span>* path = argv[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">char</span>* args[] = &#123; path, nullptr &#125;;<br>        execv(path, args);<br>        PLOG(FATAL) &lt;&lt; <span class="hljs-string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot;) failed&quot;</span>;<br>    &#125;<br>              <br> &#125;<br>   <br></code></pre></td></tr></table></figure><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><ol><li>初始化属性系统</li><li>执行SELinux第二阶段并恢复一些文件安全上下文</li><li>新建epoll并初始化子进程终止信号处理函数</li><li>设置其他系统属性并开启属性服务</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">//初始化属性系统</span><br>   <span class="hljs-comment">//继续初始化日志、属性系统和内核命令行参数，并准备系统启动。</span><br>    InitKernelLogging(argv);<br>    ....<br>    <span class="hljs-comment">//property系统用于管理系统属性</span><br>    process_kernel_dt();<br>    process_kernel_cmdline();<br><br>    export_kernel_boot_props();<br><br>    property_set(<span class="hljs-string">&quot;ro.boottime.init&quot;</span>, getenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>));<br>    property_set(<span class="hljs-string">&quot;ro.boottime.init.selinux&quot;</span>, getenv(<span class="hljs-string">&quot;INIT_SELINUX_TOOK&quot;</span>));<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* avb_version = getenv(<span class="hljs-string">&quot;INIT_AVB_VERSION&quot;</span>);<br>    <span class="hljs-keyword">if</span> (avb_version) property_set(<span class="hljs-string">&quot;ro.boot.avb_version&quot;</span>, avb_version);<br>    <span class="hljs-comment">// Clean up our environment.</span><br>    unsetenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_SELINUX_TOOK&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_AVB_VERSION&quot;</span>);<br><br>    <span class="hljs-comment">//加载 SELinux 策略</span><br>    SelinuxSetupKernelLogging();<br>    SelabelInitialize();<br>    SelinuxRestoreContext();<br>    <span class="hljs-comment">//启动 epoll 等待系统事件(设置 epoll 文件描述符，用于监听系统事件，并启动属性服务和信号处理。)</span><br>    epoll_fd = epoll_create1(EPOLL_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (epoll_fd == <span class="hljs-number">-1</span>) &#123;<br>        PLOG(FATAL) &lt;&lt; <span class="hljs-string">&quot;epoll_create1 failed&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//来初始化信号处理过程</span><br>    sigchld_handler_init();<br><br>    <span class="hljs-keyword">if</span> (!IsRebootCapable()) &#123;<br>    <br>        InstallSigtermHandler();<br>    &#125;<br>    <span class="hljs-comment">//设置其他系统属性并开启属性服务</span><br>    property_load_boot_defaults();<br>    export_oem_lock_status();<br>    start_property_service();<br>    set_usb_controller();<br>    ...<br>    <span class="hljs-type">const</span> BuiltinFunctionMap function_map;<br>    Action::set_function_map(&amp;function_map);<br><br>   <span class="hljs-comment">// Android 中负责管理子上下文</span><br>    subcontexts = InitializeSubcontexts();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><ol><li>通过init.rc机制，读取配置文件，来启动不同的进程。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>    <span class="hljs-comment">//通常负责管理系统中的各种动作或命令, 解析init.rc等文件，建立rc文件的action 、service，启动其他进程</span><br>    <span class="hljs-comment">//ActionManager 和 ServiceList 管理系统中的命令和服务，初始化并触发系统的启动事件和动作。</span><br>    ActionManager&amp; am = ActionManager::GetInstance();<br><span class="hljs-comment">//负责管理系统中所有的服务</span><br>    ServiceList&amp; sm = ServiceList::GetInstance();<br><br>    <span class="hljs-comment">//加载脚本文件命令</span><br>    LoadBootScripts(am, sm);<br><br>    ...<br><br>   <span class="hljs-comment">//进入主循环，使用 epoll_wait 监听系统事件，并执行相应的系统命令和服务操作。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// By default, sleep until something happens.</span><br>        <span class="hljs-type">int</span> epoll_timeout_ms = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;<br>            do_shutdown = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;<br>                shutting_down = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;<br>            am.ExecuteOneCommand();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;<br>            <span class="hljs-keyword">if</span> (!shutting_down) &#123;<br>                <span class="hljs-keyword">auto</span> next_process_restart_time = RestartProcesses();<br>                <span class="hljs-keyword">if</span> (next_process_restart_time) &#123;<br>                    epoll_timeout_ms = <span class="hljs-built_in">std</span>::chrono::<span class="hljs-built_in">ceil</span>&lt;<span class="hljs-built_in">std</span>::chrono::milliseconds&gt;(<br>                                           *next_process_restart_time - boot_clock::now())<br>                                           .count();<br>                    <span class="hljs-keyword">if</span> (epoll_timeout_ms &lt; <span class="hljs-number">0</span>) epoll_timeout_ms = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        epoll_event ev;<br>        <span class="hljs-type">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="hljs-number">1</span>, epoll_timeout_ms));<br>        <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">-1</span>) &#123;<br>            PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;epoll_wait failed&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">1</span>) &#123;<br>            ((<span class="hljs-type">void</span> (*)()) ev.data.ptr)();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="init-rc脚本"><a href="#init-rc脚本" class="headerlink" title="init.rc脚本"></a><code>init.rc</code>脚本</h3><p><img src="https://s2.loli.net/2024/12/20/kTpboDfICxgNz1Q.png" alt="image-20241008120230933"></p><p><strong>service zygote &#x2F;system&#x2F;bin&#x2F;app_process -Xzygote &#x2F;system&#x2F;bin –zygote –start-system-server</strong>:</p><ul><li><strong>service zygote</strong>: 定义一个名为zygote的服务</li><li><strong>&#x2F;system&#x2F;bin&#x2F;app_process</strong>：这是启动Zygote进程的可执行文件，64位系统为<code>app_process64</code>。</li><li><strong>-Xzygote</strong>：标志表明这是一个Zygote进程启动的特殊模式。</li><li><strong>&#x2F;system&#x2F;bin</strong>：指定进程的工作目录。</li><li><strong>–zygote</strong>：告诉app_process以Zygote模式启动。</li><li><strong>–start-system-server</strong>：Zygote启动时还要启动System Server进程，这是Android系统中管理关键系统服务的核心进程。</li></ul><p><strong>class main</strong>:</p><ul><li>将Zygote服务归类为main类别。</li><li>Android系统在启动过程中会启动所有“main”类别的服务。</li></ul><p><strong>socket zygote stream 660 root system</strong>:<br>创建了一个名为zygote的UNIX域Socket套接字，用于其他进程与Zygote进程通信。</p><p><strong>onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</strong>：<br>当zygote服务重启时，系统应该将“&#x2F;sys&#x2F;android_power&#x2F;request_state”文件的内容设置为“wake”，以唤醒设备。</p><p><strong>onrestart write &#x2F;sys&#x2F;power&#x2F;state on</strong>：<br>当zygote服务重启时，系统应该将“&#x2F;sys&#x2F;power&#x2F;state”文件的内容设置为 “on”，以打开电源。</p><p><strong>onrestart restart media</strong>：<br>当zygote服务重启时，系统应该重启媒体服务（如音频、视频等），以恢复媒体功能。</p><p><strong>onrestart restart netd</strong>：<br>当zygote服务重启时，系统应该重启网络守护进程（netd），以恢复网络功能。</p><h1 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h1><p>在上一节，可以看到在启动 app_process中，启动zygote了进程，并同时启动了诸如audioserver、cameraserver、media等服务。</p><h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a><code>main</code>方法</h2><p><code>app_process</code>主入口点是<code>main</code>方法，它是整个进程启动流程的起点。</p><p>通过解析rc文件参数，启动ZygoteInit。</p><p><img src="https://s2.loli.net/2024/10/08/md2z6wo5qugXxY8.png" alt="image-20241008194103840"></p><h2 id="AppRuntime类-AndroidRuntime"><a href="#AppRuntime类-AndroidRuntime" class="headerlink" title="AppRuntime类(AndroidRuntime)"></a><code>AppRuntime</code>类(AndroidRuntime)</h2><p><strong>AppRuntime</strong>继承自<strong>AndroidRuntime</strong>(ART)，是Android中的一个关键类，负责管理和启动 Android 应用程序或系统服务的 Java 虚拟机 (JVM)。</p><p><img src="https://s2.loli.net/2024/10/08/htVWoFqQnzSuYyL.png" alt="image-20241008194008645"></p><p><img src="https://s2.loli.net/2024/10/08/3pqmgrcHeWozPQx.png" alt="image-20241008194040488"></p><p><code>app_process</code>的main方法调用了<code>AppRuntime</code>的start方法，也就是<code>AppRuntime</code>的父类<code>AndroidRuntime</code>的start方法</p><p><img src="https://s2.loli.net/2024/10/08/dZTmxI2Yy8kz1tM.png" alt="image-20241008194334607"></p><p>通过JNI调用ZygoteInit.main()</p><p><img src="https://s2.loli.net/2024/10/08/IzisVvtlSMXnOaE.png" alt="image-20241008194356872"></p><h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>在<code>AndroidRuntime</code>的<strong>start</strong>方法，通过JNI调用ZygoteInit.main()，系统第一次进入Java层(ZygoteInit是系统运行的第一个Java类)，当前线程也正式成为Java虚拟机（JVM）的主线程。</p><p><img src="https://s2.loli.net/2024/10/08/RgeblPvEmN8SAQ3.png" alt="image-20241008194450720"></p><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241008194506579.png" alt="image-20241008194506579"></p><p><img src="https://s2.loli.net/2024/10/08/JMYWoLXnjBU49V1.png" alt="image-20241008194607975"></p><p><img src="https://s2.loli.net/2024/10/08/pc7S2BMIEv4QqCW.png" alt="image-20241008194639231"></p><p>整体流程图：</p><p><img src="https://s2.loli.net/2024/10/08/WKLGhCXSPNOwpg4.png" alt="753d2faffdc5f60b5e5d98fd108d4421"></p><h1 id="SystemServer进程"><a href="#SystemServer进程" class="headerlink" title="SystemServer进程"></a>SystemServer进程</h1><p>Android系统在启动的时候,在启动两个重要的进程，一个是Zygote进程，另一个是由zygote进程fork出来的system_server进程。SystemSever负责启动系统的各项服务，Android系统中Java世界的核心Service都在这里启动。比如：</p><table><thead><tr><th>服务名称</th><th>功能说明</th></tr></thead><tbody><tr><td>Activity Manager Service (AMS)</td><td>管理应用程序的生命周期，包括启动和停止应用、管理任务和活动栈、处理广播等</td></tr><tr><td>Package Manager Service (PMS)</td><td>管理应用包的安装、卸载、更新、权限分配等</td></tr><tr><td>System Config Service</td><td>管理系统配置和资源</td></tr><tr><td>Power Manager Service</td><td>管理设备的电源状态和电源策略，如休眠、唤醒等</td></tr><tr><td>Display Manager Service</td><td>管理显示设备，如屏幕亮度、显示模式等</td></tr><tr><td>User Manager Service</td><td>管理用户账户和用户信息</td></tr><tr><td>Battery Service</td><td>监控和管理电池状态和电池使用情况</td></tr><tr><td>Vibrator Service</td><td>控制设备的振动功能</td></tr><tr><td>Sensor Service</td><td>管理设备的传感器，如加速度计、陀螺仪等</td></tr><tr><td>Window Manager Service (WMS)</td><td>管理窗口和显示内容，包括窗口的创建、删除、布局等</td></tr><tr><td>Input Manager Service</td><td>管理输入设备，如触摸屏、键盘等</td></tr><tr><td>Alarm Manager Service</td><td>提供定时任务调度功能</td></tr><tr><td>Connectivity Service</td><td>管理网络连接，如 Wi-Fi、移动数据等</td></tr><tr><td>Network Management Service</td><td>管理网络接口和网络连接</td></tr><tr><td>Telephony Registry</td><td>管理电话和短信服务</td></tr><tr><td>Input Method Manager Service (IMMS)</td><td>管理输入法框架</td></tr><tr><td>Accessibility Manager Service</td><td>管理无障碍服务，为有特殊需要的用户提供辅助功能</td></tr><tr><td>Mount Service</td><td>管理存储设备的挂载和卸载</td></tr><tr><td>Location Manager Service</td><td>管理位置服务，如 GPS 和网络定位</td></tr><tr><td>Search Manager Service</td><td>管理系统搜索功能</td></tr><tr><td>Clipboard Service</td><td>管理剪贴板功能</td></tr><tr><td>DevicePolicy Manager Service</td><td>管理设备的安全策略和企业管理功能</td></tr><tr><td>Status Bar Service</td><td>管理状态栏显示和操作</td></tr><tr><td>Wallpaper Manager Service</td><td>管理壁纸设置和操作</td></tr><tr><td>Media Router Service</td><td>管理媒体设备路由</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/10/08/eztnSVYgbl8LAmj.png" alt="image-20241008200351668"></p><p><img src="https://s2.loli.net/2024/10/08/G39r2btcljHy5mv.png" alt="image-20241008200413406"></p><p>整体流程如下：</p><p><img src="https://s2.loli.net/2024/10/08/Xe7iEBZK5OhstyR.png" alt="0776be314b69defe63cbf793f867f1b9"></p><h1 id="Home进程"><a href="#Home进程" class="headerlink" title="Home进程"></a>Home进程</h1><p>一般情况下，Android原生的软体会包含两个home进程，一个是Settings进程的Fallbackhome，一个是Launcher进程。</p><h2 id="Launcher进程启动"><a href="#Launcher进程启动" class="headerlink" title="Launcher进程启动"></a>Launcher进程启动</h2><p>​    FallbackHome是系统由未解密到解密过程的一个过度界面，只要用户把系统解锁过一次后，FallbackHome收到解锁广播就会退出，而WMS检测到当前Acitivity栈是空的，进而启动真正的Launcher。由于FallbackHome没有界面，所以可能会出现一个问题，home进程切换时会出现空白界面，接下来才是显示Launcher的一个图标界面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@packages</span>\apps\Settings\src\com\android\settings\FallbackHome.java<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>    ...<br>    registerReceiver(mReceiver, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>(Intent.ACTION_USER_UNLOCKED));<span class="hljs-comment">//注册ACTION_USER_UNLOCKED广播</span><br>    maybeFinish();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">BroadcastReceiver</span> <span class="hljs-variable">mReceiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastReceiver</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        maybeFinish();<span class="hljs-comment">//接收ACTION_USER_UNLOCKED广播</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maybeFinish</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (getSystemService(UserManager.class).isUserUnlocked()) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">homeIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_MAIN)<br>                .addCategory(Intent.CATEGORY_HOME);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ResolveInfo</span> <span class="hljs-variable">homeInfo</span> <span class="hljs-operator">=</span> getPackageManager().resolveActivity(homeIntent, <span class="hljs-number">0</span>);<span class="hljs-comment">//查询home包名信息，此处一般是返回Launcher的信息</span><br>        <span class="hljs-keyword">if</span> (Objects.equals(getPackageName(), homeInfo.activityInfo.packageName)) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;User unlocked but no home; let&#x27;s hope someone enables one soon?&quot;</span>);<br>            mHandler.sendEmptyMessageDelayed(<span class="hljs-number">0</span>, <span class="hljs-number">500</span>);<span class="hljs-comment">//间隔500ms轮询</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;User unlocked and real home found; let&#x27;s go!&quot;</span>);<br>            getSystemService(PowerManager.class).userActivity(<br>                    SystemClock.uptimeMillis(), <span class="hljs-literal">false</span>);<br>            finish();<span class="hljs-comment">//结束当前Activity，启动Launcher应用</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上一节systemserver中注意到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOtherServices</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 启动ActivityManagerService</span><br>    mActivityManagerService = mSystemServiceManager.startService(<br>            ActivityManagerService.Lifecycle.class).getService();<br>    ...<br>    <span class="hljs-comment">// 启动Launcher</span><br>    mActivityManagerService.systemReady(...)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在AMS中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">systemReady</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable goingCallback, TimingsTraceAndSlog t)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 在所有显示器上启动Launcher</span><br>    mAtmInternal.startHomeOnAllDisplays(currentUserId, <span class="hljs-string">&quot;systemReady&quot;</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>此行代码最终会调用到<code>RootWindowContainer.java</code>的<code>startHomeOnAllDisplays</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnAllDisplays</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">homeStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> getChildCount() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">displayId</span> <span class="hljs-operator">=</span> getChildAt(i).mDisplayId;<br>        <span class="hljs-comment">// 在每一个显示器上启动桌面程序</span><br>        homeStarted |= startHomeOnDisplay(userId, reason, displayId);<br>    &#125;<br>    <span class="hljs-keyword">return</span> homeStarted;<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, <span class="hljs-type">int</span> displayId)</span> &#123;<br>    <span class="hljs-keyword">return</span> startHomeOnDisplay(userId, reason, displayId, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, <span class="hljs-type">int</span> displayId, <span class="hljs-type">boolean</span> allowInstrumenting, <span class="hljs-type">boolean</span> fromHomeKey)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 调用startHomeOnTaskDisplayArea</span><br>    <span class="hljs-keyword">return</span> display.reduceOnAllTaskDisplayAreas((taskDisplayArea, result) -&gt;<br>                    result | startHomeOnTaskDisplayArea(userId, reason, taskDisplayArea,<br>                            allowInstrumenting, fromHomeKey),<span class="hljs-literal">false</span>);<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnTaskDisplayArea</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, TaskDisplayArea taskDisplayArea,</span><br><span class="hljs-params">        <span class="hljs-type">boolean</span> allowInstrumenting, <span class="hljs-type">boolean</span> fromHomeKey)</span> &#123;<br>    ...<br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">homeIntent</span> <span class="hljs-operator">=</span> mService.getHomeIntent();<br>    mService.getActivityStartController().startHomeActivity(homeIntent, aInfo, myReason,<br>            taskDisplayArea);<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>最终通过Intent和startHomeActivity方法启动了桌面程序</p><h2 id="FallbackHome进程启动"><a href="#FallbackHome进程启动" class="headerlink" title="FallbackHome进程启动"></a>FallbackHome进程启动</h2><h3 id="（1）-启动home进程"><a href="#（1）-启动home进程" class="headerlink" title="（1） 启动home进程"></a><strong>（1）</strong> 启动home进程</h3><p>   刚开机时，SystemSever进程会启动WMS服务，如果WMS未检测到Activity栈有任务时，会启动一个默认的home进程，此进程即FallbackHome。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@frameworks</span>\base\services\core\java\com\android\server\wm\RootWindowContainer.java<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">startHomeOnEmptyDisplays</span><span class="hljs-params">(String reason)</span> &#123;<br>    forAllTaskDisplayAreas(taskDisplayArea -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (taskDisplayArea.topRunningActivity() == <span class="hljs-literal">null</span>) &#123;<br>            startHomeOnTaskDisplayArea(mCurrentUser, reason, taskDisplayArea,<br>                    <span class="hljs-literal">false</span> <span class="hljs-comment">/* allowInstrumenting */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* fromHomeKey */</span>);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）-ACTION-USER-UNLOCKED广播发送"><a href="#（2）-ACTION-USER-UNLOCKED广播发送" class="headerlink" title="（2） ACTION_USER_UNLOCKED广播发送"></a><strong>（2）</strong> ACTION_USER_UNLOCKED广播发送</h3><p>​    系统解锁时会发送该广播，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@frameworks</span>\base\services\core\java\com\android\server\am\UserController.java<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserUnlocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserState uss)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!mInjector.getUserManager().isPreCreated(userId)) &#123;<br>        <span class="hljs-comment">// Dispatch unlocked to external apps</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">unlockedIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_USER_UNLOCKED);<br>        unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);<br>        unlockedIntent.addFlags(<br>                Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);<br>        mInjector.broadcastIntent(unlockedIntent, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>,<br>                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID,<br>                Binder.getCallingUid(), Binder.getCallingPid(), userId);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上一张完整流程图：</p><p><img src="https://s2.loli.net/2024/10/08/mpCSY3h7r8szdJ2.png" alt="android系统启动流程"></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/anywherego/p/18221943">Android启动过程-万字长文(Android14) - 柳云居士 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/IT_xiao_bai0516/article/details/121566564?spm=1001.2014.3001.5502">源码详解Android 9.0(P) 系统启动流程之SystemServer_android9 systemserver启动-CSDN博客</a></p><p><a href="https://www.cnblogs.com/zhiqinlin/p/18001113#44-init%E8%BF%9B%E7%A8%8B">Android 开机流程介绍 - 林奋斗同学 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Andorid源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入学习Golang语言</title>
    <link href="/2023/09/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Golang%E8%AF%AD%E8%A8%80/"/>
    <url>/2023/09/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Golang%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-常用数据结构高级使用"><a href="#Golang-常用数据结构高级使用" class="headerlink" title="Golang 常用数据结构高级使用"></a><strong>Golang 常用数据结构高级使用</strong></h1><p><a href="https://zhuanlan.zhihu.com/p/676122697">深入理解 Golang 中的值类型和引用类型 - 知乎</a></p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><h3 id="1-值类型（Value-Types）"><a href="#1-值类型（Value-Types）" class="headerlink" title="1. 值类型（Value Types）"></a>1. <strong>值类型（Value Types）</strong></h3><p>值类型在赋值或作为参数传递时，会将数据本身拷贝一份。也就是说，值类型的变量存储的是数据的副本。</p><h4 id="1-1-常见的值类型"><a href="#1-1-常见的值类型" class="headerlink" title="1.1 常见的值类型"></a>1.1 <strong>常见的值类型</strong></h4><ul><li>基本数据类型：<code>int</code>、<code>float</code>、<code>bool</code>、<code>string</code> 等。</li><li>数组：数组在 Go 中是值类型，赋值或传递参数时会复制整个数组。</li><li>结构体（<code>struct</code>）：结构体也是值类型，每个字段的值都会被复制。</li></ul><h4 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 <strong>特性</strong></h4><ul><li><strong>赋值时复制数据</strong>：当将一个值类型的变量赋值给另一个变量时，数据会被复制，两个变量互不影响。</li><li><strong>函数参数传递时拷贝数据</strong>：当值类型作为函数参数传递时，实际上传递的是该值的副本。</li></ul><h4 id="1-3-例子"><a href="#1-3-例子" class="headerlink" title="1.3 例子"></a>1.3 <strong>例子</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span><span class="hljs-params">(p Person)</span></span> &#123;<br>    p.Name = <span class="hljs-string">&quot;Changed&quot;</span><br>    p.Age = <span class="hljs-number">30</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p1 := Person&#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>&#125;<br>    modify(p1)<br>    fmt.Println(p1) <span class="hljs-comment">// &#123;John 25&#125;, p1未被修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>modify</code> 函数修改的是 <code>p</code> 的副本，而不是 <code>p1</code> 本身，因此 <code>p1</code> 的值没有被改变。</p><h3 id="2-引用类型（Reference-Types）"><a href="#2-引用类型（Reference-Types）" class="headerlink" title="2. 引用类型（Reference Types）"></a>2. <strong>引用类型（Reference Types）</strong></h3><p>引用类型存储的是数据的地址（引用），而不是数据本身。当引用类型被赋值或作为参数传递时，实际上传递的是指向数据的引用，而不是数据本身的副本。</p><h4 id="2-1-常见的引用类型"><a href="#2-1-常见的引用类型" class="headerlink" title="2.1 常见的引用类型"></a>2.1 <strong>常见的引用类型</strong></h4><ul><li>切片（<code>slice</code>）</li><li>映射（<code>map</code>）</li><li>通道（<code>channel</code>）</li><li>指针（<code>pointer</code>）</li></ul><h4 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 <strong>特性</strong></h4><ul><li><strong>赋值时复制引用</strong>：当一个引用类型的变量赋值给另一个变量时，实际上是复制了指向数据的引用，两个变量都指向同一个数据。</li><li><strong>函数参数传递时传递引用</strong>：当引用类型作为函数参数传递时，实际上传递的是数据的引用，因此函数对数据的修改会影响到原始数据。</li></ul><h4 id="2-3-例子"><a href="#2-3-例子" class="headerlink" title="2.3 例子"></a>2.3 <strong>例子</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> &#123;<br>    s[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    modify(arr)<br>    fmt.Println(arr) <span class="hljs-comment">// [99 2 3], arr被修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>modify</code> 函数对切片 <code>arr</code> 的修改会直接影响到 <code>arr</code>，因为切片是引用类型，函数传递的是切片的引用。</p><h3 id="3-值类型与引用类型的比较"><a href="#3-值类型与引用类型的比较" class="headerlink" title="3. 值类型与引用类型的比较"></a>3. <strong>值类型与引用类型的比较</strong></h3><table><thead><tr><th>特性</th><th>值类型</th><th>引用类型</th></tr></thead><tbody><tr><td><strong>存储方式</strong></td><td>存储数据本身</td><td>存储数据的引用（地址）</td></tr><tr><td><strong>赋值操作</strong></td><td>复制数据</td><td>复制引用，指向同一数据</td></tr><tr><td><strong>传递方式</strong></td><td>传递数据的副本</td><td>传递数据的引用</td></tr><tr><td><strong>内存分配</strong></td><td>每个值都有独立的内存位置</td><td>所有引用指向相同的数据内存位置</td></tr><tr><td><strong>影响</strong></td><td>改变副本不会影响原始数据</td><td>改变引用数据会影响原始数据</td></tr></tbody></table><h3 id="4-Go-中的优化"><a href="#4-Go-中的优化" class="headerlink" title="4. Go 中的优化"></a>4. <strong>Go 中的优化</strong></h3><p>Go 语言对于一些数据结构，如切片和映射，提供了特定的优化。例如：</p><ul><li><strong>切片</strong>：虽然切片是引用类型，但切片本身是结构体，它包含了指向底层数组的指针、切片的长度和容量。通过切片传递的数据并不会完全复制，只会复制其结构体，底层数组不会被复制。因此，修改切片的内容会影响原始数据。</li><li><strong>映射（map）</strong>：映射是引用类型，当作为参数传递时，传递的是引用，所以在函数内对映射的修改会影响原始的映射。</li></ul><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><p><a href="https://cloud.tencent.com/developer/article/2397884">Go语言进阶：数组与切片-腾讯云开发者社区-腾讯云</a></p><h2 id="golang中的Map"><a href="#golang中的Map" class="headerlink" title="golang中的Map"></a>golang中的Map</h2><p><a href="https://segmentfault.com/a/1190000041327964">彻底理解Golang Map - 个人文章 - SegmentFault 思否</a></p><p><a href="https://golang.design/go-questions/map/principal/">map 的实现原理 | Go 程序员面试笔试宝典</a></p><p><a href="https://cloud.tencent.com/developer/article/2400014">深入理解Go语言中的map：结构、性能与最佳实践-腾讯云开发者社区-腾讯云</a></p><h2 id="new-和-make-的区别"><a href="#new-和-make-的区别" class="headerlink" title="new 和 make 的区别"></a>new 和 make 的区别</h2><table><thead><tr><th>特性</th><th><code>new</code></th><th><code>make</code></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>为任意类型分配内存并返回指向该类型的指针</td><td>初始化并返回切片、映射或通道的引用</td></tr><tr><td><strong>适用类型</strong></td><td>所有类型（包括基础类型、结构体、数组等）</td><td>仅适用于切片、映射和通道</td></tr><tr><td><strong>返回值</strong></td><td>返回指向类型的指针</td><td>返回已初始化的对象（如切片、映射或通道）</td></tr><tr><td><strong>初始化</strong></td><td>初始化为该类型的零值（例如：<code>0</code>、<code>&quot;&quot;</code>、<code>false</code>等）</td><td>为切片、映射和通道分配内存并初始化</td></tr><tr><td><strong>内存分配方式</strong></td><td>分配原始内存（返回指针）</td><td>初始化分配并准备好可以使用的对象</td></tr></tbody></table><ul><li>**<code>new</code>**：用于分配内存并初始化为零值，返回指向类型的指针。适用于所有类型。</li><li>**<code>make</code>**：用于创建并初始化切片、映射和通道，返回的是初始化后的对象，而不是指针。适用于这三种数据结构。</li></ul><p>这两者的关键区别在于：</p><ul><li>new只用于分配内存，返回一个指向地址的<strong>指针</strong>。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li><li>make只可用于<strong>slice,map,channel</strong>的初始化,返回的是<strong>引用</strong>。</li></ul><h1 id="Go的垃圾回收机制"><a href="#Go的垃圾回收机制" class="headerlink" title="Go的垃圾回收机制"></a>Go的垃圾回收机制</h1><p>[<a href="https://zhuanlan.zhihu.com/p/334999060">Go三关-典藏版]Golang垃圾回收+混合写屏障GC全分析 - 知乎</a></p><p><a href="https://blog.csdn.net/haopingbiji/article/details/145174901">Golang——内存（内存管理、内存逃逸、垃圾回收 (GC) 机制）-CSDN博客</a></p><p><a href="https://segmentfault.com/a/1190000020086769">深入理解Go-垃圾回收机制 - go学习 - SegmentFault 思否</a></p><p><a href="https://blog.csdn.net/Shoulen/article/details/140456878">Go语言的垃圾回收机制，图文并茂 一篇搞懂！_go垃圾回收-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/article/2411390">GO语言学习笔记 | 垃圾回收机制剖析-腾讯云开发者社区-腾讯云</a></p><p><a href="https://zhuanlan.zhihu.com/p/390926887">图解Golang垃圾回收机制！ - 知乎</a></p><h1 id="Go的并发机制"><a href="#Go的并发机制" class="headerlink" title="Go的并发机制"></a>Go的并发机制</h1><h2 id="Go的Select"><a href="#Go的Select" class="headerlink" title="Go的Select"></a>Go的Select</h2><p><a href="https://zhuanlan.zhihu.com/p/269401036">Go 深入源码 —— select 与 channel - 知乎</a></p><p><a href="https://cloud.tencent.com/developer/article/2205909">最全Go select底层原理，一文学透高频用法-腾讯云开发者社区-腾讯云</a></p><p><a href="https://blog.csdn.net/u011957758/article/details/82230316">由浅入深聊聊Golang中select的实现机制_golang select原理-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/article/2372901">一文搞懂Go中select的随机公平策略：并发编程的黄金法则-腾讯云开发者社区-腾讯云</a></p><h2 id="Go的Channel"><a href="#Go的Channel" class="headerlink" title="Go的Channel"></a>Go的Channel</h2><p><a href="https://segmentfault.com/a/1190000020286676">深入理解go-channel和select的原理 - go学习 - SegmentFault 思否</a></p><p><a href="https://segmentfault.com/a/1190000017958702">总结了才知道，原来channel有这么多用法！ - Go语言实战 - SegmentFault 思否</a></p><h2 id="Go的Context"><a href="#Go的Context" class="headerlink" title="Go的Context"></a>Go的Context</h2><p><a href="https://segmentfault.com/a/1190000040917752">【Go语言】小白也能看懂的context包详解：从入门到精通 - 个人文章 - SegmentFault 思否</a></p><p><a href="https://www.cnblogs.com/qcrao-2018/p/11007503.html">深度解密Go语言之context - Stefno - 博客园</a></p><p><a href="https://www.cnblogs.com/asong2020/articles/13662174.html">详解context包，看这一篇就够了 - Golang梦工厂 - 博客园</a></p><h2 id="Go的协程机制"><a href="#Go的协程机制" class="headerlink" title="Go的协程机制"></a>Go的协程机制</h2><p><a href="https://juejin.cn/post/7044741465930465311#heading-13">一文看懂Go语言协程的设计与原理背景 Go语言最大的特色就是从语言层面支持并发（Goroutine），Goroutine - 掘金</a></p><p><a href="https://www.cnblogs.com/secondtonone1/p/11803961.html">图解Go协程调度原理，小白都能理解 - 恋恋风辰 - 博客园</a></p><h1 id="Go的defer原理"><a href="#Go的defer原理" class="headerlink" title="Go的defer原理"></a>Go的defer原理</h1><p><a href="https://cloud.tencent.com/developer/article/2137023">深入分析Go defer底层原理-腾讯云开发者社区-腾讯云</a></p><p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/">理解 Go 语言 defer 关键字的原理 | Go 语言设计与实现</a></p><p><a href="https://segmentfault.com/a/1190000042896300">万字长文：从实践到原理说透Golang defer - 个人文章 - SegmentFault 思否</a></p><h1 id="Go的内存分配"><a href="#Go的内存分配" class="headerlink" title="Go的内存分配"></a>Go的内存分配</h1><blockquote><p><a href="https://blog.csdn.net/shudaqi2010/article/details/115961209">图解Go语言内存分配（面试重点，讲的很详细）_字节跳动 go 语言面试高频题 01:内存分配-CSDN博客</a></p></blockquote><h1 id="其他零碎"><a href="#其他零碎" class="headerlink" title="其他零碎"></a>其他零碎</h1><h2 id="var和-有什么区别？"><a href="#var和-有什么区别？" class="headerlink" title="var和:=有什么区别？"></a><code>var</code>和<code>:=</code>有什么区别？</h2><ul><li><code>var</code>用于声明具有明确类型的变量。</li><li><code>:=</code>用于声明并赋值类型由编译器推断的变量。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;John Doe&quot;</span><br>name := <span class="hljs-string">&quot;Jane Doe&quot;</span><br></code></pre></td></tr></table></figure><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://zhuanlan.zhihu.com/p/360306642">Go语言面试问得最多的面试题 - 知乎</a></p><p><a href="https://geektutu.com/post/qa-golang-1.html">Go 语言笔试面试题(基础语法) | 极客面试 | 极客兔兔</a></p><p><a href="https://www.cnblogs.com/cheyunhua/p/18591661">Go 开发者面试突破：50 道高频面试题及解答 - 技术颜良 - 博客园</a></p><p><strong><a href="https://zhuanlan.zhihu.com/p/471490292">Go常见面试题【由浅入深】2022版 - 知乎</a></strong></p><p><a href="https://segmentfault.com/a/1190000043941391#item-4">精选Golang高频面试题和答案汇总 - Go语言学习专栏 - SegmentFault 思否</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goalng语法概览</title>
    <link href="/2023/08/10/Golang%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <url>/2023/08/10/Golang%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文仅是由于自己经常多语言开发，对于一些语言时常不用感到陌生或者使用中同其他语言用法混淆，故作此文，仅为自己提供一个Golang语言使用的知识体系。</p></blockquote><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table><thead><tr><th>数据类型</th><th>描述</th><th>示例代码</th><th>占用内存</th></tr></thead><tbody><tr><td><strong>布尔型</strong></td><td><code>true</code> 或 <code>false</code></td><td><code>var isActive bool = true</code></td><td>1 字节</td></tr><tr><td><strong>整数型</strong></td><td>有符号整数类型</td><td><code>var x int = 42</code></td><td></td></tr><tr><td></td><td><code>int</code>（平台相关）</td><td><code>var y int32 = 100</code></td><td>32 位或 64 位</td></tr><tr><td></td><td><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></td><td><code>var z int64 = -123456</code></td><td>8, 16, 32, 64 位</td></tr><tr><td></td><td>无符号整数类型</td><td><code>var u uint = 50</code></td><td></td></tr><tr><td></td><td><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></td><td><code>var u2 uint64 = 9876</code></td><td>8, 16, 32, 64 位</td></tr><tr><td><strong>浮点型</strong></td><td>单精度和双精度浮点数</td><td><code>var pi float64 = 3.14159</code></td><td></td></tr><tr><td></td><td><code>float32</code>, <code>float64</code></td><td></td><td>32 位，64 位</td></tr><tr><td><strong>复数型</strong></td><td>实部和虚部的组合（浮点数）</td><td><code>var c complex128 = complex(1.2, 3.4)</code></td><td>64 位（每部分）</td></tr><tr><td></td><td><code>complex64</code>, <code>complex128</code></td><td></td><td></td></tr><tr><td><strong>字符型</strong></td><td>单个字符（Unicode）</td><td><code>var char rune = &#39;A&#39;</code></td><td>4 字节（<code>rune</code>）</td></tr><tr><td></td><td><code>rune</code>（等同于 <code>int32</code>）</td><td><code>var b byte = 65</code></td><td>1 字节（<code>byte</code>）</td></tr><tr><td><strong>字符串型</strong></td><td>不可变字符序列</td><td><code>var name string = &quot;Hello&quot;</code></td><td>每个字符占 1 字节（UTF-8 编码）</td></tr><tr><td><strong>派生类型</strong></td><td>复合数据类型（如数组、切片、结构体等）</td><td><code>var arr [3]int</code></td><td>根据类型不同</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/12/27/rvOaeF317VlDwTL.png" alt="数据类型"></p><h1 id="数据结构封装"><a href="#数据结构封装" class="headerlink" title="数据结构封装"></a>数据结构封装</h1><p>Go 语言不像 C++ 那样有类似 <strong>STL</strong> 的内建模板库，提供了一套丰富的泛型容器和算法封装。不过，Go 提供了一些内建的数据类型和库，使得开发者能够有效地处理常见的数据结构和操作。为了实现类似于 STL 的功能，Go 通过以下几种方式来弥补：</p><h2 id="1-Go-内建数据类型"><a href="#1-Go-内建数据类型" class="headerlink" title="1. Go 内建数据类型"></a>1. <strong>Go 内建数据类型</strong></h2><p>Go 语言提供了一些常用的数据结构和类型，能够完成基本的容器操作。常见的有：</p><ul><li><strong>数组（Array）</strong> 和 <strong>切片（Slice）</strong>：Go 的切片类似于 C++ 中的 <code>vector</code>，支持动态扩展，且非常灵活。</li><li><strong>映射（Map）</strong>：Go 提供了原生的哈希表（类似 C++ 的 <code>unordered_map</code> 或 <code>map</code>）。</li><li><strong>通道（Channel）</strong>：Go 内建的并发数据结构，用于在 goroutine 之间传递数据。</li></ul><h2 id="2-标准库"><a href="#2-标准库" class="headerlink" title="2. 标准库"></a>2. <strong>标准库</strong></h2><p>Go 提供了一些标准库来处理常见的算法和数据结构操作。虽然它不如 C++ STL 那样提供完备的模板库，但提供了一些非常实用的工具：</p><ul><li>**<code>container/list</code>**：提供双向链表。</li><li>**<code>container/heap</code>**：提供堆（优先队列）实现。</li><li>**<code>sort</code>**：对切片进行排序。</li><li>**<code>sync</code>**：提供并发控制结构，例如 <code>Mutex</code>、<code>RWMutex</code> 等。</li><li>**<code>math</code> 和 <code>math/rand</code>**：数学和随机数生成库。</li></ul><p>还有一些常见的第三方 Go 库，可以用来实现类似 STL 的功能：</p><ul><li>**<code>golang-collections/collections</code>**：提供一些额外的集合数据结构，例如队列、栈等。</li><li>**<code>gods</code>**（GoDS）：一个包含常见数据结构的包，如链表、堆、树、图、集合等。</li><li>**<code>go-datastructures</code>**：提供高级数据结构，如红黑树、跳表、堆等。</li></ul><h1 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h1><table><thead><tr><th>操作&#x2F;函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><strong><code>make([]T, len, cap)</code></strong></td><td>创建一个切片并初始化，<code>len</code> 是切片的长度，<code>cap</code> 是容量。</td><td><code>s := make([]int, 5)</code> 创建长度为 5 的切片，容量为 5。 <code>s := make([]int, 5, 10)</code> 创建长度为 5，容量为 10 的切片。</td></tr><tr><td><strong><code>len(s)</code></strong></td><td>获取切片的长度，即切片中元素的个数。</td><td><code>s := []int&#123;1, 2, 3&#125;</code> <code>fmt.Println(len(s))</code> 输出 <code>3</code>。</td></tr><tr><td><strong><code>cap(s)</code></strong></td><td>获取切片的容量，即切片底层数组的长度。</td><td><code>s := make([]int, 5, 10)</code> <code>fmt.Println(cap(s))</code> 输出 <code>10</code>。</td></tr><tr><td><strong><code>append(s, elems...)</code></strong></td><td>向切片添加元素，如果容量不足则会自动扩展切片的容量。</td><td><code>s := []int&#123;1, 2&#125;</code> <code>s = append(s, 3, 4)</code> 输出 <code>s = [1, 2, 3, 4]</code>。</td></tr><tr><td><strong><code>copy(dest, src)</code></strong></td><td>将 <code>src</code> 切片的内容复制到 <code>dest</code> 切片，返回实际复制的元素个数。</td><td><code>s1 := []int&#123;1, 2, 3&#125;</code> <code>s2 := make([]int, 3)</code> <code>n := copy(s2, s1)</code> 输出 <code>n = 3</code>，<code>s2 = [1, 2, 3]</code>。</td></tr><tr><td><strong><code>s[start:end]</code></strong></td><td>切片操作，返回一个从索引 <code>start</code> 到 <code>end-1</code> 的切片。</td><td><code>s := []int&#123;1, 2, 3, 4, 5&#125;</code> <code>fmt.Println(s[1:4])</code> 输出 <code>[2, 3, 4]</code>。</td></tr><tr><td><strong><code>s[:end]</code></strong></td><td>切片操作，返回一个从索引 <code>0</code> 到 <code>end-1</code> 的切片。</td><td><code>s := []int&#123;1, 2, 3, 4, 5&#125;</code> <code>fmt.Println(s[:3])</code> 输出 <code>[1, 2, 3]</code>。</td></tr><tr><td><strong><code>s[start:]</code></strong></td><td>切片操作，返回一个从 <code>start</code> 到切片末尾的切片。</td><td><code>s := []int&#123;1, 2, 3, 4, 5&#125;</code> <code>fmt.Println(s[2:])</code> 输出 <code>[3, 4, 5]</code>。</td></tr><tr><td><strong><code>var s []T</code></strong></td><td>声明一个空切片，未指定长度和容量。</td><td><code>var s []int</code> 声明一个空的整数切片。</td></tr><tr><td><strong><code>s = make([]int, 0)</code></strong></td><td>创建一个长度为 0 的切片。</td><td><code>s := make([]int, 0)</code> 创建一个空的整数切片。</td></tr><tr><td><strong>删除元素</strong></td><td>使用 <code>append</code> 删除切片中的元素。</td><td><code>s := []int&#123;1, 2, 3, 4&#125;</code> <code>s = append(s[:i], s[i+1:]...)</code> 删除索引 <code>i</code> 的元素。</td></tr></tbody></table><p><code>[][]int</code> 是一个二维切片的类型声明，没有实际分配内存。</p><p><code>make([][]int)</code> 创建了一个切片类型，并为外层切片分配了内存，但每一行（子切片）默认是 <code>nil</code>，需要进一步初始化。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Go 语言在 <strong>1.18</strong> 版本中引入了 <strong>泛型（Generics）</strong>，这使得开发者能够编写类型安全的代码，同时避免了重复的类型声明。泛型允许函数、方法、类型和数据结构在不同类型之间进行抽象，提升代码的复用性和灵活性。与 C++ 或 Java 的泛型相比，Go 的泛型相对简单，并通过类型参数实现。</p><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. <strong>基本语法</strong></h3><p>泛型的核心在于 **类型参数。通过类型参数，可以定义支持不同类型的函数、结构体、接口等。</p><h4 id="1-1-函数泛型"><a href="#1-1-函数泛型" class="headerlink" title="1.1 函数泛型"></a>1.1 函数泛型</h4><p>Go 中可以通过 <code>type</code> 参数来创建一个可以接受任意类型的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 泛型函数，T 表示类型参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(value T)</span></span> &#123;<br>    fmt.Println(value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Print(<span class="hljs-number">42</span>)       <span class="hljs-comment">// 输出: 42</span><br>    Print(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">// 输出: Hello</span><br>    Print(<span class="hljs-number">3.14</span>)     <span class="hljs-comment">// 输出: 3.14</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>Print</code> 函数接受一个类型为 <code>T</code> 的参数，<code>T</code> 是一个类型参数，表示可以是任何类型。<code>any</code> 是 Go 1.18 引入的类型别名，等同于 <code>interface&#123;&#125;</code>，表示可以接受任意类型。</p><h4 id="1-2-类型约束"><a href="#1-2-类型约束" class="headerlink" title="1.2 类型约束"></a>1.2 <strong>类型约束</strong></h4><p>Go 允许为类型参数设置约束，限制类型参数的范围。通过接口约束，可以指定类型参数必须满足某些条件。</p><p>例如，我们可以定义一个泛型函数，它只接受实现了 <code>Stringer</code> 接口的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义约束：只允许实现了 String 方法的类型</span><br><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 泛型函数，要求类型参数实现 Stringer 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintString</span>[<span class="hljs-title">T</span> <span class="hljs-title">Stringer</span>]<span class="hljs-params">(value T)</span></span> &#123;<br>    fmt.Println(value.String())<br>&#125;<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Person 实现了 Stringer 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> p.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>&#125;<br>    PrintString(p)  <span class="hljs-comment">// 输出: Alice</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>PrintString</code> 函数要求传入的类型 <code>T</code> 必须实现 <code>Stringer</code> 接口，只有实现了 <code>String()</code> 方法的类型才能作为参数传递。</p><h3 id="2-结构体泛型"><a href="#2-结构体泛型" class="headerlink" title="2. 结构体泛型"></a>2. <strong>结构体泛型</strong></h3><p>Go 语言也支持为结构体定义泛型，使得结构体能够接受不同类型的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个泛型结构体，T 为类型参数</span><br><span class="hljs-keyword">type</span> Box[T any] <span class="hljs-keyword">struct</span> &#123;<br>    Value T<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    intBox := Box[<span class="hljs-type">int</span>]&#123;Value: <span class="hljs-number">42</span>&#125;     <span class="hljs-comment">// 泛型结构体，类型为 int</span><br>    stringBox := Box[<span class="hljs-type">string</span>]&#123;Value: <span class="hljs-string">&quot;Hello&quot;</span>&#125; <span class="hljs-comment">// 泛型结构体，类型为 string</span><br><br>    fmt.Println(intBox.Value)    <span class="hljs-comment">// 输出: 42</span><br>    fmt.Println(stringBox.Value) <span class="hljs-comment">// 输出: Hello</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>Box</code> 结构体接受一个类型参数 <code>T</code>，并且 <code>T</code> 可以是任意类型（<code>any</code>）。在 <code>main</code> 函数中，<code>intBox</code> 和 <code>stringBox</code> 是不同类型的泛型实例。</p><h3 id="3-接口泛型"><a href="#3-接口泛型" class="headerlink" title="3. 接口泛型"></a>3. <strong>接口泛型</strong></h3><p>接口也可以使用泛型。通过泛型接口，可以定义可以接受不同类型的接口，进一步提升代码的灵活性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个泛型接口</span><br><span class="hljs-keyword">type</span> Comparator[T any] <span class="hljs-keyword">interface</span> &#123;<br>    Compare(a, b T) <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> IntComparator <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(IntComparator)</span></span> Compare(a, b <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    comparator := IntComparator&#123;&#125;<br>    fmt.Println(comparator.Compare(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出: -1</span><br>    fmt.Println(comparator.Compare(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出: 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Comparator</code> 接口定义了一个泛型方法 <code>Compare</code>，它接受两个参数并返回一个整数。<code>IntComparator</code> 实现了 <code>Comparator</code> 接口，可以比较 <code>int</code> 类型的数据。</p><h3 id="4-类型约束"><a href="#4-类型约束" class="headerlink" title="4. 类型约束"></a>4. <strong>类型约束</strong></h3><p>Go 泛型支持对类型参数设置约束，限制它们只能是某些类型或满足某些条件。这些约束可以是：</p><ul><li><strong>内建约束类型</strong>（如 <code>any</code>，表示没有约束）</li><li><strong>接口约束</strong>：要求类型实现某些方法</li><li><strong>组合约束</strong>：可以通过组合多个接口约束来实现更复杂的约束</li></ul><h4 id="4-1-内建类型约束：any-和-comparable"><a href="#4-1-内建类型约束：any-和-comparable" class="headerlink" title="4.1 内建类型约束：any 和 comparable"></a>4.1 <strong>内建类型约束：<code>any</code> 和 <code>comparable</code></strong></h4><ul><li><code>any</code>：表示没有约束，可以是任何类型。</li><li><code>comparable</code>：表示类型支持比较操作（例如，<code>==</code> 和 <code>!=</code>）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 泛型函数，约束参数必须是可比较类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compare</span>[<span class="hljs-title">T</span> <span class="hljs-title">comparable</span>]<span class="hljs-params">(a, b T)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> a == b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(Compare(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))  <span class="hljs-comment">// 输出: true</span><br>    fmt.Println(Compare(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>)) <span class="hljs-comment">// 输出: false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-多个类型参数"><a href="#5-多个类型参数" class="headerlink" title="5. 多个类型参数"></a>5. <strong>多个类型参数</strong></h3><p>Go 允许为函数或结构体定义多个类型参数，这使得泛型能够处理更加复杂的类型组合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个接受两个类型参数的泛型函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Swap</span>[<span class="hljs-title">T</span>, <span class="hljs-title">U</span> <span class="hljs-title">any</span>]<span class="hljs-params">(a T, b U)</span></span> (U, T) &#123;<br>    <span class="hljs-keyword">return</span> b, a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a, b := Swap(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br>    fmt.Println(a, b) <span class="hljs-comment">// 输出: hello 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-泛型与性能"><a href="#6-泛型与性能" class="headerlink" title="6. 泛型与性能"></a>6. <strong>泛型与性能</strong></h3><p>Go 的泛型实现使用了 **类型擦除的技术【可参考对比Java】。在编译时，Go 会将泛型函数或类型的类型参数“擦除”，并生成特定类型的代码。与 C++ 或 Java 的泛型实现不同，Go 不会生成每个类型的特定代码，而是使用通用的类型实现，保持较好的性能。</p><p>具体可参考：<a href="https://segmentfault.com/a/1190000041634906">后端 - Go 1.18 泛型全面讲解：一篇讲清泛型的全部 - 个人文章 - SegmentFault 思否</a></p><h1 id="面向接口组合"><a href="#面向接口组合" class="headerlink" title="面向接口组合"></a>面向接口组合</h1><p>Go 语言不像传统的面向对象编程（OOP）语言（如 Java 或 C++）那样具有类（<code>class</code>）和继承的概念。Go 语言的面向对象编程模型更加简洁，提供了通过 <strong>结构体（<code>struct</code>）</strong> 和 <strong>方法（<code>method</code>）</strong> 实现类似面向对象的设计思路。虽然没有类和继承，但 Go 通过组合（composition）和接口（interface）来实现面向对象的思想。</p><h3 id="Go-面向对象编程的基本概念"><a href="#Go-面向对象编程的基本概念" class="headerlink" title="Go 面向对象编程的基本概念"></a>Go 面向对象编程的基本概念</h3><ol><li><strong>结构体（Struct）</strong></li><li><strong>方法（Method）</strong></li><li><strong>接口（Interface）</strong></li><li><strong>组合（Composition）</strong></li><li><strong>多态（Polymorphism）</strong></li></ol><p>下面详细介绍这些概念：</p><hr><h3 id="1-结构体（Struct）"><a href="#1-结构体（Struct）" class="headerlink" title="1. 结构体（Struct）"></a>1. <strong>结构体（Struct）</strong></h3><p>在 Go 中，<code>struct</code> 是一种自定义的数据类型，用于将多个不同类型的数据组合成一个单一的数据结构。虽然结构体不是类，但它可以用来表示对象。</p><h4 id="示例：定义和使用结构体"><a href="#示例：定义和使用结构体" class="headerlink" title="示例：定义和使用结构体"></a>示例：定义和使用结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个结构体（类似于类）</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个结构体实例</span><br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br>    <br>    <span class="hljs-comment">// 访问结构体的字段</span><br>    fmt.Println(p.Name)  <span class="hljs-comment">// 输出: Alice</span><br>    fmt.Println(p.Age)   <span class="hljs-comment">// 输出: 30</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-方法（Method）"><a href="#2-方法（Method）" class="headerlink" title="2. 方法（Method）"></a>2. <strong>方法（Method）</strong></h3><p>方法是与类型（如结构体）绑定的函数。与面向对象语言中的类方法类似，Go 中的 <strong>方法</strong> 是通过指定一个 <strong>接收者（receiver）</strong> 来将方法与结构体（或其他类型）关联。</p><h4 id="示例：结构体方法"><a href="#示例：结构体方法" class="headerlink" title="示例：结构体方法"></a>示例：结构体方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个方法（与结构体 Person 绑定）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Greet() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, my name is&quot;</span>, p.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个结构体实例</span><br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br>    <br>    <span class="hljs-comment">// 调用结构体的方法</span><br>    p.Greet()  <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>Greet</code> 是一个 <strong>方法</strong>，它绑定到 <code>Person</code> 结构体上。方法的接收者 <code>p</code> 是 <code>Person</code> 类型的一个实例。</p><ul><li>方法接收者可以是值接收者（<code>p Person</code>）或者指针接收者（<code>p *Person</code>）。</li><li>如果使用指针接收者，方法会改变接收者的值；如果使用值接收者，则方法操作的是接收者的副本。</li></ul><h4 id="示例：指针接收者和值接收者"><a href="#示例：指针接收者和值接收者" class="headerlink" title="示例：指针接收者和值接收者"></a>示例：指针接收者和值接收者</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 使用值接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> CelebrateBirthday() &#123;<br>    p.Age++<br>    fmt.Println(<span class="hljs-string">&quot;Happy Birthday! Now I am&quot;</span>, p.Age, <span class="hljs-string">&quot;years old.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 使用指针接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> HaveBirthday() &#123;<br>    p.Age++<br>    fmt.Println(<span class="hljs-string">&quot;Happy Birthday! Now I am&quot;</span>, p.Age, <span class="hljs-string">&quot;years old.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用值接收者</span><br>    p1 := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br>    p1.CelebrateBirthday()  <span class="hljs-comment">// 输出: Happy Birthday! Now I am 31 years old.</span><br>    fmt.Println(p1.Age)      <span class="hljs-comment">// 输出: 30 (没有改变)</span><br><br>    <span class="hljs-comment">// 使用指针接收者</span><br>    p2 := &amp;Person&#123;Name: <span class="hljs-string">&quot;Bob&quot;</span>, Age: <span class="hljs-number">25</span>&#125;<br>    p2.HaveBirthday()        <span class="hljs-comment">// 输出: Happy Birthday! Now I am 26 years old.</span><br>    fmt.Println(p2.Age)      <span class="hljs-comment">// 输出: 26 (值已经改变)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-接口（Interface）"><a href="#3-接口（Interface）" class="headerlink" title="3. 接口（Interface）"></a>3. <strong>接口（Interface）</strong></h3><p>Go 中的接口是面向对象编程的关键部分，它是 <strong>动态类型</strong>，并且没有显式的继承关系。Go 中的接口不需要显式声明实现，任何类型只要实现了接口中的方法，就可以认为该类型实现了该接口。</p><h4 id="示例：定义和使用接口"><a href="#示例：定义和使用接口" class="headerlink" title="示例：定义和使用接口"></a>示例：定义和使用接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个接口</span><br><span class="hljs-keyword">type</span> Greeter <span class="hljs-keyword">interface</span> &#123;<br>    Greet()<br>&#125;<br><br><span class="hljs-comment">// 定义一个结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Greet() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, my name is&quot;</span>, p.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>&#125;<br>    <br>    <span class="hljs-comment">// 使用接口</span><br>    <span class="hljs-keyword">var</span> g Greeter = p<br>    g.Greet()  <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go 的接口是 <strong>隐式实现</strong> 的，即如果一个类型实现了接口所定义的所有方法，就认为该类型实现了接口。</p><h3 id="4-组合（Composition）"><a href="#4-组合（Composition）" class="headerlink" title="4. 组合（Composition）"></a>4. <strong>组合（Composition）</strong></h3><p>Go 语言通过组合（而非继承）来实现代码复用。你可以将一个结构体嵌入到另一个结构体中，从而获得它的方法和字段。</p><h4 id="示例：结构体组合"><a href="#示例：结构体组合" class="headerlink" title="示例：结构体组合"></a>示例：结构体组合</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个基础结构体</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Animal)</span></span> Speak() &#123;<br>    fmt.Println(a.Name, <span class="hljs-string">&quot;says hello!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义一个结构体，组合了 Animal</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>    Animal<br>    Breed <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    d := Dog&#123;Animal: Animal&#123;Name: <span class="hljs-string">&quot;Rex&quot;</span>&#125;, Breed: <span class="hljs-string">&quot;Golden Retriever&quot;</span>&#125;<br>    d.Speak()  <span class="hljs-comment">// 输出: Rex says hello!</span><br>    fmt.Println(d.Breed)  <span class="hljs-comment">// 输出: Golden Retriever</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>Dog</code> 结构体通过 <strong>组合</strong> 包含了 <code>Animal</code> 结构体。<code>Dog</code> 可以直接调用 <code>Animal</code> 的方法 <code>Speak()</code>。</p><h3 id="5-多态（Polymorphism）"><a href="#5-多态（Polymorphism）" class="headerlink" title="5. 多态（Polymorphism）"></a>5. <strong>多态（Polymorphism）</strong></h3><p>Go 的多态通过接口实现。不同的类型可以实现相同的接口，因此通过接口可以让不同的类型表现出相同的行为。</p><h4 id="示例：多态实现"><a href="#示例：多态实现" class="headerlink" title="示例：多态实现"></a>示例：多态实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义接口</span><br><span class="hljs-keyword">type</span> Speaker <span class="hljs-keyword">interface</span> &#123;<br>    Speak()<br>&#125;<br><br><span class="hljs-comment">// 定义结构体 1</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Speak() &#123;<br>    fmt.Println(p.Name, <span class="hljs-string">&quot;says hello!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义结构体 2</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Speak() &#123;<br>    fmt.Println(d.Name, <span class="hljs-string">&quot;barks!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 多态</span><br>    <span class="hljs-keyword">var</span> speaker Speaker<br><br>    speaker = Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>&#125;<br>    speaker.Speak()  <span class="hljs-comment">// 输出: Alice says hello!</span><br><br>    speaker = Dog&#123;Name: <span class="hljs-string">&quot;Rex&quot;</span>&#125;<br>    speaker.Speak()  <span class="hljs-comment">// 输出: Rex barks!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Person</code> 和 <code>Dog</code> 类型都实现了 <code>Speak()</code> 方法，因此它们都实现了 <code>Speaker</code> 接口。通过接口 <code>Speaker</code>，我们可以在运行时动态地决定调用哪个类型的方法，从而实现多态。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Go 语言虽然没有传统面向对象语言中的类和继承概念，但它通过结构体（<code>struct</code>）、方法（<code>method</code>）、接口（<code>interface</code>）和组合（<code>composition</code>）等机制实现了类似面向对象编程的功能。通过这些特性，Go 可以进行封装、抽象、接口设计以及代码复用。</p><ul><li><strong>结构体</strong>：用于定义数据类型。</li><li><strong>方法</strong>：与结构体关联的函数。</li><li><strong>接口</strong>：通过方法签名定义的行为契约，支持隐式实现。</li><li><strong>组合</strong>：通过组合结构体实现代码复用，而不是继承。</li><li><strong>多态</strong>：通过接口支持不同类型的行为一致性。</li></ul><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>Go 语言的并发编程是其最强大的特性之一。与许多语言相比，Go 提供了非常简洁和高效的并发模型。Go 的并发通过 <strong>goroutines</strong> 和 <strong>channels</strong> 来实现，具有以下特点：</p><ul><li><strong>goroutines</strong>：轻量级的线程，是 Go 实现并发的核心。</li><li><strong>channels</strong>：用于 goroutines 之间通信的管道，帮助协调不同的并发任务。</li></ul><p>在 Go 中，所有并发操作都围绕 <strong>goroutines</strong> 和 <strong>channels</strong> 进行。</p><h3 id="1-goroutines"><a href="#1-goroutines" class="headerlink" title="1. goroutines"></a>1. <strong>goroutines</strong></h3><p>goroutine 是 Go 中的一个轻量级线程，可以执行并发任务。启动一个 goroutine 非常简单，只需要在函数调用前加上 <code>go</code> 关键字即可。每个 goroutine 都有独立的栈，Go 会为每个 goroutine 分配一个小的栈空间，通常是几 KB，随着需要可以动态增长。</p><h4 id="示例：创建-goroutine"><a href="#示例：创建-goroutine" class="headerlink" title="示例：创建 goroutine"></a>示例：创建 goroutine</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-comment">// 定义一个函数，在 goroutine 中执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello from goroutine!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 启动一个 goroutine</span><br>    <span class="hljs-keyword">go</span> sayHello()<br>    <br>    <span class="hljs-comment">// 主线程休眠，以便 goroutine 执行</span><br>    time.Sleep(time.Second)<br>    fmt.Println(<span class="hljs-string">&quot;Hello from main!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们通过 <code>go sayHello()</code> 启动了一个新的 goroutine，它与主线程并发执行。由于主线程在结束前需要等待，使用 <code>time.Sleep</code> 来确保 goroutine 有足够的时间执行。</p><h3 id="2-channels"><a href="#2-channels" class="headerlink" title="2. channels"></a>2. <strong>channels</strong></h3><p>Go 使用 <strong>channels</strong> 来进行 goroutines 之间的通信。channel 就是一个管道，它可以传递数据。通过 channels，goroutines 可以安全地传递数据，而不需要显式的锁机制。</p><h4 id="示例：使用-channels-进行通信"><a href="#示例：使用-channels-进行通信" class="headerlink" title="示例：使用 channels 进行通信"></a>示例：使用 channels 进行通信</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个函数，接收一个 channel 作为参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    ch &lt;- <span class="hljs-string">&quot;Hello from goroutine!&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个 channel</span><br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <br>    <span class="hljs-comment">// 启动一个 goroutine</span><br>    <span class="hljs-keyword">go</span> greet(ch)<br>    <br>    <span class="hljs-comment">// 从 channel 中接收数据</span><br>    msg := &lt;-ch<br>    fmt.Println(msg)  <span class="hljs-comment">// 输出: Hello from goroutine!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>greet</code> 函数将一条消息通过 channel 传回主线程，主线程通过 <code>&lt;-ch</code> 接收消息并打印。</p><h3 id="3-channel-的类型"><a href="#3-channel-的类型" class="headerlink" title="3. channel 的类型"></a>3. <strong>channel 的类型</strong></h3><p>Go 中的 channels 可以有不同的类型和方向：</p><ul><li><strong>无缓冲 channel</strong>：接收和发送操作是同步的，即只有一个 goroutine 完成发送，另一个 goroutine 才能接收到数据。</li><li><strong>有缓冲 channel</strong>：允许在接收方还未准备好接收数据时，发送方可以继续发送数据。</li></ul><h4 id="示例：无缓冲-channel"><a href="#示例：无缓冲-channel" class="headerlink" title="示例：无缓冲 channel"></a>示例：无缓冲 channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)  <span class="hljs-comment">// 无缓冲 channel</span><br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        ch &lt;- <span class="hljs-string">&quot;Hello from goroutine!&quot;</span><br>    &#125;()<br>    <br>    msg := &lt;-ch<br>    fmt.Println(msg)  <span class="hljs-comment">// 输出: Hello from goroutine!</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例：有缓冲-channel"><a href="#示例：有缓冲-channel" class="headerlink" title="示例：有缓冲 channel"></a>示例：有缓冲 channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 创建一个有缓冲区的 channel</span><br>    <br>    <span class="hljs-comment">// 启动两个 goroutine</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        ch &lt;- <span class="hljs-string">&quot;Message 1&quot;</span><br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        ch &lt;- <span class="hljs-string">&quot;Message 2&quot;</span><br>    &#125;()<br>    <br>    <span class="hljs-comment">// 接收数据</span><br>    fmt.Println(&lt;-ch)  <span class="hljs-comment">// 输出: Message 1</span><br>    fmt.Println(&lt;-ch)  <span class="hljs-comment">// 输出: Message 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ch</code> 是一个有缓冲区的 channel，可以存储最多 2 个消息。如果缓冲区未满，发送方不会被阻塞；只有当缓冲区满时，发送操作才会被阻塞。</p><h3 id="4-select-语句"><a href="#4-select-语句" class="headerlink" title="4. select 语句"></a>4. <strong>select 语句</strong></h3><p><code>select</code> 是 Go 提供的多路复用机制，允许 goroutine 同时等待多个 channel 操作。<code>select</code> 会阻塞，直到有一个 case 能够执行。</p><h4 id="示例：使用-select-实现多个-channel-的监听"><a href="#示例：使用-select-实现多个-channel-的监听" class="headerlink" title="示例：使用 select 实现多个 channel 的监听"></a>示例：使用 select 实现多个 channel 的监听</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        ch1 &lt;- <span class="hljs-string">&quot;Message from ch1&quot;</span><br>    &#125;()<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>        ch2 &lt;- <span class="hljs-string">&quot;Message from ch2&quot;</span><br>    &#125;()<br>    <br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> msg1 := &lt;-ch1:<br>        fmt.Println(msg1)  <span class="hljs-comment">// 输出: Message from ch1</span><br>    <span class="hljs-keyword">case</span> msg2 := &lt;-ch2:<br>        fmt.Println(msg2)  <span class="hljs-comment">// 不会执行，除非 ch2 先发送数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>select</code> 会等待并接收第一个准备好的 channel 中的数据。如果多个 channel 都准备好了，它会随机选择一个执行。</p><h3 id="5-goroutine-的生命周期和同步"><a href="#5-goroutine-的生命周期和同步" class="headerlink" title="5. goroutine 的生命周期和同步"></a>5. <strong>goroutine 的生命周期和同步</strong></h3><h4 id="使用-sync-WaitGroup-等待多个-goroutine-完成"><a href="#使用-sync-WaitGroup-等待多个-goroutine-完成" class="headerlink" title="使用 sync.WaitGroup 等待多个 goroutine 完成"></a>使用 <code>sync.WaitGroup</code> 等待多个 goroutine 完成</h4><p><code>sync.WaitGroup</code> 是 Go 提供的一个同步工具，用于等待一组 goroutine 执行完成。它允许你在多个 goroutines 执行完之前阻塞主线程。</p><h4 id="示例：sync-WaitGroup-等待多个-goroutine-完成"><a href="#示例：sync-WaitGroup-等待多个-goroutine-完成" class="headerlink" title="示例：sync.WaitGroup 等待多个 goroutine 完成"></a>示例：<code>sync.WaitGroup</code> 等待多个 goroutine 完成</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(wg *sync.WaitGroup, n <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()  <span class="hljs-comment">// 完成时通知 WaitGroup</span><br>    fmt.Println(n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <br>    <span class="hljs-comment">// 启动多个 goroutine</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 向 WaitGroup 中添加计数</span><br>        <span class="hljs-keyword">go</span> printNumber(&amp;wg, i)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 等待所有 goroutine 完成</span><br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;All goroutines finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，主线程通过 <code>wg.Wait()</code> 阻塞，直到所有的 goroutines 完成它们的任务。<code>wg.Done()</code> 用于通知 <code>WaitGroup</code> 当前 goroutine 完成。</p><h3 id="6-Go-的并发优势"><a href="#6-Go-的并发优势" class="headerlink" title="6. Go 的并发优势"></a>6. <strong>Go 的并发优势</strong></h3><ul><li><strong>轻量级</strong>：goroutines 仅占用很小的内存（通常为 2KB），可以创建成千上万个 goroutine。</li><li><strong>简洁易用</strong>：Go 的并发模型通过 <code>go</code> 关键字和 <code>channel</code> 提供了简洁的编程模型，极大地减少了传统线程和锁的复杂性。</li><li><strong>高效</strong>：Go 的调度器能够高效地管理 goroutines 的调度，允许高并发的应用程序在多核处理器上良好运行。</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Go 语言的异常处理机制与传统的面向对象语言（如 Java、Python）不同。Go 语言没有像 <code>try-catch</code> 的传统异常处理机制，而是采用了一种基于 <strong>错误值（error）</strong> 的显式错误处理方式。这种方法使得错误处理更加清晰，开发者可以明确知道每个函数的返回值是否表示一个错误。</p><h3 id="1-Go-中的错误处理"><a href="#1-Go-中的错误处理" class="headerlink" title="1. Go 中的错误处理"></a>1. <strong>Go 中的错误处理</strong></h3><p>Go 使用 <code>error</code> 类型来表示错误。<code>error</code> 是一个内建的接口类型，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span>  <span class="hljs-comment">// 定义 Error() 方法，返回错误信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>error</code> 接口只有一个方法 <code>Error()</code>，它返回一个字符串，用于描述错误的详细信息。大多数 Go 函数会返回一个 <code>error</code> 类型的值，表示是否发生了错误。</p><h4 id="示例：基本的错误处理"><a href="#示例：基本的错误处理" class="headerlink" title="示例：基本的错误处理"></a>示例：基本的错误处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个返回错误的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;division by zero&quot;</span>)  <span class="hljs-comment">// 返回错误</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span>  <span class="hljs-comment">// 没有错误，返回结果和 nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    result, err := divide(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 检查错误</span><br>        fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br>    &#125;<br><br>    result, err = divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)  <span class="hljs-comment">// 输出: Error: division by zero</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>divide</code> 函数会返回一个 <code>int</code> 结果和一个 <code>error</code>。如果分母为 0，则返回一个错误对象，<code>error</code> 的值为 <code>&quot;division by zero&quot;</code>。</p><h3 id="2-panic-和-recover"><a href="#2-panic-和-recover" class="headerlink" title="2. panic 和 recover"></a>2. <strong><code>panic</code> 和 <code>recover</code></strong></h3><p>Go 提供了 <code>panic</code> 和 <code>recover</code> 两个机制，用于在程序中处理严重错误或不可恢复的错误。</p><ul><li>**<code>panic</code>**：<code>panic</code> 用于触发一个运行时错误，类似于其他语言中的抛出异常。当 <code>panic</code> 被调用时，程序会中止当前函数的执行，逐级向上传播，直到程序崩溃或被 <code>recover</code> 捕获。</li><li>**<code>recover</code>**：<code>recover</code> 用于从 <code>panic</code> 引发的错误中恢复，并防止程序崩溃。<code>recover</code> 只能在 <code>defer</code> 函数中使用。</li></ul><h4 id="示例：使用-panic-和-recover"><a href="#示例：使用-panic-和-recover" class="headerlink" title="示例：使用 panic 和 recover"></a>示例：使用 <code>panic</code> 和 <code>recover</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">causePanic</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;something went wrong&quot;</span>)  <span class="hljs-comment">// 触发 panic</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">safeFunction</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Recovered from panic:&quot;</span>, r)  <span class="hljs-comment">// 恢复 panic</span><br>        &#125;<br>    &#125;()<br>    <br>    causePanic()  <span class="hljs-comment">// 调用会引发 panic 的函数</span><br>    fmt.Println(<span class="hljs-string">&quot;This will not be printed&quot;</span>)  <span class="hljs-comment">// 不会执行</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    safeFunction()<br>    fmt.Println(<span class="hljs-string">&quot;Program continues...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>causePanic</code> 函数触发了 <code>panic</code>，导致程序崩溃。</li><li><code>safeFunction</code> 使用 <code>defer</code> 和 <code>recover</code> 来捕获 <code>panic</code>，防止程序崩溃并恢复执行。</li></ul><p>输出结果：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">Recovered from panic: something went wrong<br><span class="hljs-function"><span class="hljs-title">Program</span></span> continues...<br></code></pre></td></tr></table></figure><h3 id="3-defer-语句"><a href="#3-defer-语句" class="headerlink" title="3. defer 语句"></a>3. <strong><code>defer</code> 语句</strong></h3><p><code>defer</code> 语句用于延迟执行一个函数，直到包含它的函数返回时执行。这常用于资源的清理操作，如文件关闭、解锁、关闭数据库连接等。</p><h4 id="示例：使用-defer-进行资源清理"><a href="#示例：使用-defer-进行资源清理" class="headerlink" title="示例：使用 defer 进行资源清理"></a>示例：使用 <code>defer</code> 进行资源清理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Opening file:&quot;</span>, filename)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closeFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Closing file:&quot;</span>, filename)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> closeFile(filename)  <span class="hljs-comment">// 函数返回时执行，确保文件被关闭</span><br>    openFile(filename)<br>    fmt.Println(<span class="hljs-string">&quot;Processing file:&quot;</span>, filename)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    processFile(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Opening <span class="hljs-built_in">file</span>: example.txt<br>Processing <span class="hljs-built_in">file</span>: example.txt<br>Closing <span class="hljs-built_in">file</span>: example.txt<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>closeFile</code> 的调用被 <code>defer</code> 推迟到 <code>processFile</code> 函数执行完毕后进行。即使在 <code>processFile</code> 中发生了错误，<code>defer</code> 也会确保资源被正确释放。</p><h3 id="4-错误处理的最佳实践"><a href="#4-错误处理的最佳实践" class="headerlink" title="4. 错误处理的最佳实践"></a>4. <strong>错误处理的最佳实践</strong></h3><ul><li><p><strong>显式错误检查</strong>：Go 的错误处理要求开发者显式检查每个可能发生错误的函数的返回值。这种方式可以确保错误不会被忽略，也更容易理解代码的执行流。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">result, err := someFunction()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>自定义错误类型</strong>：如果需要返回更详细的错误信息，可以定义自定义的错误类型。自定义错误类型通常实现 <code>error</code> 接口的 <code>Error()</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    Code    <span class="hljs-type">int</span><br>    Message <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Code: %d, Message: %s&quot;</span>, e.Code, e.Message)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorExample</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> &amp;MyError&#123;Code: <span class="hljs-number">404</span>, Message: <span class="hljs-string">&quot;Not Found&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    err := errorExample()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)  <span class="hljs-comment">// 输出: Code: 404, Message: Not Found</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个自定义的错误类型 <code>MyError</code>，它包含错误的 <code>Code</code> 和 <code>Message</code> 字段。</p></li><li><p><strong>不要使用 <code>panic</code> 来处理常规错误</strong>：Go 提倡通过返回错误值来处理错误，而不是使用 <code>panic</code>。<code>panic</code> 主要用于程序中的严重错误（例如，无法恢复的错误）。</p></li><li><p><strong>错误链</strong>：Go 1.13 引入了错误包装功能，允许我们在原有错误的基础上添加更多的上下文信息，这使得错误处理更加灵活。可以使用 <code>fmt.Errorf</code> 来包装错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;initial error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    err := someFunction()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 使用 fmt.Errorf 包装错误</span><br>        err = fmt.Errorf(<span class="hljs-string">&quot;additional context: %w&quot;</span>, err)<br>        fmt.Println(err)  <span class="hljs-comment">// 输出: additional context: initial error</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>%w</code> 用于将原始错误包装到新错误中，允许后续代码使用 <code>errors.Is()</code> 或 <code>errors.As()</code> 来检查原始错误。</p></li></ul><h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. <strong>总结</strong>：</h3><p>Go 的错误处理方式与传统的异常机制不同，更加显式和简单。错误值 (<code>error</code>) 是 Go 的核心机制，开发者需要通过检查每个函数的返回值来处理错误。Go 还提供了 <code>panic</code> 和 <code>recover</code> 来处理不可恢复的错误，同时通过 <code>defer</code> 来处理资源清理工作。</p><ul><li><strong>错误处理</strong>：通过返回 <code>error</code> 类型来传递错误信息。</li><li>**<code>panic</code> 和 <code>recover</code>**：用于处理不可恢复的错误，<code>panic</code> 会导致程序崩溃，<code>recover</code> 可以捕获并恢复。</li><li>**<code>defer</code>**：用于推迟执行函数，确保资源的释放或清理。</li><li><strong>最佳实践</strong>：显式检查错误、自定义错误类型、错误链的使用等。</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Go 语言的内存管理采用了自动垃圾回收（<strong>GC，Garbage Collection</strong>）机制，并提供了类似于其他现代语言的 <strong>堆</strong>（Heap）和 <strong>栈</strong>（Stack）管理模型。Go 的内存管理机制设计旨在减少手动内存管理的复杂性，同时保持高效的性能。</p><p>Go 的内存管理包括以下几个关键概念：</p><ol><li><strong>堆和栈</strong></li><li><strong>垃圾回收（GC）</strong></li><li><strong>内存分配（Memory Allocation）</strong></li><li><strong>指针与引用</strong></li><li><strong>逃逸分析（Escape Analysis）</strong></li></ol><h3 id="1-堆和栈"><a href="#1-堆和栈" class="headerlink" title="1. 堆和栈"></a>1. <strong>堆和栈</strong></h3><p>Go 使用堆和栈来管理内存，像 C 语言一样，内存分为这两部分：</p><ul><li><strong>栈（Stack）</strong>：用于存储局部变量、函数调用等。栈的内存分配是由编译器自动管理的，且随着函数的调用和返回自动分配和释放。</li><li><strong>堆（Heap）</strong>：用于存储动态分配的对象，比如使用 <code>new</code> 或 <code>make</code> 创建的对象。堆内存由垃圾回收（GC）机制管理。</li></ul><h4 id="栈内存："><a href="#栈内存：" class="headerlink" title="栈内存："></a>栈内存：</h4><ul><li>栈内存的分配非常高效，因为栈是一个先进后出的结构，内存分配和释放非常迅速。</li><li>栈上的数据是自动回收的，局部变量的生命周期与其所在的函数的生命周期一致。</li></ul><h4 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h4><ul><li>堆内存是通过 <code>new</code> 或 <code>make</code> 显式分配的，内存释放由垃圾回收器管理。</li><li>堆上的数据通常具有较长的生命周期，可以跨越多个函数调用和 goroutine。</li></ul><h3 id="2-垃圾回收（GC）"><a href="#2-垃圾回收（GC）" class="headerlink" title="2. 垃圾回收（GC）"></a>2. <strong>垃圾回收（GC）</strong></h3><p>Go 的垃圾回收（GC）机制是自动的，目的是减少内存泄漏和提高内存使用的效率。Go 使用 <strong>标记-清除（Mark-and-Sweep）</strong> 和 <strong>三色标记法（Tri-Color Marking）</strong> 来进行垃圾回收。</p><h4 id="GC-的工作原理："><a href="#GC-的工作原理：" class="headerlink" title="GC 的工作原理："></a>GC 的工作原理：</h4><ol><li><strong>标记阶段</strong>：首先，GC 会扫描所有活动的对象，并标记它们为“活动”（Reachable）。活动对象包括从根对象（如全局变量、栈上的变量等）可直接访问到的对象。</li><li><strong>清除阶段</strong>：接着，GC 会清除那些没有被标记为活动的对象，释放它们所占用的内存。</li><li><strong>压缩阶段（optional）</strong>：对于某些实现，GC 可能还会进行内存的压缩（移动活动对象）以减少内存碎片。</li></ol><p>Go 的垃圾回收器是 <strong>并行且增量的</strong>，可以在程序运行时进行垃圾回收，而不会阻塞程序执行过长时间。Go 1.5 之后，GC 的性能得到了大幅改进，减少了对程序的影响。</p><h4 id="GC-触发时机："><a href="#GC-触发时机：" class="headerlink" title="GC 触发时机："></a>GC 触发时机：</h4><p>Go 会定期进行垃圾回收，通常有以下几种情况会触发 GC：</p><ul><li><strong>内存使用超过某个阈值</strong>：当堆内存的使用量超过了设定的阈值时，GC 会被触发。</li><li>**显式调用 <code>runtime.GC()</code>**：你可以通过调用 <code>runtime.GC()</code> 手动触发 GC，但这通常是不推荐的，除非在特定情况下需要精确控制。</li></ul><h4 id="配置垃圾回收："><a href="#配置垃圾回收：" class="headerlink" title="配置垃圾回收："></a>配置垃圾回收：</h4><p>你可以使用 <code>GOGC</code> 环境变量来调整垃圾回收的频率：</p><ul><li><code>GOGC=100</code>（默认）：表示在堆内存增长 100% 时触发 GC。</li><li>设置为更高的值，如 <code>GOGC=200</code>，表示需要堆内存增长到 200% 才会触发 GC，通常可以降低 GC 的频率，从而提高性能，但会增加内存占用。</li></ul><h3 id="3-内存分配（Memory-Allocation）"><a href="#3-内存分配（Memory-Allocation）" class="headerlink" title="3. 内存分配（Memory Allocation）"></a>3. <strong>内存分配（Memory Allocation）</strong></h3><p>Go 提供了多种内存分配方式，最常见的是通过 <code>new</code> 和 <code>make</code> 来分配内存：</p><ul><li><p>**<code>new</code>**：<code>new</code> 用于分配零值初始化的内存并返回指向该内存块的指针。它通常用于分配基础类型或结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span><br>p = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)  <span class="hljs-comment">// p 指向一个值为 0 的 int</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>make</code>**：<code>make</code> 用于分配并初始化切片（<code>slice</code>）、映射（<code>map</code>）、通道（<code>channel</code>）等特殊类型。<code>make</code> 会返回一个初始化后的引用，不是指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)  <span class="hljs-comment">// 创建一个空的映射</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)       <span class="hljs-comment">// 创建一个通道</span><br></code></pre></td></tr></table></figure></li><li><p><strong>直接分配</strong>：Go 支持通过常规的声明直接分配内存，如使用 <code>var</code> 或 <code>:=</code> 语法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span>  <span class="hljs-comment">// 栈分配一个 int</span><br>b := <span class="hljs-number">10</span>    <span class="hljs-comment">// 自动分配并初始化变量</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="内存池（Memory-Pool）："><a href="#内存池（Memory-Pool）：" class="headerlink" title="内存池（Memory Pool）："></a>内存池（Memory Pool）：</h4><p>Go 还提供了内存池（<code>sync.Pool</code>）来优化内存的分配和回收。它适用于短生命周期的对象，避免频繁的内存分配和回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> pool = sync.Pool&#123;<br>    New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)  <span class="hljs-comment">// 自定义对象池生成新对象</span><br>    &#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := pool.Get().(*<span class="hljs-type">int</span>)  <span class="hljs-comment">// 从池中获取对象</span><br>    *p = <span class="hljs-number">42</span><br>    fmt.Println(*p)  <span class="hljs-comment">// 输出: 42</span><br>    pool.Put(p)      <span class="hljs-comment">// 将对象放回池中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-指针与引用"><a href="#4-指针与引用" class="headerlink" title="4. 指针与引用"></a>4. <strong>指针与引用</strong></h3><p>Go 支持指针，但是没有显式的指针运算（即没有像 C 语言那样的指针算术）。指针是 Go 中的重要概念，尤其是在传递大型对象或结构体时，通过指针传递可以避免对象的拷贝，提高效率。</p><h4 id="示例：使用指针"><a href="#示例：使用指针" class="headerlink" title="示例：使用指针"></a>示例：使用指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(x *<span class="hljs-type">int</span>)</span></span> &#123;<br>    *x++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := <span class="hljs-number">10</span><br>    increment(&amp;a)  <span class="hljs-comment">// 传递指向 a 的指针</span><br>    fmt.Println(a)  <span class="hljs-comment">// 输出: 11</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go 中的指针与 C 语言类似，但是没有指针算术功能，指针只能用于引用数据，而不能做加减运算。</p><h3 id="5-逃逸分析（Escape-Analysis）"><a href="#5-逃逸分析（Escape-Analysis）" class="headerlink" title="5. 逃逸分析（Escape Analysis）"></a>5. <strong>逃逸分析（Escape Analysis）</strong></h3><p>Go 语言的编译器会进行 <strong>逃逸分析</strong>，它决定了变量是分配在栈上还是堆上。如果变量在函数返回后仍然被使用（例如，作为 goroutine 的参数），它将分配在堆上；如果变量仅在函数内使用，并且没有逃逸出去，它将分配在栈上。</p><h4 id="示例：逃逸分析"><a href="#示例：逃逸分析" class="headerlink" title="示例：逃逸分析"></a>示例：逃逸分析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>    a := <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> &amp;a  <span class="hljs-comment">// a 的指针逃逸到堆上</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := newInt()<br>    fmt.Println(*p)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，变量 <code>a</code> 的指针被返回并被 <code>main</code> 函数使用，导致编译器将 <code>a</code> 从栈上分配到堆上，避免栈内存的过早回收。</p><h3 id="6-内存泄漏"><a href="#6-内存泄漏" class="headerlink" title="6. 内存泄漏"></a>6. <strong>内存泄漏</strong></h3><p>Go 的垃圾回收机制能帮助我们自动回收不再使用的对象，防止内存泄漏。但如果一个对象的引用仍然存在，即使不再需要它，GC 也无法回收它，导致内存泄漏。</p><p>例如，切片、映射或通道的引用如果被误持有，可能会导致它们无法被垃圾回收。</p><h4 id="示例：内存泄漏"><a href="#示例：内存泄漏" class="headerlink" title="示例：内存泄漏"></a>示例：内存泄漏</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createLeak</span><span class="hljs-params">()</span></span> []<span class="hljs-type">int</span> &#123;<br>    slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1000000</span>)<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    leak := createLeak()  <span class="hljs-comment">// 内存泄漏：slice 被返回并持有</span><br>    fmt.Println(<span class="hljs-built_in">len</span>(leak))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-总结："><a href="#7-总结：" class="headerlink" title="7. 总结："></a>7. <strong>总结</strong>：</h3><p>Go 的内存管理机制结合了 <strong>垃圾回收</strong> 和 <strong>自动内存分配</strong>，极大地简化了内存管理的复杂性，避免了显式的内存释放操作（如 <code>free</code>），同时依然提供了足够的控制能力。</p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>Go 语言的网络编程非常简单且高效，得益于其内置的 <strong><code>net</code></strong> 包，它提供了大量功能来实现网络通信，支持 TCP、UDP、HTTP、DNS 等协议的客户端和服务端编程。Go 的并发模型（goroutines 和 channels）使得处理并发连接变得非常简便。</p><h3 id="1-TCP-服务端和客户端"><a href="#1-TCP-服务端和客户端" class="headerlink" title="1. TCP 服务端和客户端"></a>1. <strong>TCP 服务端和客户端</strong></h3><h4 id="TCP-服务端"><a href="#TCP-服务端" class="headerlink" title="TCP 服务端"></a>TCP 服务端</h4><p>Go 语言通过 <code>net.Listen</code> 来创建一个监听指定端口的 TCP 服务器。服务器可以接收客户端的连接请求，接着通过 <code>Accept</code> 方法获取连接并处理。</p><h5 id="示例：TCP-服务端"><a href="#示例：TCP-服务端" class="headerlink" title="示例：TCP 服务端"></a>示例：TCP 服务端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        n, err := conn.Read(buffer)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Error reading:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>        conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from server!&quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> listener.Close()<br>    fmt.Println(<span class="hljs-string">&quot;Server is listening on port 8080...&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error accepting connection:&quot;</span>, err)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)  <span class="hljs-comment">// 使用 goroutine 处理每个连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>net.Listen</code> 创建一个监听端口 8080 的 TCP 服务器。</li><li><code>listener.Accept</code> 等待客户端连接，一旦接收到连接，<code>handleConnection</code> 被调用来处理通信。</li><li>使用 <code>go</code> 关键字为每个连接启动一个新的 goroutine，从而支持并发连接。</li></ul><h4 id="TCP-客户端"><a href="#TCP-客户端" class="headerlink" title="TCP 客户端"></a>TCP 客户端</h4><p>客户端通过 <code>net.Dial</code> 连接到服务端，向服务器发送数据并接收响应。</p><h5 id="示例：TCP-客户端"><a href="#示例：TCP-客户端" class="headerlink" title="示例：TCP 客户端"></a>示例：TCP 客户端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br><br>    <span class="hljs-comment">// 向服务端发送数据</span><br>    conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, server!&quot;</span>))<br><br>    <span class="hljs-comment">// 读取服务端响应</span><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    n, err := conn.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Server response:&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个客户端示例中：</p><ul><li><code>net.Dial</code> 用于连接到指定的 TCP 服务端。</li><li>通过 <code>conn.Write</code> 发送消息，使用 <code>conn.Read</code> 接收服务端返回的消息。</li></ul><h3 id="2-UDP-服务端和客户端"><a href="#2-UDP-服务端和客户端" class="headerlink" title="2. UDP 服务端和客户端"></a>2. <strong>UDP 服务端和客户端</strong></h3><p>与 TCP 不同，UDP 是一种无连接协议，因此不需要建立连接，直接向指定地址发送数据包即可。</p><h4 id="UDP-服务端"><a href="#UDP-服务端" class="headerlink" title="UDP 服务端"></a>UDP 服务端</h4><h5 id="示例：UDP-服务端"><a href="#示例：UDP-服务端" class="headerlink" title="示例：UDP 服务端"></a>示例：UDP 服务端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建 UDP 地址</span><br>    addr, err := net.ResolveUDPAddr(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 监听 UDP 地址</span><br>    conn, err := net.ListenUDP(<span class="hljs-string">&quot;udp&quot;</span>, addr)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    fmt.Println(<span class="hljs-string">&quot;UDP server listening on port 8080...&quot;</span>)<br><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        n, addr, err := conn.ReadFromUDP(buffer)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Error reading from UDP:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;Received: %s from %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]), addr)<br>        conn.WriteToUDP([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from server!&quot;</span>), addr)  <span class="hljs-comment">// 向客户端发送响应</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="UDP-客户端"><a href="#UDP-客户端" class="headerlink" title="UDP 客户端"></a>UDP 客户端</h4><h5 id="示例：UDP-客户端"><a href="#示例：UDP-客户端" class="headerlink" title="示例：UDP 客户端"></a>示例：UDP 客户端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建 UDP 地址</span><br>    addr, err := net.ResolveUDPAddr(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 连接到 UDP 服务端</span><br>    conn, err := net.DialUDP(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-literal">nil</span>, addr)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br><br>    <span class="hljs-comment">// 向服务器发送消息</span><br>    conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, server!&quot;</span>))<br><br>    <span class="hljs-comment">// 读取响应</span><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    n, err := conn.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Server response:&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>&#125;<br></code></pre></td></tr></table></figure><p>UDP 客户端和服务端的通信相较于 TCP 更简单，不需要连接管理，但它不提供数据传输的可靠性保证。</p><h3 id="3-HTTP-服务端和客户端"><a href="#3-HTTP-服务端和客户端" class="headerlink" title="3. HTTP 服务端和客户端"></a>3. <strong>HTTP 服务端和客户端</strong></h3><p>Go 的 <code>net/http</code> 包提供了方便的 HTTP 服务端和客户端功能。</p><h4 id="HTTP-服务端"><a href="#HTTP-服务端" class="headerlink" title="HTTP 服务端"></a>HTTP 服务端</h4><p>Go 中实现 HTTP 服务端非常简单，可以通过 <code>http.HandleFunc</code> 注册路由，使用 <code>http.ListenAndServe</code> 启动服务器。</p><h5 id="示例：HTTP-服务端"><a href="#示例：HTTP-服务端" class="headerlink" title="示例：HTTP 服务端"></a>示例：HTTP 服务端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, helloHandler)<br>    fmt.Println(<span class="hljs-string">&quot;HTTP server listening on port 8080...&quot;</span>)<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error starting server:&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>http.HandleFunc</code> 用来注册路由和处理函数。当收到 HTTP 请求时，<code>helloHandler</code> 会被调用，返回 <code>&quot;Hello, World!&quot;</code>。</p><h4 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h4><p>Go 提供了 <code>http.Get</code>、<code>http.Post</code> 等方法，简化了 HTTP 请求的发送。</p><h5 id="示例：HTTP-客户端"><a href="#示例：HTTP-客户端" class="headerlink" title="示例：HTTP 客户端"></a>示例：HTTP 客户端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 发送 HTTP GET 请求</span><br>    resp, err := http.Get(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>    <span class="hljs-comment">// 读取响应数据</span><br>    body, err := ioutil.ReadAll(resp.Body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Server Response:&quot;</span>, <span class="hljs-type">string</span>(body))<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>http.Get</code> 向本地运行的 HTTP 服务发送请求，并打印返回的数据。</p><h3 id="4-HTTP-服务器和路由"><a href="#4-HTTP-服务器和路由" class="headerlink" title="4. HTTP 服务器和路由"></a>4. <strong>HTTP 服务器和路由</strong></h3><p>Go 语言的 <code>net/http</code> 包也支持高级路由功能。你可以使用 <strong><code>http.ServeMux</code></strong> 或第三方路由库（如 <strong>Gin</strong>、<strong>Echo</strong>）来创建更复杂的 HTTP 路由和中间件。</p><h4 id="示例：自定义路由"><a href="#示例：自定义路由" class="headerlink" title="示例：自定义路由"></a>示例：自定义路由</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    mux := http.NewServeMux()<br>    mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, helloHandler)<br>    <br>    fmt.Println(<span class="hljs-string">&quot;HTTP server listening on port 8080...&quot;</span>)<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, mux); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error starting server:&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>http.NewServeMux</code> 创建了一个自定义的路由器，并为 <code>/</code> 路径注册了 <code>helloHandler</code>。</p><h3 id="5-使用-goroutines-和-channels-实现并发"><a href="#5-使用-goroutines-和-channels-实现并发" class="headerlink" title="5. 使用 goroutines 和 channels 实现并发"></a>5. <strong>使用 goroutines 和 channels 实现并发</strong></h3><p>Go 的并发模型使得处理多个并发连接非常简单。通过 <code>goroutines</code> 和 <code>channels</code>，你可以轻松地管理多个连接和通信。</p><h4 id="示例：并发处理-TCP-连接"><a href="#示例：并发处理-TCP-连接" class="headerlink" title="示例：并发处理 TCP 连接"></a>示例：并发处理 TCP 连接</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        n, err := conn.Read(buffer)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Error reading:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>        conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from server!&quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> listener.Close()<br>    fmt.Println(<span class="hljs-string">&quot;Server is listening on port 8080...&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error accepting connection:&quot;</span>, err)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)  <span class="hljs-comment">// 为每个连接启动一个 goroutine</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们通过 <code>go</code> 启动了一个新的 goroutine，来处理每个连接，从而支持并发的 TCP 服务端。</p><h1 id="文件流处理"><a href="#文件流处理" class="headerlink" title="文件流处理"></a>文件流处理</h1><p>Go 语言提供了丰富的文件流处理功能，能够进行高效的文件读取、写入和处理。Go 使用标准库中的 <code>os</code> 和 <code>io</code> 包来处理文件操作，支持同步和异步的文件流操作。</p><h3 id="1-打开和关闭文件"><a href="#1-打开和关闭文件" class="headerlink" title="1. 打开和关闭文件"></a>1. <strong>打开和关闭文件</strong></h3><p>要操作文件，首先需要通过 <code>os.Open</code> 或 <code>os.OpenFile</code> 打开文件。打开文件后，我们可以进行读取、写入或其他操作。操作完成后，记得通过 <code>defer file.Close()</code> 关闭文件。</p><h4 id="示例：打开文件"><a href="#示例：打开文件" class="headerlink" title="示例：打开文件"></a>示例：打开文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 打开文件，只读模式</span><br>    file, err := os.Open(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close() <span class="hljs-comment">// 程序退出时关闭文件</span><br><br>    fmt.Println(<span class="hljs-string">&quot;File opened successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>os.Open</code> 打开文件以进行读取。如果文件不存在或无法打开，会返回错误。</li><li><code>defer file.Close()</code> 确保在函数退出时关闭文件，避免资源泄露。</li></ul><h4 id="示例：以可读写模式打开文件"><a href="#示例：以可读写模式打开文件" class="headerlink" title="示例：以可读写模式打开文件"></a>示例：以可读写模式打开文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.OpenFile(<span class="hljs-string">&quot;example.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br></code></pre></td></tr></table></figure><p><code>os.O_RDWR</code> 表示以读写模式打开文件，<code>os.O_CREATE</code> 表示如果文件不存在则创建，<code>0666</code> 是文件的权限。</p><h3 id="2-文件读取"><a href="#2-文件读取" class="headerlink" title="2. 文件读取"></a>2. <strong>文件读取</strong></h3><p>Go 提供了多种读取文件的方法，最常见的包括：</p><ul><li>使用 <code>Read</code> 方法逐字节读取文件。</li><li>使用 <code>ReadLine</code> 逐行读取文件。</li><li>使用 <code>ioutil.ReadFile</code> 一次性读取整个文件。</li></ul><h4 id="示例：逐字节读取文件"><a href="#示例：逐字节读取文件" class="headerlink" title="示例：逐字节读取文件"></a>示例：逐字节读取文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.Open(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    bytesRead, err := file.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Read %d bytes: %s\n&quot;</span>, bytesRead, <span class="hljs-type">string</span>(buffer[:bytesRead]))<br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中：</p><ul><li><code>file.Read(buffer)</code> 逐字节读取文件，最多读取 <code>1024</code> 字节，返回实际读取的字节数。</li><li>读取的内容存储在 <code>buffer</code> 中，并通过 <code>string(buffer[:bytesRead])</code> 转换为字符串。</li></ul><h4 id="示例：逐行读取文件"><a href="#示例：逐行读取文件" class="headerlink" title="示例：逐行读取文件"></a>示例：逐行读取文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.Open(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    scanner := bufio.NewScanner(file)<br>    <span class="hljs-keyword">for</span> scanner.Scan() &#123;<br>        fmt.Println(scanner.Text())  <span class="hljs-comment">// 打印每一行</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>bufio.NewScanner(file)</code> 创建了一个逐行读取文件的扫描器。</li><li>使用 <code>scanner.Scan()</code> 遍历文件中的每一行，并使用 <code>scanner.Text()</code> 获取当前行的内容。</li></ul><h4 id="示例：一次性读取整个文件"><a href="#示例：一次性读取整个文件" class="headerlink" title="示例：一次性读取整个文件"></a>示例：一次性读取整个文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    content, err := ioutil.ReadFile(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;File content:\n%s\n&quot;</span>, content)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ioutil.ReadFile</code> 会将整个文件读取到内存中，如果文件很大，需要小心内存使用。</p><h3 id="3-文件写入"><a href="#3-文件写入" class="headerlink" title="3. 文件写入"></a>3. <strong>文件写入</strong></h3><p>Go 提供了多种文件写入方式，包括：</p><ul><li>使用 <code>Write</code> 方法逐字节写入文件。</li><li>使用 <code>WriteString</code> 将字符串写入文件。</li><li>使用 <code>ioutil.WriteFile</code> 一次性写入文件。</li></ul><h4 id="示例：写入文件（覆盖）"><a href="#示例：写入文件（覆盖）" class="headerlink" title="示例：写入文件（覆盖）"></a>示例：写入文件（覆盖）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.Create(<span class="hljs-string">&quot;output.txt&quot;</span>)  <span class="hljs-comment">// 创建并打开文件（覆盖模式）</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    _, err = file.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Data written to file successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>os.Create</code> 用于创建文件并打开。如果文件已存在，会覆盖原文件。</li><li><code>file.Write([]byte(&quot;Hello, World!&quot;))</code> 将字节写入文件。</li></ul><h4 id="示例：追加模式写入文件"><a href="#示例：追加模式写入文件" class="headerlink" title="示例：追加模式写入文件"></a>示例：追加模式写入文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.OpenFile(<span class="hljs-string">&quot;output.txt&quot;</span>, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>_, err = file.WriteString(<span class="hljs-string">&quot;Appending text...\n&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Data appended to file.&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>os.OpenFile</code> 使用 <code>os.O_APPEND</code> 标志以追加模式打开文件。</li><li><code>file.WriteString</code> 用于写入字符串。</li></ul><h4 id="示例：一次性写入整个文件"><a href="#示例：一次性写入整个文件" class="headerlink" title="示例：一次性写入整个文件"></a>示例：一次性写入整个文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    data := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, Go!&quot;</span>)<br>    err := ioutil.WriteFile(<span class="hljs-string">&quot;output.txt&quot;</span>, data, <span class="hljs-number">0644</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Data written to file.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ioutil.WriteFile</code> 会覆盖文件内容，如果文件不存在，则会创建文件。</p><h3 id="4-文件复制"><a href="#4-文件复制" class="headerlink" title="4. 文件复制"></a>4. <strong>文件复制</strong></h3><p>Go 通过 <code>io.Copy</code> 可以实现文件的复制。</p><h4 id="示例：文件复制"><a href="#示例：文件复制" class="headerlink" title="示例：文件复制"></a>示例：文件复制</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    src, err := os.Open(<span class="hljs-string">&quot;source.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> src.Close()<br><br>    dst, err := os.Create(<span class="hljs-string">&quot;destination.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> dst.Close()<br><br>    _, err = io.Copy(dst, src)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;File copied successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.Copy</code> 会将源文件的内容复制到目标文件中。它可以高效地处理大文件，因为它会在内部使用缓冲区。</p><h3 id="5-文件指针"><a href="#5-文件指针" class="headerlink" title="5. 文件指针"></a>5. <strong>文件指针</strong></h3><p>可以通过 <code>Seek</code> 方法控制文件指针的位置，允许在文件中进行随机访问。</p><h4 id="示例：使用-Seek-进行文件定位"><a href="#示例：使用-Seek-进行文件定位" class="headerlink" title="示例：使用 Seek 进行文件定位"></a>示例：使用 Seek 进行文件定位</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.OpenFile(<span class="hljs-string">&quot;example.txt&quot;</span>, os.O_RDWR, <span class="hljs-number">0666</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    <span class="hljs-comment">// 定位到文件的第 5 个字节</span><br>    _, err = file.Seek(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">// 0 表示从文件开头开始定位</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">5</span>)<br>    _, err = file.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Read from position 5: %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>file.Seek(5, 0)</code> 将文件指针移动到文件的第 5 个字节位置，然后读取接下来的数据。</p><h3 id="6-文件权限和文件信息"><a href="#6-文件权限和文件信息" class="headerlink" title="6. 文件权限和文件信息"></a>6. <strong>文件权限和文件信息</strong></h3><p>Go 提供了 <code>os.Stat</code> 和 <code>os.Lstat</code> 用来获取文件的基本信息，包括文件大小、权限、修改时间等。</p><h4 id="示例：获取文件信息"><a href="#示例：获取文件信息" class="headerlink" title="示例：获取文件信息"></a>示例：获取文件信息</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fileInfo, err := os.Stat(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;File name: %s\n&quot;</span>, fileInfo.Name())<br>    fmt.Printf(<span class="hljs-string">&quot;File size: %d bytes\n&quot;</span>, fileInfo.Size())<br>    fmt.Printf(<span class="hljs-string">&quot;File mode: %s\n&quot;</span>, fileInfo.Mode())<br>    fmt.Printf(<span class="hljs-string">&quot;Last modified: %s\n&quot;</span>, fileInfo.ModTime())<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>os.Stat</code> 返回一个 <code>os.FileInfo</code> 对象，其中包含文件的元数据（如大小、权限、修改时间等）。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// diameterOfBinaryTree 函数，返回二叉树的直径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span> <span class="hljs-comment">// 存储最大直径</span><br>    <span class="hljs-keyword">var</span> depth <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span> <span class="hljs-type">int</span> <span class="hljs-comment">// 声明 depth 函数</span><br>    depth = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rt *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> rt == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        L := depth(rt.Left)   <span class="hljs-comment">// 左子树的深度</span><br>        R := depth(rt.Right)  <span class="hljs-comment">// 右子树的深度</span><br>        ans = max(ans, L+R)   <span class="hljs-comment">// 更新最大直径</span><br>        <span class="hljs-keyword">return</span> max(L, R) + <span class="hljs-number">1</span>  <span class="hljs-comment">// 返回当前节点为根的子树的深度</span><br>    &#125;<br><br>    depth(root)  <br>    <span class="hljs-keyword">return</span> ans   <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数是第一类公民</strong>： 在 Go 中，函数是“第一类公民”，这意味着函数可以像其他类型的变量一样进行赋值、传递和调用。因此，可以将一个匿名函数赋值给一个函数类型的变量（如 <code>depth</code>）。</p><p><strong>匿名函数（闭包）</strong>：比如 <code>depth</code> 是一个匿名函数（没有名字的函数），它作为一个闭包可以访问外部的 <code>ans</code> 变量。闭包是指一个函数和它的环境（外部变量）绑定在一起。在这里，<code>depth</code> 函数能够访问 <code>ans</code> 变量并且递归调用自己。</p><p><strong>函数变量的定义与赋值</strong>： 首先声明了一个函数变量 <code>depth</code>，并定义了它的类型：<code>func(*TreeNode) int</code>，表示它是一个接受 <code>*TreeNode</code> 类型参数并返回 <code>int</code> 的函数。然后你通过 <code>depth = func(rt *TreeNode) int &#123; ... &#125;</code> 来将一个匿名函数赋值给这个变量。赋值后，<code>depth</code> 就成为了一个可用的函数，你可以像调用普通函数一样调用它。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学体系框架</title>
    <link href="/2023/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <url>/2023/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在提供对密码学体系框架的了解，建立相对完善知识体系，对一些细节并没有事无巨细的进行阐述，如有纰漏错误，请多指正。</p></blockquote><h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p><img src="https://s21.ax1x.com/2024/09/28/pA1VbIH.jpg" alt="1"></p><p>简化版：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1VLid.png" alt="2"></p><h1 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h1><blockquote><p>机密性是指向无权访问数据者隐藏真实数据，而加密可以实现这一目标。发明密码学的初衷就是加密，加密也是早期的密码学家最关心的技术，他们经常会问自己：“如何才能向观察者隐藏我们的对话内容？”</p></blockquote><p>对称加密算法是一种加密方法，使用相同的密钥进行数据的加密和解密。发送方和接收方必须共享同一个密钥，以便于对数据进行加密和解密。对称加密算法通常速度较快，适用于大数据量的加密。这其中又因为应用场景不同又分为分块加密和流加密。</p><p>分组加密将数据分为固定大小的块逐块加密，适合大数据量，如文件加密；流加密则逐字节加密，适合实时数据传输，如音视频流。分组加密速度较慢，流加密较快，但流加密在错误传播时影响更大。</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1Vjzt.png" alt="image-20240928180400857"></p><h2 id="分组密码算法-Block-cipher"><a href="#分组密码算法-Block-cipher" class="headerlink" title="分组密码算法(Block cipher)"></a>分组密码算法(Block cipher)</h2><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><blockquote><p>pdf源于B站:<a href="https://www.alipan.com/s/nZN1ABDPfGf">https://www.alipan.com/s/nZN1ABDPfGf</a> 提取码: sw76 </p><p>有关的数学知识参考：<a href="https://zhuanlan.zhihu.com/p/78913397">密码学基础：AES加密算法 - 知乎</a></p></blockquote><p>由于DES加密算法被破解了，3DES加密算法虽然没有被破解，但是3DES算法的加解密效率低，所有现在都使用AES算法。<br>AES加密算法是密码学中的高级加密标准，AES为分组加密法，把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文，在AES标准规范中，分组长度只能是128位，AES是按照字节进行加密的，也就是说每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。这导致密钥长度不同，推荐加密的轮数也不同。</p><p>其加密过程如下：(解密过程同理)</p><p><img src="https://s2.loli.net/2024/12/22/W9DUKLNB7dJ38Xj.png" alt="image-20241222153104837"></p><h4 id="初识变换"><a href="#初识变换" class="headerlink" title="初识变换"></a>初识变换</h4><img src="https://s2.loli.net/2024/12/22/ERrMZa2NTvubAde.png" alt="image-20241222153413982" style="zoom:50%;" /><p>其中初识变换是对其做按字节异或操作：</p><img src="https://s2.loli.net/2024/12/22/vzXk1eYaCiBQAct.png" alt="image-20241222153444413" style="zoom:50%;" /><h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><p>属于非线性替换，具体原理就是通过一个替换表（S盒）对每个字节进行替换，实际上就是一个查表操作，并且此过程可逆，将每一个字节的前4位作为行值，后4位作为列值，去S盒查找，进行输出。<br>下图为S盒（x表示行，y表示列），例如字节为0x14，那么前四位的16进制为1，后四位的16进制为4，去查找s盒中的第1行第4列的值，可以看出为0xfa，就把原先的字节0x14替换为0xfa。解密过程与此相同，唯一就是采用的是逆S盒。</p><p><img src="https://s2.loli.net/2024/12/22/DJ8cU19IoROqPng.png" alt="image-20241222153712844"></p><h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态当，从而达到<a href="https://zhida.zhihu.com/search?content_id=105665820&content_type=Article&match_order=1&q=%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94&zhida_source=entity">雪崩效应</a>。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。</p><p>在加密时：</p><p>对于4*4的矩阵，操作为：<br>第0行：保持不动；<br>第1行：循环左移1个字节；<br>第2行：循环左移2个字节；<br>第3行：循环左移3个字节。<br>解密过程变为循环右移，每行移动字节数与加密过程相同，下图为列位移示意图。</p><p><img src="https://s2.loli.net/2024/12/22/8MhbPmAsDTtaL5E.png" alt="image-20241222153925099"></p><h4 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h4><p>实际上为4<em>4的矩阵与另一个4</em>4矩阵异或相乘（注意为右乘操作），重新得到一个4*4的矩阵。解密过程为重新与此矩阵异或，因为两次异或得到的值为原数据本身。但实际过程却比较复杂</p><p><img src="https://s2.loli.net/2024/12/22/G1Bd4MJoiSKyfNj.png" alt="1"></p><p>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：</p><p><img src="https://s2.loli.net/2024/12/22/5qpuD8Q1In4cUZ3.png" alt="2"></p><p>其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 &#x3D; (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：</p><p><img src="https://s2.loli.net/2024/12/22/9FNmzsqhVan2OQI.png" alt="3"></p><p>也就是说，如果a7为1，则进行异或运算，否则不进行。<br>类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：</p><p><img src="https://s2.loli.net/2024/12/22/MeJvXsjxan6qkQA.png" alt="4"></p><p>乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：</p><img src="https://i-blog.csdnimg.cn/blog_migrate/3cd9fdef1e1047d154a8c11bcfb898fa.png#pic_center" alt="4" style="zoom:150%;" /><p>因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。</p><p>最终：</p><p><img src="https://s2.loli.net/2024/12/22/7ZtU198y4rswegB.png" alt="image-20241222154656683"></p><h4 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h4><h5 id="AES密钥生成"><a href="#AES密钥生成" class="headerlink" title="AES密钥生成"></a><strong>AES密钥生成</strong></h5><p><img src="https://s2.loli.net/2024/12/22/XjW4mgapc6UZVGQ.png" alt="image-20241222155137422"></p><p>函数T由3部分组成：字循环、字节代换和轮常量异或。</p><p><strong>函数T()首先将4个输入字节进行翻转，并执行一个按字节的S盒代换，最后用第一个字节与轮系数Rcon进行异或运算。轮系数是一个有10个元素的一维数组，一个元素1个字节。</strong></p><p><img src="https://s2.loli.net/2024/12/22/jf1Xl6NpGMLJq48.png" alt="6"></p><hr><p>轮密钥与状态矩阵进行逐比特异或操作。<br>这个轮密钥是由种子密钥通过密钥编排算法得到的，并且轮密钥长度与分组长度相同。<br>解密过程与之相同，两次异或得到原始数据。</p><p>最终：</p><p><img src="https://s2.loli.net/2024/12/22/YAac6FbnZWVQ8eH.png" alt="8"></p><h4 id="1轮最终轮T"><a href="#1轮最终轮T" class="headerlink" title="1轮最终轮T"></a>1轮最终轮T</h4><p>最终轮的操作与普通轮类似，但<strong>省略了列混合（MixColumns）</strong>。最终轮包含以下三个步骤：</p><ol><li><strong>字节代换（SubBytes）</strong>。</li><li><strong>行移位（ShiftRows）</strong>。</li><li><strong>轮密钥加（AddRoundKey）</strong>。</li></ol><h3 id="TEA算法"><a href="#TEA算法" class="headerlink" title="TEA算法"></a>TEA算法</h3><p>TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的。</p><p>TEA 算法使用 64 位的明文分组和 128 位的密钥，它使用 Feistel 分组加密框架，建议的迭代次数为 32 轮。该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ&#x3D;「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）。</p><p>之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Encrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    <span class="hljs-comment">//总共加密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        sum += delta;<br>        x += ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        y += ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Decrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    sum = delta &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">//注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br>    <span class="hljs-comment">//总共加密32轮 那么反序也解密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        <span class="hljs-comment">// 先将y解开 然后参与运算在解x</span><br>        y -= ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>        x -= ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        sum -= delta;<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> Data[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">//明文，必须是8字节的倍数，不够需要程序补全，参考base64方法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;待加密的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);  <br><br>    <span class="hljs-type">long</span> key[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;   <span class="hljs-comment">//密钥随便</span><br><br>    <span class="hljs-comment">//Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.</span><br>    Encrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;加密后的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);<br>    Decrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密后的数值：%d %d\&quot;,Data[0],Data[1]);</span><br><span class="hljs-string">    system(&quot;</span>pause<span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h5 id="逆向练习："><a href="#逆向练习：" class="headerlink" title="逆向练习："></a>逆向练习：</h5><p>题目来源：攻防世界(easy-app)</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1VXRI.png" alt="image-20240925190902367"></p><h2 id="流密码算法-Stream-cipher"><a href="#流密码算法-Stream-cipher" class="headerlink" title="流密码算法(Stream cipher)"></a>流密码算法(Stream cipher)</h2><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><p>RC4（Rivest Cipher 4）是一种流加密算法，由罗纳德·李维斯特（Ron Rivest）在1987年开发。RC4算法的核心思想是利用伪随机数生成器（PRNG）和密钥共同生成一个密钥流，该密钥流与明文进行异或运算得到密文。</p><p>在RC4算法中，密钥流由两部分组成：密钥调度算法（KSA）和伪随机数生成算法（PRGA）。KSA的主要作用是将输入的密钥进行排列，生成一个密钥数组。PRGA则根据密钥数组生成伪随机数序列，这个序列与明文进行异或运算，得到密文。</p><blockquote><p>来源于大佬：B站&#x2F;可厉害的土豆</p></blockquote><p><img src="https://s2.loli.net/2024/12/30/uF3ptzxAscLb419.png" alt="image-20241230174024627"></p><p>[<img src="https://s2.loli.net/2024/12/30/AoLV8Z3K6BjaN5t.png" alt="image-20241230174042662"></p><p><img src="https://s2.loli.net/2024/12/30/qZbOoz1IgD2wSsG.png" alt="image-20241230174059487"></p><p><img src="https://s2.loli.net/2024/12/30/UFCKGxewkjE5VSN.png" alt="image-20241230174109548"></p><p><img src="https://s2.loli.net/2024/12/30/aMchGDSPjz1pr8y.png" alt="image-20241230174122187"></p><h4 id="（1）初始化S表"><a href="#（1）初始化S表" class="headerlink" title="（1）初始化S表"></a>（1）初始化S表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 得到S-box */</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>    S[i] = i;<br>    T[i] = puc_key[i % key_length];<br>&#125;<br> <br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>    j = (j + S[i] + T[i]) % <span class="hljs-number">256</span>;<br>    swap_uchar(&amp;S[i], &amp;S[j]); <span class="hljs-comment">//交换S[i]和S[j]</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）利用S盒生成密钥流"><a href="#（2）利用S盒生成密钥流" class="headerlink" title="（2）利用S盒生成密钥流"></a>（2）利用S盒生成密钥流</h4><p><img src="https://s2.loli.net/2024/12/22/cB6mPfT4FY8opqz.png" alt="10"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 生成密钥流 Keystream */</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; ul_data_length; k++) &#123;<br>    i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>    j = (j + puc_sbox[i]) % <span class="hljs-number">256</span>;<br>    swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);<br>    t = (puc_sbox[i] + puc_sbox[j]) % <span class="hljs-number">256</span>;<br>    puc_key_stream[k] = puc_sbox[t];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="非对称密码算法"><a href="#非对称密码算法" class="headerlink" title="非对称密码算法"></a><strong>非对称密码算法</strong></h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>对称加密(公钥密码算法)的安全性依赖于密钥的保密性和算法的强度。如果密钥被泄露，攻击者可以轻易解密数据。因此，在实际应用中，密钥管理和分发是对称加密的关键挑战之一。而通过使用密钥交换协议，通信双方可以安全地获得一个对称密钥，而敌手却无法知道这个对称密钥。</p><p>非对称密码算法使用一对密钥进行加密和解密，通常包括公钥和私钥。公钥可以公开，任何人都可以使用它加密数据；而私钥则必须保密，仅由拥有者使用来解密数据。</p><p><strong>主要特性</strong>：</p><ol><li><strong>密钥对</strong>：每个用户拥有一对密钥，公钥用于加密，私钥用于解密。</li><li><strong>安全性</strong>：即使公钥被公开，私钥的保密性仍能确保加密数据的安全性。</li><li><strong>身份验证</strong>：可用于数字签名，通过私钥签名的数据可以用公钥验证，确保信息来源和完整性。</li></ol><p><img src="https://s21.ax1x.com/2024/09/28/pA1VxQP.png" alt="image-20240928180525589"></p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><blockquote><p>RSA加密算法.pdf <a href="https://www.alipan.com/s/tpBA521QB9q">https://www.alipan.com/s/tpBA521QB9q</a> 提取码: k9b2 </p><p><a href="https://www.cnblogs.com/testtraveler/p/18499698">RSA算法详解及相关数学原理解析 - testtraveler - 博客园</a></p></blockquote><h4 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h4><h5 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h5><p>RSA（Rivest-Shamir-Adleman）加密算法是一种基于数论的非实时加密算法，广泛用于安全通信。RSA算法的核心依赖于<strong>大整数分解</strong>的困难性</p><h5 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h5><p>RSA是一种非加密加密算法，它使用<strong>公钥</strong>进行加密，<strong>私钥</strong>进行解密。非加密加密的优势在于，公钥可以公开（存储于公钥数据库PKDB），而私钥仅保留给接收者。这种设计使得消息安全传输，而消耗共享加密密钥。</p><h5 id="1-3-素数（素数）"><a href="#1-3-素数（素数）" class="headerlink" title="1.3 素数（素数）"></a>1.3 <strong>素数（素数）</strong></h5><p>RSA依赖于两个大素数的乘积。素数是指只能被1和自身整除的整数。两个大素数的乘积积极难以进行因数分解，而这一问题构成了RSA的安全基础。</p><h5 id="1-4-模运算（Modulo）"><a href="#1-4-模运算（Modulo）" class="headerlink" title="1.4 模运算（Modulo）"></a>1.4 <strong>模运算（Modulo）</strong></h5><p>余数 RSA 中广泛使用模破坏。模破坏是一种余数破坏，定义为一个整数除以另一个整数后得到的数。在 RSA 中，模破坏对加密和解密过程的避免可以在有限的数值范围内进行，从而避免溢出和精度问题。</p><h5 id="1-5欧几里得函数"><a href="#1-5欧几里得函数" class="headerlink" title="1.5欧几里得函数"></a>1.5欧几里得函数</h5><p>给定两个非负整数 a 和 b（假设 a ≥ b），欧几里得算法基于以下原理：</p><ol><li>如果 a &#x3D; b，那么结果就是 a（或 b）。</li><li>如果 a &#x3D; 0，那么结果是 b，反之亦然。</li><li>如果 a ≠ b，那么可以用较小的那个数去除较大的那个数，然后用余数代替较大的数，重复此步骤直到余数为 0。</li></ol><p>欧几里得算法的步骤</p><ol><li>计算 a mod b 得到余数 r。</li><li>如果 r &#x3D; 0，那么 b 就是 a 和 b 的最大公约数。</li><li>如果 r ≠ 0，令 a &#x3D; b，b &#x3D; r，然后重复步骤 1。</li></ol><p>示例</p><p>假设我们要找 48 和 18 的最大公约数：</p><ol><li>48mod  18&#x3D;1248mod18&#x3D;12</li><li>18mod  12&#x3D;618mod12&#x3D;6</li><li>12mod  6&#x3D;012mod6&#x3D;0，此时余数为 0，所以最大公约数是 6。</li></ol><p>扩展欧几里得算法</p><p>扩展欧几里得算法不仅可以找到 a 和 b 的最大公约数 d，还可以找到一对整数 x 和 y，使得 ax + by &#x3D; d</p><h5 id="1-6-欧拉函数φ-n"><a href="#1-6-欧拉函数φ-n" class="headerlink" title="1.6 欧拉函数φ(n)"></a>1.6 <strong>欧拉函数φ(n)</strong></h5><p>欧拉函数（Euler’s Totient Function），通常记作 φ(n)，是数论中的一个重要函数。它对于一个正整数 n 定义为小于或等于 n 的正整数中与 n 互质的数的数目。两个数互质（coprime）指的是它们的最大公约数（GCD）为 1。</p><p>例如，φ(9) &#x3D; 6，因为 1, 2, 4, 5, 7 和 8 与 9 互质；而 φ(8) &#x3D; 4，因为只有 1, 3, 5 和 7 与 8 互质。</p><p>如果 n 是一个质数 p 的幂次 p^k，则有：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">φ(pk)=pk−pk−<span class="hljs-number">1</span>=pk(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p)*φ*<span class="hljs-comment">(*p**k*)</span>=*p**k*−*p**k*−<span class="hljs-number">1</span>=*p**k*(<span class="hljs-number">1</span>−*p*<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>对于任意正整数 n，如果 n 可以分解为不同质数的乘积：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">n=p1k1⋅p2k2⋯pmkm<span class="hljs-emphasis">*n*</span>=<span class="hljs-emphasis">*p*</span>1<span class="hljs-emphasis">*k*</span>1⋅<span class="hljs-emphasis">*p*</span>2<span class="hljs-emphasis">*k*</span>2⋯<span class="hljs-emphasis">*p<span class="hljs-strong">**m**</span>k<span class="hljs-strong">**m*</span></span><br></code></pre></td></tr></table></figure><p>那么根据欧拉函数的性质，我们可以计算出：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">φ(n)=φ(p1k1)⋅φ(p2k2)⋯φ(pmkm)*φ*<span class="hljs-comment">(*n*)</span>=*φ*<span class="hljs-comment">(*p*1*k*1)⋅*φ*(*p*2*k*2)⋯*φ*(*p**m**k**m*)</span> φ(n)=n⋅(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p1)⋅(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p2)⋯(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>pm)*φ*<span class="hljs-comment">(*n*)</span>=*n*⋅(<span class="hljs-number">1</span>−*p*<span class="hljs-number">11</span>)⋅(<span class="hljs-number">1</span>−*p*<span class="hljs-number">21</span>)⋯(<span class="hljs-number">1</span>−*p**m*<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="0x02-算法描述"><a href="#0x02-算法描述" class="headerlink" title="0x02 算法描述"></a>0x02 算法描述</h4><h5 id="1-1-密钥计算步骤"><a href="#1-1-密钥计算步骤" class="headerlink" title="1.1 密钥计算步骤"></a>1.1 密钥计算步骤</h5><p>1、生成两个大素数p和q</p><p>2、计算两个素数的乘积</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">n</span>=p*q <br></code></pre></td></tr></table></figure><p>3、计算欧拉函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">φ(n)=(p-1)*(q-1)<br></code></pre></td></tr></table></figure><p>4、选择一个整数<code>e</code>（1 &lt; e &lt; φ(n)），使得<code>e</code>与<code>φ(n)</code>互质（即最大公约数gcd(e, φ(n)) &#x3D; 1）。通常情况下，<code>e</code>取一个较小的质数如65537 (<code>2^16 + 1</code>)，因为它使得加密过程更高效。</p><p>5、欧几里得算法计算d(私钥)</p><p><code>d</code>（1 &lt; d &lt; φ(n)），使得</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">(d * e) <span class="hljs-built_in">mod</span> φ(n) = <span class="hljs-number">1</span><br>d = e^<span class="hljs-number">-1</span> <span class="hljs-built_in">mod</span> φ(n)<br></code></pre></td></tr></table></figure><p>换句话说，<code>d</code>是<code>e</code>在模<code>φ(n)</code>下的乘法逆元</p><p>6、公钥：<strong>由<code>(n, e)</code>组成</strong></p><p> 私钥：<strong>由<code>(n, d)</code>组成</strong></p><p>7、加密</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">m（其中m必须小于n）使用公钥<span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">,</span> e<span class="hljs-punctuation">)</span>，加密公式为<span class="hljs-built_in">c</span> <span class="hljs-operator">=</span> m<span class="hljs-operator">^</span>e mod n，这里<span class="hljs-built_in">c</span>是密文<br></code></pre></td></tr></table></figure><p>8、解密</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">c</span>使用私钥<span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">,</span> d<span class="hljs-punctuation">)</span>，解密公式为m <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-operator">^</span>d mod n，这样就恢复了原始的消息m<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><table><thead><tr><th>公钥</th><th>（e,n）</th></tr></thead><tbody><tr><td><strong>私钥</strong></td><td><strong>（d,n）</strong></td></tr><tr><td><strong>密钥对</strong></td><td><strong>（e,n,d）</strong></td></tr><tr><td><strong>加密</strong></td><td><strong>c &#x3D; m^e mod n</strong></td></tr><tr><td><strong>解密</strong></td><td><strong>m &#x3D; c ^d mod n</strong></td></tr></tbody></table><table><thead><tr><th>n</th><th>p*q</th></tr></thead><tbody><tr><td><strong>φ(n)</strong></td><td><strong>(p-1)*(q-1)</strong></td></tr><tr><td><strong>e</strong></td><td><strong>1&lt;e&lt; φ(n)</strong></td></tr><tr><td><strong>d</strong></td><td><strong>1&lt;d&lt; φ(n)</strong> <strong>,e*d mod φ(n) &#x3D; 1</strong></td></tr></tbody></table><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-comment">// 计算最大公约数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// 求模反元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">modInverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt; m; x++) &#123;<br>        <span class="hljs-keyword">if</span> ((a * x) % m == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 快速幂算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">power</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    x = x % p;<br>    <span class="hljs-keyword">while</span> (y &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) <br>            res = (res * x) % p;<br>        y = y &gt;&gt; <span class="hljs-number">1</span>;<br>        x = (x * x) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// RSA加密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(m, e, n);<br>&#125;<br><br><span class="hljs-comment">// RSA解密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_decrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(c, d, n);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">61</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> q = <span class="hljs-number">53</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> n = p * q; <span class="hljs-comment">// 计算n</span><br>    <span class="hljs-type">int</span> phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算φ(n)</span><br>    <br>    <span class="hljs-type">int</span> e = <span class="hljs-number">17</span>; <span class="hljs-comment">// 选择公钥</span><br>    <span class="hljs-keyword">while</span> (gcd(e, phi) != <span class="hljs-number">1</span>) &#123;<br>        e++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> d = modInverse(e, phi); <span class="hljs-comment">// 计算私钥</span><br>    <br>    <span class="hljs-type">int</span> m = <span class="hljs-number">65</span>; <span class="hljs-comment">// 明文</span><br>    <span class="hljs-type">int</span> c = rsa_encrypt(m, e, n); <span class="hljs-comment">// 加密</span><br>    <span class="hljs-type">int</span> decrypted = rsa_decrypt(c, d, n); <span class="hljs-comment">// 解密</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;明文: %d\n&quot;</span>, m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;密文: %d\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密: %d\n&quot;</span>, decrypted);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>简单地说，数字签名的作用类似于现实生活中在支票和合同上的签名。当然数字签名是一种密码学技术，相比手写签名，它提供了更多的安全保证。当数字签名应用在各种各样的协议中时，它会让这些协议具有更加强大的功能</p><p>我们知道数字签名与现实生活中的签名非常相似。该密码学原语是在直观上很容易理解的密码原语之一。</p><ul><li>只有签名者本人可以对任意消息生成签名。</li><li>任何人都可以验证签名者对消息的签名。</li></ul><p><strong>在非对称密码领域，我们很容易想到数字签名的这种非对称性实现方式。</strong></p><p>签名方案通常由3种不同的算法组成。</p><ul><li>密钥对生成算法：签名者使用该算法生成新的私钥和公钥（公钥可以共享出去）。</li><li>签名算法：该算法以私钥和消息为输入，输出消息的签名。</li><li>验证算法：该算法以公钥、消息以及消息的签名为输入，输出验证结果（通过或不通过）。</li></ul><p>有时我们也将私钥称为签名密钥，将公钥称为验证密钥。上述3种算法的原理如图7.1所示。</p><p><img src="https://s2.loli.net/2024/12/22/aUc9M5T7Avg46uq.png" alt="image-20240928211112408"></p><p>那么为什么数字签名应用如此广泛呢？这是因为数字签名可以用于验证消息的来源以及完整性。</p><ul><li>来源：如果这个消息中包含某个人的签名，那么说明该消息源于这个人。</li><li>完整性：如果有人篡改了消息，签名就会失效。</li></ul><h3 id="数字证书-公钥的数字签名"><a href="#数字证书-公钥的数字签名" class="headerlink" title="数字证书(公钥的数字签名)"></a>数字证书(公钥的数字签名)</h3><p>数字证书也称为身份证书和<a href="https://zhida.zhihu.com/search?content_id=222777750&content_type=Article&match_order=1&q=%E5%85%AC%E9%92%A5%E8%AF%81%E4%B9%A6&zhida_source=entity">公钥证书</a>，是一种利用公钥基础设施(PKI)并使个人和企业能够通过互联网安全地共享数据的电子密码。</p><p>在信任可传递的假设下，数字签名将变得更加强大。简而言之，如果你相信我，而我相信Alice，那么你就可以相信Alice。信任的传递性使得系统中的信任关系得到极大地扩展。想象一下，假设我们信任某些权威机构及其验证密钥。那么，假设该权威机构对某些消息进行签名，比如Charles或者David的公钥信息等，我们就可以选择相信这个签名与消息的映射关系！这种映射称为公钥基础设施(Public Key Infrastructure，PKI)。例如，当我们尝试与Charles进行密钥交换，且他声称自己的公钥是3848时，可以通过检查我们信任的权威机构是否对类似“Charles的公钥是3848…”的消息进行签名来验证Charles的公钥的真实性。</p><p>PKI在实践中的一个应用是Web PKI。浏览器每天都通过Web PKI对我们与网站的密钥交换过程进行认证。Web PKI可以简化如下（见图7.3）过程：当我们下载浏览器时，它附带了一些内置在浏览器中的验证密钥。此验证密钥与一个权威机构相关联，该机构负责对成千上万个网站的公钥进行签名，以便网络用户可以信任这些公钥，而不必知道权威机构的存在。而用户不能观察到的是，这些网站在获得它们公钥的签名之前，必须向权威机构证明它们确实拥有自己所声称的域名。（事实上，浏览器信任许多权威机构而不仅只有一个。）</p><p><img src="https://s2.loli.net/2024/12/22/FUx1TDnlH94KktQ.png" alt="image-20240928212930338"></p><h1 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a><strong>摘要算法</strong></h1><h2 id="密码原语-基础知识"><a href="#密码原语-基础知识" class="headerlink" title="密码原语(基础知识)"></a>密码原语(基础知识)</h2><p>哈希函数(Hash Function)，它可以给任何数据生成一个全局唯一的标识符。哈希函数在密码学中随处可见！非正式地说，哈希函数以任意值为输入，并输出一个唯一的字节串。给定相同的输入，哈希函数总是产生相同的字节串。这可能看起来没什么，但在密码学中，许多算法都是基于哈希函数构造的。哈希函数的输出通常被称为摘要(Digest)或哈希值(Hash)</p><p>哈希函数的三种安全属性的表格及其简要介绍：</p><table><thead><tr><th>属性</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>抗第一原像性</td><td>给定哈希值，无法找到一个输入值，使得该输入值的哈希值等于该给定哈希值。</td><td>这确保了即使攻击者知道哈希值，也不能轻易反推原始输入。</td></tr><tr><td>抗第二原像性</td><td>给定输入值，无法找到另一个不同的输入值，使得两个输入的哈希值相同。</td><td>这保证了不同输入产生相同哈希值的概率极低，有效抵御替换攻击。</td></tr><tr><td>抗碰撞性</td><td>任何两个不同的输入值，几乎不可能产生相同的哈希值。</td><td>这使得攻击者无法找到两个不同的输入使它们的哈希值相同。</td></tr></tbody></table><p>主要应用场景：</p><table><thead><tr><th>应用场景</th><th>描述</th></tr></thead><tbody><tr><td>数据完整性验证</td><td>检查数据在传输或存储过程中的完整性，确保未被篡改。</td></tr><tr><td>密码存储</td><td>将用户密码哈希后存储，防止直接获取明文密码。</td></tr><tr><td>数字签名</td><td>生成数字签名的摘要，确保签名的数据未被篡改并提供身份验证。</td></tr><tr><td>文件完整性校验</td><td>在软件分发时，通过哈希值验证下载文件的完整性，防止恶意篡改。</td></tr><tr><td>区块链技术</td><td>用于生成区块的哈希值，确保区块链中的数据不可篡改和一致性。</td></tr><tr><td>身份认证</td><td>在安全协议中，确保用户身份的验证，防止伪造身份。</td></tr><tr><td>网络协议安全</td><td>在SSL&#x2F;TLS等协议中用于数据传输的安全性和完整性校验。</td></tr><tr><td>防止重放攻击</td><td>确保每次通信都有唯一的哈希值，防止旧通信内容被重放。</td></tr><tr><td>电子邮件安全</td><td>用于生成邮件的哈希值，确保邮件内容未被篡改。</td></tr><tr><td>代码签名</td><td>验证软件代码的完整性和来源，确保软件未被篡改。</td></tr></tbody></table><h2 id="消息摘要算法-Message-Digest"><a href="#消息摘要算法-Message-Digest" class="headerlink" title="消息摘要算法(Message Digest)"></a>消息摘要算法(Message Digest)</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><h4 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： MD5（Message-Digest Algorithm 5）是一种广泛使用的哈希函数，它产生一个128位（16字节）的哈希值，通常以32位十六进制数字表示。</p><p><strong>主要特性</strong>：</p><ul><li><strong>输出固定长度</strong>：无论输入数据大小如何，MD5总是生成128位的哈希值。</li><li><strong>快速计算</strong>：MD5的计算速度相对较快，适合处理大量数据。</li><li><strong>抗碰撞性</strong>：理论上，MD5应保证不同输入不产生相同的哈希值（尽管实际应用中存在漏洞）。</li><li><strong>广泛应用</strong>：MD5曾被广泛用于数据完整性校验、数字签名和密码存储等场景。</li></ul><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块"><a href="#数据填充和分块" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>对待加密的文件或者字符串的处理是将一个字符串分割成每512位为一个分组(小到KB大到GB都是如此划分)，形如N*512+R，这里的R是余下的位数。这个R分为几种情况：</p><ul><li>当R&#x3D;0时，实际上不需要单独“补上一个512位的分组”，因为接下来的填充和长度信息添加会自动形成一个完整的分组。</li><li>当R&lt;448时，需要在消息后面添加一个<code>1</code>，然后添加足够多的<code>0</code>，直到消息长度达到448位。之后，添加64位的长度信息（即原始消息的长度，以位为单位，低位在前）。</li><li>当R&gt;448时，确实需要添加足够的<code>0</code>（加上那个初始的<code>1</code>）来填满当前分组（即达到512位），然后在下一个分组中继续添加64位的长度信息(下一个分组的前64位)。但请注意，这里不是“再补上一个512位的分组”，而是说长度信息会放在一个新的分组中（如果原始消息加上填充的<code>1</code>和<code>0</code>不足以填满一个完整的分组，则可能看起来像是“再补”了一个分组，但实际上只是长度信息占据了一个分组的前部分）。</li></ul><p>这里的最后长度的填充一般在输出的前一刻执行。前面的分块后就可以执行后续操作了。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">Md5Finalise</span>  <br><span class="hljs-params">(  </span><br><span class="hljs-params">    Md5Context*         Context,        <span class="hljs-comment">// [in out] 指向MD5上下文的指针，该上下文将被修改以完成哈希计算。  </span></span><br><span class="hljs-params">    MD5_HASH*           Digest          <span class="hljs-comment">// [out] 用于接收最终哈希值的缓冲区。  </span></span><br><span class="hljs-params">)</span>  <br>&#123;  <br>    <span class="hljs-type">uint32_t</span>    used;     <span class="hljs-comment">// 用于存储缓冲区中已使用字节的数量。  </span><br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;     <span class="hljs-comment">// 用于存储缓冲区中剩余空闲字节的数量。  </span><br>  <br>    <span class="hljs-comment">// 计算缓冲区中已使用的字节数。  </span><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;  <br>  <br>    <span class="hljs-comment">// 在缓冲区的当前位置添加一个0x80字节作为填充的开始。  </span><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;  <br>  <br>    <span class="hljs-comment">// 计算填充0x80字节后剩余的空闲空间。  </span><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;  <br>  <br>    <span class="hljs-comment">// 如果剩余的空闲空间不足以存放64位长度信息，则进行填充、变换，并重置used和free。  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );  <br>        <span class="hljs-comment">//压缩循环函数(暂时不要管)</span><br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br>        used = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 在剩余空间中填充0，直到距离缓冲区末尾剩下8个字节用于存放长度信息。  </span><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );  <br>  <br>    <span class="hljs-comment">// 将消息长度（以位为单位）左移3位（这不是标准MD5），并存储到缓冲区末尾。  </span><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;  <br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );  <br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );  <br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );  <br>  <br>    <span class="hljs-comment">// 对填充后的缓冲区进行最后的变换，得到最终的哈希值。  </span><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br></code></pre></td></tr></table></figure><h5 id="链接变量初始化"><a href="#链接变量初始化" class="headerlink" title="链接变量初始化"></a>链接变量初始化</h5><p>初始化一个128-bit 的 MD 缓冲区，初始记为CV0，可以表示成4个32-bit 寄存器（A, B, C, D），后续的迭代始终在 MD 缓冲区进行，最后一步的128-bit 输出即为MD5算法的结果。</p><p>MD5有四个32位的被称作链接变量的整数参数，这是个参数我们定义为A、B、C、D其取值为：A&#x3D;0x01234567，B&#x3D;0x89abcdef，C&#x3D;0xfedcba98，D&#x3D;0x76543210。但考虑到内存数据存储大小端的问题我们将其赋值为：A&#x3D;0x67452301，B&#x3D;0xefcdab89，C&#x3D;0x98badcfe，D&#x3D;0x10325476。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span>     lo;<br>    <span class="hljs-type">uint32_t</span>     hi;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint8_t</span>      buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">uint32_t</span>     block[<span class="hljs-number">16</span>];<br>&#125; Md5Context;<br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;a = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;b = <span class="hljs-number">0xefcdab89</span>;<br>    Context-&gt;c = <span class="hljs-number">0x98badcfe</span>;<br>    Context-&gt;d = <span class="hljs-number">0x10325476</span>;<br><br>    Context-&gt;lo = <span class="hljs-number">0</span>;<br>    Context-&gt;hi = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="压缩循环"><a href="#压缩循环" class="headerlink" title="压缩循环"></a>压缩循环</h5><p>MD5算法规定了四个非线性操作函数（&amp;是与，|是或，~是非，^是异或）</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define F( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">z</span>) ^ ((<span class="hljs-name">x</span>) &amp; ((<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>))) )<br>#define G( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">z</span>) &amp; ((<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>))) )<br>#define H( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>) )<br>#define I( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">x</span>) | ~(<span class="hljs-name">z</span>)) )<br></code></pre></td></tr></table></figure><p>这些函数设计思想的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。</p><p>利用上面的四种操作，生成四个重要的计算函数。首先我们声明四个中间变量a,b,c,d，赋值：a &#x3D; A, b &#x3D; B, c &#x3D; C, d &#x3D; D。然后定义这四个计算函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br></code></pre></td></tr></table></figure><p>其中M[j]表示消息的第j个子分组（从0到15），&lt;&lt;表示循环左移s，常数ti是4294967296*abs(sin(i))的整数部分，i取值从1到64，单位是弧度。</p><p>定义好上述的四个计算函数后，就可以实现MD5的真正循环计算了。<strong>这个循环的循环次数为512位分组的个数</strong>。</p><blockquote><p>压缩函数每次都从CV（即上文提到的 128-bit 缓冲区）输入128位，从之前分好的消息分组中按顺序输入512位，完成4轮循环后，得到该轮压缩的128位结果，加到原来的缓冲区中，然后用下一分组继续上述步骤。（<strong>说具体一点，就是函数每次都从缓冲区(A, B, C, D)拿到四个数a, b, c, d，然后对于a, b, c, d进行压缩循环操作，把最后得到的结果a, b, c, d加到原来的(A, B, C, D)中，下一次函数执行再从(A, B, C, D)中拿数据</strong>）</p></blockquote><p>每次循环执行64次计算，上述4个函数每个16次.</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span>*<br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*     ctx,</span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*     data,</span><br><span class="hljs-params">        <span class="hljs-type">uintmax_t</span>       size</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span>*     ptr;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint32_t</span>     saved_a;<br>    <span class="hljs-type">uint32_t</span>     saved_b;<br>    <span class="hljs-type">uint32_t</span>     saved_c;<br>    <span class="hljs-type">uint32_t</span>     saved_d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> GET(n) (ctx-&gt;block[(n)])</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(n) (ctx-&gt;block[(n)] =             \</span><br><span class="hljs-meta">            ((uint32_t)ptr[(n)*4 + 0] &lt;&lt; 0 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 1] &lt;&lt; 8 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 2] &lt;&lt; 16)      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 3] &lt;&lt; 24) )</span><br><br>    ptr = (<span class="hljs-type">uint8_t</span>*)data;<br><br>    a = ctx-&gt;a;<br>    b = ctx-&gt;b;<br>    c = ctx-&gt;c;<br>    d = ctx-&gt;d;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        saved_a = a;<br>        saved_b = b;<br>        saved_c = c;<br>        saved_d = d;<br><br>        <span class="hljs-comment">// Round 1</span><br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xd76aa478</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xe8c7b756</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x242070db</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xc1bdceee</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf57c0faf</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">5</span>),  <span class="hljs-number">0x4787c62a</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa8304613</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xfd469501</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">8</span> ),  <span class="hljs-number">0x698098d8</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">9</span> ),  <span class="hljs-number">0x8b44f7af</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">10</span> ), <span class="hljs-number">0xffff5bb1</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">11</span> ), <span class="hljs-number">0x895cd7be</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">12</span> ), <span class="hljs-number">0x6b901122</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">13</span> ), <span class="hljs-number">0xfd987193</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">14</span> ), <span class="hljs-number">0xa679438e</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">15</span> ), <span class="hljs-number">0x49b40821</span>, <span class="hljs-number">22</span> )<br><br>        <span class="hljs-comment">// Round 2</span><br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xf61e2562</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xc040b340</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x265e5a51</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xe9b6c7aa</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xd62f105d</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0x02441453</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xd8a1e681</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xe7d3fbc8</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0x21e1cde6</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xc33707d6</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xf4d50d87</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x455a14ed</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0xa9e3e905</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xfcefa3f8</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x676f02d9</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x8d2a4c8a</span>, <span class="hljs-number">20</span> )<br><br>        <span class="hljs-comment">// Round 3</span><br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfffa3942</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x8771f681</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x6d9d6122</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xfde5380c</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xa4beea44</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0x4bdecfa9</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xf6bb4b60</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xbebfbc70</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x289b7ec6</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xeaa127fa</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xd4ef3085</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0x04881d05</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xd9d4d039</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0xe6db99e5</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0x1fa27cf8</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xc4ac5665</span>, <span class="hljs-number">23</span> )<br><br>        <span class="hljs-comment">// Round 4</span><br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xf4292244</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x432aff97</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xab9423a7</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfc93a039</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x655b59c3</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0x8f0ccc92</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xffeff47d</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0x85845dd1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x6fa87e4f</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xfe2ce6e0</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa3014314</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x4e0811a1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf7537e82</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0xbd3af235</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x2ad7d2bb</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xeb86d391</span>, <span class="hljs-number">21</span> )<br><br>        a += saved_a;<br>        b += saved_b;<br>        c += saved_c;<br>        d += saved_d;<br><br>        ptr += <span class="hljs-number">64</span>;<br>    &#125; <span class="hljs-keyword">while</span>( size -= <span class="hljs-number">64</span> );<br><br>    ctx-&gt;a = a;<br>    ctx-&gt;b = b;<br>    ctx-&gt;c = c;<br>    ctx-&gt;d = d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> GET</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> SET</span><br><br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*         Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    saved_lo;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    saved_lo = Context-&gt;lo;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;lo = (saved_lo + BufferSize) &amp; <span class="hljs-number">0x1fffffff</span>) &lt; saved_lo )<br>    &#123;<br>        Context-&gt;hi++;<br>    &#125;<br>    Context-&gt;hi += (<span class="hljs-type">uint32_t</span>)( BufferSize &gt;&gt; <span class="hljs-number">29</span> );<br><br>    used = saved_lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    <span class="hljs-keyword">if</span>( used )<br>    &#123;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>        <span class="hljs-keyword">if</span>( BufferSize &lt; <span class="hljs-built_in">free</span> )<br>        &#123;<br>            <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, BufferSize );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, <span class="hljs-built_in">free</span> );<br>        Buffer = (<span class="hljs-type">uint8_t</span>*)Buffer + <span class="hljs-built_in">free</span>;<br>        BufferSize -= <span class="hljs-built_in">free</span>;<br>        TransformFunction(Context, Context-&gt;buffer, <span class="hljs-number">64</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( BufferSize &gt;= <span class="hljs-number">64</span> )<br>    &#123;<br>        Buffer = TransformFunction( Context, Buffer, BufferSize &amp; ~(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-number">0x3f</span> );<br>        BufferSize &amp;= <span class="hljs-number">0x3f</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( Context-&gt;buffer, Buffer, BufferSize );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h5><p>处理完所有的512位的分组后，得到一组新的A,B,C,D的值，将这些值按ABCD的顺序级联，就得到了想要的MD5散列值。当然，输出依然要考虑内存存储的大小端问题。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Finalise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        MD5_HASH*           Digest          <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;<br><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );<br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>        used = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );<br><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;<br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );<br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );<br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );<br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );<br><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>    <br>    <br>    <span class="hljs-comment">//-----------结果输出-----------------</span><br><br>    Digest-&gt;bytes[<span class="hljs-number">0</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a );<br>    Digest-&gt;bytes[<span class="hljs-number">1</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">2</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">3</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">4</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b );<br>    Digest-&gt;bytes[<span class="hljs-number">5</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">6</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">7</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">8</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c );<br>    Digest-&gt;bytes[<span class="hljs-number">9</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">10</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">11</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">12</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d );<br>    Digest-&gt;bytes[<span class="hljs-number">13</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">14</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">15</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">24</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h3><p><a href="https://www.cnblogs.com/myseries/p/11581170.html">MD5算法+盐Salt - myseries - 博客园 (cnblogs.com)</a></p><p><strong>概念</strong>： MD5加盐是指在计算MD5哈希值时，向原始数据中添加一个随机的字符串（称为“盐”），以增强哈希值的安全性。盐的主要目的是防止使用预计算的哈希值（如彩虹表）进行攻击。(MD5加盐常用于密码存储、用户认证等需要保护敏感数据的场合)</p><p><strong>工作原理</strong>：</p><ol><li><strong>生成盐</strong>：为每个用户或数据生成一个随机字符串，通常长度在8至16字节之间。</li><li><strong>组合数据</strong>：将盐与原始数据（如密码）结合。可以是简单的拼接，或采用更复杂的方式。</li><li><strong>计算哈希</strong>：使用MD5算法计算组合后的数据的哈希值。</li></ol><h2 id="安全散列算法-Secure-Hash-Algorithm"><a href="#安全散列算法-Secure-Hash-Algorithm" class="headerlink" title="安全散列算法(Secure Hash Algorithm)"></a>安全散列算法(Secure Hash Algorithm)</h2><p>哈希函数的概念最早出现在计算机科学中，主要用于数据结构（如哈希表）和简单的完整性校验</p><h3 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h3><h4 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-1（Secure Hash Algorithm 1）是一种广泛使用的加密哈希函数，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于1995年。SHA-1生成一个160位（20字节）的哈希值，通常以40位十六进制数表示。(SHA-1已不再安全)</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出固定长度</strong>：无论输入数据的大小，SHA-1总是生成160位的哈希值。</li><li><strong>快速计算</strong>：SHA-1计算速度较快，适合处理大数据量。</li><li><strong>抗碰撞性</strong>：SHA-1设计上应保证不同输入产生不同哈希值，但随着研究的深入，已被发现存在碰撞漏洞。</li></ol><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块-1"><a href="#数据填充和分块-1" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>将512位的明文分组划分为16个子明文分组，每个子明文分组为32位。</p><p>其中分块与填充同MD5相同不多赘述</p><h5 id="初始化MD-Buffer"><a href="#初始化MD-Buffer" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-comment">// SHA1 initialisation constants</span><br>    Context-&gt;State[<span class="hljs-number">0</span>] = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;State[<span class="hljs-number">1</span>] = <span class="hljs-number">0xEFCDAB89</span>;<br>    Context-&gt;State[<span class="hljs-number">2</span>] = <span class="hljs-number">0x98BADCFE</span>;<br>    Context-&gt;State[<span class="hljs-number">3</span>] = <span class="hljs-number">0x10325476</span>;<br>    Context-&gt;State[<span class="hljs-number">4</span>] = <span class="hljs-number">0xC3D2E1F0</span>;<br>    Context-&gt;Count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    Context-&gt;Count[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="16份子明文分组扩展为80份"><a href="#16份子明文分组扩展为80份" class="headerlink" title="16份子明文分组扩展为80份"></a>16份子明文分组扩展为80份</h5><p>扩充的方法:</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1Z9eS.png" alt="image-20240919202000585"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> blk(i) (block-&gt;l[i&amp;15] = rol(block-&gt;l[(i+13)&amp;15] ^ block-&gt;l[(i+8)&amp;15] ^ block-&gt;l[(i+2)&amp;15] ^ block-&gt;l[i&amp;15],1))</span><br><span class="hljs-comment">//rol函数用于循环左移:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rol(value, bits) (((value) <span class="hljs-string">&lt;&lt; (bits)) | ((value) &gt;</span>&gt; (32 - (bits))))</span><br></code></pre></td></tr></table></figure><h5 id="80份子明文分组进行4轮运算"><a href="#80份子明文分组进行4轮运算" class="headerlink" title="80份子明文分组进行4轮运算"></a>80份子明文分组进行4轮运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1ZSL8.png" alt="image-20240919203025400"></p><p>其中k为固定值：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1eT4H.png" alt="2"></p><p>f函数为(之所以称为四轮运算的原因)：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1eb8A.png" alt="1111"></p><h5 id="链接变量与初始链接变量进行求和运算"><a href="#链接变量与初始链接变量进行求和运算" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1eqgI.png" alt="image-20240919203559058"></p><p>这里的Ho就是初始化的5个常量</p><p>注意这里的”+”是指:</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mSUg.png" alt="image-20240919203941364"></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            state[<span class="hljs-number">5</span>],</span><br><span class="hljs-params">        <span class="hljs-type">uint8_t</span> <span class="hljs-type">const</span>       buffer[<span class="hljs-number">64</span>]</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>            a;<br>    <span class="hljs-type">uint32_t</span>            b;<br>    <span class="hljs-type">uint32_t</span>            c;<br>    <span class="hljs-type">uint32_t</span>            d;<br>    <span class="hljs-type">uint32_t</span>            e;<br>    <span class="hljs-type">uint8_t</span>             workspace[<span class="hljs-number">64</span>];<br>    CHAR64LONG16*       block = (CHAR64LONG16*) workspace;<br><br>    Load128BitsAsWords( block-&gt;l, buffer );<br><br>    <span class="hljs-comment">// Copy context-&gt;state[] to working vars</span><br>    a = state[<span class="hljs-number">0</span>];<br>    b = state[<span class="hljs-number">1</span>];<br>    c = state[<span class="hljs-number">2</span>];<br>    d = state[<span class="hljs-number">3</span>];<br>    e = state[<span class="hljs-number">4</span>];<br><br>    <span class="hljs-comment">// 4 rounds of 20 operations each. Loop unrolled.</span><br>    R0(a,b,c,d,e, <span class="hljs-number">0</span>); R0(e,a,b,c,d, <span class="hljs-number">1</span>); R0(d,e,a,b,c, <span class="hljs-number">2</span>); R0(c,d,e,a,b, <span class="hljs-number">3</span>);<br>    R0(b,c,d,e,a, <span class="hljs-number">4</span>); R0(a,b,c,d,e, <span class="hljs-number">5</span>); R0(e,a,b,c,d, <span class="hljs-number">6</span>); R0(d,e,a,b,c, <span class="hljs-number">7</span>);<br>    R0(c,d,e,a,b, <span class="hljs-number">8</span>); R0(b,c,d,e,a, <span class="hljs-number">9</span>); R0(a,b,c,d,e,<span class="hljs-number">10</span>); R0(e,a,b,c,d,<span class="hljs-number">11</span>);<br>    R0(d,e,a,b,c,<span class="hljs-number">12</span>); R0(c,d,e,a,b,<span class="hljs-number">13</span>); R0(b,c,d,e,a,<span class="hljs-number">14</span>); R0(a,b,c,d,e,<span class="hljs-number">15</span>);<br>    R1(e,a,b,c,d,<span class="hljs-number">16</span>); R1(d,e,a,b,c,<span class="hljs-number">17</span>); R1(c,d,e,a,b,<span class="hljs-number">18</span>); R1(b,c,d,e,a,<span class="hljs-number">19</span>);<br>    R2(a,b,c,d,e,<span class="hljs-number">20</span>); R2(e,a,b,c,d,<span class="hljs-number">21</span>); R2(d,e,a,b,c,<span class="hljs-number">22</span>); R2(c,d,e,a,b,<span class="hljs-number">23</span>);<br>    R2(b,c,d,e,a,<span class="hljs-number">24</span>); R2(a,b,c,d,e,<span class="hljs-number">25</span>); R2(e,a,b,c,d,<span class="hljs-number">26</span>); R2(d,e,a,b,c,<span class="hljs-number">27</span>);<br>    R2(c,d,e,a,b,<span class="hljs-number">28</span>); R2(b,c,d,e,a,<span class="hljs-number">29</span>); R2(a,b,c,d,e,<span class="hljs-number">30</span>); R2(e,a,b,c,d,<span class="hljs-number">31</span>);<br>    R2(d,e,a,b,c,<span class="hljs-number">32</span>); R2(c,d,e,a,b,<span class="hljs-number">33</span>); R2(b,c,d,e,a,<span class="hljs-number">34</span>); R2(a,b,c,d,e,<span class="hljs-number">35</span>);<br>    R2(e,a,b,c,d,<span class="hljs-number">36</span>); R2(d,e,a,b,c,<span class="hljs-number">37</span>); R2(c,d,e,a,b,<span class="hljs-number">38</span>); R2(b,c,d,e,a,<span class="hljs-number">39</span>);<br>    R3(a,b,c,d,e,<span class="hljs-number">40</span>); R3(e,a,b,c,d,<span class="hljs-number">41</span>); R3(d,e,a,b,c,<span class="hljs-number">42</span>); R3(c,d,e,a,b,<span class="hljs-number">43</span>);<br>    R3(b,c,d,e,a,<span class="hljs-number">44</span>); R3(a,b,c,d,e,<span class="hljs-number">45</span>); R3(e,a,b,c,d,<span class="hljs-number">46</span>); R3(d,e,a,b,c,<span class="hljs-number">47</span>);<br>    R3(c,d,e,a,b,<span class="hljs-number">48</span>); R3(b,c,d,e,a,<span class="hljs-number">49</span>); R3(a,b,c,d,e,<span class="hljs-number">50</span>); R3(e,a,b,c,d,<span class="hljs-number">51</span>);<br>    R3(d,e,a,b,c,<span class="hljs-number">52</span>); R3(c,d,e,a,b,<span class="hljs-number">53</span>); R3(b,c,d,e,a,<span class="hljs-number">54</span>); R3(a,b,c,d,e,<span class="hljs-number">55</span>);<br>    R3(e,a,b,c,d,<span class="hljs-number">56</span>); R3(d,e,a,b,c,<span class="hljs-number">57</span>); R3(c,d,e,a,b,<span class="hljs-number">58</span>); R3(b,c,d,e,a,<span class="hljs-number">59</span>);<br>    R4(a,b,c,d,e,<span class="hljs-number">60</span>); R4(e,a,b,c,d,<span class="hljs-number">61</span>); R4(d,e,a,b,c,<span class="hljs-number">62</span>); R4(c,d,e,a,b,<span class="hljs-number">63</span>);<br>    R4(b,c,d,e,a,<span class="hljs-number">64</span>); R4(a,b,c,d,e,<span class="hljs-number">65</span>); R4(e,a,b,c,d,<span class="hljs-number">66</span>); R4(d,e,a,b,c,<span class="hljs-number">67</span>);<br>    R4(c,d,e,a,b,<span class="hljs-number">68</span>); R4(b,c,d,e,a,<span class="hljs-number">69</span>); R4(a,b,c,d,e,<span class="hljs-number">70</span>); R4(e,a,b,c,d,<span class="hljs-number">71</span>);<br>    R4(d,e,a,b,c,<span class="hljs-number">72</span>); R4(c,d,e,a,b,<span class="hljs-number">73</span>); R4(b,c,d,e,a,<span class="hljs-number">74</span>); R4(a,b,c,d,e,<span class="hljs-number">75</span>);<br>    R4(e,a,b,c,d,<span class="hljs-number">76</span>); R4(d,e,a,b,c,<span class="hljs-number">77</span>); R4(c,d,e,a,b,<span class="hljs-number">78</span>); R4(b,c,d,e,a,<span class="hljs-number">79</span>);<br><br>    <span class="hljs-comment">// Add the working vars back into context.state[]</span><br>    state[<span class="hljs-number">0</span>] += a;<br>    state[<span class="hljs-number">1</span>] += b;<br>    state[<span class="hljs-number">2</span>] += c;<br>    state[<span class="hljs-number">3</span>] += d;<br>    state[<span class="hljs-number">4</span>] += e;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span>  <span class="hljs-type">const</span>*        Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    i;<br>    <span class="hljs-type">uint32_t</span>    j;<br><br>    j = (Context-&gt;Count[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">63</span>;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;Count[<span class="hljs-number">0</span>] += BufferSize &lt;&lt; <span class="hljs-number">3</span>) &lt; (BufferSize &lt;&lt; <span class="hljs-number">3</span>) )<br>    &#123;<br>        Context-&gt;Count[<span class="hljs-number">1</span>]++;<br>    &#125;<br><br>    Context-&gt;Count[<span class="hljs-number">1</span>] += (BufferSize &gt;&gt; <span class="hljs-number">29</span>);<br>    <span class="hljs-keyword">if</span>( (j + BufferSize) &gt; <span class="hljs-number">63</span> )<br>    &#123;<br>        i = <span class="hljs-number">64</span> - j;<br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], Buffer, i );<br>        TransformFunction(Context-&gt;State, Context-&gt;Buffer);<br>        <span class="hljs-keyword">for</span>( ; i + <span class="hljs-number">63</span> &lt; BufferSize; i += <span class="hljs-number">64</span> )<br>        &#123;<br>            TransformFunction(Context-&gt;State, (<span class="hljs-type">uint8_t</span>*)Buffer + i);<br>        &#125;<br>        j = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        i = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], &amp;((<span class="hljs-type">uint8_t</span>*)Buffer)[i], BufferSize - i );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="链接变量作为下一个明文分组的输入重复进行以上操作"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mp5Q.png" alt="image-20240919203902118"></p><p>代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pf">// Copy context-&gt;state[] <span class="hljs-keyword">to</span> working vars<br>  a = <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>];<br>  b = <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>];<br>  c = <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>];<br>  d = <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>];<br>  e = <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>];<br><br>  // <span class="hljs-number">4</span> rounds of <span class="hljs-number">20</span> operations each. Loop unrolled.<br>  ............<br>  .....<br>  .<br><br>  // Add the working vars back into context.<span class="hljs-keyword">state</span>[]<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>] += a;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>] += b;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>] += c;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>] += d;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>] += e;<br></code></pre></td></tr></table></figure><h5 id="最后5个链接变量里面的数据就是SHA1摘要"><a href="#最后5个链接变量里面的数据就是SHA1摘要" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>在所有数据块处理完成后，5个链接变量的最终值即为SHA1的摘要值。</p><h3 id="SHA2算法"><a href="#SHA2算法" class="headerlink" title="SHA2算法"></a>SHA2算法</h3><h4 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-2（Secure Hash Algorithm 2）是一组加密哈希函数的集合，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于2001年。SHA-2包含多个变种，主要有SHA-224、SHA-256、SHA-384、SHA-512等，输出的哈希值长度分别为224、256、384和512位。</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出长度可变</strong>：SHA-2支持多种输出长度，适应不同安全需求。</li><li><strong>增强的安全性</strong>：相较于SHA-1，SHA-2提供更强的抗碰撞性和抗预映像性，当前被认为是安全的哈希算法。</li><li><strong>广泛应用</strong>：被广泛用于数据完整性验证、数字签名、SSL&#x2F;TLS证书等领域。</li></ol><h4 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充与分组"><a href="#数据填充与分组" class="headerlink" title="数据填充与分组"></a>数据填充与分组</h5><p>同MD5 算法、SHA-1 算法，第一步还是要将数据填充为512 bits 的整数倍，也就是64字节的整数倍。这些n 段512bits(64字节)的数据会作为原始信息进行处理。</p><h5 id="初始化MD-Buffer-1"><a href="#初始化MD-Buffer-1" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha256Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha256Context*      Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;curlen = <span class="hljs-number">0</span>;<br>    Context-&gt;length = <span class="hljs-number">0</span>;<br>    Context-&gt;state[<span class="hljs-number">0</span>] = <span class="hljs-number">0x6A09E667</span>UL;<br>    Context-&gt;state[<span class="hljs-number">1</span>] = <span class="hljs-number">0xBB67AE85</span>UL;<br>    Context-&gt;state[<span class="hljs-number">2</span>] = <span class="hljs-number">0x3C6EF372</span>UL;<br>    Context-&gt;state[<span class="hljs-number">3</span>] = <span class="hljs-number">0xA54FF53A</span>UL;<br>    Context-&gt;state[<span class="hljs-number">4</span>] = <span class="hljs-number">0x510E527F</span>UL;<br>    Context-&gt;state[<span class="hljs-number">5</span>] = <span class="hljs-number">0x9B05688C</span>UL;<br>    Context-&gt;state[<span class="hljs-number">6</span>] = <span class="hljs-number">0x1F83D9AB</span>UL;<br>    Context-&gt;state[<span class="hljs-number">7</span>] = <span class="hljs-number">0x5BE0CD19</span>UL;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="将512bits数据（164字节）扩展为644字节"><a href="#将512bits数据（164字节）扩展为644字节" class="headerlink" title="将512bits数据（164字节）扩展为644字节"></a>将512bits数据（16<em>4字节）扩展为64</em>4字节</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mCCj.png" alt="image-20240919212319707"></p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mP8s.png" alt="image-20240919212345601"></p><h5 id="进入主循环，进行64次循环"><a href="#进入主循环，进行64次循环" class="headerlink" title="进入主循环，进行64次循环"></a>进入主循环，进行64次循环</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mi2n.png" alt="image-20240919212616394"></p><p><img src="https://s2.loli.net/2024/09/29/HyfBTmEteP3s1h6.png" alt="image-20240919213245654.png"></p><p>注意A、B、C、D 、E、F、G、H分别是上一段512bits 处理后留下来的8个整数(<strong>第一次运算的时候这8个数为固定的常数</strong>)。在对该512bits 数据运算前需要先把这8个整数临时存起来（作为下一组运算的初始值，一直到64 次循环彻底结束。）。</p><p><img src="https://s2.loli.net/2024/09/29/2MSCtv1HZTLQg4o.png" alt="image-20240919212718907.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ed7f15772e4ddc5d23f140f85027b53.gif" alt="W_t">表示一个32 bits(4个字节) 的输入数据(512bits 数据其中的32bits)，<img src="https://i-blog.csdnimg.cn/blog_migrate/23a5f8b290dde5116088d13bad292457.gif" alt="K_t"> 表示一个32bits 的常数(这个也是固定的)</p><p><img src="https://s2.loli.net/2024/09/29/21ld5pgQmVKWs3t.png" alt="image-20240919213306065.png"></p><h5 id="链接变量与初始链接变量进行求和运算-1"><a href="#链接变量与初始链接变量进行求和运算-1" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s2.loli.net/2024/09/29/xurShl8HjsMXFZN.png" alt="image-20240919213011417.png"></p><h5 id="链接变量作为下一个明文分组的输入重复进行以上操作-1"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作-1" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p><h5 id="最后5个链接变量里面的数据就是SHA1摘要-1"><a href="#最后5个链接变量里面的数据就是SHA1摘要-1" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>最后一段512bits 运算后得到最终的A、B、C、D、E，即为最终的160bits数，因为需要得到最后256bits(64 位16进制)的字符串，所以要将每个4字节的数转换成8位的16进制字符串。</p><hr><h2 id="消息认证码法-Message-Authentication-Code"><a href="#消息认证码法-Message-Authentication-Code" class="headerlink" title="消息认证码法(Message Authentication Code)"></a>消息认证码法(Message Authentication Code)</h2><p><img src="https://s2.loli.net/2024/09/29/PG2V5SeEJ4IvfxH.png" alt="image-20240919215256824"></p><p><strong>把哈希函数和密钥结合起来</strong>，将得到一个新的保护数据完整性的密码学原语——消息认证码(Message Authentication Code，MAC)。密钥是安全的基础：没有密钥就无法保证机密性，也无法实现认证性。虽然哈希函数可以为任意数据提供认证性或完整性，但它需要依赖于一个不可篡改的可信信道.</p><blockquote><p><em>比如：恶意用户可以修改cookie中的信息。若cookie中仅包含用户名及用户名的哈希值，则可以通过修改这些信息来模拟不同的用户</em></p><p><em>为了确保用户的cookie不被随意更改，我们可以使用上面提到的密码学原语。当用户第一次登录网站时，网站根据密钥和用户名生成一个认证标签，并让用户将用户名和认证标签存储在cookie中。由于不知道密钥，所以用户无法伪造其他用户名的有效认证标签。</em></p></blockquote><p>实现方式有：</p><table><thead><tr><th><strong>实现方式</strong></th><th><strong>原理</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>HMAC</strong></td><td>基于哈希函数与密钥结合，经过两次哈希生成认证码</td><td>简单易实现，支持多种哈希函数，安全性好</td><td>相较于其他方法，计算效率较低</td><td>网络协议（TLS、IPsec）、API认证、OAuth</td></tr><tr><td><strong>CMAC</strong></td><td>基于分组密码（如AES），通过分组加密生成认证码</td><td>适合硬件实现，安全性高</td><td>密钥管理相对复杂</td><td>无线通信协议（如IEEE 802.11i）、密码学库</td></tr><tr><td><strong>OMAC</strong></td><td>基于CMAC的简化版本，仅使用一个密钥</td><td>密钥管理简单，适合低资源场景</td><td>不适合并行计算</td><td>嵌入式系统</td></tr><tr><td><strong>PMAC</strong></td><td>通过块加密算法并行处理消息块生成认证码</td><td>支持并行处理，速度快</td><td>实现复杂度较高</td><td>高性能场景，如高速网络、数据加密存储</td></tr><tr><td><strong>GMAC</strong></td><td>基于Galois&#x2F;Counter Mode（GCM）模式生成认证码</td><td>高性能，支持并行处理</td><td>需要与加密模式结合使用</td><td>IPsec、TLS等加密协议</td></tr><tr><td><strong>Poly1305</strong></td><td>基于伪随机函数，通过模数运算生成认证码</td><td>轻量级设计，计算效率高</td><td>需要与ChaCha20等算法配合</td><td>嵌入式设备、高效加密协议（如TLS 1.3）</td></tr><tr><td><strong>CBC-MAC</strong></td><td>基于分组加密的CBC模式生成认证码</td><td>简单易实现</td><td>对变长消息不安全，容易受长度攻击</td><td>已被更安全的CMAC替代</td></tr></tbody></table><h3 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h3><h4 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>HMAC</strong>（基于哈希的消息认证码）是一种通过哈希函数生成消息认证码的算法。它的主要作用是验证消息的完整性和真实性，防止消息在传输过程中被篡改。HMAC 结合了加密哈希函数（如SHA-256或SHA-1）和一个密钥，生成一个固定长度的消息摘要。</p><h4 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://s2.loli.net/2024/09/29/p4hcDSjUk9e3YG2.png" alt="image-20240919214933334"><br>其中：<br>H 为密码Hash函数（如MD5或SHA-2），能够对明文进行分组循环压缩；<br>k 为密钥（secret key）；<br>m 为要认证的消息；<br>k’ 是从原始密钥 k 导出的另一个密钥（如果 k 短于散列函数的输入块大小，则向右填充零；如果比该块大小更长，则对 k 进行散列）<br>ipad 内部填充（0x5C5C5C…5C5C，一段十六进制常量）；<br>opad 外部填充（0x363636…3636，一段十六进制常量)<br><img src="https://s2.loli.net/2024/09/29/2XDcgNFAbvwBxmG.png" alt="R-C"></p><p>a) 在密钥k后面添加0，或者对密钥k用H（Hash函数）进行处理，创建一个字长为B的字符串（B为Hash函数的明文分组长度）；<br>b) 将上一步生成的B字长的字符串ipad做异或运算；<br>c)将数据流m填充至第二步的结果字符串中；<br>d)用H作用于第三步生成的数据流；<br>e)将第一步生成的B字长字符串与opad做异或运算；<br>f)再将第四步的结果填充进第五步的结果中；<br>g)用H作用于第六步生成的数据流，输出最终结果。</p><hr><h2 id="国密-SM3"><a href="#国密-SM3" class="headerlink" title="国密(SM3)"></a>国密(SM3)</h2><h3 id="简单介绍-5"><a href="#简单介绍-5" class="headerlink" title="简单介绍"></a>简单介绍</h3><p><strong>概述</strong>： SM3是一种由中国国家密码管理局设计的加密哈希函数，属于国密算法系列，发布于2010年。SM3主要用于确保数据完整性和身份验证，输出的哈希值长度为256位。(SM3广泛应用于电子商务、数字签名、区块链和信息安全等领域)</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出固定长度</strong>：无论输入数据大小，SM3总是生成256位的哈希值。</li><li><strong>安全性</strong>：SM3经过严格的安全评估，具有良好的抗碰撞性和抗预映像性，适合用于高安全性需求的场合。</li><li><strong>高效性</strong>：在硬件和软件实现上具有较高的效率，适合处理大规模数据。</li></ol><h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="消息填充"><a href="#消息填充" class="headerlink" title="消息填充"></a>消息填充</h4><p><img src="https://s2.loli.net/2024/09/29/wTA6OfE2Yb4lJ5H.png" alt="image-20240920102423212"></p><h4 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h4><p>SM3的迭代压缩步骤没有直接使用数据分组进行运算，而是使用这个步骤产生的132个消息字。（一个消息字的长度为32位&#x2F;4个字节&#x2F;8个16j进制数字）概括来说，先将一个512位数据分组划分为16个消息字，并且作为生成的132个消息字的前16个。再<strong>用这16个消息字递推生成剩余的116个消息字</strong>。</p><p>在最终得到的132个消息字中，前68个消息字构成数列 {W j {W_j}Wj}，后64个消息字构成数列 {W j ‘ {W_j^&#96;}Wj‘}，其中下标j从0开始计数。</p><p><img src="https://s2.loli.net/2024/09/29/SYcCjgi3HDQW2pN.png" alt="image-20240920102620139"></p><h4 id="迭代压缩"><a href="#迭代压缩" class="headerlink" title="迭代压缩"></a>迭代压缩</h4><p>这块结构和SHA系列算法也比较相似，由初始化向量然后对于每一个扩展后的消息进行处理，直到处理完最后一个分块。</p><p><img src="https://s2.loli.net/2024/09/29/xBK6a4djoQMH5tV.jpg" alt="f0adf403fda784ac40e30771876caede (1)"></p><h5 id="压缩函数-核心"><a href="#压缩函数-核心" class="headerlink" title="压缩函数(核心)"></a>压缩函数(核心)</h5><p><img src="https://s2.loli.net/2024/09/29/1Ao9rcevbuyjOtM.png" alt="image-20240920103047143"></p><p>其中初值IV被放在A、B、C、D、E、F、G、H八个<a href="https://www.zhihu.com/search?q=32%E4%BD%8D%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:129692191%7D">32位变量</a>中</p><p>压缩函数将这八个变量进行64轮相同的计算，一轮的计算过程如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/PH7kIDdAfOyKMSc.jpg" alt="748a9c1bcf39b12e4d868474649ff333"></p><p>最后，再将计算完成的A、B、C、D、E、F、G、H和原来的A、B、C、D、E、F、G、H分别进行异或，就是压缩函数的输出。这个输出再作为下一次调用压缩函数时的初值。依次类推，直到用完最后一组132个消息字为止。</p><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://s2.loli.net/2024/09/29/DafG4M9qZjzh1LC.png" alt="image-20240920103309918"></p><p>将得到的A、B、C、D、E、F、G、H八个变量拼接输出，就是SM3算法的输出。</p><h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="Base系列算法"><a href="#Base系列算法" class="headerlink" title="Base系列算法"></a>Base系列算法</h2><h3 id="Base16编码"><a href="#Base16编码" class="headerlink" title="Base16编码"></a>Base16编码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Base16（也称为Hexadecimal或Hex）是一种常见的编码方式，用于将二进制数据转换为可读的文本格式。它使用16个不同的字符来表示每4位二进制数。Base16编码使用的字符集包括<code>0-9</code>和<code>A-F</code>，其中<code>A-F</code>代表10到15的数字。这种编码方式通常用于计算机系统中表示二进制数据，并且非常适合于调试和数据展示。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据（通常是字节）准备好。</li><li><strong>分组处理</strong>：将每个字节（8位）分解为两个4位的部分。</li><li><strong>映射字符</strong>：使用Base16字符集将每个4位部分映射为一个Base16字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base16字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base16编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base16字符转换为对应的4位二进制值。</li><li><strong>合并处理</strong>：将这些4位二进制值重新组合成字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base16 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* hexChars = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 每个字节对应两个十六进制字符</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &gt;&gt; <span class="hljs-number">4</span>]);   <span class="hljs-comment">// 高四位</span><br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &amp; <span class="hljs-number">0x0F</span>]); <span class="hljs-comment">// 低四位</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base16 解码函数</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">decodeHexChar</span><span class="hljs-params">(<span class="hljs-type">char</span> hexChar)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;F&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid hex character&quot;</span>);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">length</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base16 input length&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> high = <span class="hljs-built_in">decodeHexChar</span>(input[i]);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> low = <span class="hljs-built_in">decodeHexChar</span>(input[i + <span class="hljs-number">1</span>]);<br>        output.<span class="hljs-built_in">push_back</span>((high &lt;&lt; <span class="hljs-number">4</span>) | low);  <span class="hljs-comment">// 高位和低位合并成一个字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase16</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase16</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base32编码"><a href="#Base32编码" class="headerlink" title="Base32编码"></a>Base32编码</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>Base32是一种编码方案，用于将二进制数据转换为可打印的文本格式。它使用32个不同的字符来表示每5位二进制数。Base32编码使用的字符集通常包括<code>A-Z</code>和<code>2-7</code>，这些字符在ASCII范围内都是可打印的。Base32通常用于需要对数据进行一定程度的可读性增强的场景，例如在URL中或在一些认证系统中。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好。</li><li><strong>分组处理</strong>：将数据分成每5位二进制的一组，每组对应一个Base32字符。</li><li><strong>映射字符</strong>：使用Base32字符集将每5位二进制数据映射为一个Base32字符。</li><li><strong>填充处理</strong>：如果数据长度不是5的倍数，使用<code>=</code>字符进行填充，以确保编码字符串的长度为8的倍数。</li><li><strong>输出结果</strong>：将所有映射得到的Base32字符和填充字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base32编码后的字符串，并去除可能存在的填充字符<code>=</code>。</li><li><strong>字符映射</strong>：将每个Base32字符转换为对应的5位二进制值。</li><li><strong>合并处理</strong>：将这些5位二进制值重新组合成字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE32_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;<br><br><span class="hljs-comment">// Base32 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 将缓冲区左移8位</span><br>        buffer |= c;   <span class="hljs-comment">// 将当前字节加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">5</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &gt;&gt; (bitsLeft - <span class="hljs-number">5</span>)) &amp; <span class="hljs-number">0x1F</span>]);  <span class="hljs-comment">// 取高5位</span><br>            bitsLeft -= <span class="hljs-number">5</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余位数不足5位的情况</span><br>    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &lt;&lt; (<span class="hljs-number">5</span> - bitsLeft)) &amp; <span class="hljs-number">0x1F</span>]);<br>        paddingCount = (<span class="hljs-number">8</span> - (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">8</span>)) % <span class="hljs-number">8</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 Base32 的 &quot;=&quot; 填充字符</span><br>    output.<span class="hljs-built_in">append</span>(paddingCount, <span class="hljs-string">&#x27;=&#x27;</span>);<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base32 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            paddingCount++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = BASE32_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base32 character&quot;</span>);<br>        &#125;<br><br>        buffer &lt;&lt;= <span class="hljs-number">5</span>;  <span class="hljs-comment">// 将缓冲区左移5位</span><br>        buffer |= index;  <span class="hljs-comment">// 将当前字符的值加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">5</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (bitsLeft - <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 取高8位</span><br>            bitsLeft -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase32</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase32</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base58-编码"><a href="#Base58-编码" class="headerlink" title="Base58 编码"></a>Base58 编码</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Base58是一种用于将二进制数据编码为可打印字符的方案，广泛应用于加密货币（如比特币地址）等领域。Base58编码通过去除Base64编码中的某些容易混淆的字符（如<code>0</code>、<code>O</code>、<code>I</code>、<code>l</code>），使编码结果更易于手动输入和读取。它使用58个可打印的ASCII字符，编码效率高，每4字节二进制数据编码为5个Base58字符。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>转换为整数</strong>：将二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：用58作为基数，将大整数逐步除以58，得到的余数用于索引Base58字符集，从而得到Base58字符。</li><li><strong>处理前导零</strong>：在编码结果前添加相应数量的Base58字符<code>1</code>，以保持与原始数据前导零的对应关系。</li><li><strong>输出结果</strong>：将所有映射得到的Base58字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base58编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base58字符转换为其在Base58字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个大整数。</li><li><strong>处理前导零</strong>：根据编码结果中的前导<code>1</code>的数量，将相应数量的前导零添加到解码结果中。</li><li><strong>转换为二进制数据</strong>：将大整数转换回二进制数据，得到原始数据。</li></ol><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE58_ALPHABET = <span class="hljs-string">&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span>;<br><br><span class="hljs-comment">// 辅助函数：将字节数组解释为大整数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">toBigInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(input.begin(), input.end())</span></span>;<br>    <span class="hljs-keyword">return</span> bigInt;<br>&#125;<br><br><span class="hljs-comment">// Base58 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; digits;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; bigInt = <span class="hljs-built_in">toBigInt</span>(input);<br><br>    <span class="hljs-comment">// 跳过前导的0字节</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte : bigInt) &#123;<br>        <span class="hljs-keyword">if</span> (byte == <span class="hljs-number">0</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将大整数转为Base58编码</span><br>    <span class="hljs-keyword">while</span> (!bigInt.<span class="hljs-built_in">empty</span>() &amp;&amp; *std::<span class="hljs-built_in">max_element</span>(bigInt.<span class="hljs-built_in">begin</span>(), bigInt.<span class="hljs-built_in">end</span>()) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = carry * <span class="hljs-number">256</span> + byte;<br>            byte = value / <span class="hljs-number">58</span>;<br>            carry = value % <span class="hljs-number">58</span>;<br>        &#125;<br>        digits.<span class="hljs-built_in">push_back</span>(carry);<br>    &#125;<br><br>    <span class="hljs-comment">// 将前导0字节编码为Base58的`1`字符</span><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;1&#x27;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 反转余数得到的Base58编码</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = digits.<span class="hljs-built_in">rbegin</span>(); it != digits.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += BASE58_ALPHABET[*it];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Base58 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-type">size_t</span> index = BASE58_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base58 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> carry = index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = byte * <span class="hljs-number">58</span> + carry;<br>            carry = value &gt;&gt; <span class="hljs-number">8</span>;<br>            byte = value &amp; <span class="hljs-number">0xFF</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (carry) &#123;<br>            bigInt.<span class="hljs-built_in">push_back</span>(carry &amp; <span class="hljs-number">0xFF</span>);<br>            carry &gt;&gt;= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理前导的&#x27;1&#x27;字符</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = bigInt.<span class="hljs-built_in">rbegin</span>(); it != bigInt.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(*it);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase58</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase58</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>Base64是一种广泛使用的编码方式，将二进制数据转换为可打印的ASCII字符。它常用于在需要将二进制数据嵌入到文本格式中时（如在电子邮件、URL、JSON等）。Base64将每3字节的二进制数据编码为4个ASCII字符，使得编码后的数据长度增加约33%。Base64字符集包括<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>、<code>+</code>、<code>/</code>和<code>=</code>（作为填充字符）。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每3字节（24位）的一组，如果数据长度不足3字节，则使用填充字符<code>=</code>进行填充，以确保处理的字节数为3的倍数。</li><li><strong>转换为6位组</strong>：将每组24位二进制数据分成4组6位的二进制数。</li><li><strong>映射字符</strong>：使用Base64字符集将每6位二进制数据映射为一个Base64字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base64字符和填充字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base64编码后的字符串，并去除填充字符<code>=</code>。</li><li><strong>字符映射</strong>：将每个Base64字符转换为对应的6位二进制值。</li><li><strong>组合处理</strong>：将这些6位二进制值重新组合成24位的二进制数据。</li><li><strong>分解字节</strong>：将24位二进制数据分解为3个字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE64_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;<br><br><span class="hljs-comment">// Base64 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output; <span class="hljs-comment">// 存储编码后的输出字符串</span><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于存储当前处理的字符值</span><br>    <span class="hljs-type">int</span> bits = <span class="hljs-number">-6</span>; <span class="hljs-comment">// 当前处理的位数，初始化为 -6，因为我们要填充 6 位的 Base64 字符</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b63 = <span class="hljs-number">0x3F</span>; <span class="hljs-comment">// 64 的二进制数（111111），用于获取 Base64 字符</span><br><br>    <span class="hljs-comment">// 遍历输入字符串的每一个字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        val = (val &lt;&lt; <span class="hljs-number">8</span>) + c; <span class="hljs-comment">// 将当前字符的 ASCII 值添加到 val 中，左移 8 位</span><br>        bits += <span class="hljs-number">8</span>; <span class="hljs-comment">// 增加已处理的位数</span><br><br>        <span class="hljs-comment">// 当处理的位数大于等于 0 时，进行编码</span><br>        <span class="hljs-keyword">while</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从 val 中提取出高 6 位，并查找对应的 Base64 字符</span><br>            output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[(val &gt;&gt; bits) &amp; b63]);<br>            bits -= <span class="hljs-number">6</span>; <span class="hljs-comment">// 每次处理 6 位，减少 bits 的值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位，如果还有剩余的 bits &gt; -6，则需要继续编码</span><br>    <span class="hljs-keyword">if</span> (bits &gt; <span class="hljs-number">-6</span>) &#123;<br>        <span class="hljs-comment">// 将剩余的位向左移动并提取对应的 Base64 字符</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[((val &lt;&lt; <span class="hljs-number">8</span>) &gt;&gt; (bits + <span class="hljs-number">8</span>)) &amp; b63]);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 output 的大小不是 4 的倍数，则添加 &#x27;=&#x27; 作为填充</span><br>    <span class="hljs-keyword">while</span> (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">4</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 添加填充字符 &#x27;=&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output; <span class="hljs-comment">// 返回编码后的 Base64 字符串</span><br>&#125;<br><br><br><span class="hljs-comment">// Base64 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>        T[BASE64_ALPHABET[i]] = i;<br>    &#125;<br><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>, bits = <span class="hljs-number">-8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        <span class="hljs-keyword">if</span> (T[c] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>        val = (val &lt;&lt; <span class="hljs-number">6</span>) + T[c];<br>        bits += <span class="hljs-number">6</span>;<br><br>        <span class="hljs-keyword">if</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">char</span>((val &gt;&gt; bits) &amp; <span class="hljs-number">0xFF</span>));<br>            bits -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase64</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    std::string decoded = <span class="hljs-built_in">decodeBase64</span>(encoded);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base85编码"><a href="#Base85编码" class="headerlink" title="Base85编码"></a>Base85编码</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>Base85是一种用于将二进制数据转换为可打印字符的编码方案。它通过使用85个不同的ASCII字符来表示每4字节（32位）的二进制数据。这种编码方式常用于需要将二进制数据嵌入文本中的场景，如在PDF文件中。相比于Base64，Base85编码能够以更高的效率将数据压缩成更短的字符串，因为每4字节的二进制数据在Base85中编码为5个字符。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每4字节（32位）的组，如果数据长度不足4字节，则进行填充。</li><li><strong>转换为整数</strong>：将每4字节的二进制数据转换为一个32位的整数。</li><li><strong>映射字符</strong>：将32位整数转换为5个Base85字符。具体来说，整数被逐步除以85，得到的余数对应Base85字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base85字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base85编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base85字符转换为Base85字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个32位的整数。</li><li><strong>分解字节</strong>：将32位整数转换回4字节（32位）的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE85_ALPHABET = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&amp;()*+-;&lt;=&gt;?@^_`&#123;|&#125;~&quot;</span>;<br><br><span class="hljs-comment">// Base85 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        buffer = buffer * <span class="hljs-number">256</span> + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(input[i]);<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>                buffer /= <span class="hljs-number">85</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">end</span>());<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        buffer &lt;&lt;= (<span class="hljs-number">4</span> - count) * <span class="hljs-number">8</span>;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>            buffer /= <span class="hljs-number">85</span>;<br>        &#125;<br>        output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">begin</span>() + count + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base85 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE85_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base85 character&quot;</span>);<br>        &#125;<br>        buffer = buffer * <span class="hljs-number">85</span> + pos;<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>            &#125;<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = count; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>            buffer = buffer * <span class="hljs-number">85</span> + <span class="hljs-number">84</span>;  <span class="hljs-comment">// 用最大值填充</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">4</span> - count; --j) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase85</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase85</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base91编码"><a href="#Base91编码" class="headerlink" title="Base91编码"></a>Base91编码</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>Base91是一种编码方案，用于将二进制数据转换为可打印的ASCII字符。它使用91个字符来表示每13位的二进制数据。Base91设计的目的是在保证编码效率的同时，提供更好的数据密度比Base64和Base85。Base91编码通常用于需要高数据密度的应用场景，例如某些压缩算法和数据传输协议。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每13位（即1.625字节）的组。由于13位并不整除8位字节，因此每个Base91编码块处理的字节数可能会有所不同。</li><li><strong>转换为整数</strong>：将每组13位的二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：将这个整数转换为Base91字符。整数会被逐步除以91，得到的余数对应Base91字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base91字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base91编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base91字符转换为Base91字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个13位的二进制整数。</li><li><strong>分解字节</strong>：将13位的二进制整数转换回原始的字节数据。这可能涉及到将整数拆分为多个字节（通常是2或3个字节）。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base91 字符集</span><br><span class="hljs-type">const</span> std::string BASE91_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span><br>                                    <span class="hljs-string">&quot;!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`&#123;|&#125;~\&quot;&quot;</span>;<br><br><span class="hljs-comment">// Base91 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer |= (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(c) &lt;&lt; bitsLeft);<br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-type">uint32_t</span> value = buffer &amp; <span class="hljs-number">8191</span>;  <span class="hljs-comment">// 取13位</span><br>            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">88</span>) &#123;                <span class="hljs-comment">// 处理特殊情况</span><br>                buffer &gt;&gt;= <span class="hljs-number">13</span>;<br>                bitsLeft -= <span class="hljs-number">13</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                value = buffer &amp; <span class="hljs-number">16383</span>;      <span class="hljs-comment">// 取14位</span><br>                buffer &gt;&gt;= <span class="hljs-number">14</span>;<br>                bitsLeft -= <span class="hljs-number">14</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value % <span class="hljs-number">91</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余不足13位的部分</span><br>    <span class="hljs-keyword">if</span> (bitsLeft) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer % <span class="hljs-number">91</span>]);<br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">7</span> || buffer &gt; <span class="hljs-number">90</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base91 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE91_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base91 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>            value = pos;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            value += pos * <span class="hljs-number">91</span>;<br>            buffer |= value &lt;&lt; bitsLeft;<br>            bitsLeft += (value &amp; <span class="hljs-number">8191</span>) &gt; <span class="hljs-number">88</span> ? <span class="hljs-number">13</span> : <span class="hljs-number">14</span>;<br><br>            <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>                output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);<br>                buffer &gt;&gt;= <span class="hljs-number">8</span>;<br>                bitsLeft -= <span class="hljs-number">8</span>;<br>            &#125;<br>            value = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位</span><br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(buffer | (value &lt;&lt; bitsLeft));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase91</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase91</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base100编码"><a href="#Base100编码" class="headerlink" title="Base100编码"></a>Base100编码</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>Base100是一种用于将二进制数据转换为可打印字符的编码方案。它使用100个不同的字符来表示每16位的二进制数据。这种编码方式在字符集选择上较为宽松，通常选择可打印的ASCII字符。Base100的设计旨在提供比Base64和Base85更高的数据密度，使得编码后的数据更为紧凑。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每16位（即2字节）的组。如果数据长度不足2字节，则进行填充。</li><li><strong>转换为整数</strong>：将每16位的二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：将这个整数转换为Base100字符。整数会被逐步除以100，得到的余数对应Base100字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base100字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base100编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base100字符转换为Base100字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个16位的二进制整数。</li><li><strong>分解字节</strong>：将16位的二进制整数转换回原始的字节数据，通常是2个字节（或1个字节的填充情况）。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base100 字符集 (ASCII 范围: 33-132)</span><br><span class="hljs-type">const</span> std::string BASE100_ALPHABET = <span class="hljs-string">&quot; !\&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;</span><br>                                     <span class="hljs-string">&quot;€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ&quot;</span>;<br><br><span class="hljs-comment">// Base100 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer = (buffer &lt;&lt; <span class="hljs-number">8</span>) | c;<br>        count++;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">2</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 填充一个字节</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base100 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 input length.&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> index1 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-type">int</span> index2 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i + <span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">if</span> (index1 == std::string::npos || index2 == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 character.&quot;</span>);<br>        &#125;<br><br>        buffer = index1 * <span class="hljs-number">100</span> + index2;<br>        output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 高字节</span><br>        output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);         <span class="hljs-comment">// 低字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase100</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase100</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/0yst3r-2046/p/11962942.html">Base系列编码浅析【base16 base32 base64 base85 base36 base 58 base91 base 92 base62】 - 0yst3r - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.equinox.chat/archives/45/">Base系列编码详解 - 二进制学习 (equinox.chat)</a></p><p><a href="https://blog.csdn.net/m0_62690279/article/details/123941239">常见加密算法总结-base系列部分_base加密-CSDN博客</a></p><p><a href="https://danielxuuuuu.github.io/2019/11/18/MD5%E7%AE%97%E6%B3%95%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84">MD5算法的C语言实现 · Daniel’s Studio (danielxuuuuu.github.io)</a></p><p><a href="https://www.cnblogs.com/foxclever/p/7668369.html">信息摘要算法之一：MD5算法解析及实现 - Moonan - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/450180396">RSA —— 经典的非对称加密算法 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/78913397">密码学基础：AES加密算法 - 知乎 (zhihu.com)</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二） - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>[RSA算法详解 - 飞翔的大熊 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA算法流程</a> 1 生成秘钥 选择两个不相等的质数p%2Cq 计算p%2Cq的乘积n 计算n的欧拉函数φ (n)%3D (p-1)*,根据上面的公式可以算出密文C 解密 接收方获取密文c，使用自己的私钥 (n%2Cd)依照如下公式解密 c^d%3Dm (mod n) c%2Cd%2Cn已知，可以算出明文m)</p><p><a href="https://blog.csdn.net/s2603898260/article/details/122389816">RSA 算法图解+数学证明_rsa算法流程图-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/98514678">AES加密算法流程介绍 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/TheSkyLee/article/details/108699243">一文彻底搞懂加密、数字签名和数字证书，看不懂你打我！-CSDN博客</a></p><p><a href="https://blog.csdn.net/xiao__1bai/article/details/123307059">解析 TEA 加密算法(C语言、python)：_tea加密-CSDN博客</a></p><p><a href="https://www.cnblogs.com/shelmean/p/14281332.html">RC4加密算法 - shelmean - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV1c34y1M7NW/?spm_id_from=333.999.0.0">HMAC | MAC | 基于哈希函数的消息认证码</a></p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能(主从复制-哨兵-集群)</title>
    <link href="/2023/07/02/%E9%AB%98%E6%80%A7%E8%83%BD(%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5-%E9%9B%86%E7%BE%A4)-Redis/"/>
    <url>/2023/07/02/%E9%AB%98%E6%80%A7%E8%83%BD(%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5-%E9%9B%86%E7%BE%A4)-Redis/</url>
    
    <content type="html"><![CDATA[<blockquote><p>具体过程可参考这些前辈的博客，已经总结很详细了：</p><p>主从复制</p><p><a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD">主从复制是怎么实现的？ | 小林coding</a></p><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/3.Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87-01-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html">Redis-高可用篇-①主从复制 | 一人の境</a></p><p>哨兵模式：</p><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/3.Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87-02-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.html">Redis-高可用篇-②哨兵模式 | 一人の境</a></p><p><a href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6">为什么要有哨兵？ | 小林coding</a></p><p>集群模式：</p><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/3.Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87-03-%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4.html">Redis-高可用篇-③切片集群 | 一人の境</a></p><p><a href="https://segmentfault.com/a/1190000039995230">redis集群 - Redis 高可用篇：Cluster 集群能支持的数据量有多大？ - Redis - SegmentFault 思否</a></p><p>本文仅是解决和收集自己在Redis高可用学习过程中产生的疑问和思考。</p></blockquote><h1 id="Redis高可用的整体架构构成是什么？"><a href="#Redis高可用的整体架构构成是什么？" class="headerlink" title="Redis高可用的整体架构构成是什么？"></a>Redis高可用的整体架构构成是什么？</h1><p>单机架构中，所有的数据都集中在一台服务器上，这样如果该服务器发生故障，整个服务将不可用。</p><p>所以Redis引入了<em><strong>主从复制</strong></em>。</p><p> 在Redis的主从架构中，由于主从模式是读写分离的，如果主节点挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点进行数据同步了。</p><p>那么该如何该自动选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。</p><p>为此Redis引入了<em><strong>哨兵机制</strong></em>，其核心作用是实现<strong>自动故障转移</strong>，保障系统的高可用性。</p><p>随着业务规模的拓展，数据量越来越大。Redis 会 Fork 子进程完成 RDB 持久化操作，fork 执行的耗时与 Redis 数据量成正相关。而 Fork 执行的时候会阻塞主线程，由于数据量过大导致阻塞主线程过长，所以出现了 Redis 响应慢等现象。那么为了保存大量数据，除了使用大内存主机的方式，还有什么方式呢？</p><p>为此使用 Redis 引入了<strong>Cluster 集群</strong>，主要解决了大数据量存储导致的各种慢问题，同时也便于横向拓展。</p><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="主从复制的整体流程？"><a href="#主从复制的整体流程？" class="headerlink" title="主从复制的整体流程？"></a>主从复制的整体流程？</h2><h3 id="全量复制-第一次同步"><a href="#全量复制-第一次同步" class="headerlink" title="全量复制(第一次同步)"></a>全量复制(第一次同步)</h3><p><img src="https://s2.loli.net/2025/01/07/ZUVlmAiPfwdF1g9.jpg" alt="851491-20210514205905608-1963479128"></p><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>在上图中的第7步，主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p><p><img src="https://s2.loli.net/2025/01/07/DObuPJTqHL2dxhj.png" alt="image-20250107191226725"></p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用<strong>增量复制</strong>的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p><p><img src="https://s2.loli.net/2025/01/07/tp54faAjvZLP1Ym.jpg" alt="OIP-C (1)"></p><p>注意：<strong>replication offset</strong>，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「<em>写</em>」到的位置，从服务器使用 slave_repl_offset 来记录自己「<em>读</em>」到的位置。</p><p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p><ul><li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</li><li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式；</li></ul><p> 当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会<strong>将增量的数据写入到 replication buffer 缓冲区</strong>，用于缓存将要传播给从服务器的命令。</p><h3 id="分摊主服务器压力"><a href="#分摊主服务器压力" class="headerlink" title="分摊主服务器压力"></a>分摊主服务器压力</h3><p>主从服务器在第一次数据同步的过程中，主服务器会做两件耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：</p><ul><li>创建RDB文件本身是个异步操作，但是如果通过 bgsave 命令来生成 RDB 文件，则主服务器会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；</li><li>传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响；</li></ul><p>Redis 的从服务器也可以有自己的从服务器，可以将某个从服务器设置为“经理角色的从服务器”，<strong>主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器</strong></p><p><img src="https://s2.loli.net/2025/01/07/AK3m4RnrJz9WjPf.png" alt="image-20250107192000560"></p><h1 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h1><blockquote><p><strong>哨兵节点之间是通过 Redis 的发布者&#x2F;订阅者机制来相互发现的</strong>。</p></blockquote><h2 id="哨兵模式的整体流程"><a href="#哨兵模式的整体流程" class="headerlink" title="哨兵模式的整体流程"></a>哨兵模式的整体流程</h2><h3 id="监控主从节点"><a href="#监控主从节点" class="headerlink" title="监控主从节点"></a>监控主从节点</h3><p>哨兵通过 <code>SENTINEL MONITOR</code> 命令监控指定的 Redis 主节点（即主节点的 IP 和端口）。哨兵不断检查主节点和从节点的健康状态。</p><p>哨兵会定期向主节点和从节点发送 <code>PING</code> 请求，以检测节点是否正常工作。</p><p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p><p><img src="https://s2.loli.net/2025/01/07/Wr3Uhgixb8PJseG.png" alt="image-20250107193228030"></p><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>在监控主从节点中，当前的哨兵只是标记了主观下线，但可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p><p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>（<em>最少需要三台机器来部署哨兵集群</em>），<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</strong>。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p><p>一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应</p><p><img src="https://s2.loli.net/2025/01/07/vRmpGLxCoBuYasn.png" alt="image-20250107193834085"></p><p>当这个哨兵的赞同票数达到哨兵配置文件中的 <code>quorum </code>配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。quorum 的值一般设置为哨兵个数的二分之一加 1（例如 3 个哨兵就设置 2）</p><h4 id="选取哨兵-leader"><a href="#选取哨兵-leader" class="headerlink" title="选取哨兵 leader"></a>选取哨兵 leader</h4><p>总结来说就是： </p><h5 id="1-候选者出现"><a href="#1-候选者出现" class="headerlink" title="1. 候选者出现"></a>1. <strong>候选者出现</strong></h5><ul><li>被标记为 <strong>客观下线</strong> 的主节点意味着已经确认故障，接下来会有一个 <strong>候选者</strong>（希望成为 Leader 的哨兵）发起选举。</li><li>以 <strong>哨兵 B</strong> 为例，<strong>哨兵 B</strong> 在主节点故障确认后，会自动成为候选者，试图成为新的故障转移 Leader。</li></ul><h5 id="2-投票机制（选举过程）"><a href="#2-投票机制（选举过程）" class="headerlink" title="2. 投票机制（选举过程）"></a>2. <strong>投票机制（选举过程）</strong></h5><ul><li>每个哨兵只有 <strong>一次投票机会</strong>，并且只能投给一个候选者。哨兵可以投给自己，也可以投给其他候选者。</li><li>哨兵 B 作为候选者，会向其他哨兵发起投票请求，表明自己希望成为 Leader。</li><li>其他哨兵接收到投票请求后，如果没有用完投票机会，会根据自己的判断投票给 <strong>候选者 B</strong> 或 <strong>候选者 A</strong>（如果出现多个候选者）。</li><li><strong>投票规则</strong>：<ul><li>哨兵必须 <strong>拿到半数以上的赞成票</strong>。</li><li>哨兵必须获得的赞成票数 <strong>大于等于 quorum 设置值</strong>。</li></ul></li></ul><h5 id="3-选举胜者"><a href="#3-选举胜者" class="headerlink" title="3. 选举胜者"></a>3. <strong>选举胜者</strong></h5><ul><li>如果有多个候选者（例如 <strong>哨兵 A</strong> 和 <strong>哨兵 B</strong>），会有竞争的情况。每个候选者会先给自己投一票，然后开始向其他哨兵请求投票。</li><li>哨兵收到投票请求后，如果还没投票，按照收到的顺序投票。每个哨兵只能投一次票，因此谁先达到条件，谁就胜出。</li><li>选举成功的候选者成为 <strong>Leader</strong>，也就是故障转移的执行者，负责执行主从切换操作。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>在哨兵集群中通过投票的方式，选举出了哨兵 leader 后，就可以进行主从故障转移的过程</p><p><img src="https://s2.loli.net/2025/01/07/DaHzjQZqLPkY15i.png" alt="image-20250107194933176"></p><h4 id="主从故障转移步骤"><a href="#主从故障转移步骤" class="headerlink" title="主从故障转移步骤"></a>主从故障转移步骤</h4><ul><li>【步骤1】：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点；</li><li>【步骤2】：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li><li>【步骤3】：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li><li>【步骤4】：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li></ul><p>具体参考：<a href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">为什么要有哨兵？ | 小林coding</a></p><h1 id="Redis切片集群"><a href="#Redis切片集群" class="headerlink" title="Redis切片集群"></a>Redis切片集群</h1><p><strong>Redis Cluster 集群</strong>属于<strong>水平扩展</strong>(横向扩展)</p><p><img src="https://s2.loli.net/2025/01/07/dCLwMYEKt7ZXcDb.png" alt="image-20250107195607264"></p><p> 在基于此大数据量存储场景下，引入Redis 的切片集群概念（虽然组建切片集群比较麻烦，但是它可以保存大量数据，而且对 Redis 主线程的阻塞影响较小）。切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。</p><p> 基于上述场景，可以把 25GB 的数据平均分成 5 份（也可以不做均分，可结合实际服务器资源进行调整），使用 5 个实例来保存，每个实例只需要保存 5GB 数据。</p><p><img src="https://s2.loli.net/2025/01/07/46usTPcVABNRbWo.png" alt="image-20250107195735133"></p><h2 id="Cluster-实现原理"><a href="#Cluster-实现原理" class="headerlink" title="Cluster 实现原理"></a>Cluster 实现原理</h2><h3 id="集群的组群过程"><a href="#集群的组群过程" class="headerlink" title="集群的组群过程"></a>集群的组群过程</h3><p> 集群是由一个个互相独立的节点（readis node）组成的， 一开始他们都是隔离、毫无联系的。需要通过一些操作，把这些节点聚集在一起，才能组成真正的可协调工作的集群。各个节点的联通是通过 CLUSTER MEET 命令完成的：<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>  做法：其中一个node向另外一个 node（指定 ip 和 port） 发送 CLUSTER MEET 命令，让两个节点进行握手（handshake操作） ，握手成功之后，node 节点就会将握手另一侧的节点添加到当前节点所在的集群中。以此类推，一步步的将需要聚集的节点都圈入同一个集群中</p><p><img src="https://s2.loli.net/2025/01/07/DsyceAIEPqz9ZnT.png" alt="image-20240722183523813.5685df14"></p><h3 id="集群数据分片原理"><a href="#集群数据分片原理" class="headerlink" title="集群数据分片原理"></a>集群数据分片原理</h3><p>Redis 集群使用 <strong>哈希槽（hash slots）</strong> 来分配数据。整个 Redis 集群包含 <strong>16384 个哈希槽</strong>，每个哈希槽可以存储多个键（key）。每个键在 Redis 集群中都会通过一个哈希算法映射到 16384 个槽中的一个槽。</p><ul><li><strong>哈希槽分配</strong>：Redis 使用一致性哈希算法来将数据分布到不同的节点上。每个节点负责处理一定数量的哈希槽，通常是均匀分配的。</li><li><strong>键值映射</strong>：当客户端向集群插入一个键值对时，首先通过一个哈希函数计算该键的哈希值，然后将哈希值映射到 16384 个哈希槽中的某一个槽。最终，数据会存储在负责该哈希槽的节点上。</li></ul><p>Redis 集群通常由多个节点组成，包括 <strong>主节点</strong> 和 <strong>从节点</strong>：</p><ul><li><strong>主节点（Master Node）</strong>：每个主节点负责一部分哈希槽的数据存储。主节点处理所有的读写操作。</li><li><strong>从节点（Slave Node）</strong>：每个从节点负责一个主节点的备份，用于数据同步和故障转移。</li></ul><p>集群中的每个节点都持有一部分数据的哈希槽，且主节点和从节点之间会进行 <strong>数据同步</strong>。</p><p><img src="https://s2.loli.net/2025/01/07/FHxUi6dnGBeZOg8.png" alt="e66ca4431d3b41ea9ed7bfa4be55c140"></p><blockquote><p><strong>当 16384 个槽都分配完全，Redis 集群才能正常工作</strong>。</p></blockquote><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis 集群通过 <strong>集群协议</strong>（Cluster Protocol）进行节点间的通信。每个节点都维护着集群的拓扑信息，并定期与其他节点交换信息，确保每个节点都知道其他节点的状态和数据分布情况。</p><ul><li><strong>节点间通信</strong>：节点之间通过 <code>PUBLISH/SUBSCRIBE</code> 模式相互通信，用于同步数据、传递故障转移信息等。</li><li><strong>集群状态</strong>：每个节点都会知道哪些哈希槽分配给了哪些节点，以及各个节点的状态（如是否健康，是否是主节点，是否有从节点等）。</li></ul><p>Redis 集群有内置的 <strong>故障转移机制</strong>，如果某个主节点发生故障，集群会通过以下步骤进行恢复：</p><ul><li>哨兵通过节点之间的通信，发现主节点失效后，集群会选举一个从节点作为新的主节点。</li><li>故障转移过程中，客户端可以继续向其他节点发起请求，而不会影响集群的正常运作。</li><li>故障转移完成后，新的主节点会开始接受写请求，且旧的主节点会作为新的从节点，加入集群进行数据同步。</li></ul><blockquote><p>关于 <code>Gossip</code> 协议可阅读文章：《<a href="https://link.segmentfault.com/?enc=0xe60mofWrcztBuMCgV5WQ==.eN57kH+XzA3D4Hg4XKvqTuDDI1kShhA8aGguIhzQ3H52XDNKalQHog8aLD0nfPtIiSZ/PoBxsbN8SPXKNS8+qg==">病毒入侵，全靠分布式</a>》</p></blockquote><p>具体参考：<a href="https://segmentfault.com/a/1190000039995230#item-5-4">redis集群 - Redis 高可用篇：Cluster 集群能支持的数据量有多大？ - Redis - SegmentFault 思否</a></p><h3 id="客户端如何定位数据所在实例"><a href="#客户端如何定位数据所在实例" class="headerlink" title="客户端如何定位数据所在实例"></a>客户端如何定位数据所在实例</h3><p>当客户端向集群发送请求时，首先会连接到集群中的一个节点。该节点会检查请求的哈希槽，并将请求路由到负责该槽的节点。</p><p><img src="https://s2.loli.net/2025/01/07/Vgo5viSdNbcOQnL.png" alt="image-20250107202921902"></p><h4 id="重新分配哈希槽"><a href="#重新分配哈希槽" class="headerlink" title="重新分配哈希槽"></a>重新分配哈希槽</h4><p>如果客户端访问的节点不是请求数据所在槽的节点，它会返回一个 <strong>MOVED</strong> 错误，并附带正确的目标节点信息。客户端接收到这个错误后，会重新向目标节点发送请求。</p><p><strong>节点定位</strong>：每个 Redis 节点会持有一部分哈希槽，因此客户端只需要找到负责某个哈希槽的节点即可。</p><p><strong>获取节点信息</strong>：客户端首次连接到集群中的任意节点后，该节点会向客户端返回集群的拓扑信息，包括每个节点的 IP 地址、端口号及其负责的哈希槽范围。</p><ul><li><strong>MOVED 错误</strong>：如果客户端请求的键并不在当前节点负责的哈希槽上，该节点会返回一个 <strong>MOVED</strong> 错误，并附带目标节点的地址信息。</li><li>客户端收到 <strong>MOVED</strong> 错误后，会自动重新发起请求，连接目标节点，继续处理请求。</li></ul><p>客户端会根据 <strong>MOVED 错误</strong> 中提供的目标节点信息，自动重定向到正确的 Redis 实例。</p><p>通过这种方式，客户端不需要手动管理集群拓扑，而是由 Redis 集群节点和客户端自动协作，确保请求能够被路由到正确的节点。</p><p><img src="https://s2.loli.net/2025/01/07/lLZSufhz7MkxBcE.png" alt="image-20250107203706675"></p><h4 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h4><p>在 Redis 集群中，当某个哈希槽的数据正在迁移（从一个实例迁移到另一个实例），客户端在访问该哈希槽的数据时，可能会遇到 <strong>ASK 错误</strong>。这种情况通常发生在 <strong>哈希槽部分迁移</strong> 的过程中。</p><h5 id="哈希槽部分迁移的场景"><a href="#哈希槽部分迁移的场景" class="headerlink" title="哈希槽部分迁移的场景"></a><strong>哈希槽部分迁移的场景</strong></h5><ul><li><strong>哈希槽迁移的过程</strong>：Redis 集群支持通过 <strong><code>CLUSTER MIGRATE</code></strong> 命令将数据从一个节点迁移到另一个节点。当一个哈希槽的数据量变大，或者为了负载均衡，Redis 集群会将某些哈希槽的数据迁移到新的节点。</li><li>部分迁移的情况在迁移过程中，目标哈希槽的数据会逐步迁移。如果客户端此时访问该哈希槽的某些键，可能会出现以下两种情况：<ul><li><strong>部分迁移完成</strong>：一部分数据已被迁移到新节点，另一部分仍在原节点。</li><li><strong>请求的键在迁移中</strong>：请求的键对应的哈希槽正在迁移过程中，部分数据可能已经移动，而部分数据还在原节点。</li></ul></li></ul><p>在这种情况下，如果客户端向当前节点发起请求，Redis 会返回 <strong>ASK 错误</strong>，提示客户端键所在的哈希槽正在迁移，并要求客户端向新的节点继续请求数据。</p><h5 id="ASK-错误的响应过程"><a href="#ASK-错误的响应过程" class="headerlink" title="ASK 错误的响应过程"></a><strong>ASK 错误的响应过程</strong></h5><ol><li><strong>请求被当前节点处理时</strong>：<ul><li>当客户端请求的键对应的哈希槽正在从一个实例迁移到另一个实例时，如果数据还没有完全迁移，客户端会接收到一个 <strong>ASK</strong> 错误。</li><li><strong>ASK 错误格式</strong>：<code>ASK &lt;slot&gt; &lt;node_id&gt;</code>，其中 <code>&lt;slot&gt;</code> 是哈希槽号，<code>&lt;node_id&gt;</code> 是迁移目标节点的 ID（即数据迁移到的目标节点）。</li></ul></li><li><strong>客户端的处理步骤</strong>：<ul><li>客户端收到 <code>ASK</code> 错误后，会先向目标节点发送一个 <strong><code>ASKING</code></strong> 命令，告知目标节点它知道当前哈希槽的数据正在迁移，并希望继续发送命令。</li><li><strong>ASKING 命令</strong>：<code>ASKING</code> 命令是一个特殊命令，告诉目标节点客户端在之前遇到 <code>ASK</code> 错误，并希望继续与目标节点交互。</li></ul></li><li><strong>继续发送命令</strong>：<ul><li>在发送完 <code>ASKING</code> 命令后，客户端可以继续向目标节点发送原本的操作命令（如 <code>GET</code> 或 <code>SET</code>）。</li></ul></li><li><strong>迁移完成后的情况</strong>：<ul><li>一旦迁移完成，客户端就可以直接访问目标节点，不再需要处理 <code>ASK</code> 错误。</li></ul></li></ol><p>假设 Redis 集群中的某个哈希槽正在迁移：</p><ol><li><p><strong>原节点响应 ASK 错误</strong>：</p><ul><li><p>假设客户端尝试获取键 <code>&quot;user:1000&quot;</code>，该键被哈希到哈希槽 <code>500</code>。</p></li><li><p>此时，哈希槽 <code>500</code> 正在从实例 A 迁移到实例 B。</p></li><li><p>客户端向实例 A 发送请求，实例 A 响应一个 ASK 错误</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ASK</span> <span class="hljs-number">500</span> <span class="hljs-number">192.168.1.2:6379</span><br></code></pre></td></tr></table></figure></li><li><p>这意味着，哈希槽 <code>500</code> 的数据正在迁移到 <code>192.168.1.2:6379</code>（实例 B）。</p></li></ul></li><li><p><strong>客户端发送 ASKING 命令</strong>：</p><ul><li><p>客户端接收到 ASK错误后，自动向实例 B 发送 ASKING命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ASKING</span><br></code></pre></td></tr></table></figure></li><li><p>该命令表明客户端知道当前键所在的哈希槽正在迁移，并且希望向目标节点实例 B 发送请求。</p></li></ul></li><li><p><strong>继续操作命令</strong>：</p><ul><li>客户端继续向实例 B 发送实际的命令（如 <code>GET user:1000</code>）。</li><li>实例 B 将正常响应该命令，返回对应的数据。</li></ul></li><li><p><strong>迁移完成</strong>：</p><ul><li>一旦迁移完成，客户端直接访问目标节点（如实例 B），不再需要处理 <code>ASK</code> 错误。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DEX文件解析器编写</title>
    <link href="/2023/06/28/DEX%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/06/28/DEX%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="纸上得来终觉浅"><a href="#纸上得来终觉浅" class="headerlink" title="纸上得来终觉浅"></a>纸上得来终觉浅</h1><h2 id="DEX的由来"><a href="#DEX的由来" class="headerlink" title="DEX的由来"></a>DEX的由来</h2><table><thead><tr><th><strong>阶段</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>Java与移动设备的限制</strong></td><td>标准的Java字节码（JVM字节码）在移动设备上运行效率低，尤其在内存和处理器资源受限的环境中。</td></tr><tr><td><strong>Dalvik虚拟机的诞生</strong></td><td>为了解决性能问题，Android团队开发了Dalvik虚拟机（DVM），用于替代标准的Java虚拟机（JVM），专为移动设备优化。</td></tr><tr><td><strong>DEX文件格式</strong></td><td>DEX文件（Dalvik Executable）是Dalvik虚拟机的字节码格式，采用了紧凑的编码方式，多个类文件被合并成一个DEX文件，优化内存和存储效率。</td></tr><tr><td><strong>优化特性</strong></td><td>1. 紧凑的字节码格式，减少内存占用。  2. 多个类文件合并为一个DEX文件，减少I&#x2F;O操作。  3. 内存管理优化，适应移动设备资源限制。</td></tr><tr><td><strong>ART虚拟机的演变</strong></td><td>从Android 5.0开始，Dalvik虚拟机被Android Runtime（ART）替代，ART优化了应用的执行速度，但仍支持DEX文件格式，直接运行或将其转换为更高效的运行时格式。</td></tr></tbody></table><h2 id="DEX整体结构"><a href="#DEX整体结构" class="headerlink" title="DEX整体结构"></a>DEX整体结构</h2><p>如下图所示：</p><p><img src="https://s2.loli.net/2024/12/23/oNDh3e9lQ1d8FAU.png" alt="dex文件结构"></p><h2 id="以案例看DEX"><a href="#以案例看DEX" class="headerlink" title="以案例看DEX"></a>以案例看DEX</h2><h4 id="Java-类-Person-例子："><a href="#Java-类-Person-例子：" class="headerlink" title="Java 类 Person 例子："></a>Java 类 <code>Person</code> 例子：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DEX-文件中的各部分结构与对应的示例："><a href="#DEX-文件中的各部分结构与对应的示例：" class="headerlink" title="DEX 文件中的各部分结构与对应的示例："></a>DEX 文件中的各部分结构与对应的示例：</h3><h5 id="1-文件头部（Header）"><a href="#1-文件头部（Header）" class="headerlink" title="1. 文件头部（Header）"></a>1. <strong>文件头部（Header）</strong></h5><ul><li><strong>magic</strong>：标识 DEX 文件版本，例如 <code>0x64 65 78 0a 30 33 35 00</code> 表示 “dex\n035\0”。</li><li><strong>file_size</strong>：表示整个 DEX 文件的大小。</li><li><strong>string_ids_size</strong>、<strong>string_ids_off</strong>：字符串标记的数量和偏移位置。</li><li><strong>type_ids_size</strong>、<strong>type_ids_off</strong>：类型标记的数量和偏移位置。</li><li><strong>method_ids_size</strong>、<strong>method_ids_off</strong>：方法标记的数量和偏移位置。</li><li><strong>class_defs_size</strong>、<strong>class_defs_off</strong>：类定义的数量和偏移位置。</li></ul><h5 id="2-字符串标记（String-IDs）"><a href="#2-字符串标记（String-IDs）" class="headerlink" title="2. 字符串标记（String IDs）"></a>2. <strong>字符串标记（String IDs）</strong></h5><p><code>String IDs</code> 表存储了所有字符串，例如类名、字段名、方法名等。每个 <code>String ID</code> 表项指向字符串数据的偏移地址。对于 <code>Person</code> 类的例子：</p><ul><li><code>&quot;Person&quot;</code>：表示类名。</li><li><code>&quot;name&quot;</code>：表示字段名称。</li><li><code>&quot;age&quot;</code>：表示字段名称。</li><li><code>&quot;getName&quot;</code>、<code>&quot;setName&quot;</code>：表示方法名称。</li><li><code>&quot;getAge&quot;</code>、<code>&quot;setAge&quot;</code>：表示方法名称。</li><li><code>&quot;Ljava/lang/String;&quot;</code>：表示 <code>String</code> 类型的描述符。</li><li><code>&quot;I&quot;</code>：表示 <code>int</code> 类型的描述符。</li></ul><p>这些字符串以 <code>UTF-8</code> 编码存储，并在 <code>String IDs</code> 中保存其偏移。</p><h5 id="3-类型标记（Type-IDs）"><a href="#3-类型标记（Type-IDs）" class="headerlink" title="3. 类型标记（Type IDs）"></a>3. <strong>类型标记（Type IDs）</strong></h5><p><code>Type IDs</code> 表存储类、基本类型和数组类型。每个 <code>Type ID</code> 指向 <code>String IDs</code> 中的一个字符串，表示具体的类型。对于 <code>Person</code> 类：</p><ul><li><code>LPerson;</code>：表示 <code>Person</code> 类，指向 <code>String IDs</code> 中的 <code>&quot;Person&quot;</code>。</li><li><code>Ljava/lang/String;</code>：表示 <code>String</code> 类型，指向 <code>String IDs</code> 中的 <code>&quot;Ljava/lang/String;&quot;</code>。</li><li><code>I</code>：表示 <code>int</code> 类型，指向 <code>String IDs</code> 中的 <code>&quot;I&quot;</code>。</li></ul><h5 id="4-方法原型标记（Proto-IDs）"><a href="#4-方法原型标记（Proto-IDs）" class="headerlink" title="4. 方法原型标记（Proto IDs）"></a>4. <strong>方法原型标记（Proto IDs）</strong></h5><p><code>Proto IDs</code> 表存储方法的原型信息，包括方法的返回类型和参数类型。例如，在 <code>Person</code> 类中：</p><ul><li><p><code>public Person(String name, int age)</code> 的方法原型：</p><ul><li>参数类型列表为 <code>[Ljava/lang/String;, I</code>（即一个 <code>String</code> 和一个 <code>int</code>）。</li><li>返回类型为 <code>V</code>（表示 <code>void</code>，因为构造函数没有返回值）。</li></ul></li><li><p><code>public String getName()</code> 的方法原型：</p><ul><li>参数类型为空。</li><li>返回类型为 <code>Ljava/lang/String;</code>（表示返回值是 <code>String</code> 类型）。</li></ul></li></ul><p>每个方法原型指向 <code>Type IDs</code> 表中对应的类型，并通过 <code>Proto IDs</code> 表项记录返回类型和参数类型。</p><h5 id="5-字段标记（Field-IDs）"><a href="#5-字段标记（Field-IDs）" class="headerlink" title="5. 字段标记（Field IDs）"></a>5. <strong>字段标记（Field IDs）</strong></h5><p><code>Field IDs</code> 表存储类中的所有字段信息，包括字段的类型、字段名称和所属类。对于 <code>Person</code> 类中的字段：</p><ul><li><p><strong>name</strong>：</p><ul><li><code>class_idx</code>：指向 <code>Type IDs</code> 表中的 <code>Person</code>。</li><li><code>type_idx</code>：指向 <code>Type IDs</code> 表中的 <code>String</code> 类型。</li><li><code>name_idx</code>：指向 <code>String IDs</code> 表中的 <code>&quot;name&quot;</code>。</li></ul></li><li><p><strong>age</strong>：</p><ul><li><code>class_idx</code>：指向 <code>Type IDs</code> 表中的 <code>Person</code>。</li><li><code>type_idx</code>：指向 <code>Type IDs</code> 表中的 <code>int</code> 类型。</li><li><code>name_idx</code>：指向 <code>String IDs</code> 表中的 <code>&quot;age&quot;</code>。</li></ul></li></ul><h5 id="6-方法标记（Method-IDs）"><a href="#6-方法标记（Method-IDs）" class="headerlink" title="6. 方法标记（Method IDs）"></a>6. <strong>方法标记（Method IDs）</strong></h5><p><code>Method IDs</code> 表存储类中的所有方法信息，包括方法名称、方法原型和所属类。对于 <code>Person</code> 类中的方法：</p><ul><li><p><strong>getName</strong>：</p><ul><li><code>class_idx</code>：指向 <code>Type IDs</code> 表中的 <code>Person</code>。</li><li><code>proto_idx</code>：指向 <code>Proto IDs</code> 表中的原型（返回 <code>String</code>，无参数）。</li><li><code>name_idx</code>：指向 <code>String IDs</code> 表中的 <code>&quot;getName&quot;</code>。</li></ul></li><li><p><strong>setName</strong>：</p><ul><li><code>class_idx</code>：指向 <code>Type IDs</code> 表中的 <code>Person</code>。</li><li><code>proto_idx</code>：指向 <code>Proto IDs</code> 表中的原型（参数为 <code>String</code>，返回 <code>void</code>）。</li><li><code>name_idx</code>：指向 <code>String IDs</code> 表中的 <code>&quot;setName&quot;</code>。</li></ul></li></ul><h5 id="7-类定义（Class-Definitions）"><a href="#7-类定义（Class-Definitions）" class="headerlink" title="7. 类定义（Class Definitions）"></a>7. <strong>类定义（Class Definitions）</strong></h5><p><code>Class Definitions</code> 表存储类的结构信息，包括类的访问权限、父类、接口、类中的字段和方法等信息。对于 <code>Person</code> 类：</p><ul><li><strong>class_idx</strong>：指向 <code>Type IDs</code> 表中的 <code>Person</code> 类。</li><li><strong>access_flags</strong>：表示类的访问权限，例如 <code>public</code>、<code>final</code> 等。</li><li><strong>superclass_idx</strong>：指向父类（通常是 <code>Ljava/lang/Object;</code>，即 <code>Object</code> 类）。</li><li><strong>interfaces_off</strong>：指向实现的接口（如果有）。</li><li><strong>class_data_off</strong>：指向类的数据（包括类的字段和方法）。</li></ul><h5 id="8-数据区（Data-Section）"><a href="#8-数据区（Data-Section）" class="headerlink" title="8. 数据区（Data Section）"></a>8. <strong>数据区（Data Section）</strong></h5><p>数据区包含方法的字节码实现、静态字段的初始值、注解等。对于 <code>Person</code> 类的构造方法和 <code>getName</code> 方法，数据区存储了它们的具体字节码：</p><ul><li><strong>字节码（Code Items）</strong>：方法的字节码，包含指令、寄存器数、异常处理表等。例如，<code>getName()</code> 方法的字节码实现会加载 <code>name</code> 字段并返回其值。</li><li><strong>字符串数据</strong>：存储了所有字符串内容，如 <code>&quot;Person&quot;</code>、<code>&quot;name&quot;</code>、<code>&quot;getName&quot;</code> 等。</li><li><strong>类型列表</strong>：存储方法的参数类型列表。</li></ul><p>如图：</p><p><img src="https://s2.loli.net/2024/12/23/bvphztNoreDnwd7.png" alt="dex文件结构"></p><h1 id="绝知此事要躬行"><a href="#绝知此事要躬行" class="headerlink" title="绝知此事要躬行"></a>绝知此事要躬行</h1><p><img src="https://s2.loli.net/2024/12/27/3VY9f5edmrqH8I7.png" alt="image-20241227142405356"></p><p>这里先给出声明：</p><p><img src="https://s2.loli.net/2024/12/27/7EXuDgVTqpaxYRO.png" alt="image-20241227145405664"></p><p><img src="https://s2.loli.net/2024/12/27/Q46EZCGpUqPAuJx.png" alt="image-20241227145425246"></p><p>要注意解析过程中的Uleb128结构和mutf-8结构</p><p>可变长度的类型其实都是基于 LEB128(Little-Endian Base) 类型的，可以用于表示 32 位大小的 int 数字，其根据所要表示的数字的大小来选择合适的长度。如下图所示，其中每个字节的最高位表示是否使用下一个字节，1 表示使用，0 表示不使用。故而每个字节其实只有 7 个有效的 bit 位用来表示相应的数字。如果有一个 LEB128 类型的变量使用了 5 个字节，并且第五个字节的最高位为 1 ，那说明出现了问题。</p><p><img src="https://s2.loli.net/2024/12/27/ECP3h7qmMZRlrHj.png" alt="image-20241227145903678"></p><p>mutf-8结构可参考<a href="https://blog.csdn.net/Roland_Sun/article/details/46716965">MUTF-8编码解析-CSDN博客</a></p><h2 id="文件头解析"><a href="#文件头解析" class="headerlink" title="文件头解析"></a>文件头解析</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://s2.loli.net/2024/12/27/RQihNucqXT3KYzn.png" alt="image-20241227142346605"></p><h2 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DexParse::ParseDexHeader</span><span class="hljs-params">(FILE* fp)</span> </span>&#123;<br>    <span class="hljs-comment">// 为 dex_hdr 分配内存</span><br>    DexHeader* dex_hdr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DexHeader</span>();<br>    <span class="hljs-comment">// 移动文件指针到文件开头</span><br>    <span class="hljs-built_in">fseek</span>(fp, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-comment">// 从文件中读取 DexHeader 内容到动态分配的内存中</span><br>    <span class="hljs-type">size_t</span> bytesRead = <span class="hljs-built_in">fread</span>(dex_hdr, <span class="hljs-built_in">sizeof</span>(DexHeader), <span class="hljs-number">1</span>, fp);<br>    <span class="hljs-keyword">if</span> (bytesRead != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Failed to read DexHeader&quot;</span>);<br>        <span class="hljs-keyword">delete</span> dex_hdr;  <span class="hljs-comment">// 确保释放内存</span><br>        dex_hdr = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出文件标识符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件标识符：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (dex_hdr-&gt;magic[i] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, dex_hdr-&gt;magic[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;校验码：%x\n&quot;</span>, dex_hdr-&gt;checksum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHA-1 签名：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kSHA1DigestLen; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02x&quot;</span>, dex_hdr-&gt;signature[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件大小：%u 字节\n&quot;</span>, dex_hdr-&gt;fileSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件头的大小：%u 字节\n&quot;</span>, dex_hdr-&gt;headerSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字节序标记：0x%08x&quot;</span>, dex_hdr-&gt;endianTag);<br>    <span class="hljs-comment">// 判断字节序类型</span><br>    <span class="hljs-keyword">if</span> (dex_hdr-&gt;endianTag == <span class="hljs-number">0x12345678</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[大端序（Big-Endianness）]\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dex_hdr-&gt;endianTag == <span class="hljs-number">0x78563412</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[小端序（Little-Endianness）]\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字节序标记未知\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链接段大小：%u 字节\n&quot;</span>, dex_hdr-&gt;linkSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链接段偏移位置：0x%08x\n&quot;</span>, dex_hdr-&gt;linkOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;map偏移位置：0x%08x\n&quot;</span>, dex_hdr-&gt;mapOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串数量：%u\n&quot;</span>, dex_hdr-&gt;stringIdsSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串表偏移：0x%08x\n&quot;</span>, dex_hdr-&gt;stringIdsOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;类型标识符列表中的元素数量：%u\n&quot;</span>, dex_hdr-&gt;typeIdsSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;类型标识符表偏移：0x%08x\n&quot;</span>, dex_hdr-&gt;typeIdsOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原型（方法）标识符列表中的元素数量：%u\n&quot;</span>, dex_hdr-&gt;protoIdsSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原型（方法）标识符表偏移：0x%08x\n&quot;</span>, dex_hdr-&gt;protoIdsOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字段标识符列表中的元素数量：%u\n&quot;</span>, dex_hdr-&gt;fieldIdsSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字段标识符表偏移：0x%08x\n&quot;</span>, dex_hdr-&gt;fieldIdsOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;方法标识符列表中的元素数量：%u\n&quot;</span>, dex_hdr-&gt;methodIdsSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;方法标识符表偏移：0x%08x\n&quot;</span>, dex_hdr-&gt;methodIdsOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;类定义列表中的元素数量：%u\n&quot;</span>, dex_hdr-&gt;classDefsSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;类定义列表偏移：0x%08x\n&quot;</span>, dex_hdr-&gt;classDefsOff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;方法标识符列表中的元素数量：%u\n&quot;</span>, dex_hdr-&gt;dataSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;方法标识符表偏移：0x%08x\n&quot;</span>, dex_hdr-&gt;dataOff);<br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">delete</span> dex_hdr;<br>    dex_hdr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://s2.loli.net/2024/12/27/pakHF3OXPUBcTQK.png" alt="image-20241227142504492"></p><h2 id="字符串标识符"><a href="#字符串标识符" class="headerlink" title="字符串标识符"></a>字符串标识符</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://s2.loli.net/2024/12/27/lNZbLcaV5nivGjT.png" alt="image-20241227142749890"></p><h3 id="解析代码-1"><a href="#解析代码-1" class="headerlink" title="解析代码"></a>解析代码</h3><p><img src="https://s2.loli.net/2024/12/27/zMqBUkaH8FGwbyu.png" alt="image-20241227142813535"></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s2.loli.net/2024/12/27/bfIDjnRXKp1CSNc.png" alt="image-20241227142844815"></p><h2 id="类型标识符"><a href="#类型标识符" class="headerlink" title="类型标识符"></a>类型标识符</h2><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://s2.loli.net/2024/12/27/j9Yfyh6z7DiOgPm.png" alt="image-20241227142939743"></p><h3 id="解析代码-2"><a href="#解析代码-2" class="headerlink" title="解析代码"></a>解析代码</h3><p><img src="https://s2.loli.net/2024/12/27/BpMPARgYmakf5oy.png" alt="image-20241227143019559"></p><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s2.loli.net/2024/12/27/KdzY8OGxWrXtJ2U.png" alt="image-20241227143041616"></p><h2 id="原型标识符"><a href="#原型标识符" class="headerlink" title="原型标识符"></a>原型标识符</h2><h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://s2.loli.net/2024/12/27/5fv8txAo2LSrgqZ.png" alt="image-20241227143136904"></p><h3 id="解析代码-3"><a href="#解析代码-3" class="headerlink" title="解析代码"></a>解析代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DexParse::ParseProtoIds</span><span class="hljs-params">(FILE* fp)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取文件大小</span><br>    <span class="hljs-built_in">fseek</span>(fp, <span class="hljs-number">0</span>, SEEK_END);<br>    <span class="hljs-type">size_t</span> fileSize = <span class="hljs-built_in">ftell</span>(fp);<br>    <span class="hljs-built_in">fseek</span>(fp, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-comment">// 读取整个文件到 byteArray</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; <span class="hljs-title">byteArray</span><span class="hljs-params">(fileSize)</span></span>;<br>    <span class="hljs-built_in">fread</span>(byteArray.<span class="hljs-built_in">data</span>(), <span class="hljs-number">1</span>, fileSize, fp);<br><br>    <span class="hljs-comment">// 使用智能指针管理 dex_hdr 内存</span><br>    <span class="hljs-keyword">auto</span> dex_hdr = std::<span class="hljs-built_in">make_unique</span>&lt;DexHeader&gt;();<br>    <span class="hljs-comment">// 从 byteArray 读取 DexHeader 内容</span><br>    <span class="hljs-built_in">memcpy</span>(dex_hdr.<span class="hljs-built_in">get</span>(), byteArray.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(DexHeader));<br>    <span class="hljs-function">std::vector&lt;DexProtoId&gt; <span class="hljs-title">Prototable</span><span class="hljs-params">(dex_hdr-&gt;protoIdsSize)</span></span>;<br>    <span class="hljs-built_in">memcpy</span>(Prototable.<span class="hljs-built_in">data</span>(), byteArray.<span class="hljs-built_in">data</span>() + dex_hdr-&gt;protoIdsOff, <span class="hljs-built_in">sizeof</span>(DexProtoId) * dex_hdr-&gt;protoIdsSize);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=======================Proto======================================\n&quot;</span>);<br><br>    <span class="hljs-comment">// 遍历并打印所有类型的字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dex_hdr-&gt;protoIdsSize; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Proto %d :&quot;</span>, i);<br>        <span class="hljs-comment">// 获取每个类型对应的字符串偏移（通过 descriptorIdx 获取对应的 DexStringId）</span><br>        <span class="hljs-type">uint32_t</span> shortyIdx = Prototable[i].shortyIdx;<br>        <span class="hljs-keyword">if</span> (shortyIdx &lt; decodedStrings.<span class="hljs-built_in">size</span>()) &#123;<br>            std::string decodedString1 = decodedStrings[shortyIdx];<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, decodedString1.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid shortyIdx: %u&quot;</span>, shortyIdx);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;:&quot;</span>);<br><br>        <span class="hljs-comment">// 获取每个类型对应的字符串偏移（通过 descriptorIdx 获取对应的 DexStringId）</span><br>        <span class="hljs-type">uint32_t</span> returntersOff = Prototable[i].returnTypeIdx;<br>        <span class="hljs-keyword">if</span> (returntersOff &lt; typeStrings.<span class="hljs-built_in">size</span>()) &#123;<br>            std::string decodedString2 = typeStrings[returntersOff];<br>            typeStrings.<span class="hljs-built_in">push_back</span>(decodedString2);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,decodedString2.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid returntersOff: %u&quot;</span>, returntersOff);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>        <span class="hljs-type">uint32_t</span> parameters = Prototable[i].parametersOff;<br>        <span class="hljs-keyword">if</span> (parameters == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;proto %d has no parameters\n&quot;</span>, i);<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过没有参数的 proto</span><br>        &#125;<br>        <span class="hljs-comment">// 移动文件指针到 parameters 偏移位置</span><br>        <span class="hljs-built_in">fseek</span>(fp, parameters, SEEK_SET);<br><br>        <span class="hljs-comment">// 读取 TypeList 的 size</span><br>        DexTypeList typeListHeader;<br>        <span class="hljs-built_in">fread</span>(&amp;typeListHeader, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint32_t</span>), <span class="hljs-number">1</span>, fp); <span class="hljs-comment">// 只读取 size</span><br><br>        <span class="hljs-comment">// 检查 size 是否有效</span><br>        <span class="hljs-keyword">if</span> (typeListHeader.size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;proto %d has no parameters\n&quot;</span>, i);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 读取参数类型索引数组</span><br>        <span class="hljs-function">std::vector&lt;DexTypeItem&gt; <span class="hljs-title">typeIndices</span><span class="hljs-params">(typeListHeader.size)</span></span>;<br>        <span class="hljs-built_in">fread</span>(typeIndices.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">sizeof</span>(DexTypeItem), typeListHeader.size, fp);<br><br>        <span class="hljs-comment">// 遍历每个参数的类型索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; typeListHeader.size; j++) &#123;<br>            <span class="hljs-type">uint16_t</span> typeIdx2 = typeIndices[j].typeIdx;<br>            <span class="hljs-keyword">if</span> (typeIdx2 &lt; typeStrings.<span class="hljs-built_in">size</span>()) &#123;<br>                std::string decodedString3 = typeStrings[typeIdx2];<br>                typeStrings.<span class="hljs-built_in">push_back</span>(decodedString3);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, decodedString3.<span class="hljs-built_in">c_str</span>());<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid returntersOff: %u&quot;</span>, returntersOff);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s2.loli.net/2024/12/27/NoJK8qTQSXvbPHZ.png" alt="image-20241227143253634"></p><h2 id="字段标识符"><a href="#字段标识符" class="headerlink" title="字段标识符"></a>字段标识符</h2><h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://s2.loli.net/2024/12/27/7UhF6ECzBQ15Iwp.png" alt="image-20241227143319968"></p><h3 id="解析代码-4"><a href="#解析代码-4" class="headerlink" title="解析代码"></a>解析代码</h3><p><img src="https://s2.loli.net/2024/12/27/w3uCsAkmeVYEZrg.png" alt="image-20241227143356792"></p><h3 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s2.loli.net/2024/12/27/goDqr7ZxpHnfBuh.png" alt="image-20241227143417836"></p><h2 id="方法标识符"><a href="#方法标识符" class="headerlink" title="方法标识符"></a>方法标识符</h2><h3 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://s2.loli.net/2024/12/27/RhsagT5y7fKcVpL.png" alt="image-20241227143438902"></p><h3 id="解析代码-5"><a href="#解析代码-5" class="headerlink" title="解析代码"></a>解析代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dex_hdr-&gt;methodIdsSize; i++)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;method %d :&quot;</span>, i);<br>    <span class="hljs-type">uint16_t</span> protoIndex1 = methodtable[i].protoIdx;<br>    DexProtoId protoId = Prototable[protoIndex1];<br>    <span class="hljs-comment">// 获取每个类型对应的字符串偏移（通过 descriptorIdx 获取对应的 DexStringId）</span><br>    <span class="hljs-type">uint32_t</span> shortyIdx = protoId.shortyIdx;<br>    <span class="hljs-keyword">if</span> (shortyIdx &lt; decodedStrings.<span class="hljs-built_in">size</span>()) &#123;<br>        std::string decodedString = decodedStrings[shortyIdx];<br>        typeStrings.<span class="hljs-built_in">push_back</span>(decodedString);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, decodedString.<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid stringIdx: %u\n&quot;</span>, shortyIdx);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;: &quot;</span>);<br><br>    <span class="hljs-type">uint16_t</span> typeIndex = methodtable[i].classIdx;<br>    DexTypeId TypeId = Typetable[typeIndex];<br>    <span class="hljs-comment">//printf(&quot;typeIndex: %d, descriptorIdx: %d\n&quot;, typeIndex, TypeId.descriptorIdx);  // 打印 descriptorIdx 的值</span><br>    <span class="hljs-type">uint32_t</span> stringIdx = TypeId.descriptorIdx;<br>    <span class="hljs-keyword">if</span> (stringIdx &lt; decodedStrings.<span class="hljs-built_in">size</span>()) &#123;<br>        std::string decodedString1 = decodedStrings[stringIdx];<br>        typeStrings.<span class="hljs-built_in">push_back</span>(decodedString1);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, decodedString1.<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid stringIdx: %u\n&quot;</span>, stringIdx);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><br>    <span class="hljs-type">uint32_t</span> stringIdx3 = methodtable[i].nameIdx;<br>    <span class="hljs-keyword">if</span> (stringIdx3 &lt; decodedStrings.<span class="hljs-built_in">size</span>()) &#123;<br>        std::string decodedString2 = decodedStrings[stringIdx3];<br>        typeStrings.<span class="hljs-built_in">push_back</span>(decodedString2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, decodedString2.<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid stringIdx: %u\n&quot;</span>, stringIdx3);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s2.loli.net/2024/12/27/poY7wfhscBtTm2J.png" alt="image-20241227144010393"></p><h2 id="类定义列表"><a href="#类定义列表" class="headerlink" title="类定义列表"></a>类定义列表</h2><blockquote><p>DexClassDex文件中所有数据都是uleb128，包括之后的偏移，所以，DexClassDataHeader这个结构体它的长度取决于这四个uleb128的长度<br>同时，接着的几个成员变量，也就是类中的成员和方法的偏移所处位置，就是DexClassDataHeader之后。<br>什么意思呢？就是说，DexClassDex结构中，位于DexClassDataHeader结构内存之后，拥有这个结构中提取出的四个整数的和的个数个uleb128整数，而每一个整数，就是一个偏移.</p></blockquote><p>在这里直接解析DexClassData和DexClassDataHeader这两个比较重要的结构，其他结构读者按需解析即可</p><h3 id="数据结构-6"><a href="#数据结构-6" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类的基本信息-------------------------------------------</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DexClassDef</span> &#123;<br>    u4 classIdx;    <span class="hljs-comment">/* 类的类型，指向DexTypeId列表的索引 */</span><br>    u4 accessFlags; <span class="hljs-comment">/* 访问标志 */</span><br>    u4 superclassIdx;  <span class="hljs-comment">/* 父类类型，指向DexTypeId列表的索引 */</span><br>    u4 interfacesOff; <span class="hljs-comment">/* 接口，指向DexTypeList的偏移 */</span><br>    u4 sourceFileIdx; <span class="hljs-comment">/* 源文件名，指向DexStringId列表的索引 */</span><br>    u4 annotationsOff; <span class="hljs-comment">/* 注解，指向DexAnnotationsDirectoryItem结构 */</span><br>    u4 classDataOff;   <span class="hljs-comment">/* 指向DexClassData结构的偏移 */</span><br>    u4 staticValuesOff;  <span class="hljs-comment">/* 指向DexEncodedArray结构的偏移 */</span><br>&#125;;<br><br><span class="hljs-comment">// 详细描述类的字段个数与方法个数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DexClassDataHeader</span> &#123;<br>    uleb128 staticFieldsSize;  <span class="hljs-comment">/* 静态字段个数 */</span><br>    uleb128 instanceFieldsSize; <span class="hljs-comment">/* 实例字段个数 */</span><br>    uleb128 directMethodsSize;  <span class="hljs-comment">/* 直接方法个数 */</span><br>    uleb128 virtualMethodsSize; <span class="hljs-comment">/* 虚方法个数 */</span><br>&#125;;<br><br><span class="hljs-comment">// 字段定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DexField</span> &#123;<br>    uleb128 fieldIdx;    <span class="hljs-comment">/* 指向DexFieldId的索引*/</span><br>    uleb128 accessFlags; <span class="hljs-comment">/* 访问标志 */</span><br>&#125;;<br><br><span class="hljs-comment">// 方法定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DexMethod</span> &#123;<br>    uleb128 methodIdx;   <span class="hljs-comment">/* 指向DexMethodId的索引 */</span><br>    uleb128 accessFlags; <span class="hljs-comment">/* 访问标志*/</span><br>    uleb128 codeOff;     <span class="hljs-comment">/* 指向DexCode结构的偏移*/</span><br>&#125;;<br><br><span class="hljs-comment">// 代码概况</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DexCode</span> &#123;<br>    u2 registersSize;   <span class="hljs-comment">/* 使用的寄存器个数 */</span><br>    u2 insSize;         <span class="hljs-comment">/* 参数个数 */</span><br>    u2 outsSize;        <span class="hljs-comment">/* 调用其他方法时其它方法使用的寄存器个数，会在自己的调用栈申请，并压栈（猜测） */</span><br>    u2 triesSize;       <span class="hljs-comment">/* Try/Catch个数 */</span><br>    u4 debugInfoOff;    <span class="hljs-comment">/* 指向调试信息的偏移 */</span><br>    u4 insnsSize;       <span class="hljs-comment">/* 指令集个数，以2字节为单位 */</span><br>    u2 insns[<span class="hljs-number">1</span>];        <span class="hljs-comment">/* 指令集 */</span><br>&#125;;<br><br><span class="hljs-comment">// 类的字段与方法概况</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DexClassData</span> &#123;<br>    DexClassDataHeader header; <span class="hljs-comment">/* 指定字段与方法的个数 */</span><br>    DexField* staticFields;    <span class="hljs-comment">/* 静态字段，DexField结构 */</span><br>    DexField* instanceFields;  <span class="hljs-comment">/* 实例字段，DexField结构 */</span><br>    DexMethod* directMethods;  <span class="hljs-comment">/* 直接方法，DexMethod结构 */</span><br>    DexMethod* virtualMethods; <span class="hljs-comment">/* 虚方法，DexMethod结构 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解析代码-6"><a href="#解析代码-6" class="headerlink" title="解析代码"></a>解析代码</h3><p><img src="https://s2.loli.net/2024/12/27/fgUSc5LKixeRIOA.png" alt="image-20241227144742929"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">//静态字段</span><br><span class="hljs-keyword">if</span> (staticFieldCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------------------static Fields=================================================&gt; \n&quot;</span>);<br>      <span class="hljs-keyword">while</span> (staticFieldCount--) &#123;<br>          <span class="hljs-type">int</span> tmpLength = <span class="hljs-number">0</span>;<br>          <span class="hljs-type">int</span> fieldIndx = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset);<br>          <span class="hljs-type">int</span> accessFlags = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset);<br><br>          <span class="hljs-comment">//----field----------</span><br>          <span class="hljs-type">uint16_t</span> typeIndex = fieldtable[fieldIndx].typeIdx;<br>          DexTypeId TypeId = Typetable[typeIndex];<br>          <span class="hljs-type">uint32_t</span> stringIdx = TypeId.descriptorIdx;<br>          <span class="hljs-keyword">if</span> (stringIdx &gt;= dex_hdr-&gt;stringIdsSize) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid descriptorIdx: %d\n&quot;</span>, stringIdx);<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          DexStringId stringId = stringtable[stringIdx];<br>          <span class="hljs-type">size_t</span> stringOffset = stringId.stringDataOff;<br>          <span class="hljs-keyword">if</span> (stringOffset &gt;= byteArray.<span class="hljs-built_in">size</span>()) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid stringDataOff: %zu\n&quot;</span>, stringOffset);<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-comment">// 解码字符串</span><br>          <span class="hljs-type">size_t</span> offset0 = stringOffset;<br>          <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset0);<br>          std::string decodedString = <span class="hljs-built_in">decodeString</span>(byteArray, offset0, length);<br><br>          <span class="hljs-comment">// 打印解码后的字符串</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : decodedString) &#123;<br>              <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\n&quot;</span>);<br>              &#125;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;;&#x27;</span>) &#123;<br>                  <span class="hljs-keyword">continue</span>;<br>              &#125;<br>              <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>              &#125;<br>          &#125;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>          <span class="hljs-type">uint16_t</span> typeIndex1 = fieldtable[i].classIdx;<br>          DexTypeId TypeId1 = Typetable[typeIndex1];<br>          <span class="hljs-type">uint32_t</span> stringIdx1 = TypeId1.descriptorIdx;<br>          <span class="hljs-keyword">if</span> (stringIdx1 &gt;= dex_hdr-&gt;stringIdsSize) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid descriptorIdx: %d\n&quot;</span>, stringIdx);<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          DexStringId stringId1 = stringtable[stringIdx1];<br>          <span class="hljs-type">size_t</span> stringOffset1 = stringId1.stringDataOff;<br>          <span class="hljs-keyword">if</span> (stringOffset1 &gt;= byteArray.<span class="hljs-built_in">size</span>()) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid stringDataOff: %zu\n&quot;</span>, stringOffset1);<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-comment">// 解码字符串</span><br>          <span class="hljs-type">size_t</span> offset1 = stringOffset1;<br>          <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length1 = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset1);<br>          std::string decodedString1 = <span class="hljs-built_in">decodeString</span>(byteArray, offset1, length1);<br>          <span class="hljs-comment">// 打印解码后的字符串</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : decodedString1) &#123;<br>              <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\n&quot;</span>);<br>              &#125;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;;&#x27;</span>) &#123;<br>                  <span class="hljs-keyword">continue</span>;<br>              &#125;<br>              <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>              &#125;<br>          &#125;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><br>          <span class="hljs-type">uint32_t</span> stringIdx3 = fieldtable[i].nameIdx;<br>          <span class="hljs-keyword">if</span> (stringIdx1 &gt;= dex_hdr-&gt;stringIdsSize) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid descriptorIdx: %d\n&quot;</span>, stringIdx);<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          DexStringId stringId3 = stringtable[stringIdx3];<br>          <span class="hljs-type">size_t</span> stringOffset3 = stringId3.stringDataOff;<br>          <span class="hljs-keyword">if</span> (stringOffset3 &gt;= byteArray.<span class="hljs-built_in">size</span>()) &#123;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid stringDataOff: %zu\n&quot;</span>, stringOffset);<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-comment">// 解码字符串</span><br>          <span class="hljs-type">size_t</span> offset3 = stringOffset3;<br>          <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length3 = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset3);<br>          std::string decodedString3 = <span class="hljs-built_in">decodeString</span>(byteArray, offset3, length3);<br>          <span class="hljs-comment">// 打印解码后的字符串</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : decodedString3) &#123;<br>              <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\n&quot;</span>);<br>              &#125;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;;&#x27;</span>) &#123;<br>                  <span class="hljs-keyword">continue</span>;<br>              &#125;<br>              <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>              &#125;<br>          &#125;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; accflag=0x%X\n&quot;</span>, accessFlags);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>实例字段同静态字段相同，只是改了相关结构命名，这里不多赘述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//直接方法</span><br><span class="hljs-keyword">if</span> (directMethodCount &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----------------direct Method===================================&gt; \n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (directMethodCount--) &#123;<br>        <span class="hljs-type">int</span> directMethodIndx = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset);<br>        <span class="hljs-type">int</span> accessFlags = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset);<br>        <span class="hljs-type">int</span> codeOff = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset);<br>        <span class="hljs-comment">//----------directMethod</span><br>        <span class="hljs-type">uint16_t</span> protoIndex1 = methodtable[directMethodIndx].protoIdx;<br>        DexProtoId protoId = Prototable[protoIndex1];<br>        <span class="hljs-comment">// 获取每个类型对应的字符串偏移（通过 descriptorIdx 获取对应的 DexStringId）</span><br>        <span class="hljs-type">uint32_t</span> shortyIdx = protoId.shortyIdx;<br>        <span class="hljs-comment">// 获取对应的 DexStringId</span><br>        DexStringId stringId = stringtable[shortyIdx];<br>        <span class="hljs-comment">// 获取字符串的偏移量</span><br>        <span class="hljs-type">size_t</span> stringOffset = stringId.stringDataOff;<br>        <span class="hljs-comment">// 读取该字符串的 ULEB128 解码的长度</span><br>        <span class="hljs-type">size_t</span> offset0 = stringOffset;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset0);<br>        <span class="hljs-comment">// 解码字符串（MUTF-8）</span><br>        std::string decodedString = <span class="hljs-built_in">decodeString</span>(byteArray, offset0, length);<br>        <span class="hljs-comment">// 打印解码后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : decodedString) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;: &quot;</span>);<br><br>        <span class="hljs-type">uint16_t</span> typeIndex = methodtable[i].classIdx;<br>        <span class="hljs-comment">// 检查类型索引是否有效</span><br>        <span class="hljs-keyword">if</span> (typeIndex &gt;= dex_hdr-&gt;typeIdsSize) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid typeIndex: %d\n&quot;</span>, typeIndex);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        DexTypeId TypeId = Typetable[typeIndex];<br>        <span class="hljs-comment">//printf(&quot;typeIndex: %d, descriptorIdx: %d\n&quot;, typeIndex, TypeId.descriptorIdx);  // 打印 descriptorIdx 的值</span><br>        <span class="hljs-type">uint32_t</span> stringIdx = TypeId.descriptorIdx;<br>        <span class="hljs-keyword">if</span> (stringIdx &gt;= dex_hdr-&gt;stringIdsSize) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid descriptorIdx: %d\n&quot;</span>, stringIdx);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        DexStringId stringId2 = stringtable[stringIdx];<br>        <span class="hljs-type">size_t</span> stringOffset2 = stringId2.stringDataOff;<br>        <span class="hljs-keyword">if</span> (stringOffset &gt;= byteArray.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid stringDataOff: %zu\n&quot;</span>, stringOffset);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解码字符串</span><br>        <span class="hljs-type">size_t</span> offset2 = stringOffset2;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length2 = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset2);<br>        std::string decodedString2 = <span class="hljs-built_in">decodeString</span>(byteArray, offset, length2);<br><br>        <span class="hljs-comment">// 打印解码后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : decodedString2) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;;&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><br>        <span class="hljs-type">uint32_t</span> stringIdx3 = methodtable[i].nameIdx;<br>        <span class="hljs-keyword">if</span> (stringIdx3 &gt;= dex_hdr-&gt;stringIdsSize) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid descriptorIdx: %d\n&quot;</span>, stringIdx3);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        DexStringId stringId3 = stringtable[stringIdx3];<br>        <span class="hljs-type">size_t</span> stringOffset3 = stringId3.stringDataOff;<br>        <span class="hljs-keyword">if</span> (stringOffset3 &gt;= byteArray.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Invalid stringDataOff: %zu\n&quot;</span>, stringOffset);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解码字符串</span><br>        <span class="hljs-type">size_t</span> offset3 = stringOffset3;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length3 = <span class="hljs-built_in">readUnsignedLeb128</span>(byteArray, offset3);<br>        std::string decodedString3 = <span class="hljs-built_in">decodeString</span>(byteArray, offset3, length3);<br><br>        <span class="hljs-comment">// 打印解码后的字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : decodedString3) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;;&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; accflag=0x%X\n&quot;</span>, accessFlags);<br><br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚拟方法同直接方法相同，只是改了相关结构命名，这里不多赘述</p><h3 id="结果-6"><a href="#结果-6" class="headerlink" title="结果"></a>结果</h3><p><img src="https://s2.loli.net/2024/12/27/8V6uIqxElspyWDv.png" alt="image-20241227144232208"></p><p>最后再给出DEX完整结构:</p><p><img src="https://s2.loli.net/2024/12/27/qMz2SkpR4iCrPyv.jpg" alt="v2-adbcde93c3d86ddda2811c3ae0d40de2_r"></p><h1 id="青，取之于蓝，而青于蓝"><a href="#青，取之于蓝，而青于蓝" class="headerlink" title="青，取之于蓝，而青于蓝"></a>青，取之于蓝，而青于蓝</h1><p><a href="https://blog.csdn.net/itermeng/article/details/79218060">Android Dex VS Class：实例图解剖析两种格式文件结构、优劣_dex文件格式-CSDN博客</a></p><p><a href="https://www.cnblogs.com/webor2006/p/16609029.html">02-为什么dex文件比class文件更适合移动端？ - cexo - 博客园 (cnblogs.com)</a></p><p><a href="https://weichao.io/eca312d65798/">第 3 章：深入理解 Dex 文件格式 - 『魏超』的 blog (weichao.io)</a></p><p><a href="https://gal2xy.github.io/2023/11/10/Android%E5%AE%89%E5%85%A8/dex%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/">dex文件格式解析 - gla2xy’s blog (gal2xy.github.io)</a></p><p><a href="https://cloud.tencent.com/developer/article/1663852">一文读懂 DEX 文件格式解析-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://blog.csdn.net/beyond702/article/details/52460721">图解Dex文件结构及解析要点_dex opcode-CSDN博客</a></p><p><a href="https://zhanweisun.github.io/2019/12/28/dex-wen-jian-jie-gou-yu-jie-xi/">DEX文件结构与解析 | 孙老师 (zhanweisun.github.io)</a></p><p><a href="https://blog.csdn.net/li0978/article/details/114981769">来，同学，坐下，谈谈对Dex文件的认识_dex什么语言-CSDN博客</a></p><p><a href="https://deepinout.com/android-system-analysis/android-framework-related/easy-to-understand-dex-file-format.html">Android dex文件格式介绍|极客笔记 (deepinout.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>逆向(android)</category>
      
      <category>文件格式/装载链接运行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向(android)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓冲问题</title>
    <link href="/2023/06/25/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98-Redis/"/>
    <url>/2023/06/25/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98-Redis/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本想着自己写的，但这位前辈已经总结的很完善了，再谈就画蛇添足了</p><p>故本篇转载<a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/4.Redis-%E5%BA%94%E7%94%A8%E7%AF%87-01-%E7%BC%93%E5%AD%98%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98.html">Redis-应用篇-①缓存并发问题 | 一人の境</a>这篇文章</p></blockquote><h1 id="缓存应用场景"><a href="#缓存应用场景" class="headerlink" title="缓存应用场景"></a>缓存应用场景</h1><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p><p> 如果用户的请求都访问数据库的话，一旦请求数量上来，数据库很容易就奔溃。因此为了避免用户直接访问数据库，会选用 Redis 作为缓存层。因为 Redis 是内存数据库，可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，以此大大提高了系统性能</p><p><img src="https://s2.loli.net/2025/01/05/mAyf3QFUIRk8Kdb.png" alt="image-20250105105537308"></p><p>通常为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存</p><p><img src="https://s2.loli.net/2025/01/05/OCpTc1LuD4VAkxH.png" alt="image-20250105105550339"></p><h1 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p> <strong>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求</strong>。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p> 在流量大时，可能导致DB挂掉，如果有人利用不存在的key频繁攻击的应用，就会导致出现很大的系统漏洞。缓存穿透的发生一般有两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>【1】<strong>限制非法请求</strong>：接口层增加校验，如用户鉴权校验、id做基础校验，id&lt;&#x3D;0的直接拦截；</p><p> 当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库</p><p>【2】<strong>临时缓存</strong>（缓存空值或者默认值）通用推荐方案：从缓存取不到的数据，在数据库中也没有取到，此时也可以将key-value键值对写为<code>key-null</code>，缓存有效时间设置要适中（如30s），防止攻击用户反复用同一个id暴力攻击</p><ul><li>临时缓存有效时间太短可能不起作用</li><li>临时缓存有效时间太长会挤占正常缓存的内存，可能对正常业务造成影响（例如某个值一开始不存在，后面又增加了，如果临时缓存有效时间设置太长就可能导致正常的数据比较长时间拿不到）<ul><li>此处可能会思考，如果新增的时候附带更新下缓存或许就能解决这个问题。但具体还是要结合实际的业务场景和缓存更新方案，例如一般新增操作不会更新缓存，只有修改的时候才会操作缓存。且纯粹的旁路缓存不一定会进行删除操作，因此要结合实际场景分析</li></ul></li></ul><p>【3】<strong>布降过滤器</strong>存在误判情况，谨慎使用：使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</p><p> bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中。其典型的应用场景就是<strong>快速判断一个key是否存在于某容器，不存在就直接返回</strong>。布隆过滤器的关键就在于hash算法和容器大小可以用布隆过滤器来应对，布隆过滤器是一种比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告知“某样东西一定不存在或者可能存在”</p><p><img src="https://s2.loli.net/2025/01/05/NOKfoyjJn9HYMzC.png" alt="image-20250105105010065"></p><p>可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p> 即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的</p><blockquote><p>布隆过滤器原理</p></blockquote><p> 布降过滤器底层是一个bit 数组，将字符串用多个Hash函数映射不同的二进制位置，将对应位置设置为1。</p><p> 布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。布隆过滤器会通过 3 个操作完成标记：</p><ul><li>【步骤1】：使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>【步骤2】：将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；</li><li>【步骤3】：将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p><img src="https://s2.loli.net/2025/01/05/SbMdqLZG4rnlHQ8.png" alt="image-20250105105053330"></p><p>结合上述图示分析，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、3、6，然后把位图数组的第 1、3、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、3、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p> 布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，<strong>存在误判</strong>的情况。</p><p> 在查询的时候，如果一个字符串所有Hash函数映射的值都存在，那么数据可能存在。为什么说可能？就是因为其他字符可能占据该值，提前点亮。</p><p> 布隆过滤器优缺点都很明显，<strong>优点是空间、时间消耗都很小，缺点是结果不是完全准确</strong></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>业务通常会有几个数据会被频繁地访问，比如秒杀活动相关，这类被频地访问的数据被称为热点数据</p><p> 缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。<strong>缓存击穿，一般指是指热键在过期失效的一瞬间，还没来得及重新产生，就有海量数据直达数据库</strong></p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>【1】<strong>热点数据支持续期</strong>，持续访问的数据可以不断续期，避免因为过期失效而被击穿</p><ul><li>热点续期的常见方案：只要有请求访问，就按照一定规则增加过期时间（可以理解为发现过期时间快到了，自动续期）</li></ul><p>【2】<strong>互斥锁方案 <strong>（加互斥锁、重建缓存）：发现缓存失效，</strong>重建缓存加互斥锁</strong>，当线程査询缓存发现缓存不存在就会尝试加锁，线程争抢锁，拿到锁的线程就会进行查询数据库、重建缓存，争抢锁失败的线程可以加一个睡眠然后循环重试</p><ul><li>方案1：使用 redis 里的 redssion 分布式锁。当线程拿到缓存发现过期了就会尝试加锁，线程争抢锁，拿到锁的线程就会进行查询数据库、重建缓存，争抢锁失败的线程，可以加一个睡眠然后循环重试（redission 直接实现了可重试和可重入还保证了原子性）</li><li>方案2：如果担心线程资源会占用很大，可以用<strong>逻辑过期</strong>来解决缓存击穿，就是给缓存加上过期时间戳而不设置 ttl，判断这个逻辑时间是否过期然后加锁重建缓存，此处争抢锁失败的线程就不再争抢了，而是直接返回已过期数据，具体解决方案还是得根据应用场景来使用。此处的时间戳概念是将当前时间序列传给redis，然后将其和要把保存的数据一起作为对象存到value中，然后在获取这个数据的时候进行反序列化，判断这个数据<strong>是否过期</strong>。</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>：是指大量的应用请求因为异常无法在Redis缓存中进行处理，像雪崩一样，直接打到数据库。</p><p> 雪崩主要原因：<strong>缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机</strong>。在一些资料学习里，会把Redis宕机算进来，原因是Redis宕机了也就无法处理缓存请求，但细究来看Redis当即也会出现缓存击穿问题。考虑缓存击穿针对的是热点数据，缓存雪崩针对的是大量数据同时失效，一些场景中会把Redis宕机当作是缓存雪崩的一种特殊场景。</p><p> <strong>缓存击穿和缓存雪崩概念很相似，可以理解为缓存击穿是缓存雪崩的一个子集，但缓存击穿指热点数据在Redis没得到及时重建，缓存雪崩是一大批数据在Redis同时失效</strong></p><h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h4><p> 不同的缓存雪崩诱因不同，其相应解决方案不同</p><p>【1】<strong>设置均匀的缓存过期时间</strong>：缓存数据的过期时间<strong>加上随机数</strong>，避免设置同一时间，防止同一时间大量数据过期现象发生</p><p>【2】**互斥锁方案 **（加互斥锁、重建缓存）：当线程拿到缓存发现缓存不存在就会尝试加锁（加互斥锁，确保同一时间内只有一个请求来构建缓存），线程争抢锁，拿到锁的线程就会进行查询数据库、重建缓存，对于争抢锁失败的线程可以加一个睡眠然后循环重试</p><p>【3】<strong>后台更新缓存</strong>：业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p> 事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，从业务的视角就以为是数据丢失了。解决上面的问题的方式有两种。</p><ul><li>方式1：后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效（可能是系统资源紧张而被淘汰的），则需从数据库读取数据，并更新到缓存。<ul><li>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</li></ul></li><li>方式2：在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong><ul><li>后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存</li><li>这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</li></ul></li></ul><p>在业务刚上线的时候，最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情</p><h2 id="Redis宕机"><a href="#Redis宕机" class="headerlink" title="Redis宕机"></a>Redis宕机</h2><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>服务熔断或请求限流机制；</li><li>构建 Redis 缓存高可靠集群；</li></ul><p><em>1. 服务熔断或请求限流机制</em></p><p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常运行，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><p><em>2. 构建 Redis 缓存高可靠集群</em></p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题</p><h2 id="缓存并发问题总结"><a href="#缓存并发问题总结" class="headerlink" title="缓存并发问题总结"></a>缓存并发问题总结</h2><table><thead><tr><th>缓存并发问题</th><th>产生原因</th><th>解决方案</th></tr></thead><tbody><tr><td>缓存穿透</td><td>数据既不在缓存中，也不在数据库中</td><td>【1】限制接口请求条件 【2】设置临时缓存（对不存在的key设置value为空或者默认值） 【3】引入布隆过滤器（快速校验数据是否存在，避免大量请求落到数据库上，但可能存在误判现象）</td></tr><tr><td>缓存击穿</td><td>热点数据在某一瞬间失效，但此时数据库还没来得及更新缓存</td><td>【1】自动续期（针对热点数据，在查询的时候可根据限定条件为快到期的数据自动续期） 【2】互斥锁方案（加互斥锁、重建缓存）：确保同一时刻只有一个请求做更新缓存操作（加互斥锁，成功获取锁资源的请求可查询数据库、重建缓存），其他未获取锁资源的请求可选择直接返回默认值，或者重试</td></tr><tr><td>缓存雪崩</td><td>大量数据在同一时间失效</td><td>【1】均匀分布过期时间（针对数据的过期时间设定，可以添加随机数，避免大量数据在同一时间同时过期） 【2】互斥锁方案（加互斥锁、重建缓存）：确保同一时刻只有一个请求做更新缓存操作（加互斥锁，成功获取锁资源的请求可查询数据库、重建缓存），其他未获取锁资源的请求可选择直接返回默认值，或者重试 【3】后台定时更新缓存（将原ttl方案交由后台完全控制，缓存不再设定过期时间，而是由后台线程进行业务逻辑操作实现定时更新）</td></tr><tr><td>Redis宕机</td><td>Redis宕机在一些场景下也被认为是缓存雪崩的一种情况，此处Redis宕机主要是由于故障引发</td><td>【1】服务熔断或请求限流机制 【2】构建 Redis 缓存高可靠集群</td></tr></tbody></table><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p>具体可参考：<a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/4.Redis-%E5%BA%94%E7%94%A8%E7%AF%87-02-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html#_2-%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83">Redis-应用篇-②缓存一致性问题 | 一人の境</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>持久化</title>
    <link href="/2023/06/21/%E6%8C%81%E4%B9%85%E5%8C%96-Redis/"/>
    <url>/2023/06/21/%E6%8C%81%E4%B9%85%E5%8C%96-Redis/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>前景导读</strong></p><p>我们知道redis是一个内存数据库，它把所有的数据保存在内存中,正因如此，它的得到了极高的读写速度。但在计算机领域没有所谓的“白弹”，如果没有一定的机制，基于内存的redis也会因为内存的易失性，在宕机时发生数据丢失。或许如此redis经常被用作<strong>缓存</strong>。它是最常见的缓存系统之一，而不是存粹的数据库，所以我们需要探讨的是：<strong>如何把redis内存中的数据持久化？****这个所谓的机制到底是什么？</strong></p><hr><h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a><strong>AOF持久化</strong></h1><blockquote><p>能否有类似mysql的redo日志功能，redis每执行一条写操作指令，就把该指令以追加的方式写入到一个文件里，在重启redis时，再读取文件中的指令并执行。相当于恢复了缓冲数据了。</p></blockquote><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>Redis将这种保存写操作命令到日志的持久化方式，叫做：AOF(append only file)持久化功能。【注意：该功能默认是不开启的，需要修改配置】</p><p><img src="https://s2.loli.net/2025/01/05/zrmLpDXWgdjtU2h.png" alt="image-20250105095517592"></p><blockquote><p>1.假如在第一步写操作后，还未执行第二步写入硬盘时，宕机了怎么办？</p><p>2.注意无论是第一步还是第二部都是在主进程中执行的，那么在第二步执行时，可能对下一个指令产生阻塞？(毕竟写磁盘的耗时可是比较大的)</p></blockquote><p>针对上述两个问题，Redis有了三种AOF的写回策略</p><h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>Redis 写回AOF日志的过程分析如下：</p><p><img src="https://s2.loli.net/2025/01/05/NGxwfygLUhMaH87.png" alt="image-20240718084139264.67302d08"></p><p>【步骤1】Redis 执行完写操作后会将命令追加到<code>server.aof_buf</code>缓冲区</p><p>【步骤2】通过write()系统调用，将缓冲区的数据写入到AOF文件（此时数据还没有写入到硬盘，而是拷贝到内核缓冲区<code>page cache</code>，等待内核将数据写入硬盘）</p><p>【步骤3】由内核决定具体内核缓冲区的数据什么时候写入硬盘</p><p><strong>Redis提供了3种写回硬盘的策略，控制的是上述【步骤3】的过程</strong>，在<code>redis.conf</code>配置文件中的<code>appendfsync</code>配置项中可配置3种参数：</p><ul><li>Always：每次写操作命令执行完，同步将AOF日志数据写回硬盘</li><li>Everysec：每次写操作命令执行完，先将命令写入到AOF文件的内核缓冲区，然后每隔1s将缓冲区中的内容写回到硬盘</li><li>No：不由Redis控制写回硬盘的时机，而是转交给操作系统进行控制。即每次写操作命令执行完，先将命令写入到AOF文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘</li></ul><p><strong>针对【主进程阻塞】和【数据丢失】问题，这3种写回策略都无法做到完美解决，因为本身这两个问题就是对立的，无法完美兼得</strong>。</p><p> <strong>针对这两个问题，3种策略的执行效果分析如下</strong></p><ul><li>Always：可最大程度保证数据不丢失，但是每执行一次写操作命令就同步写回，不可避免对主进程造成影响</li><li>No：由操作系统决定何时将AOF日志内容写回硬盘，相对于Always策略而言其性能较好，但由于操作系统写回硬盘的时机不可预知，一旦服务器宕机，就会丢失不定数量的数据</li><li>Everysec：是一种<strong>折中方案</strong>，它避免了Always策略的性能开销，一定程度上也比No策略更能避免数据丢失。与此同时，每秒回写则意味着如果服务器发生宕机时，上一秒的写操作命令还没写回硬盘，则这部分数据会丢失</li></ul><h4 id="三种写回硬盘的策略对比"><a href="#三种写回硬盘的策略对比" class="headerlink" title="三种写回硬盘的策略对比"></a>三种写回硬盘的策略对比</h4><p>对于这三种写回硬盘的策略场景选择，主要从【高可靠】和【高性能】两者之间进行择选</p><table><thead><tr><th>写回策略</th><th>写回时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Always</td><td>同步写回</td><td>可靠性高，最大程度保证数据不丢失</td><td>每个写命令都要写回硬盘，性能开销大</td></tr><tr><td>Everysec</td><td>每秒写回</td><td>性能适中</td><td>宕机时会丢失1s内的数据</td></tr><tr><td>No</td><td>由操作系统控制写回</td><td>性能好</td><td>可靠性较差，宕机时丢失数据不定量</td></tr></tbody></table><h4 id="三种策略的实现方式"><a href="#三种策略的实现方式" class="headerlink" title="三种策略的实现方式"></a>三种策略的实现方式</h4><p>深入源码分析，实际上这三种策略只是在控制<code>fsync()</code>函数的调用时机。当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中，然后排入队列，然后由内核决定何时写入硬盘</p><p><img src="https://s2.loli.net/2025/01/05/jfTs4IA2ZcrEL7m.png" alt="image-20240718184722730.12f7f45c"></p><ul><li>Always策略：每次写入AOF文件数据之后，执行fsync()函数</li><li>Everysec策略：创建一个异步任务来执行fsync()函数</li><li>No策略：永不执行fsync()函数，由操作系统决定写入时机</li></ul><h3 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h3><blockquote><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。这时该如何解决？</p></blockquote><p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p> AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件（可以理解为新建一个文件记录当前数据库的最新键值对信息，然后用这个新的AOF文件覆盖旧文件以达到压缩的目的）</p><p> 可以结合案例分析：在没有使用重写机制前，假设前后执行了「<em>set name noob</em>」和「<em>set name noob007</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件，如果同一个key被修改多次，那么相应也会记录到对应的AOF日志。</p><p> 在引入AOF 重写机制后，就会读取每个key最新的value（最新的键值对信息），然后用一条命令例如【set key value】记录到新的AOF文件中。在重写工作完成后，就会用这个新的AOF文件覆盖现有的AOF文件，以此达到压缩AOF文件的目的。因为此处关心的是最新的键值对信息，对于key中间修改的旧命令是没有必要记录了，所以只用一条最新的键值记录来记录某个key。</p><p><img src="https://s2.loli.net/2025/01/05/1H4BIKCRSojcnwy.png" alt="image-20240718191347417.4d7ec6d9"></p><p>重写机制的设计核心在于，尽管某个键值被多次修改，最终只需要记录最新的记录将其转换为命令写入到新AOF文件中，以此减少AOF文件中命令数量，进而达到压缩文件的目的。</p><p> 此处“先写新文件后覆盖”的设计点在于尽量减少重写对现有文件的影响。因为 <strong>如果AOF 重写过程中失败了，现有的 AOF 文件就会造成污染</strong>，可能无法用于恢复使用。所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。</p><h3 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h3><p>写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。</p><p>但是在触发 AOF 重写时，比如当 AOF 文件大于 64M 时，就会对 AOF 文件进行重写，这时是需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。</p><p>这个过程其实是很耗时的，所以重写的操作不能放在主进程里。</p><p>所以，Redis 的<strong>重写 AOF 过程是由后台子进程bgrewriteaof来完成的</strong>，这么做可以达到两个好处：</p><ul><li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li><li>子进程带有主进程的数据副本（<em>数据副本怎么产生的后面会说</em>），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li></ul><p>子进程是怎么拥有主进程一样的数据副本的呢？</p><p>主进程在通过 <code>fork</code> 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p><p><img src="https://s2.loli.net/2025/01/05/cF8YbNrBLMI4RCj.png" alt="image-20250105103111670"></p><p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p><p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「**写时复制(Copy On Write)**」。</p><p>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p><p>当然，操作系统复制父进程页表的时候，父进程也是阻塞中的，不过页表的大小相比实际的物理内存小很多，所以通常复制页表的过程是比较快的。</p><p>不过，如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久。</p><p>所以，有两个阶段会导致阻塞父进程：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li></ul><p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p><p>但是子进程重写过程中，主进程依然可以正常处理命令。</p><p>如果此时<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的</strong>。</p><p>所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。</p><p>还有个问题，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p><p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><p><img src="https://s2.loli.net/2025/01/05/KmSWarZMkvtXezE.png" alt="image-20250105103235754"></p><p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p><p>在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程。</p><h4 id="AOF-重写流程核心"><a href="#AOF-重写流程核心" class="headerlink" title="AOF 重写流程核心"></a>AOF 重写流程核心</h4><p> 重写的核心在于读取最新的记录，然后写入新的AOF日志中，所有重写操作完成之后用新AOF日志覆盖掉原有的AOF日志</p><ul><li><strong>一次拷贝</strong>为了减少对主流程的影响，重写发生时，主进程会fork一个子进程，子进程和主进程共享Redis物理内存，让子进程将这些Redis数据写入重写日志</li><li>两处日志重写发生时，当有新的写入命令执行，主进程会分别写入【AOF缓冲】和【AOF重写缓冲】<ul><li>【AOF缓冲】用于保证此时发生宕机时，原来的AOF日志也是完整的，可用于恢复</li><li>【AOF重写缓冲】用于保证新的AOF文件，不会丢失最新的写入操作</li></ul></li></ul><h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><blockquote><p>AOF 通过记录每一个写操作（命令）来进行数据持久化，确保数据能精确恢复到最后一次操作。然而，这种方式带来了较大的性能开销，尤其是在频繁进行写操作和频繁磁盘 I&#x2F;O时。有没有一种方式可以将性能开销相对减少一点？</p></blockquote><p>RDB 是 Redis 的快照持久化机制，它通过定期将数据库的状态快照保存到磁盘来实现持久化。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，其区别就在于是否在「主线程」里执行：</p><ul><li>执行 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行 bgsave 命令，会创建一个子进程来生成 RDB 文件，可以<strong>避免主线程的阻塞</strong>；</li></ul><p> RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure><p> 别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。<strong>只要满足上面条件的任意一个，就会执行 bgsave</strong>，其含义分别是：</p><ul><li>900 秒之内，对数据库进行了至少 1 次修改；</li><li>300 秒之内，对数据库进行了至少 10 次修改；</li><li>60 秒之内，对数据库进行了至少 10000 次修改；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"># RDB 存储配置（配置存储路径和存储文件名称）<br>dbfilename dump.rdb<br>dir <span class="hljs-operator">/</span><span class="hljs-keyword">User</span><span class="hljs-operator">/</span>xxx<span class="hljs-operator">/</span>code<span class="hljs-operator">/</span>redis<br></code></pre></td></tr></table></figure><p> Redis 的快照是<strong>全量快照</strong>，即每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。可以认为执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><p> 通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。</p><p> RDB 快照的缺点：在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少</p><p> Redis时通过fork一个子进程的方式来进行RDB，配合写时复制技术（相当于异步执行），和主进程互不干扰，将对执行流程的影响降到最低</p><h2 id="什么时候进行持久化？"><a href="#什么时候进行持久化？" class="headerlink" title="什么时候进行持久化？"></a>什么时候进行持久化？</h2><p> Redis 持久化会在下面几种情况进行：</p><blockquote><p>方式1：主动执行命令save</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"># 执行bgsave指令<br>save<br><span class="hljs-meta"># output</span><br>Ok<br></code></pre></td></tr></table></figure><blockquote><p>方式2：主动执行命令bgsave</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"># 执行bgsave指令<br>bgsave<br><span class="hljs-meta"># output</span><br>Background saving started<br></code></pre></td></tr></table></figure><blockquote><p>方式3：达到持久化阈值</p></blockquote><p> Redis 可以配置持久化策略，达到策略就出发持久化。比较推荐的是后台save，尽可能减少对主流程的影响，当达到阈值之后，由周期函数出发持久化</p><blockquote><p>方式4：程序正常关闭的时候执行</p></blockquote><p> 在关闭时，Redis会启动一次阻塞式持久化，以记录更全的数据</p><h2 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h2><p> 对于bgsave场景：执行 bgsave 过程中，由于是交给子进程来构建 RDB 文件，主线程还是可以继续工作的，此时主线程可以修改数据吗？如果不可以修改数据的话，那这样性能一下就降低了很多。如果可以修改数据，又是如何做到呢？&#x3D;》执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的</p><p> 关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong>执行 bgsave 命令的时候，会通过 <code>fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个（写时复制这块概念可以参考上述AOF概念梳理中的后台重写机制进行复盘）</p><p> 创建 bgsave 子进程后，由于共享父进程的所有内存数据，于是就可以直接读取主线程（父进程）里的内存数据，并将数据写入到 RDB 文件。当主线程（父进程）对这些共享的内存数据也都是只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。</p><p> 但是，如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code>A&#39;</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code>A&#39;</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件</strong>。</p><blockquote><p>bgsave 的执行过程</p></blockquote><p> Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是由 bgsave 子进程在后台完成的，执行时不会阻塞主线程，这就使得主线程同时可以修改数据。</p><p> bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p><p> 所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p><p> 此外，写时复制的时候会出现这么个极端的情况。在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong>因此，针对写操作多的场景，要留意下快照过程中内存的变化，防止内存被占满了</p><h1 id="AOF-和-RDB-的互补性"><a href="#AOF-和-RDB-的互补性" class="headerlink" title="AOF 和 RDB 的互补性"></a>AOF 和 RDB 的互补性</h1><p>虽然 AOF 和 RDB 各自有优缺点，但它们在 Redis 中可以互补使用，根据不同的场景，选择合适的持久化机制来保证数据的安全性与系统性能。</p><table><thead><tr><th>特性</th><th><strong>AOF 持久化</strong></th><th><strong>RDB 持久化</strong></th></tr></thead><tbody><tr><td><strong>数据恢复精度</strong></td><td>更高，可以恢复到最后一次写操作</td><td>恢复到上一次快照时的数据，可能丢失数据</td></tr><tr><td><strong>性能开销</strong></td><td>较高，尤其是当设置了严格的 fsync 策略时</td><td>性能开销小，写入操作较快</td></tr><tr><td><strong>文件大小</strong></td><td>文件会随着写操作增加，可能变得很大</td><td>文件较小，仅包含快照数据</td></tr><tr><td><strong>适用场景</strong></td><td>高度重视数据持久化和一致性的场景（如交易系统）</td><td>适用于定期备份和对丢失部分数据容忍的场景</td></tr><tr><td><strong>恢复速度</strong></td><td>恢复速度较慢，需要重放所有写操作</td><td>恢复速度较快，直接加载 RDB 快照</td></tr><tr><td><strong>数据安全性</strong></td><td>可以配置为每秒同步一次或每次写操作同步，保障较高的数据安全性</td><td>数据丢失的风险较大，但可以定期备份以减少丢失</td></tr></tbody></table><h1 id="AOF-RDB-合体（混合持久化方案）"><a href="#AOF-RDB-合体（混合持久化方案）" class="headerlink" title="AOF &amp; RDB 合体（混合持久化方案）"></a>AOF &amp; RDB 合体（混合持久化方案）</h1><blockquote><p>为什么要引入混合持久化方案？&#x3D;》充分利用两者的优势</p></blockquote><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><ul><li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li><li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li></ul><p> 如果希望兼顾 RDB 恢复速度快的优点和 AOF 丢失数据少的优点，可以考虑将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aof-use-rdb-preamble <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><blockquote><p>混合持久化方案</p></blockquote><p> 混合持久化工作在 <strong>AOF 日志重写过程</strong>，可以理解为其在AOF重写基础上做了一些改动</p><ul><li>使用RDB持久化函数将内存数据写入到AOF文件中（数据格式是RDB格式）</li><li>重写期间新写入的命令会追加到新的AOF文件中（数据格式是AOF格式）</li><li>此时新的AOF文件就是由RDB格式和AOF格式组合成的日志文件</li></ul><p> 当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p> 使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p> 混合使用的优点在于：重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，<strong>加载的时候速度会很快</strong>。加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，此处的AOF内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong></p><p>参考博客：</p><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/2.Redis-%E5%9F%BA%E7%A1%80%E7%AF%87-04-%E6%8C%81%E4%B9%85%E5%8C%96.html#aof-rdb-%E5%90%88%E4%BD%93-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88">Redis-基础篇-④持久化 | 一人の境</a></p><p><a href="https://xiaolincoding.com/redis/storage/rdb.html#rdb-%E5%92%8C-aof-%E5%90%88%E4%BD%93">RDB 快照是怎么实现的？ | 小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁</title>
    <link href="/2023/06/20/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis/"/>
    <url>/2023/06/20/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/asd051377305/article/details/108384490">Redis分布式锁-这一篇全了解(Redisson实现分布式锁完美方案)-CSDN博客</a></p><p><a href="https://www.cnblogs.com/song-a/p/18601170">Redis分布式锁 - Song-a - 博客园</a></p><p><a href="https://www.cnblogs.com/crazymakercircle/p/14731826.html">Redis分布式锁 （图解-秒懂-史上最全） - 疯狂创客圈 - 博客园</a></p><p><a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html">Redis实现分布式锁的7种方案 - why414 - 博客园</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>独立功能</title>
    <link href="/2023/06/16/%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD-Redis/"/>
    <url>/2023/06/16/%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD-Redis/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这一部分，先给出部分参考文章，以后有时间具体完善</p></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/2.Redis-%E5%9F%BA%E7%A1%80%E7%AF%87-05-%E4%BA%8B%E5%8A%A1.html">Redis-基础篇-⑤事务 | 一人の境</a></p><p><a href="https://blog.csdn.net/weixin_43520450/article/details/107548277">Redis之事务（详细解析）_什么是redis事务-CSDN博客</a></p><p><a href="https://www.cnblogs.com/wangcp-2014/p/16194605.html">Redis进阶 - 事务：Redis事务详解 - 飘飘雪 - 博客园</a></p></blockquote><h1 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h1><blockquote><p><a href="https://lua.ac.cn/manual/5.4/">Lua 5.4 参考手册 - 目录 - Lua 编程语言</a></p><p><a href="https://blog.csdn.net/le_17_4_6/article/details/117588021">Redis 使用lua脚本最全教程_redis lua语法-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/376535035">后端程序员必备基础：Redis使用lua脚本(要收藏起来哦) - 知乎</a></p></blockquote><h1 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h1><blockquote><p><a href="https://blog.csdn.net/w15558056319/article/details/121490953">Redis进阶——发布订阅详解_redis发布订阅模式-CSDN博客</a></p><p><a href="https://www.redisio.com/manual/pubsub.html#%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%A0%BC%E5%BC%8F">Redis 发布&#x2F;订阅 - Redis 中文文档</a></p><p><a href="https://juejin.cn/post/7134591236195188744#heading-8">Redis pub&#x2F;sub 发布订阅机制原理与实战</a></p></blockquote><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote><p><a href="https://blog.csdn.net/su1573/article/details/118280719">Redis（十）：进阶篇 - 排序SORT_redis sort-CSDN博客</a></p><p><a href="https://segmentfault.com/a/1190000044789570">后端 - 深入浅出Redis（十二）：Redis的排序命令Sort - 个人文章 - SegmentFault 思否</a></p></blockquote><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><blockquote><p><a href="https://www.cnblogs.com/duanxz/p/14748386.html">Redis 慢查询日志 - duanxz - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/82256981">Redis慢查询日志 - 知乎</a></p><p><a href="https://segmentfault.com/a/1190000009915519">Redis高级功能 - 慢查询日志 - redis学习笔记 - SegmentFault 思否</a></p><p><a href="https://www.cnblogs.com/yangmingxianshen/p/8070594.html">Redis——慢查询分析 - 明王不动心 - 博客园</a></p></blockquote><h1 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h1><blockquote><p><a href="https://www.cnblogs.com/fatedeity/p/17419818.html">Redis - 二进制位数组 - 程序员翔仔 - 博客园</a></p><p><a href="https://blog.csdn.net/HouXinLin_CSDN/article/details/108506560">深入理解Redis二进制位数组_redis set二进制-CSDN博客</a></p></blockquote><h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><blockquote><p><a href="https://cloud.tencent.com/developer/article/1945300">Redis使用及源码剖析-18.Redis二进制位数组、慢查询日志和监视器实现-2021-2-3-腾讯云开发者社区-腾讯云</a></p><p>[<a href="https://blog.csdn.net/zhaoyaxuan001/article/details/84722448">Redis扫盲]—(2)独立功能—(1)监视器_redis监视器作用-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零碎知识点</title>
    <link href="/2023/05/28/mysql%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/05/28/mysql%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="MVCC机制原理"><a href="#MVCC机制原理" class="headerlink" title="MVCC机制原理"></a>MVCC机制原理</h1><p><a href="https://cloud.tencent.com/developer/article/2184720">【MySQL】MVCC原理分析 + 源码解读 – 必须说透-腾讯云开发者社区-腾讯云</a></p><p><a href="https://juejin.cn/post/7066633257781035045">深入理解MySQL的MVCC原理介绍MySQL的MVCC实现初衷（为什么要有MVCC）、实现原理（是如何实现的）、MVC - 掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入学习Python语言</title>
    <link href="/2023/05/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Python%E8%AF%AD%E8%A8%80/"/>
    <url>/2023/05/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Python%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-中单引号、双引号、三引号的区别。"><a href="#Python-中单引号、双引号、三引号的区别。" class="headerlink" title="Python 中单引号、双引号、三引号的区别。"></a><strong>Python 中单引号、双引号、三引号的区别。</strong></h1><ol><li><p>**单引号 (<code>&#39;</code>) 和双引号 (<code>&quot;</code>)**：</p><ul><li><p>它们在 Python 中是等价的，表示字符串的开始和结束。</p></li><li><p>主要区别在于当字符串中包含某种引号时，可以选择使用另一种引号来避免转义字符的使用。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">string1 = <span class="hljs-string">&#x27;This is a string.&#x27;</span><br>string2 = <span class="hljs-string">&quot;This is also a string.&quot;</span><br>string3 = <span class="hljs-string">&#x27;She said, &quot;Hello!&quot;&#x27;</span><br>string4 = <span class="hljs-string">&quot;It&#x27;s a beautiful day.&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>使用单引号或双引号都可以，通常选择根据字符串内容或个人习惯来决定。</p></li></ul></li><li><p>**三引号 (<code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code>)**：</p><ul><li><p>三引号用于表示多行字符串，也可以用于包含换行符的长文本。</p></li><li><p>这种方式允许在字符串中直接包含换行、制表符等特殊字符，而不需要使用转义字符。</p></li><li><p>也可以用于编写文档字符串（docstring），这是函数、类、模块等的文档描述。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">multiline_string = <span class="hljs-string">&#x27;&#x27;&#x27;This is a string</span><br><span class="hljs-string">that spans multiple lines.&#x27;&#x27;&#x27;</span><br><br>docstring_example = <span class="hljs-string">&quot;&quot;&quot;This is a function that does something important.</span><br><span class="hljs-string">It will take two arguments and return a result.&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="Python-直接赋值、浅拷贝和深度拷贝解析"><a href="#Python-直接赋值、浅拷贝和深度拷贝解析" class="headerlink" title="Python 直接赋值、浅拷贝和深度拷贝解析"></a>Python 直接赋值、浅拷贝和深度拷贝解析</h1><p>在 Python 中，赋值、浅拷贝和深拷贝是常见的操作，它们之间的主要区别在于它们如何处理对象中的引用关系。下面逐一解析它们的不同：</p><h3 id="1-直接赋值（赋值操作-）"><a href="#1-直接赋值（赋值操作-）" class="headerlink" title="1. 直接赋值（赋值操作 =）"></a>1. <strong>直接赋值</strong>（赋值操作 <code>=</code>）</h3><p>直接赋值是将一个对象的引用（内存地址）赋给另一个变量，而不是复制对象的内容。这意味着两个变量指向相同的对象。</p><ul><li><p><strong>行为</strong>：赋值后的两个变量指向同一个对象，修改一个变量的内容会影响另一个变量。</p></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = a  <span class="hljs-comment"># 赋值操作</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出: [99, 2, 3]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># 输出: [99, 2, 3]</span><br></code></pre></td></tr></table></figure><p>这里，a 和 b都指向同一个列表对象，修改 b 会影响 a。</p><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250119163807705.png" alt="image-20250119163807705"></p></li></ul><h3 id="2-浅拷贝（Shallow-Copy）"><a href="#2-浅拷贝（Shallow-Copy）" class="headerlink" title="2. 浅拷贝（Shallow Copy）"></a>2. <strong>浅拷贝</strong>（Shallow Copy）</h3><p>浅拷贝创建一个新的对象，但该对象内的元素仍然是原对象中元素的引用。如果原对象是一个复合对象（如列表或字典），那么浅拷贝的对象和原对象会共享内部的子对象。</p><ul><li><p><strong>行为</strong>：对外部对象的修改不会影响原对象，但对内部子对象的修改会影响原对象。</p></li><li><p><strong>常见方法</strong>：</p><ul><li><p>使用 copy模块中的 copy()</p><p> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>b = copy.copy(a)<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br>b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">77</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出: [1, 2, [77, 4]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># 输出: [99, 2, [77, 4]]</span><br></code></pre></td></tr></table></figure></li><li><p>通过对象的 <code>copy()</code> 方法（例如：<code>list.copy()</code>）。</p></li><li><p>使用切片操作（对于列表等可变序列）：<code>b = a[:]</code>。</p></li></ul><p>在这个例子中，<code>a</code> 和 <code>b</code> 是两个独立的对象，但它们共享列表中的子对象 <code>[3, 4]</code>。因此，修改子对象会影响原对象。</p><p><img src="https://s2.loli.net/2025/01/19/r3Rh2koCIBgnyTJ.png" alt="image-20250119163930602"></p></li></ul><h3 id="3-深度拷贝（Deep-Copy）"><a href="#3-深度拷贝（Deep-Copy）" class="headerlink" title="3. 深度拷贝（Deep Copy）"></a>3. <strong>深度拷贝</strong>（Deep Copy）</h3><p>深度拷贝创建一个新的对象，并递归地复制对象及其所有嵌套对象。这样，原对象和拷贝对象之间完全独立，修改任何一个对象都不会影响另一个。</p><ul><li><p><strong>行为</strong>：对外部对象和内部子对象的修改都不会影响原对象。</p></li><li><p>常见方法：</p><ul><li><p>使用 copy 模块中的 deepcopy()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>b = copy.deepcopy(a)<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br>b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">77</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出: [1, 2, [3, 4]]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># 输出: [99, 2, [77, 4]]</span><br></code></pre></td></tr></table></figure></li></ul><p>这里，a和 b是完全独立的对象，修改 b不会影响 a，包括嵌套的子对象。</p><p><img src="https://s2.loli.net/2025/01/19/plYBy3aMisUcetu.png" alt="image-20250119163942956"></p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>直接赋值</strong>：两个变量指向同一个对象，修改一个变量会影响另一个。</li><li><strong>浅拷贝</strong>：创建一个新的对象，但内部的嵌套对象仍然是原对象的引用，修改嵌套对象会影响原对象。</li><li><strong>深度拷贝</strong>：创建一个新的对象，并递归地复制所有嵌套对象，修改任何一个对象都不会影响另一个。</li></ul><h1 id="Python中的三器一闭（迭代器、生成器、装饰器、闭包）"><a href="#Python中的三器一闭（迭代器、生成器、装饰器、闭包）" class="headerlink" title="Python中的三器一闭（迭代器、生成器、装饰器、闭包）"></a>Python中的三器一闭（迭代器、生成器、装饰器、闭包）</h1><p><a href="https://blog.csdn.net/weixin_50804299/article/details/129390844">Python中的三器一闭(详细版)_python三大器知识梳理-CSDN博客</a></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>**迭代器（iterator）与可迭代对象（*<em>iterable*<em>）</em></em></p><ul><li>可以用for循环遍历的对象，都是可迭代对象。可迭代对象包含 <strong>iter</strong>() 方法。（<strong>iter</strong>()）</li><li>迭代器是可迭代的对象，它包含方法 <strong>iter</strong>() 和 <strong>next</strong>() 方法。（或者说__iter__()、<strong>next</strong>()）</li></ul><p>列表、元组、字典和集合都是可迭代的对象。它们是可迭代的容器，可以从中获取迭代器（Iterator）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;大家好&#x27;</span><br>str2 = <span class="hljs-built_in">str</span>.__iter__() <span class="hljs-comment"># 或 str2 = iter(str)</span><br><span class="hljs-built_in">print</span>(str2)     <span class="hljs-comment"># &lt;str_iterator object at 0x000001D8869CAC20&gt;</span><br><span class="hljs-built_in">print</span>(str2.__next__())  <span class="hljs-comment"># 大</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(str2))       <span class="hljs-comment"># 家</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(str2))       <span class="hljs-comment"># 好</span><br></code></pre></td></tr></table></figure><p>迭代器从第一个元素开始访问，直到访问所有元素时结束。</p><p>while循环遍历迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">iter1 = <span class="hljs-string">&#x27;大家好&#x27;</span>.__iter__()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iter1))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器的本质就是迭代器。在每次迭代时返回一个值，直到抛出 StopIteration 异常。</p><p><strong>创建生成器的方式：</strong></p><h3 id="（1）生成器函数"><a href="#（1）生成器函数" class="headerlink" title="（1）生成器函数"></a>（1）生成器函数</h3><p>使用关键字 <strong>yield</strong>，函数中出现了 <strong>yield</strong>，那该函数就是一个生成器函数；生成器函数执行的时候，并不会立即执行函数，得到的是生成器。</p><ul><li>生成器可以通过 <strong>yield</strong> 返回数据</li><li>可以分段执行函数的内容，通过 <strong>next</strong>，执行到下一个 <strong>yield</strong> 的位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;你好&#x27;</span><br><br>f = func1()<br><span class="hljs-built_in">print</span>(f)    <span class="hljs-comment"># &lt;generator object func1 at 0x0000029349D7C6D0&gt;</span><br>ret = f.__next__()  <span class="hljs-comment"># hello</span><br><span class="hljs-built_in">print</span>(ret)          <span class="hljs-comment"># 你好</span><br></code></pre></td></tr></table></figure><p>和 return 相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。</p><p>不仅如此，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func3</span>():<br>    list1 = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>        list1.append(<span class="hljs-string">f&#x27;No <span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> list1     <span class="hljs-comment"># 前面for循环执行完毕才到该行 yield，因此list1有10个元素</span><br><br>f = func3()<br><span class="hljs-built_in">print</span>(f)                <span class="hljs-comment"># &lt;generator object func3 at 0x000002B7C060DD20&gt;</span><br><span class="hljs-built_in">print</span>(f.__next__())     <span class="hljs-comment"># [&#x27;No 1&#x27;, &#x27;No 2&#x27;, &#x27;No 3&#x27;, &#x27;No 4&#x27;, &#x27;No 5&#x27;, &#x27;No 6&#x27;, &#x27;No 7&#x27;, &#x27;No 8&#x27;, &#x27;No 9&#x27;, &#x27;No 10&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="（2）生成器表达式"><a href="#（2）生成器表达式" class="headerlink" title="（2）生成器表达式"></a>（2）生成器表达式</h3><p>(表达式 for 变量 in 序列 if 条件) </p><p>列表生成式中提过，使用小括号的生成式并不是返回一个元组，而是返回一个生成器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(g)            <span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000023A9728DD20&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))      <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))      <span class="hljs-comment"># 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))      <span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>内部函数引用外部函数的变量（非全局变量），外部函数返回内部函数（返回内部函数的函数名），内部函数就是<strong>闭包</strong>函数。</p><p>所以闭包有以下特点：</p><ul><li>函数嵌套</li><li>内部函数使用外部函数的变量</li><li>外部函数返回内部函数名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">m</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(m + n)<br>    <span class="hljs-keyword">return</span> inner<br><br>func1 = outer(<span class="hljs-number">10</span>)  <span class="hljs-comment"># func1相当于inner，m=10</span><br>func1(<span class="hljs-number">20</span>)          <span class="hljs-comment"># 相当于inner(20), m=10,n=20</span><br></code></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器的本质是一个闭包。装饰器可以在不改变函数功能的基础上，给函数增加一些功能。装饰器可以让代码更简洁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">external</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):     <span class="hljs-comment"># 可以接收任意参数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br>        res = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@external</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sport</span>(<span class="hljs-params">name, addr</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> do sport <span class="hljs-subst">&#123;addr&#125;</span>&#x27;</span>)<br><br><span class="hljs-meta">@external</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">game</span>(<span class="hljs-params">hours</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;game <span class="hljs-subst">&#123;hours&#125;</span> hours&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;happy&#x27;</span><br><br>sport(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;outside&#x27;</span>)<br>game(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://s2.loli.net/2025/01/19/9x5YlOar8NHQPLA.png" alt="image-20250119185230467"></p><h1 id="python-常用数据结构高级使用"><a href="#python-常用数据结构高级使用" class="headerlink" title="python 常用数据结构高级使用"></a><strong>python 常用数据结构高级使用</strong></h1><h2 id="Python数组和列表有什么区别？"><a href="#Python数组和列表有什么区别？" class="headerlink" title="Python数组和列表有什么区别？"></a><strong>Python数组和列表有什么区别？</strong></h2><table><thead><tr><th>特性</th><th><strong>列表（List）</strong></th><th><strong>数组（Array）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>内建数据结构，无需导入模块。</td><td>需要导入 <code>array</code> 模块，存储同类型数据。</td></tr><tr><td><strong>导入</strong></td><td>不需要导入，直接使用。</td><td>需要导入 <code>array</code> 模块：<code>import array</code>。</td></tr><tr><td>元素类型</td><td><strong>可以包含不同类型的元素（异构）。</strong></td><td><strong>所有元素必须是同类型（同质）。</strong></td></tr><tr><td><strong>灵活性</strong></td><td>高，支持不同数据类型和多种操作。</td><td>相对较低，主要用于数值数据处理。</td></tr><tr><td><strong>内存效率</strong></td><td>较低，元素可以是不同类型，因此内存开销较大。</td><td>更高效，存储同类型元素，占用内存紧凑。</td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>功能和方法</strong></td><td>丰富的内置方法（如 <code>append()</code>、<code>pop()</code>、<code>remove()</code> 等）。</td><td>方法较少，主要集中在类型和内存操作。</td></tr><tr><td><strong>操作类型</strong></td><td>支持增加、删除、排序等复杂操作。</td><td>提供基本的添加和删除操作，适合简单的数值计算。</td></tr><tr><td><strong>用途</strong></td><td>一般编程，适用于存储不同类型数据。</td><td>数值计算、大规模数据处理，特别是在科学计算中。</td></tr><tr><td></td><td></td><td></td></tr><tr><td><strong>与 Numpy 关系</strong></td><td>Python 列表与 <code>numpy.ndarray</code> 不兼容。</td><td><code>array</code> 比 <code>numpy</code> 数组性能差，但可以用 <code>numpy</code> 进一步优化。</td></tr></tbody></table><h2 id="Python-列表推导式"><a href="#Python-列表推导式" class="headerlink" title="Python 列表推导式"></a><strong>Python 列表推导式</strong></h2><p><strong>列表推导式</strong>是 Python 中一种简洁的语法，用来生成新的列表。它允许你通过对一个已有的可迭代对象（如列表、元组、字符串等）进行遍历，按需对元素进行处理并生成新的列表。通过列表推导式可以更高效、更简洁地生成列表。</p><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable <span class="hljs-keyword">if</span> condition]<br></code></pre></td></tr></table></figure><ul><li><code>expression</code>：对每个元素进行处理，生成新元素。</li><li><code>item</code>：当前正在遍历的元素。</li><li><code>iterable</code>：可以遍历的对象（如列表、范围等）。</li><li><code>condition</code>（可选）：对元素的筛选条件，只有符合条件的元素才会被处理。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><ol><li><p><strong>生成一个平方数列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(squares)<br><span class="hljs-comment"># 输出: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>生成一个偶数平方数的列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">even_squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(even_squares)<br><span class="hljs-comment"># 输出: [0, 4, 16, 36, 64]</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="Python-字典推导式"><a href="#Python-字典推导式" class="headerlink" title="Python 字典推导式"></a><strong>Python 字典推导式</strong></h2><p><strong>字典推导式</strong>是 Python 中一种简洁的语法，用来生成新的字典。字典推导式的语法与列表推导式类似，但它生成的是键值对（key-value）而不是列表元素。可以通过遍历可迭代对象并指定键值对来创建新的字典。</p><h4 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;key_expression: value_expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable <span class="hljs-keyword">if</span> condition&#125;<br></code></pre></td></tr></table></figure><ul><li><code>key_expression</code>：生成字典的键。</li><li><code>value_expression</code>：生成字典的值。</li><li><code>item</code>：当前正在遍历的元素。</li><li><code>iterable</code>：可以遍历的对象。</li><li><code>condition</code>（可选）：对元素的筛选条件，只有符合条件的元素才会被处理。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><ol><li><p><strong>生成一个数值的平方作为值，数值作为键的字典：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">squares_dict = &#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br><span class="hljs-built_in">print</span>(squares_dict)<br><span class="hljs-comment"># 输出: &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>生成一个字典，键是数字，值是数字是否为偶数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">even_odd_dict = &#123;x: (<span class="hljs-string">&#x27;even&#x27;</span> <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;odd&#x27;</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br><span class="hljs-built_in">print</span>(even_odd_dict)<br><span class="hljs-comment"># 输出: &#123;0: &#x27;even&#x27;, 1: &#x27;odd&#x27;, 2: &#x27;even&#x27;, 3: &#x27;odd&#x27;, 4: &#x27;even&#x27;&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="列出python中可变数据类型和不可变数据类型，简述原理"><a href="#列出python中可变数据类型和不可变数据类型，简述原理" class="headerlink" title="列出python中可变数据类型和不可变数据类型，简述原理"></a><strong>列出python中可变数据类型和不可变数据类型，简述原理</strong></h2><p>在 Python 中，数据类型根据其是否可以被修改分为 <strong>可变数据类型（Mutable）</strong> 和 <strong>不可变数据类型（Immutable）</strong>。它们的主要区别在于对象的修改是否会影响原始数据及内存管理的方式。</p><h3 id="1-可变数据类型（Mutable-Types）"><a href="#1-可变数据类型（Mutable-Types）" class="headerlink" title="1. 可变数据类型（Mutable Types）"></a>1. <strong>可变数据类型（Mutable Types）</strong></h3><p>可变数据类型是指对象的内容可以在创建后被修改。对这些类型的对象进行修改时，Python 会在原址修改对象，而不会创建新的对象。</p><h4 id="常见的可变数据类型："><a href="#常见的可变数据类型：" class="headerlink" title="常见的可变数据类型："></a>常见的可变数据类型：</h4><ul><li><strong>列表（list）</strong>：可以修改列表中的元素，改变列表的大小（添加、删除元素）。</li><li><strong>字典（dict）</strong>：可以修改字典的键值对。</li><li><strong>集合（set）</strong>：可以修改集合的元素（添加、删除）。</li><li><strong>自定义对象</strong>：如果类中包含可变的数据结构（如列表、字典等），对象的属性可以修改。</li></ul><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ul><li><strong>内存管理</strong>：可变数据类型的对象存储在堆内存中。当对象内容发生变化时，内存地址不变，直接修改其内容。</li><li><strong>修改行为</strong>：修改可变对象时，原对象的内存地址保持不变，不会创建新对象。直接修改对象内容的同时，其他引用该对象的变量会看到变化。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可变类型 - 列表</span><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = a  <span class="hljs-comment"># a 和 b 指向同一个对象</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>  <span class="hljs-comment"># 修改 b 的元素</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出: [99, 2, 3]  # a 被改变</span><br></code></pre></td></tr></table></figure><h3 id="2-不可变数据类型（Immutable-Types）"><a href="#2-不可变数据类型（Immutable-Types）" class="headerlink" title="2. 不可变数据类型（Immutable Types）"></a>2. <strong>不可变数据类型（Immutable Types）</strong></h3><p>不可变数据类型是指对象的内容一旦创建就不能被修改。对这些类型的对象进行修改时，实际上会创建一个新的对象。</p><h4 id="常见的不可变数据类型："><a href="#常见的不可变数据类型：" class="headerlink" title="常见的不可变数据类型："></a>常见的不可变数据类型：</h4><ul><li><strong>整数（int）</strong>：整数的值一旦赋值后无法更改。</li><li><strong>浮点数（float）</strong>：浮点数一旦赋值后无法更改。</li><li><strong>字符串（str）</strong>：字符串一旦创建后，无法修改其中的字符。</li><li><strong>元组（tuple）</strong>：元组中的元素无法修改，但可以创建一个新的元组来替代。</li><li><strong>冻结集合（frozenset）</strong>：冻结集合是不可变的集合，不能修改其内容。</li><li><strong>字面量常量</strong>：如布尔值 <code>True</code> 和 <code>False</code>，以及 <code>None</code>。</li></ul><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><ul><li><strong>内存管理</strong>：不可变数据类型的对象存储在内存中时，其内容一旦创建就无法改变。如果要修改内容，Python 会创建一个新的对象，并且将原对象标记为可回收。</li><li><strong>修改行为</strong>：不可变对象一旦创建，其内容不能被改变。如果尝试改变，实际上是生成了一个新的对象，并分配给一个新的内存地址。</li></ul><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不可变类型 - 字符串</span><br>s = <span class="hljs-string">&quot;hello&quot;</span><br>t = s  <span class="hljs-comment"># s 和 t 都指向 &quot;hello&quot;</span><br>s = <span class="hljs-string">&quot;world&quot;</span>  <span class="hljs-comment"># 重新分配新的字符串给 s</span><br><span class="hljs-built_in">print</span>(s)  <span class="hljs-comment"># 输出: &quot;world&quot;</span><br><span class="hljs-built_in">print</span>(t)  <span class="hljs-comment"># 输出: &quot;hello&quot;  # t 不受 s 改变的影响</span><br></code></pre></td></tr></table></figure><h3 id="3-可变与不可变的内存管理差异"><a href="#3-可变与不可变的内存管理差异" class="headerlink" title="3. 可变与不可变的内存管理差异"></a>3. <strong>可变与不可变的内存管理差异</strong></h3><ul><li><strong>可变对象</strong>：内存中存储的是对象的引用（地址）。修改对象时，不会重新分配新的内存地址，直接修改原来的内容。因此，所有引用该对象的变量都会看到变化。</li><li><strong>不可变对象</strong>：当不可变对象被修改时，Python 会创建一个新的对象，并将新的对象分配一个新的内存地址，原来的对象会被保留，而与其关联的变量会指向新的对象。由于其不可变性，其他变量无法看到对原对象的修改。</li></ul><h2 id="阐述Python下range-函数的用法？"><a href="#阐述Python下range-函数的用法？" class="headerlink" title="阐述Python下range()函数的用法？"></a>阐述Python下range()函数的用法？</h2><h2 id="range＆xrange有什么区别？"><a href="#range＆xrange有什么区别？" class="headerlink" title="range＆xrange有什么区别？"></a><strong>range＆xrange有什么区别？</strong></h2><h2 id="字典如何删除键和合并两个字典"><a href="#字典如何删除键和合并两个字典" class="headerlink" title="字典如何删除键和合并两个字典"></a><strong>字典如何删除键和合并两个字典</strong></h2><h2 id="python实现列表去重的方法"><a href="#python实现列表去重的方法" class="headerlink" title="python实现列表去重的方法"></a><strong>python实现列表去重的方法</strong></h2><h2 id="如何将值添加到python数组？"><a href="#如何将值添加到python数组？" class="headerlink" title="如何将值添加到python数组？"></a><strong>如何将值添加到python数组？</strong></h2><h2 id="在Python中split-，sub-，subn-功能。"><a href="#在Python中split-，sub-，subn-功能。" class="headerlink" title="在Python中split()，sub()，subn()功能。"></a><strong>在Python中split()，sub()，subn()功能。</strong></h2><h2 id="如何在Python中随机化列表中的元素？"><a href="#如何在Python中随机化列表中的元素？" class="headerlink" title="如何在Python中随机化列表中的元素？"></a><strong>如何在Python中随机化列表中的元素？</strong></h2><h1 id="什么是Python中的类型转换？"><a href="#什么是Python中的类型转换？" class="headerlink" title="什么是Python中的类型转换？"></a><strong>什么是Python中的类型转换？</strong></h1><p><strong>类型转换（Type Conversion）</strong> 是将一个数据类型的值转换为另一数据类型的过程。在 Python 中，类型转换分为 <strong>显式转换</strong>（即手动转换）和 <strong>隐式转换</strong>（即自动转换）。在某些情况下，Python 会自动进行类型转换，但也可以通过显式的方式进行转换。</p><table><thead><tr><th><strong>转换函数</strong></th><th><strong>功能说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>int()</code></td><td>将数据转换为整数。</td><td><code>int(&quot;123&quot;)</code> → <code>123</code></td></tr><tr><td><code>float()</code></td><td>将数据转换为浮点数。</td><td><code>float(&quot;3.14&quot;)</code> → <code>3.14</code></td></tr><tr><td><code>str()</code></td><td>将数据转换为字符串。</td><td><code>str(123)</code> → <code>&quot;123&quot;</code></td></tr><tr><td><code>list()</code></td><td>将可迭代对象转换为列表。</td><td><code>list((1, 2, 3))</code> → <code>[1, 2, 3]</code></td></tr><tr><td><code>tuple()</code></td><td>将可迭代对象转换为元组。</td><td><code>tuple([1, 2, 3])</code> → <code>(1, 2, 3)</code></td></tr><tr><td><code>set()</code></td><td>将可迭代对象转换为集合，去除重复元素。</td><td><code>set([1, 2, 2, 3])</code> → <code>&#123;1, 2, 3&#125;</code></td></tr><tr><td><code>bool()</code></td><td>将数据转换为布尔类型。空值、零值等转换为 <code>False</code>，其余为 <code>True</code>。</td><td><code>bool(0)</code> → <code>False</code> <code>bool(&quot;hello&quot;)</code> → <code>True</code></td></tr><tr><td><code>dict()</code></td><td>将包含键值对的可迭代对象转换为字典。</td><td><code>dict([(&quot;a&quot;, 1), (&quot;b&quot;, 2)])</code> → <code>&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</code></td></tr><tr><td><code>chr()</code></td><td>将整数转换为对应的 Unicode 字符。</td><td><code>chr(97)</code> → <code>&#39;a&#39;</code></td></tr><tr><td><code>ord()</code></td><td>将字符转换为对应的 Unicode 整数。</td><td><code>ord(&#39;a&#39;)</code> → <code>97</code></td></tr><tr><td><code>bin()</code></td><td>将整数转换为二进制字符串。</td><td><code>bin(5)</code> → <code>&#39;0b101&#39;</code></td></tr><tr><td><code>hex()</code></td><td>将整数转换为十六进制字符串。</td><td><code>hex(255)</code> → <code>&#39;0xff&#39;</code></td></tr><tr><td><code>oct()</code></td><td>将整数转换为八进制字符串。</td><td><code>oct(8)</code> → <code>&#39;0o10&#39;</code></td></tr></tbody></table><h3 id="类型转换的注意事项："><a href="#类型转换的注意事项：" class="headerlink" title="*类型转换的注意事项："></a>*<em>类型转换的注意事项：</em></h3><ul><li><p><strong>从字符串转换为数字：</strong> 当字符串中包含无法转换为数字的字符时，会抛出 <code>ValueError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;abc&quot;</span>)  <span class="hljs-comment"># 错误：ValueError: invalid literal for int() with base 10: &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>浮点数到整数的转换：</strong> <code>float()</code> 转换为整数时会丢失小数部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span>(<span class="hljs-number">3.14</span>)  <span class="hljs-comment"># 输出: 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong>布尔类型转换：</strong> 例如，<code>0</code>、空字符串、空列表、<code>None</code> 都转换为 <code>False</code>，其余转换为 <code>True</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bool</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 输出: False</span><br><span class="hljs-built_in">bool</span>(<span class="hljs-string">&quot;hello&quot;</span>)  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="Python中的self是什么？"><a href="#Python中的self是什么？" class="headerlink" title="Python中的self是什么？"></a><strong>Python中的self是什么？</strong></h1><h1 id="面向对象中-new-和-init-区别"><a href="#面向对象中-new-和-init-区别" class="headerlink" title="面向对象中__new__和__init__区别"></a><strong>面向对象中__new__和__init__区别</strong></h1><h1 id="python2和python3的range（100）的区别"><a href="#python2和python3的range（100）的区别" class="headerlink" title="python2和python3的range（100）的区别"></a><strong>python2和python3的range（100）的区别</strong></h1><h1 id="什么是lambda函数？"><a href="#什么是lambda函数？" class="headerlink" title="什么是lambda函数？"></a><strong>什么是lambda函数？</strong></h1>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查询优化</title>
    <link href="/2023/05/25/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <url>/2023/05/25/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>参考博客：</p><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/1.MySQL/MySQL-%E5%8E%9F%E7%90%86%E7%AF%87-06-%E8%B0%83%E4%BC%98.html">MySQL-原理篇-⑥调优 | 一人の境</a></p><p><a href="https://segmentfault.com/a/1190000044539044">性能优化 - MySQL优化：12种提升SQL执行效率的有效方法 - 架构师技术栈 - SegmentFault 思否</a></p><p><a href="https://zhuanlan.zhihu.com/p/375828064">高mysql千万级大数据SQL查询优化几十条经验 - 知乎</a></p><p><a href="https://blog.csdn.net/weixin_41942838/article/details/111244411">MySQL性能优化：优化思路、查询优化、索引优化、存储优化、数据库结构优化、数据库结构优化_mysql查询优化,索引优化,存储优化-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/554034113">最全Mysql查询性能优化总结（超详细） - 知乎</a></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android类加载流程</title>
    <link href="/2023/05/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/05/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://wangxiaobai08.github.io/2023/05/15/Dex%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/#DexFile">Dex加载流程 - The Peak Tower</a>这篇文章中，详细探讨了dex的加载流程，而类加载的整个过程如下：</p><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th><th><strong>相关技术&#x2F;组件</strong></th></tr></thead><tbody><tr><td><strong>1. 编译与打包</strong></td><td>将 <code>.java</code> 源代码编译成 <code>.class</code> 文件，然后使用 <code>d8</code> 或 <code>dx</code> 工具将其转换为 <code>.dex</code> 文件，并打包到 APK 中。</td><td><code>d8</code>、<code>dx</code>、<code>APK</code></td></tr><tr><td><strong>2. 应用启动</strong></td><td>当应用启动时，系统加载 <code>.dex</code> 文件，准备执行其中的代码。</td><td><code>Dalvik</code>（Android 5.0 之前）、<code>ART</code>（Android 5.0 及以上）</td></tr><tr><td><strong>3. 类加载器加载</strong></td><td>使用 <code>ClassLoader</code> 加载 <code>.dex</code> 文件中的类。根据不同场景使用不同的类加载器。</td><td><code>DexClassLoader</code>、<code>PathClassLoader</code>、<code>InMemoryDexClassLoader</code>（Android 8.0 及以上）</td></tr><tr><td><strong>4. 加载与执行</strong></td><td>将 <code>.dex</code> 文件中的类加载到内存中，转换为 Java 类对象并进行执行。</td><td><code>defineClass()</code>（加载类）</td></tr><tr><td><strong>5. ART 的 AOT 编译</strong></td><td>在 ART 中，<code>.dex</code> 文件可以通过 AOT 编译预先生成机器码，提高启动性能。</td><td><code>AOT</code>（Ahead-of-Time Compilation）</td></tr><tr><td><strong>6. 动态加载支持</strong></td><td>支持动态加载额外的 <code>.dex</code> 文件，例如插件化和热更新场景。</td><td><code>DexClassLoader</code>（动态加载）</td></tr></tbody></table><p>自然的这章，我们将要讨论的是android中如何将类从.dex文件中加载到内存中，转换为 Java 类对象并进行执行。</p><p>在一个类加载之前，其类对应的dex文件已经在内存中。</p><p><img src="https://s2.loli.net/2024/12/27/YNU83osbr7j6tKQ.png" alt="image-20241227110250246"></p><hr><h1 id="android类加载过程"><a href="#android类加载过程" class="headerlink" title="android类加载过程"></a>android类加载过程</h1><p>ClassLoader类是所有类加载器的虚基类，在静态&#x2F;动态加载一个类时会首先调用此虚基类的LoadClass函数。</p><h2 id="LoadClass"><a href="#LoadClass" class="headerlink" title="LoadClass"></a>LoadClass</h2><p><img src="https://s2.loli.net/2024/10/22/S9zgVq4kNRPx2YE.png" alt="image-20241022201826940"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 第一步，检查类是否已经被加载</span><br>    Class&lt;?&gt; c = findLoadedClass(name);  <br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果类没有被加载，则继续查找</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 如果父类加载器不为 null，则尝试使用父加载器加载</span><br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                c = parent.loadClass(name, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 调用父加载器的 loadClass 方法</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c = findBootstrapClassOrNull(name);  <span class="hljs-comment">// 如果没有父加载器，则尝试查找引导类（Bootstrap Class）</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-comment">// 如果父加载器找不到该类，则会抛出 ClassNotFoundException</span><br>            <span class="hljs-comment">// 这里捕获该异常，继续处理</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果父加载器仍然没有找到该类，则调用 findClass 方法查找类</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            c = findClass(name);  <span class="hljs-comment">// 使用当前加载器查找该类</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;  <span class="hljs-comment">// 返回已加载的类，或者抛出 ClassNotFoundException</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：c &#x3D; parent.loadClass(name, false);涉及到了双亲委派机制【双亲委派机制是 Java 类加载器（<code>ClassLoader</code>）的核心机制之一，旨在确保 Java 类的加载遵循一种优先级的委派模式。其基本思想是：当前类加载器请求加载一个类时，首先会将请求委派给父类加载器，如果父类加载器无法处理，则由当前类加载器处理。这种机制有助于避免类的重复加载和冲突。】具体可参考之前文章<a href="https://wangxiaobai08.github.io/2024/12/19/%E5%88%9D%E8%AF%86JVM/">初识JVM - The Peak Tower</a></p><h3 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h3><p>因为BaseDexClassLoader继承了ClassLoader虚类，其他加载器的类基本都继承于BaseDexClassLoader类，BaseDexClassLoader类中重写了findClass方法，所以上一步会去调用BaseDexClassLoader类中的findClass方法。</p><p><img src="https://s2.loli.net/2024/10/22/8FJPWLdXoZ2qRaf.png" alt="image-20241022201923215"></p><p>从类路径中查找类，如果找不到，抛出一个带有附加信息的 <code>ClassNotFoundException</code> 异常，并将其他抑制的异常添加到这个异常中。</p><p><code>pathList.findClass</code> 是查找类的关键步骤。<code>pathList</code> 代表一个类路径，它包含了可能包含类的文件（如 <code>.dex</code> 文件）。</p><p><code>findClass</code> 方法会返回一个 <code>Class</code> 对象（如果找到类），或者返回 <code>null</code>（如果没有找到类）。</p><p>BaseDexClassLoader的findclass会继续调用DexPathList的findClass方法</p><p><img src="https://s2.loli.net/2024/12/27/oi2XVYPfSazjW7I.png" alt="image-20241227111809430"></p><p>这个 <code>findClass</code> 方法的作用是在 <code>dexElements</code> 中查找类 <code>name</code>。它遍历所有的 <code>Element</code>（每个 <code>Element</code> 通常表示一个 DEX 文件或类加载单元），尝试从中找到指定的类。如果找到，则返回该类；如果没有找到，并且在查找过程中发生了异常，它会将这些异常添加到 <code>suppressed</code> 列表中，然后返回 <code>null</code>。</p><p>Element类的findClass方法去调用loadClassBinaryName函数，</p><p><img src="https://s2.loli.net/2024/10/22/1bwDHAv2tn8feVR.png" alt="image-20241022202335209"></p><p>该方法的作用是尝试通过 <code>dexFile</code> 加载指定的类。如果 <code>dexFile</code> 不为 <code>null</code>，则通过 <code>dexFile</code> 来加载类；否则，返回 <code>null</code>。</p><h4 id="loadClassBinaryName"><a href="#loadClassBinaryName" class="headerlink" title="loadClassBinaryName"></a>loadClassBinaryName</h4><p><img src="https://s2.loli.net/2024/10/22/eQVpLgxDUlo2MYW.png" alt="image-20241022202450656"></p><p><code>loadClassBinaryName</code> 是一个公开的方法，它负责加载指定名称的类。</p><ul><li><code>name</code>：要加载的类的名称（例如 <code>com.example.MyClass</code>）。</li><li><code>loader</code>：用于加载该类的类加载器（<code>ClassLoader</code>）。</li><li><code>suppressed</code>：一个 <code>List&lt;Throwable&gt;</code> 类型的参数，用来存储抑制的异常。</li></ul><p>该方法通过 <code>defineClass</code> 方法加载类并返回 <code>Class</code> 对象。<code>defineClass</code> 是一个静态方法，它的主要任务是通过 <code>defineClassNative</code>（本地方法）定义类。</p><h5 id="defineClassNative"><a href="#defineClassNative" class="headerlink" title="defineClassNative"></a>defineClassNative</h5><p>loadClassBinaryName函数接着会调用defineClass-&gt;defineClassNative。defineClassNative函数是一个native函数在art虚拟机中实现。</p><blockquote><p>&#x2F;<a href="http://aospxref.com/android-5.0.2_r3/xref/art/">art</a>&#x2F;<a href="http://aospxref.com/android-5.0.2_r3/xref/art/runtime/">runtime</a>&#x2F;<a href="http://aospxref.com/android-5.0.2_r3/xref/art/runtime/native/">native</a>&#x2F;<a href="http://aospxref.com/android-5.0.2_r3/xref/art/runtime/native/dalvik_system_DexFile.cc">dalvik_system_DexFile.cc</a></p></blockquote><p><img src="https://s2.loli.net/2024/10/22/d2mhlM48NF7BD9y.png" alt="image-20241022203615592"></p><h2 id="DexFile-defineClassNative"><a href="#DexFile-defineClassNative" class="headerlink" title="DexFile_defineClassNative"></a>DexFile_defineClassNative</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> jclass <span class="hljs-title function_">DexFile_defineClassNative</span><span class="hljs-params">(JNIEnv* env,</span><br><span class="hljs-params">                                        jclass,</span><br><span class="hljs-params">                                        jstring javaName,</span><br><span class="hljs-params">                                        jobject javaLoader,</span><br><span class="hljs-params">                                        jobject cookie,</span><br><span class="hljs-params">                                        jobject dexFile)</span> &#123;<br>    <span class="hljs-comment">// 创建一个空的 DexFile 数组，存储后续找到的 DexFile 对象</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">const</span> DexFile*&gt; dex_files;<br>    <span class="hljs-type">const</span> OatFile* oat_file;<br><br>    <span class="hljs-comment">// 将传入的 Java cookie 转换为 DexFile 数组，并尝试找到 Oat 文件</span><br>    <span class="hljs-keyword">if</span> (!ConvertJavaArrayToDexFiles(env, cookie, <span class="hljs-comment">/*out*/</span> dex_files, <span class="hljs-comment">/*out*/</span> oat_file)) &#123;<br>        VLOG(class_linker) &lt;&lt; <span class="hljs-string">&quot;Failed to find dex_file&quot;</span>;<br>        DCHECK(env-&gt;ExceptionCheck());<br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 将传入的 Java 字符串 (类名) 转换为 C++ 字符串</span><br>    ScopedUtfChars <span class="hljs-title function_">class_name</span><span class="hljs-params">(env, javaName)</span>;<br>    <span class="hljs-keyword">if</span> (class_name.c_str() == nullptr) &#123;<br>        VLOG(class_linker) &lt;&lt; <span class="hljs-string">&quot;Failed to find class_name&quot;</span>;<br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 将类名从 &#x27;.&#x27; 格式转换为描述符格式，例如 &quot;java.lang.String&quot; -&gt; &quot;Ljava/lang/String;&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">descriptor</span><span class="hljs-params">(DotToDescriptor(class_name.c_str()))</span>;<br>    <br>    <span class="hljs-comment">// 计算类名的修改 UTF-8 哈希值，用于高效查找类</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(ComputeModifiedUtf8Hash(descriptor.c_str()))</span>;<br><br>    <span class="hljs-comment">// 遍历所有 dex 文件，查找指定描述符的类</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dex_file : dex_files) &#123;<br>        <span class="hljs-comment">// 从 dex 文件中查找类定义</span><br>        <span class="hljs-type">const</span> DexFile::ClassDef* dex_class_def =<br>            OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);<br>        <br>        <span class="hljs-comment">// 如果找到了类定义，则继续处理</span><br>        <span class="hljs-keyword">if</span> (dex_class_def != nullptr) &#123;<br>            ScopedObjectAccess <span class="hljs-title function_">soa</span><span class="hljs-params">(env)</span>;<br>            ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();<br>            <br>            <span class="hljs-comment">// 创建堆栈句柄，处理 ClassLoader 和 DexCache</span><br>            StackHandleScope&lt;1&gt; <span class="hljs-title function_">hs</span><span class="hljs-params">(soa.Self())</span>;<br>            Handle&lt;mirror::ClassLoader&gt; <span class="hljs-title function_">class_loader</span><span class="hljs-params">(</span><br><span class="hljs-params">                hs.NewHandle(soa.Decode&lt;mirror::ClassLoader&gt;(javaLoader)))</span>;<br><br>            <span class="hljs-comment">// 注册 Dex 文件，并将其关联到 ClassLoader</span><br>            ObjPtr&lt;mirror::DexCache&gt; dex_cache =<br>                class_linker-&gt;RegisterDexFile(*dex_file, class_loader.Get());<br><br>            <span class="hljs-comment">// 如果注册失败，返回 null</span><br>            <span class="hljs-keyword">if</span> (dex_cache == nullptr) &#123;<br>                <span class="hljs-comment">// OOME 或者 InternalError（可能是 dexFile 已经被不同的 class loader 注册）</span><br>                soa.Self()-&gt;AssertPendingException();<br>                <span class="hljs-keyword">return</span> nullptr;<br>            &#125;<br><br>            <span class="hljs-comment">// 使用 ClassLinker 定义类</span><br>            ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),<br>                                                                   descriptor.c_str(),<br>                                                                   hash,<br>                                                                   class_loader,<br>                                                                   *dex_file,<br>                                                                   *dex_class_def);<br><br>            <span class="hljs-comment">// 将已使用的 Dex 文件插入到 ClassLoader 中（此步骤仅对于 DexFile.loadClass API 有用）</span><br>            class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),<br>                                                       class_loader.Get());<br><br>            <span class="hljs-comment">// 如果成功定义类，返回类对象</span><br>            <span class="hljs-keyword">if</span> (result != nullptr) &#123;<br>                VLOG(class_linker) &lt;&lt; <span class="hljs-string">&quot;DexFile_defineClassNative returning &quot;</span> &lt;&lt; result<br>                                   &lt;&lt; <span class="hljs-string">&quot; for &quot;</span> &lt;&lt; class_name.c_str();<br>                <span class="hljs-keyword">return</span> soa.AddLocalReference&lt;jclass&gt;(result);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果未找到类定义，输出日志并返回 null</span><br>    VLOG(class_linker) &lt;&lt; <span class="hljs-string">&quot;Failed to find dex_class_def &quot;</span> &lt;&lt; class_name.c_str();<br>    <span class="hljs-keyword">return</span> nullptr;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="DefineClass"><a href="#DefineClass" class="headerlink" title="DefineClass"></a>DefineClass</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义并加载类，过程包括类的注册、准备和连接等步骤。</span><br><span class="hljs-type">static</span> jclass <span class="hljs-title function_">ClassLinker::DefineClass</span><span class="hljs-params">(Thread* self,</span><br><span class="hljs-params">                                       <span class="hljs-type">const</span> <span class="hljs-type">char</span>* descriptor,<span class="hljs-type">size_t</span> hash,Handle&lt;mirror::ClassLoader&gt; class_loader,<span class="hljs-type">const</span> DexFile&amp; dex_file,<span class="hljs-type">const</span> DexFile::ClassDef&amp; dex_class_def)</span> &#123;<br>    StackHandleScope&lt;3&gt; <span class="hljs-title function_">hs</span><span class="hljs-params">(self)</span>;<br>    <span class="hljs-keyword">auto</span> klass = hs.NewHandle&lt;mirror::Class&gt;(nullptr);<br><br>    <span class="hljs-comment">// 如果初始化未完成，为一些常见类（如 Object, String, Class）分配类根</span><br>    <span class="hljs-keyword">if</span> (UNLIKELY(!init_done_)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(descriptor, <span class="hljs-string">&quot;Ljava/lang/Object;&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            klass.Assign(GetClassRoot(kJavaLangObject));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(descriptor, <span class="hljs-string">&quot;Ljava/lang/Class;&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            klass.Assign(GetClassRoot(kJavaLangClass));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(descriptor, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            klass.Assign(GetClassRoot(kJavaLangString));<br>        &#125; <span class="hljs-comment">// ... (其他常见类)</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果未找到类根，则分配一个新类对象（尚未完全准备好）</span><br>    <span class="hljs-keyword">if</span> (klass == nullptr) &#123;<br>        klass.Assign(AllocClass(self, SizeOfClassWithoutEmbeddedTables(dex_file, dex_class_def)));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (UNLIKELY(klass == nullptr)) &#123;<br>        self-&gt;AssertPendingOOMException();  <span class="hljs-comment">// 内存分配失败，抛出异常</span><br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取实际的 Dex 文件和类定义</span><br>    DexFile <span class="hljs-type">const</span>* new_dex_file = nullptr;<br>    DexFile::ClassDef <span class="hljs-type">const</span>* new_class_def = nullptr;<br><br>    <span class="hljs-comment">// 调用回调函数进行类定义前的处理</span><br>    Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPreDefine(descriptor, klass, class_loader,dex_file,<br>dex_class_def,&amp;new_dex_file,&amp;new_class_def);<br>    <span class="hljs-comment">// 如果发生异常，返回 null</span><br>    <span class="hljs-keyword">if</span> (self-&gt;IsExceptionPending()) &#123;<br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    <span class="hljs-comment">// 注册 Dex 文件并将其关联到类</span><br>    ObjPtr&lt;mirror::DexCache&gt; dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());<br>    <span class="hljs-keyword">if</span> (dex_cache == nullptr) &#123;<br>        self-&gt;AssertPendingException();  <span class="hljs-comment">// 注册失败，抛出异常</span><br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    klass-&gt;SetDexCache(dex_cache);<br><br>    <span class="hljs-comment">// 设置类的相关属性</span><br>    SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());<br><br>    <span class="hljs-comment">// 对字符串类进行特殊标记</span><br>    <span class="hljs-keyword">if</span> (UNLIKELY(!init_done_) &amp;&amp; <span class="hljs-built_in">strcmp</span>(descriptor, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        klass-&gt;SetStringClass();<br>    &#125;<br><br>    <span class="hljs-comment">// 锁定类，设置初始化线程 ID 和接口表</span><br>    ObjectLock&lt;mirror::Class&gt; <span class="hljs-title function_">lock</span><span class="hljs-params">(self, klass)</span>;<br>    klass-&gt;SetClinitThreadId(self-&gt;GetTid());<br>    klass-&gt;SetIfTable(GetClassRoot(kJavaLangObject)-&gt;GetIfTable());<br><br>    <span class="hljs-comment">// 将类插入到类表中，如果已存在则返回已有类的引用</span><br>    ObjPtr&lt;mirror::Class&gt; existing = InsertClass(descriptor, klass.Get(), hash);<br>    <span class="hljs-keyword">if</span> (existing != nullptr) &#123;<br>        <span class="hljs-keyword">return</span> EnsureResolved(self, descriptor, existing);  <span class="hljs-comment">// 解决类加载冲突</span><br>    &#125;<br><br>    <span class="hljs-comment">// 加载类的字段等内容</span><br>    LoadClass(self, *new_dex_file, *new_class_def, klass);<br>    <span class="hljs-keyword">if</span> (self-&gt;IsExceptionPending()) &#123;<br>        <span class="hljs-keyword">if</span> (!klass-&gt;IsErroneous()) &#123;<br>            mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 加载失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 加载类的父类和接口</span><br>    <span class="hljs-keyword">if</span> (!LoadSuperAndInterfaces(klass, *new_dex_file)) &#123;<br>        <span class="hljs-keyword">if</span> (!klass-&gt;IsErroneous()) &#123;<br>            mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 加载失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 发布类加载事件，标记类为已加载</span><br>    Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassLoad(klass);<br><br>    <span class="hljs-comment">// 链接类，确保类是完全准备好的</span><br>    <span class="hljs-keyword">auto</span> interfaces = hs.NewHandle&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(nullptr);<br>    MutableHandle&lt;mirror::Class&gt; h_new_class = hs.NewHandle&lt;mirror::Class&gt;(nullptr);<br>    <span class="hljs-keyword">if</span> (!LinkClass(self, descriptor, klass, interfaces, &amp;h_new_class)) &#123;<br>        <span class="hljs-keyword">if</span> (!klass-&gt;IsErroneous()) &#123;<br>            mirror::Class::SetStatus(klass, mirror::Class::kStatusErrorUnresolved, self);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 链接失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 安装方法入口点（如果需要）</span><br>    <span class="hljs-keyword">if</span> (Runtime::Current()-&gt;GetInstrumentation()-&gt;AreExitStubsInstalled()) &#123;<br>        Runtime::Current()-&gt;GetInstrumentation()-&gt;InstallStubsForClass(h_new_class.Get());<br>    &#125;<br><br>    <span class="hljs-comment">// 发布类准备事件</span><br>    Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;ClassPrepare(klass, h_new_class);<br><br>    <span class="hljs-comment">// 通知 JIT 编译器有新类型加载</span><br>    jit::Jit::NewTypeLoadedIfUsingJit(h_new_class.Get());<br><br>    <span class="hljs-keyword">return</span> h_new_class.Get();  <span class="hljs-comment">// 返回已定义的类</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="LoadClass-1"><a href="#LoadClass-1" class="headerlink" title="LoadClass"></a>LoadClass</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 加载类的成员，包括字段、方法等</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ClassLinker::LoadClass</span><span class="hljs-params">(Thread* self,</span><br><span class="hljs-params">                            <span class="hljs-type">const</span> DexFile&amp; dex_file,</span><br><span class="hljs-params">                            <span class="hljs-type">const</span> DexFile::ClassDef&amp; dex_class_def,</span><br><span class="hljs-params">                            Handle&lt;mirror::Class&gt; klass)</span> &#123;<br>    <span class="hljs-comment">// 获取类的数据部分</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* class_data = dex_file.GetClassData(dex_class_def);<br>    <br>    <span class="hljs-comment">// 如果类数据为空，意味着该类没有字段或方法，可能是一个标记接口</span><br>    <span class="hljs-keyword">if</span> (class_data == nullptr) &#123;<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 不需要进一步处理</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 加载类的成员：字段、方法等</span><br>    LoadClassMembers(self, dex_file, class_data, klass);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="LoadClassMembers"><a href="#LoadClassMembers" class="headerlink" title="LoadClassMembers"></a>LoadClassMembers</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ClassLinker::LoadClassMembers</span><span class="hljs-params">(Thread* self,<span class="hljs-type">const</span> DexFile&amp; dex_file,<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* class_data,Handle&lt;mirror::Class&gt; klass)</span> &#123;<br>    <span class="hljs-comment">// 禁止线程挂起，确保字段和方法数组设置完成后再进行线程操作</span><br>    ScopedAssertNoThreadSuspension <span class="hljs-title function_">nts</span><span class="hljs-params">(__FUNCTION__)</span>;<br>    <br>    <span class="hljs-comment">// 加载静态字段</span><br>    LinearAlloc* <span class="hljs-type">const</span> allocator = GetAllocatorForClassLoader(klass-&gt;GetClassLoader());<br>    ClassDataItemIterator <span class="hljs-title function_">it</span><span class="hljs-params">(dex_file, class_data)</span>;<br>    LengthPrefixedArray&lt;ArtField&gt;* sfields = AllocArtFieldArray(self, allocator, it.NumStaticFields());<br>    <span class="hljs-type">size_t</span> num_sfields = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> last_field_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; it.HasNextStaticField(); it.Next()) &#123;<br>        <span class="hljs-type">uint32_t</span> field_idx = it.GetMemberIndex();<br>        DCHECK_GE(field_idx, last_field_idx);  <span class="hljs-comment">// 验证字段顺序</span><br>        <span class="hljs-keyword">if</span> (num_sfields == <span class="hljs-number">0</span> || LIKELY(field_idx &gt; last_field_idx)) &#123;<br>            LoadField(it, klass, &amp;sfields-&gt;At(num_sfields));<br>            ++num_sfields;<br>            last_field_idx = field_idx;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 加载实例字段</span><br>    LengthPrefixedArray&lt;ArtField&gt;* ifields = AllocArtFieldArray(self, allocator, it.NumInstanceFields());<br>    <span class="hljs-type">size_t</span> num_ifields = <span class="hljs-number">0</span>;<br>    last_field_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; it.HasNextInstanceField(); it.Next()) &#123;<br>        <span class="hljs-type">uint32_t</span> field_idx = it.GetMemberIndex();<br>        DCHECK_GE(field_idx, last_field_idx);  <span class="hljs-comment">// 验证字段顺序</span><br>        <span class="hljs-keyword">if</span> (num_ifields == <span class="hljs-number">0</span> || LIKELY(field_idx &gt; last_field_idx)) &#123;<br>            LoadField(it, klass, &amp;ifields-&gt;At(num_ifields));<br>            ++num_ifields;<br>            last_field_idx = field_idx;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查并处理字段的重复定义</span><br>    <span class="hljs-keyword">if</span> (UNLIKELY(num_sfields != it.NumStaticFields()) || UNLIKELY(num_ifields != it.NumInstanceFields())) &#123;<br>        LOG(WARNING) &lt;&lt; <span class="hljs-string">&quot;Duplicate fields in class &quot;</span> &lt;&lt; klass-&gt;PrettyDescriptor()<br>                     &lt;&lt; <span class="hljs-string">&quot; (unique static fields: &quot;</span> &lt;&lt; num_sfields &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; it.NumStaticFields()<br>                     &lt;&lt; <span class="hljs-string">&quot;, unique instance fields: &quot;</span> &lt;&lt; num_ifields &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; it.NumInstanceFields() &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">if</span> (sfields != nullptr) &#123;<br>            sfields-&gt;SetSize(num_sfields);  <span class="hljs-comment">// 调整静态字段数组的大小</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (ifields != nullptr) &#123;<br>            ifields-&gt;SetSize(num_ifields);  <span class="hljs-comment">// 调整实例字段数组的大小</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置字段数组</span><br>    klass-&gt;SetSFieldsPtr(sfields);<br>    DCHECK_EQ(klass-&gt;NumStaticFields(), num_sfields);<br>    klass-&gt;SetIFieldsPtr(ifields);<br>    DCHECK_EQ(klass-&gt;NumInstanceFields(), num_ifields);<br><br>    <span class="hljs-comment">// 加载方法</span><br>    <span class="hljs-type">bool</span> has_oat_class = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">const</span> OatFile::OatClass oat_class =<br>        (Runtime::Current()-&gt;IsStarted() &amp;&amp; !Runtime::Current()-&gt;IsAotCompiler())<br>            ? OatFile::FindOatClass(dex_file, klass-&gt;GetDexClassDefIndex(), &amp;has_oat_class)<br>            : OatFile::OatClass::Invalid();<br>    <span class="hljs-type">const</span> OatFile::OatClass* oat_class_ptr = has_oat_class ? &amp;oat_class : nullptr;<br>    klass-&gt;SetMethodsPtr(<br>        AllocArtMethodArray(self, allocator, it.NumDirectMethods() + it.NumVirtualMethods()),<br>        it.NumDirectMethods(),<br>        it.NumVirtualMethods());<br>    <br>    <span class="hljs-type">size_t</span> class_def_method_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> last_dex_method_index = DexFile::kDexNoIndex;<br>    <span class="hljs-type">size_t</span> last_class_def_method_index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 加载直接方法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; it.HasNextDirectMethod(); i++, it.Next()) &#123;<br>        ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);<br>        LoadMethod(dex_file, it, klass, method);<br>        LinkCode(this, method, oat_class_ptr, class_def_method_index);<br>        <span class="hljs-type">uint32_t</span> it_method_index = it.GetMemberIndex();<br>        <span class="hljs-keyword">if</span> (last_dex_method_index == it_method_index) &#123;<br>            <span class="hljs-comment">// 处理重复的方法</span><br>            method-&gt;SetMethodIndex(last_class_def_method_index);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            method-&gt;SetMethodIndex(class_def_method_index);<br>            last_dex_method_index = it_method_index;<br>            last_class_def_method_index = class_def_method_index;<br>        &#125;<br>        class_def_method_index++;<br>    &#125;<br><br>    <span class="hljs-comment">// 加载虚方法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; it.HasNextVirtualMethod(); i++, it.Next()) &#123;<br>        ArtMethod* method = klass-&gt;GetVirtualMethodUnchecked(i, image_pointer_size_);<br>        LoadMethod(dex_file, it, klass, method);<br>        DCHECK_EQ(class_def_method_index, it.NumDirectMethods() + i);<br>        LinkCode(this, method, oat_class_ptr, class_def_method_index);<br>        class_def_method_index++;<br>    &#125;<br>    DCHECK(!it.HasNext());<br><br>    <span class="hljs-comment">// 标记类的卡片以便垃圾回收</span><br>    Runtime::Current()-&gt;GetHeap()-&gt;WriteBarrierEveryFieldOf(klass.Get());<br>    <br>    <span class="hljs-comment">// 恢复线程挂起</span><br>    self-&gt;AllowThreadSuspension();<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>逆向(android)</category>
      
      <category>文件格式/装载链接运行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向(android)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引机制</title>
    <link href="/2023/05/16/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2023/05/16/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="索引的基本思想"><a href="#索引的基本思想" class="headerlink" title="索引的基本思想"></a>索引的基本思想</h1><p> 索引是<strong>提升查询速度的一种数据结构</strong>，可以理解为类似书的目录。索引之所以能提升查询速度，在于它在插入时对数据进行了排序（显而易见，其缺点是影响插入或者更新的性能）。有效的设计并创建索引可以提升数据库系统的整体性能，但是也要考虑索引维护带来的成本消耗。</p><table><thead><tr><th><strong>类别</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td><strong>索引的作用</strong></td><td>1. 提高查询速度，通过减少扫描的数据量，避免全表扫描。2. 加速排序和分组操作。3. 实现唯一性约束，确保数据的唯一性。</td></tr><tr><td><strong>索引结构</strong></td><td>1. <strong>B树索引</strong>：自平衡的树结构，适合常见的等值和范围查询。2. <strong>哈希索引</strong>：基于哈希表，适用于等值查询。3. <strong>全文索引</strong>：适用于文本搜索，采用倒排索引。4. <strong>空间索引</strong>：用于空间数据的索引。</td></tr><tr><td><strong>索引工作原理</strong></td><td>1. <strong>查找</strong>：通过索引快速定位数据，避免全表扫描。2. <strong>范围查询</strong>：使用B树索引，快速定位范围的起始位置并顺序扫描。3. <strong>覆盖索引</strong>：查询字段全部在索引中，直接从索引中获取数据，减少对数据表的访问。</td></tr><tr><td><strong>索引分类</strong></td><td>1. <strong>单列索引</strong>：在单一列上创建的索引。2. <strong>联合索引</strong>：多个列上创建的索引，适用于多列查询。3. <strong>唯一索引</strong>：确保索引列中的值唯一。</td></tr><tr><td><strong>优缺点</strong></td><td><strong>优点</strong>：1. 提高查询速度。2. 优化排序、分组等操作。3. 实现唯一性约束。<strong>缺点</strong>：1. 占用存储空间。2. 插入、更新、删除时性能开销较大。</td></tr><tr><td><strong>索引维护成本</strong></td><td>1. <strong>空间开销</strong>：索引会占用额外的磁盘空间。2. <strong>更新开销</strong>：插入、更新或删除数据时需要同步更新索引，增加性能开销。3. <strong>维护复杂性</strong>：随着索引数量增多，维护复杂度上升，需要定期优化。</td></tr><tr><td><strong>优化索引设计</strong></td><td>1. <strong>选择高选择性的列</strong>：索引选择性高（重复值少）时能更有效提高查询性能。2. <strong>避免过多索引</strong>：过多的索引会增加更新操作的开销。3. <strong>使用联合索引</strong>：适合多列查询的情况下，联合索引比单列索引效率更高。4. <strong>覆盖索引</strong>：尽量使用覆盖索引，避免访问数据表。</td></tr><tr><td><strong>索引的类型</strong></td><td>1. <strong>PRIMARY KEY</strong>：唯一标识每行，自动创建索引。2. <strong>UNIQUE KEY</strong>：确保列值唯一，创建唯一索引。3. <strong>INDEX</strong>：普通索引，提升查询性能。4. <strong>FULLTEXT</strong>：全文索引，支持文本检索。</td></tr><tr><td><strong>索引使用场景</strong></td><td>1. <strong>单列查询</strong>：适用于单列查询条件，尤其是大表。2. <strong>范围查询</strong>：适用于<code>BETWEEN</code>、<code>&lt;</code>、<code>&gt;</code>等条件。3. <strong>JOIN操作</strong>：在多表连接时，使用索引提高连接效率。4. <strong>排序和分组</strong>：使用索引优化<code>ORDER BY</code>和<code>GROUP BY</code>操作。</td></tr><tr><td><strong>索引的维护建议</strong></td><td>1. 定期使用<code>OPTIMIZE TABLE</code>优化表和索引。2. 对频繁更新的数据表，定期重建索引。3. 在高并发场景下，避免对同一列频繁创建索引，减少锁竞争。</td></tr></tbody></table><h1 id="索引的演化历史"><a href="#索引的演化历史" class="headerlink" title="索引的演化历史"></a>索引的演化历史</h1><blockquote><p><a href="https://www.chanmufeng.com/posts/storage/MySQL/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%9A%84%E4%B8%BB%E9%94%AE%E6%9F%A5%E8%AF%A2%E8%BF%99%E4%B9%88%E5%BF%AB.html">为什么MySQL的主键查询这么快 | 蝉沐风</a></p><p><a href="https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84">从数据页的角度看 B+ 树 | 小林coding</a></p><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/1.MySQL/MySQL-%E5%8E%9F%E7%90%86%E7%AF%87-02-%E7%B4%A2%E5%BC%95.html#_2-b-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84">MySQL-原理篇-②索引（重点） | 一人の境</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dex加载流程</title>
    <link href="/2023/05/15/Dex%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/05/15/Dex%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="DexFile"><a href="#DexFile" class="headerlink" title="DexFile"></a>DexFile</h1><p>在开始之前需要搞清楚目标才不至于在偌大的源码世界里迷失方向，既然是Dex文件加载流程，首先需要关心的即DEX文件结构在android源码中的封装调用形式：</p><p><code>DexFile</code> 是 Dalvik Executable (DEX) 文件的封装对象，代表了 Dalvik 虚拟机中可执行的 <code>.dex</code> 文件，内部包含类定义、方法、字段以及常量等信息。</p><p>DEX 文件的结构从文件头到各种表（如字符串表、类型表、方法表等）组成，每个表都通过偏移量进行索引。</p><p><img src="https://s2.loli.net/2024/12/26/4Ykev6nwpsd37P2.png" alt="image-20241226171718879"></p><p>在接下来的源码阅读中，我们需要着重关注这个结构体。</p><h1 id="ART和Dalvik"><a href="#ART和Dalvik" class="headerlink" title="ART和Dalvik"></a>ART和Dalvik</h1><p>总所周知：Dalvik 基本上在 Android 4.x 及之前的所有设备中运行，所有的 Android 应用都会在 Dalvik 虚拟机上运行。Android 5.0 之后，ART 成为默认虚拟机，但是它保持了与 Dalvik 的兼容性。大多数旧版 Dalvik 应用可以在 ART 中运行，但对于某些特定应用（尤其是依赖 Dalvik 特性的应用），可能需要额外的调整。</p><table><thead><tr><th>特性</th><th><strong>Dalvik</strong></th><th><strong>ART</strong></th></tr></thead><tbody><tr><td><strong>编译方式</strong></td><td>JIT（Just-In-Time）编译</td><td>AOT（Ahead-Of-Time）编译</td></tr><tr><td><strong>启动速度</strong></td><td>较慢（因运行时编译）</td><td>较快（因安装时编译）</td></tr><tr><td><strong>性能</strong></td><td>启动慢，但运行时逐步优化</td><td>启动快且性能较稳定，运行时优化更多</td></tr><tr><td><strong>内存使用</strong></td><td>较高（JIT 编译时占用更多内存）</td><td>较低（安装时已编译为本地机器码）</td></tr><tr><td><strong>垃圾回收</strong></td><td>标记-清除、分代垃圾回收</td><td>增量垃圾回收、并发垃圾回收</td></tr><tr><td><strong>兼容性</strong></td><td>支持旧版应用，主要在 Android 4.x 及之前使用</td><td>向后兼容 Dalvik，但需要设备支持，Android 5.0 起成为默认虚拟机</td></tr><tr><td><strong>调试支持</strong></td><td>调试工具成熟，适应 JIT 编译</td><td>需要额外的调试工具支持 AOT 编译</td></tr><tr><td><strong>跨平台优化</strong></td><td>较少优化</td><td>更多硬件架构优化，安装时针对设备进行优化</td></tr></tbody></table><p>在接下来的探究中，将分为Dalvik和ART下加载dex，</p><p>其中ART下，在 Android 5.0（Lollipop）到 Android 7.x（Nougat）之间，Android 并没有引入专门的 <code>InMemoryClassLoader</code> 类。这一期间，类加载机制主要是通过传统的 <code>ClassLoader</code> 以及 <code>DexClassLoader</code> 来加载本地或外部的 <code>.dex</code> 文件。</p><p>而在Android 8.0以后新增InMemoryDexClassLoader类加载器，继承自BaseDexClassLoader，用于加载内存中的dex文件，大致流程和DexClassLoader是差不多的，最主要的区别还是在于InMemoryDexClassLoader过程中并没有生成oat文件</p><p>故下ART下将根据版本再划分android(5-7)和android8及以上进行讨论。</p><h1 id="Dalvik下Dex加载流程"><a href="#Dalvik下Dex加载流程" class="headerlink" title="Dalvik下Dex加载流程"></a>Dalvik下Dex加载流程</h1><img src="https://s2.loli.net/2024/12/27/QLPaYJWRgM5lGNz.png" alt="image-20241227100031401" style="zoom:50%;" /><h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p><img src="https://s2.loli.net/2024/10/22/9DbcjU1TetnwZQd.png" alt="image-20241022193337296"></p><h2 id="BaseDexClassLoader-java层"><a href="#BaseDexClassLoader-java层" class="headerlink" title="BaseDexClassLoader(java层)"></a>BaseDexClassLoader(java层)</h2><p><img src="https://s2.loli.net/2024/10/22/4lZ6xOtkR35wbBa.png" alt="image-20241022193830981"></p><h3 id="DexPathList"><a href="#DexPathList" class="headerlink" title="DexPathList"></a>DexPathList</h3><p><img src="https://s2.loli.net/2024/10/22/sF84ENnGvzWhjak.png" alt="image-20241022194349357"></p><p><code>DexPathList</code> 主要用于管理 Android 应用的 <strong>DEX 文件</strong>，它通常与 <strong><code>PathClassLoader</code></strong> 和 <strong><code>DexClassLoader</code></strong> 结合使用。主要负责以下几个任务：</p><ul><li><strong>存储 DEX 文件路径</strong>：<code>DexPathList</code> 保存了所有相关的 DEX 文件（包括 APK 文件中的 DEX 文件和外部路径上的 DEX 文件）的路径。</li><li><strong>优化类加载</strong>：它通过维护 DEX 文件和对应的类的映射关系，帮助虚拟机优化类加载过程。</li><li><strong>支持多重路径和 DEX 文件加载</strong>：<code>DexPathList</code> 允许应用程序在多个路径下查找 DEX 文件，支持外部插件或多个 APK 文件的情况。</li></ul><p><code>DexPathList</code> 的构造通常依赖于一个或多个 DEX 文件路径，并将它们映射到内存中的 <code>DexFile</code> 对象。具体来说，<code>DexPathList</code> 会将每个指定路径下的 DEX 文件加载为一个 <code>DexFile</code> 对象，然后通过类加载器管理这些 <code>DexFile</code> 对象中的类。</p><h4 id="makeDexElements"><a href="#makeDexElements" class="headerlink" title="makeDexElements"></a>makeDexElements</h4><p><img src="https://s2.loli.net/2024/10/22/tqmxvVjZA5YGbMf.png" alt="image-20241022195612513"></p><ol><li>如果文件是一个目录，表示这个目录将用于查找资源（而不是加载Dex字节码）。这个目录类型的文件将被直接添加到<code>elements</code>中。</li><li>如果文件是以<code>.dex</code>后缀结尾的，它被认为是原始的<code>.dex</code>文件，直接调用<code>loadDexFile()</code>加载该文件。如果加载失败，会捕获<code>IOException</code>，并输出日志。</li><li>如果文件不是<code>.dex</code>文件，则假定它可能是压缩包文件（<code>zip</code>或<code>apk</code>）。也调用<code>loadDexFile()</code>尝试加载它，并将可能抛出的<code>IOException</code>加入到<code>suppressedExceptions</code>列表中，供后续排查问题时使用。</li><li>如果一个文件成功加载了<code>.dex</code>文件，或者它是一个压缩包文件，都会被封装成<code>Element</code>对象，并添加到<code>elements</code>列表中。</li><li>最终，该方法将所有的<code>Element</code>对象转为数组，并返回。这个数组将用于后续的类加载操作。</li></ol><p><code>makeDexElements</code> 方法的主要作用是从指定的路径（如 APK 文件的路径、外部插件的路径等）创建并返回一个 <code>DexElement</code> 数组，这个数组将被 <code>DexPathList</code> 用于加载和管理 <code>DexFile</code>（即 <code>.dex</code> 文件）。而**<code>DexElement</code>**是 <code>DexPathList</code> 中的内部类，它包含了对一个 <code>DexFile</code> 或 <code>.dex</code> 文件的引用。<code>DexElement</code> 主要负责存储单个 <code>.dex</code> 文件的路径和它对应的 <code>DexFile</code> 对象（即字节码文件）。</p><h5 id="LoadDexFile"><a href="#LoadDexFile" class="headerlink" title="LoadDexFile"></a>LoadDexFile</h5><p><img src="https://s2.loli.net/2024/10/22/K2x9F8d3hOj1Iga.png" alt="image-20241022195909286"></p><p>该方法通常用于将一个指定的 <code>.dex</code> 文件加载到内存中。加载后，<code>.dex</code> 文件的字节码和类信息会被解析并存储为 <code>DexFile</code> 对象，供系统或应用程序使用。</p><p><img src="https://s2.loli.net/2024/10/22/oEJlr9mZnbdcusH.png" alt="image-20241022200042165"></p><p>调用loadDex方法，返回DexFile对象：</p><p><img src="https://s2.loli.net/2024/10/22/yHglCDSRzvm8XhN.png" alt="image-20241022200233016"></p><p>这里有一个核心的地方，调用了openDexFile方法，然后返回一个int值</p><h6 id="openDexFile"><a href="#openDexFile" class="headerlink" title="openDexFile"></a>openDexFile</h6><p>Android 4及以下，最终调用带三个参数的native方法<code>openDexFile()</code>，但并不接受文件字节码作为参数。<strong>然而其另一个重载方法接受字节码数组作为参数传入</strong>，具体如下：</p><p><img src="https://s2.loli.net/2024/10/22/Yycrz2CtonAbSOg.png" alt="202312101628175"></p><p>Android 5~7，最终调用<code>openDexFile()</code>方法，里面会调用native方法<code>openDexFileNative()</code>，然而并不接受文件字节码作为参数。因此需要借助<code>libart.so</code>库中的<code>OpenMemory()</code>函数来实现内存加载文件字节码（需要编写native层代码实现）。</p><p><img src="https://s2.loli.net/2024/10/22/uoRvTQa3JBALwSF.png" alt="image-20241022200816916"></p><p><img src="https://s2.loli.net/2024/10/22/lTaPSI7RUbDKNzC.png" alt="image-20241022200837731"></p><p>Android 8及以上，跟Android 5~7一样的流程，但是额外多了一个用于加载内存dex的类加载器InMemoryDexClassLoader</p><h2 id="openDexFileNative-native层"><a href="#openDexFileNative-native层" class="headerlink" title="openDexFileNative(native层)"></a>openDexFileNative(native层)</h2><blockquote><p><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp#133">http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp#133</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Dalvik_dalvik_system_DexFile_openDexFileNative</span><br><span class="hljs-comment">// 1. 获取输入参数中的 sourceName 和 outputName</span><br>sourceName = dvmCreateCstrFromString(sourceNameObj);<br><span class="hljs-keyword">if</span> (outputNameObj != <span class="hljs-literal">NULL</span>)<br>    outputName = dvmCreateCstrFromString(outputNameObj);<br><span class="hljs-keyword">else</span><br>    outputName = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 2. 校验是否尝试加载引导类路径的 DEX 文件（不允许重复加载）</span><br><span class="hljs-keyword">if</span> (dvmClassPathContains(gDvm.bootClassPath, sourceName)) &#123;<br>    dvmThrowIOException(<span class="hljs-string">&quot;Re-opening BOOTCLASSPATH DEX files is not allowed&quot;</span>);<br>    <span class="hljs-built_in">free</span>(sourceName);<br>    <span class="hljs-built_in">free</span>(outputName);<br>    RETURN_VOID();<br>&#125;<br><br><span class="hljs-comment">// 3. 尝试直接加载 `.dex` 文件，若失败则尝试加载 ZIP 格式的 `.jar`</span><br><span class="hljs-keyword">if</span> (hasDexExtension(sourceName)<br>        &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, <span class="hljs-literal">false</span>) == <span class="hljs-number">0</span>) &#123;<br>    pDexOrJar = (DexOrJar*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DexOrJar));<br>    pDexOrJar-&gt;isDex = <span class="hljs-literal">true</span>;<br>    pDexOrJar-&gt;pRawDexFile = pRawDexFile;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, <span class="hljs-literal">false</span>) == <span class="hljs-number">0</span>) &#123;<br>    pDexOrJar = (DexOrJar*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DexOrJar));<br>    pDexOrJar-&gt;isDex = <span class="hljs-literal">false</span>;<br>    pDexOrJar-&gt;pJarFile = pJarFile;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dvmThrowIOException(<span class="hljs-string">&quot;unable to open DEX file&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 4. 若加载成功，将 DexOrJar 对象保存到全局表</span><br><span class="hljs-keyword">if</span> (pDexOrJar != <span class="hljs-literal">NULL</span>) &#123;<br>    pDexOrJar-&gt;fileName = sourceName;<br>    addToDexFileTable(pDexOrJar);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">free</span>(sourceName);<br>&#125;<br><br><span class="hljs-comment">// 5. 清理资源并返回结果</span><br><span class="hljs-built_in">free</span>(outputName);<br>RETURN_PTR(pDexOrJar);<br><br></code></pre></td></tr></table></figure><ul><li><strong><code>dvmCreateCstrFromString</code></strong><br>将 Java 字符串对象转为 C 字符串。</li><li><strong><code>dvmClassPathContains</code></strong><br>检查文件是否属于引导类路径，防止重复加载引发冲突。</li><li><strong><code>hasDexExtension</code></strong><br>判断文件是否以 <code>.dex</code> 结尾。</li><li><strong><code>dvmRawDexFileOpen</code> 和 <code>dvmJarFileOpen</code></strong><br>分别用于加载原生 DEX 文件和 JAR 文件中的 <code>classes.dex</code>。</li><li><strong><code>addToDexFileTable</code></strong><br>将成功加载的 <code>DexOrJar</code> 对象存储到全局表中以供后续使用。</li><li><strong><code>dvmThrowIOException</code> 和 <code>RETURN_VOID/RETURN_PTR</code></strong><br>处理异常和函数返回。</li></ul><h3 id="dvmRawDexFileOpen"><a href="#dvmRawDexFileOpen" class="headerlink" title="dvmRawDexFileOpen"></a><strong>dvmRawDexFileOpen</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 打开一个原生 DEX 文件，并尝试从缓存加载优化后的版本。</span><br><span class="hljs-comment"> * 如果缓存无效或不存在，则生成新的优化文件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dvmRawDexFileOpen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* odexOutputName,</span><br><span class="hljs-params">    RawDexFile** ppRawDexFile, <span class="hljs-type">bool</span> isBootstrap)</span><br>&#123;<br>    DvmDex* pDvmDex = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 存储 DVM 中的 DEX 文件对象</span><br>    <span class="hljs-type">char</span>* cachedName = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 缓存文件名</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;         <span class="hljs-comment">// 返回值</span><br>    <span class="hljs-type">int</span> dexFd = <span class="hljs-number">-1</span>;          <span class="hljs-comment">// 原始 DEX 文件描述符</span><br>    <span class="hljs-type">int</span> optFd = <span class="hljs-number">-1</span>;          <span class="hljs-comment">// 优化后的 DEX 文件描述符</span><br>    u4 modTime = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 文件的最后修改时间</span><br>    u4 adler32 = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 文件校验和</span><br>    <span class="hljs-type">size_t</span> fileSize = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 文件大小</span><br>    <span class="hljs-type">bool</span> newFile = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 标记是否是新缓存文件</span><br>    <span class="hljs-type">bool</span> locked = <span class="hljs-literal">false</span>;     <span class="hljs-comment">// 标记缓存文件是否加锁</span><br>    <span class="hljs-comment">// 打开源文件 (只读模式)</span><br>    dexFd = open(fileName, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (dexFd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 设置文件描述符为子进程不可继承</span><br>    dvmSetCloseOnExec(dexFd);<br>    <span class="hljs-comment">// 校验文件头的合法性，并获取校验和</span><br>    <span class="hljs-keyword">if</span> (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;Error with header for %s&quot;</span>, fileName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 获取文件的最后修改时间和大小</span><br>    <span class="hljs-keyword">if</span> (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;Error with stat for %s&quot;</span>, fileName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 生成或使用指定的缓存文件名</span><br>    <span class="hljs-keyword">if</span> (odexOutputName == <span class="hljs-literal">NULL</span>) &#123;<br>        cachedName = dexOptGenerateCacheFileName(fileName, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 根据源文件名生成缓存文件名</span><br>        <span class="hljs-keyword">if</span> (cachedName == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">goto</span> bail;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cachedName = strdup(odexOutputName); <span class="hljs-comment">// 使用指定的 odex 文件名</span><br>    &#125;<br>    ALOGV(<span class="hljs-string">&quot;dvmRawDexFileOpen: Checking cache for %s (%s)&quot;</span>, fileName, cachedName);<br>    <span class="hljs-comment">// 尝试打开缓存文件，并判断是否需要重新生成</span><br>    optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime, adler32, isBootstrap, &amp;newFile, <span class="hljs-comment">/*createIfMissing=*/</span><span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (optFd &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGI(<span class="hljs-string">&quot;Unable to open or create cache for %s (%s)&quot;</span>, fileName, cachedName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    locked = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果缓存文件是新生成的，执行优化流程</span><br>    <span class="hljs-keyword">if</span> (newFile) &#123;<br>        u8 startWhen, copyWhen, endWhen;<br>        <span class="hljs-type">off_t</span> dexOffset;<br>        <span class="hljs-comment">// 获取当前文件位置（缓存文件偏移）</span><br>        dexOffset = lseek(optFd, <span class="hljs-number">0</span>, SEEK_CUR);<br>        <span class="hljs-keyword">if</span> (dexOffset &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bail;<br>        <span class="hljs-comment">// 将源 DEX 文件内容复制到缓存文件</span><br>        startWhen = dvmGetRelativeTimeUsec();<br>        <span class="hljs-keyword">if</span> (copyFileToFile(optFd, dexFd, fileSize) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bail;<br>        copyWhen = dvmGetRelativeTimeUsec();<br>        <span class="hljs-comment">// 执行 DEX 文件优化</span><br>        <span class="hljs-keyword">if</span> (!dvmOptimizeDexFile(optFd, dexOffset, fileSize, fileName, modTime, adler32, isBootstrap)) &#123;<br>            ALOGE(<span class="hljs-string">&quot;Unable to extract+optimize DEX from &#x27;%s&#x27;&quot;</span>, fileName);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        endWhen = dvmGetRelativeTimeUsec();<br>        ALOGD(<span class="hljs-string">&quot;DEX prep &#x27;%s&#x27;: copy in %dms, rewrite %dms&quot;</span>,<br>            fileName, (<span class="hljs-type">int</span>)(copyWhen - startWhen) / <span class="hljs-number">1000</span>, (<span class="hljs-type">int</span>)(endWhen - copyWhen) / <span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-comment">// 将优化后的缓存文件映射到内存</span><br>    <span class="hljs-keyword">if</span> (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != <span class="hljs-number">0</span>) &#123;<br>        ALOGI(<span class="hljs-string">&quot;Unable to map cached %s&quot;</span>, fileName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 解锁缓存文件，允许其他进程访问</span><br>    <span class="hljs-keyword">if</span> (locked) &#123;<br>        <span class="hljs-keyword">if</span> (!dvmUnlockCachedDexFile(optFd)) &#123;<br>            ALOGE(<span class="hljs-string">&quot;Unable to unlock DEX file&quot;</span>);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        locked = <span class="hljs-literal">false</span>;<br>    &#125;<br>    ALOGV(<span class="hljs-string">&quot;Successfully opened &#x27;%s&#x27;&quot;</span>, fileName);<br>    <span class="hljs-comment">// 创建 RawDexFile 对象并返回</span><br>    *ppRawDexFile = (RawDexFile*) <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(RawDexFile));<br>    (*ppRawDexFile)-&gt;cacheFileName = cachedName;<br>    (*ppRawDexFile)-&gt;pDvmDex = pDvmDex;<br>    cachedName = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 防止资源被释放</span><br>    result = <span class="hljs-number">0</span>;<br>bail:<br>    <span class="hljs-comment">// 释放资源和关闭文件</span><br>    <span class="hljs-built_in">free</span>(cachedName);<br>    <span class="hljs-keyword">if</span> (dexFd &gt;= <span class="hljs-number">0</span>) close(dexFd);<br>    <span class="hljs-keyword">if</span> (optFd &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (locked) (<span class="hljs-type">void</span>) dvmUnlockCachedDexFile(optFd);<br>        close(optFd);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="dvmOptimizeDexFile"><a href="#dvmOptimizeDexFile" class="headerlink" title="dvmOptimizeDexFile"></a><strong>dvmOptimizeDexFile</strong></h4><p><code>dvmOptimizeDexFile</code> 是 Android 中 Dalvik 虚拟机源代码中的一个函数，主要用于优化 <code>.dex</code> 文件。优化的过程通常涉及对字节码进行某些优化，以提高执行效率。具体的优化操作由外部工具 <code>dexopt</code> 执行，<code>dvmOptimizeDexFile</code> 函数通过创建子进程来调用该工具。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">dvmOptimizeDexFile</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> dexOffset, <span class="hljs-type">long</span> dexLength,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, u4 modWhen, u4 crc, <span class="hljs-type">bool</span> isBootstrap)</span><br>&#123;<br>    <span class="hljs-comment">// 提取文件路径中的文件名部分</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* lastPart = <span class="hljs-built_in">strrchr</span>(fileName, <span class="hljs-string">&#x27;/&#x27;</span>);  <span class="hljs-comment">// 获取路径中的最后一个 &#x27;/&#x27; 字符的位置</span><br>    <span class="hljs-keyword">if</span> (lastPart != <span class="hljs-literal">NULL</span>)<br>        lastPart++;  <span class="hljs-comment">// 获取文件名（跳过路径部分）</span><br>    <span class="hljs-keyword">else</span><br>        lastPart = fileName;  <span class="hljs-comment">// 如果没有路径，则文件名就是文件本身</span><br><br>    ALOGD(<span class="hljs-string">&quot;DexOpt: --- BEGIN &#x27;%s&#x27; (bootstrap=%d) ---&quot;</span>, lastPart, isBootstrap);  <span class="hljs-comment">// 打印优化开始的日志</span><br><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">// 检查是否已经在进行优化，避免递归优化</span><br>    <span class="hljs-keyword">if</span> (gDvm.optimizing) &#123;<br>        ALOGW(<span class="hljs-string">&quot;Rejecting recursive optimization attempt on &#x27;%s&#x27;&quot;</span>, fileName);  <span class="hljs-comment">// 如果正在优化，则打印警告</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    pid = fork();  <span class="hljs-comment">// 创建子进程来执行优化任务</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 子进程执行优化</span><br>        <span class="hljs-comment">// 设置常量用于执行命令</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kUseValgrind = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* kDexOptBin = <span class="hljs-string">&quot;/bin/dexopt&quot;</span>;  <span class="hljs-comment">// dexopt 工具的路径</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* kValgrinder = <span class="hljs-string">&quot;/usr/bin/valgrind&quot;</span>;  <span class="hljs-comment">// 如果需要，调试时使用的 valgrind 路径</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFixedArgCount = <span class="hljs-number">10</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kValgrindArgCount = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxIntLen = <span class="hljs-number">12</span>;  <span class="hljs-comment">// 整数转字符串的最大长度</span><br>        <span class="hljs-type">int</span> bcpSize = dvmGetBootPathSize();  <span class="hljs-comment">// 获取引导类路径的大小</span><br>        <span class="hljs-type">int</span> argc = kFixedArgCount + bcpSize + (kValgrindArgCount * kUseValgrind);  <span class="hljs-comment">// 计算参数个数</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[argc + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 参数数组（最后一个为 NULL）</span><br>        <span class="hljs-type">char</span> values[argc][kMaxIntLen];  <span class="hljs-comment">// 存储每个参数值的数组</span><br>        <span class="hljs-type">char</span>* execFile;  <span class="hljs-comment">// 存储要执行的文件路径</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* androidRoot;  <span class="hljs-comment">// 存储 Android 根目录路径</span><br>        <span class="hljs-type">int</span> flags;  <span class="hljs-comment">// 存储优化标志</span><br><br>        <span class="hljs-comment">// 设置进程组，避免与其他进程冲突</span><br>        setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 获取 Android 根目录路径</span><br>        androidRoot = getenv(<span class="hljs-string">&quot;ANDROID_ROOT&quot;</span>);<br>        <span class="hljs-keyword">if</span> (androidRoot == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">// 如果没有设置 ANDROID_ROOT 环境变量，则使用默认路径</span><br>            ALOGW(<span class="hljs-string">&quot;ANDROID_ROOT not set, defaulting to /system&quot;</span>);<br>            androidRoot = <span class="hljs-string">&quot;/system&quot;</span>;<br>        &#125;<br>        execFile = (<span class="hljs-type">char</span>*)alloca(<span class="hljs-built_in">strlen</span>(androidRoot) + <span class="hljs-built_in">strlen</span>(kDexOptBin) + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(execFile, androidRoot);<br>        <span class="hljs-built_in">strcat</span>(execFile, kDexOptBin);  <span class="hljs-comment">// 拼接 dexopt 工具的完整路径</span><br><br>        <span class="hljs-comment">// 构建 dexopt 命令的参数</span><br>        <span class="hljs-type">int</span> curArg = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 如果启用了 valgrind 调试工具，添加相关的调试参数</span><br>        <span class="hljs-keyword">if</span> (kUseValgrind) &#123;<br>            argv[curArg++] = (<span class="hljs-type">char</span>*)kValgrinder;  <span class="hljs-comment">// valgrind 路径</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--tool=memcheck&quot;</span>;  <span class="hljs-comment">// 使用 memcheck 工具</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--leak-check=yes&quot;</span>;  <span class="hljs-comment">// 检查内存泄漏</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--leak-resolution=med&quot;</span>;  <span class="hljs-comment">// 设置内存泄漏分辨率</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--num-callers=16&quot;</span>;  <span class="hljs-comment">// 设置调用栈的深度</span><br>            assert(curArg == kValgrindArgCount);  <span class="hljs-comment">// 确保参数个数正确</span><br>        &#125;<br><br>        <span class="hljs-comment">// 添加 dexopt 的执行路径到参数中</span><br>        argv[curArg++] = execFile;<br><br>        <span class="hljs-comment">// 添加 `--dex` 参数，表示要处理一个 dex 文件</span><br>        argv[curArg++] = <span class="hljs-string">&quot;--dex&quot;</span>;<br><br>        <span class="hljs-comment">// 添加 Dalvik VM 构建版本号</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">2</span>], <span class="hljs-string">&quot;%d&quot;</span>, DALVIK_VM_BUILD);<br>        argv[curArg++] = values[<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 添加文件描述符、偏移量和长度</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%d&quot;</span>, fd);<br>        argv[curArg++] = values[<span class="hljs-number">3</span>];<br><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">4</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) dexOffset);<br>        argv[curArg++] = values[<span class="hljs-number">4</span>];<br><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">5</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) dexLength);<br>        argv[curArg++] = values[<span class="hljs-number">5</span>];<br><br>        <span class="hljs-comment">// 添加文件名路径</span><br>        argv[curArg++] = (<span class="hljs-type">char</span>*)fileName;<br><br>        <span class="hljs-comment">// 添加文件的修改时间和 CRC 值</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">7</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) modWhen);<br>        argv[curArg++] = values[<span class="hljs-number">7</span>];<br><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">8</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) crc);<br>        argv[curArg++] = values[<span class="hljs-number">8</span>];<br><br>        <span class="hljs-comment">// 设置优化和验证标志</span><br>        flags = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (gDvm.dexOptMode != OPTIMIZE_MODE_NONE) &#123;<br>            flags |= DEXOPT_OPT_ENABLED;  <span class="hljs-comment">// 启用优化</span><br>            <span class="hljs-keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)<br>                flags |= DEXOPT_OPT_ALL;  <span class="hljs-comment">// 启用所有优化</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (gDvm.classVerifyMode != VERIFY_MODE_NONE) &#123;<br>            flags |= DEXOPT_VERIFY_ENABLED;  <span class="hljs-comment">// 启用验证</span><br>            <span class="hljs-keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_ALL)<br>                flags |= DEXOPT_VERIFY_ALL;  <span class="hljs-comment">// 启用所有验证</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (isBootstrap)  <span class="hljs-comment">// 如果是引导类路径，设置标志</span><br>            flags |= DEXOPT_IS_BOOTSTRAP;<br>        <span class="hljs-keyword">if</span> (gDvm.generateRegisterMaps)  <span class="hljs-comment">// 如果需要生成寄存器映射，设置标志</span><br>            flags |= DEXOPT_GEN_REGISTER_MAPS;<br>        <br>        <span class="hljs-comment">// 添加优化标志</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">9</span>], <span class="hljs-string">&quot;%d&quot;</span>, flags);<br>        argv[curArg++] = values[<span class="hljs-number">9</span>];<br><br>        <span class="hljs-comment">// 添加引导类路径中的每个文件路径</span><br>        ClassPathEntry* cpe;<br>        <span class="hljs-keyword">for</span> (cpe = gDvm.bootClassPath; cpe-&gt;ptr != <span class="hljs-literal">NULL</span>; cpe++) &#123;<br>            argv[curArg++] = cpe-&gt;fileName;<br>        &#125;<br><br>        assert(curArg == argc);  <span class="hljs-comment">// 确保参数个数正确</span><br>        argv[curArg] = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 参数数组最后一个元素为 NULL</span><br><br>        <span class="hljs-comment">// 执行 dexopt 工具进行优化</span><br>        <span class="hljs-keyword">if</span> (kUseValgrind)<br>            execv(kValgrinder, const_cast&lt;<span class="hljs-type">char</span>**&gt;(argv));  <span class="hljs-comment">// 如果启用 valgrind 调试，执行 valgrind</span><br>        <span class="hljs-keyword">else</span><br>            execv(execFile, const_cast&lt;<span class="hljs-type">char</span>**&gt;(argv));  <span class="hljs-comment">// 执行 dexopt 工具</span><br><br>        <span class="hljs-comment">// 如果 execv 失败，打印错误信息并退出</span><br>        ALOGE(<span class="hljs-string">&quot;execv &#x27;%s&#x27;%s failed: %s&quot;</span>, execFile,<br>            kUseValgrind ? <span class="hljs-string">&quot; [valgrind]&quot;</span> : <span class="hljs-string">&quot;&quot;</span>, strerror(errno));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 父进程等待子进程完成</span><br>        ALOGV(<span class="hljs-string">&quot;DexOpt: waiting for verify+opt, pid=%d&quot;</span>, (<span class="hljs-type">int</span>) pid);<br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">pid_t</span> gotPid;<br><br>        <span class="hljs-comment">// 等待子进程完成优化</span><br>        ThreadStatus oldStatus = dvmChangeStatus(<span class="hljs-literal">NULL</span>, THREAD_VMWAIT);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            gotPid = waitpid(pid, &amp;status, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等待子进程退出</span><br>            <span class="hljs-keyword">if</span> (gotPid == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR) &#123;<br>                ALOGD(<span class="hljs-string">&quot;waitpid interrupted, retrying&quot;</span>);  <span class="hljs-comment">// 如果被中断，重新尝试</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        dvmChangeStatus(<span class="hljs-literal">NULL</span>, oldStatus);  <span class="hljs-comment">// 恢复线程状态</span><br><br>        <span class="hljs-comment">// 如果子进程成功退出，返回 true，表示优化成功</span><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == <span class="hljs-number">0</span>) &#123;<br>            ALOGD(<span class="hljs-string">&quot;DexOpt: --- END &#x27;%s&#x27; (success) ---&quot;</span>, lastPart);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则返回 false，表示优化失败</span><br>            ALOGW(<span class="hljs-string">&quot;DexOpt: --- END &#x27;%s&#x27; --- status=0x%04x, process failed&quot;</span>,<br>                lastPart, status);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="DexOpt"><a href="#DexOpt" class="headerlink" title="DexOpt"></a>DexOpt</h5><blockquote><p><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp#416">http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp#416</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/26/MAcehVTarDqkKwZ.png" alt="image-20241226152644172"></p><h6 id="fromDex"><a href="#fromDex" class="headerlink" title="fromDex"></a>fromDex</h6><p><img src="https://s2.loli.net/2024/12/26/Nca6WHpv5uzj1dx.png" alt="image-20241226155351156"></p><h6 id="dvmContinueOptimization"><a href="#dvmContinueOptimization" class="headerlink" title="dvmContinueOptimization"></a><strong>dvmContinueOptimization</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 继续优化 DEX 文件，处理字节码优化和依赖数据写入。</span><br><span class="hljs-comment"> * fd: 文件描述符</span><br><span class="hljs-comment"> * dexOffset: DEX 数据在文件中的偏移</span><br><span class="hljs-comment"> * dexLength: DEX 数据的长度</span><br><span class="hljs-comment"> * fileName: DEX 文件的路径</span><br><span class="hljs-comment"> * modWhen: 文件的最后修改时间</span><br><span class="hljs-comment"> * crc: 文件的校验和</span><br><span class="hljs-comment"> * isBootstrap: 是否为启动类加载器处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">dvmContinueOptimization</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> dexOffset, <span class="hljs-type">long</span> dexLength,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, u4 modWhen, u4 crc, <span class="hljs-type">bool</span> isBootstrap)</span><br>&#123;<br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 优化结果</span><br>    <span class="hljs-type">void</span>* mapAddr;        <span class="hljs-comment">// 文件映射地址</span><br><br>    assert(dexOffset &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 检查 DEX 文件大小是否合法</span><br>    <span class="hljs-keyword">if</span> (dexLength &lt; (<span class="hljs-type">int</span>)<span class="hljs-keyword">sizeof</span>(DexHeader)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 文件过小&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dexOffset &lt; (<span class="hljs-type">int</span>)<span class="hljs-keyword">sizeof</span>(DexOptHeader)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;没有足够空间存储优化头&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 映射整个文件以支持读写操作</span><br>    mapAddr = mmap(<span class="hljs-literal">NULL</span>, dexOffset + dexLength, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (mapAddr == MAP_FAILED) &#123;<br>        ALOGE(<span class="hljs-string">&quot;无法映射 DEX 文件: %s&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br><br>    <span class="hljs-comment">// 确定是否需要验证和优化</span><br>    <span class="hljs-type">bool</span> doVerify = (gDvm.classVerifyMode == VERIFY_MODE_ALL) ||<br>                    (gDvm.classVerifyMode == VERIFY_MODE_REMOTE &amp;&amp; !isBootstrap);<br>    <span class="hljs-type">bool</span> doOpt = (gDvm.dexOptMode == OPTIMIZE_MODE_ALL) ||<br>                 ((gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED || gDvm.dexOptMode == OPTIMIZE_MODE_FULL) &amp;&amp; doVerify);<br><br>    <span class="hljs-comment">// 重写 DEX 文件，执行字节码优化和类验证</span><br>    <span class="hljs-keyword">if</span> (!rewriteDex(((u1*)mapAddr) + dexOffset, dexLength, doVerify, doOpt, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 文件优化失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 写入依赖数据（如依赖列表和优化数据）</span><br>    <span class="hljs-type">off_t</span> depsOffset = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br>    <span class="hljs-keyword">if</span> (writeDependencies(fd, modWhen, crc) != <span class="hljs-number">0</span>) &#123;<br>        ALOGW(<span class="hljs-string">&quot;写入依赖列表失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 写入优化后的数据</span><br>    <span class="hljs-keyword">if</span> (!writeOptData(fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)) &#123;<br>        ALOGW(<span class="hljs-string">&quot;写入优化数据失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算文件校验和并更新优化头</span><br>    u4 optChecksum;<br>    <span class="hljs-keyword">if</span> (!computeFileChecksum(fd, depsOffset, lseek(fd, <span class="hljs-number">0</span>, SEEK_END) - depsOffset, &amp;optChecksum)) &#123;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br><br>    DexOptHeader optHdr;<br>    <span class="hljs-built_in">memset</span>(&amp;optHdr, <span class="hljs-number">0xff</span>, <span class="hljs-keyword">sizeof</span>(optHdr));<br>    <span class="hljs-built_in">memcpy</span>(optHdr.magic, DEX_OPT_MAGIC, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">memcpy</span>(optHdr.magic + <span class="hljs-number">4</span>, DEX_OPT_MAGIC_VERS, <span class="hljs-number">4</span>);<br>    optHdr.dexOffset = (u4)dexOffset;<br>    optHdr.dexLength = (u4)dexLength;<br>    optHdr.depsOffset = (u4)depsOffset;<br>    optHdr.checksum = optChecksum;<br>    <span class="hljs-comment">// 确保写入的数据持久化，并写入优化头</span><br>    fsync(fd);<br>    lseek(fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-keyword">if</span> (sysWriteFully(fd, &amp;optHdr, <span class="hljs-keyword">sizeof</span>(optHdr), <span class="hljs-string">&quot;DexOpt opt header&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    result = <span class="hljs-literal">true</span>;<br>bail:<br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-keyword">if</span> (mapAddr != MAP_FAILED) munmap(mapAddr, dexOffset + dexLength);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="rewriteDex"><a href="#rewriteDex" class="headerlink" title="rewriteDex()"></a><strong>rewriteDex()</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 重写 DEX 文件：执行字节序转换、类加载、验证和优化。</span><br><span class="hljs-comment"> * addr: DEX 数据起始地址</span><br><span class="hljs-comment"> * len: DEX 数据长度</span><br><span class="hljs-comment"> * doVerify: 是否执行类验证</span><br><span class="hljs-comment"> * doOpt: 是否执行字节码优化</span><br><span class="hljs-comment"> * ppClassLookup: 用于存储类查找表的指针</span><br><span class="hljs-comment"> * ppDvmDex: 用于存储 DvmDex 对象的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">rewriteDex</span><span class="hljs-params">(u1* addr, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> doVerify, <span class="hljs-type">bool</span> doOpt,</span><br><span class="hljs-params">    DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)</span><br>&#123;<br>    DexClassLookup* pClassLookup = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 类查找表</span><br>    DvmDex* pDvmDex = <span class="hljs-literal">NULL</span>;              <span class="hljs-comment">// DvmDex 对象</span><br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;                 <span class="hljs-comment">// 返回结果</span><br><br>    <span class="hljs-comment">// 如果 DEX 文件字节序错误，执行字节序转换并校验</span><br>    <span class="hljs-keyword">if</span> (dexSwapAndVerify(addr, len) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 创建 DvmDex 对象以便直接操作 DEX 文件</span><br>    <span class="hljs-keyword">if</span> (dvmDexFileOpenPartial(addr, len, &amp;pDvmDex) != <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;无法创建 DexFile&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 创建类查找表，用于快速定位类定义</span><br>    pClassLookup = dexCreateClassLookup(pDvmDex-&gt;pDexFile);<br>    <span class="hljs-keyword">if</span> (pClassLookup == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">goto</span> bail;<br>    pDvmDex-&gt;pDexFile-&gt;pClassLookup = pClassLookup;<br>    <span class="hljs-comment">// 如果不需要验证或优化，直接返回</span><br>    <span class="hljs-keyword">if</span> (!doVerify &amp;&amp; !doOpt) &#123;<br>        result = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 加载 DEX 文件中的所有类</span><br>    <span class="hljs-keyword">if</span> (!loadAllClasses(pDvmDex))<br>        <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 创建字节码优化所需的内联子表</span><br>    <span class="hljs-keyword">if</span> (!dvmCreateInlineSubsTable())<br>        <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 验证和优化 DEX 文件中的所有类</span><br>    verifyAndOptimizeClasses(pDvmDex-&gt;pDexFile, doVerify, doOpt);<br>    <span class="hljs-comment">// 根据操作模式记录日志</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msgStr = doVerify &amp;&amp; doOpt ? <span class="hljs-string">&quot;verify+opt&quot;</span> :<br>                         doVerify          ? <span class="hljs-string">&quot;verify&quot;</span> :<br>                         doOpt             ? <span class="hljs-string">&quot;opt&quot;</span> : <span class="hljs-string">&quot;???&quot;</span>;<br>    ALOGD(<span class="hljs-string">&quot;DexOpt: load %dms, %s %dms, %d bytes&quot;</span>,<br>        (<span class="hljs-type">int</span>)(dvmGetRelativeTimeUsec() - dvmGetRelativeTimeUsec()) / <span class="hljs-number">1000</span>,<br>        msgStr,<br>        (<span class="hljs-type">int</span>)(dvmGetRelativeTimeUsec() - dvmGetRelativeTimeUsec()) / <span class="hljs-number">1000</span>,<br>        gDvm.pBootLoaderAlloc-&gt;curOffset);<br><br>    result = <span class="hljs-literal">true</span>;<br>bail:<br>    <span class="hljs-comment">// 清理资源：释放类查找表和 DvmDex 对象</span><br>    <span class="hljs-keyword">if</span> (pDvmDex != <span class="hljs-literal">NULL</span>)<br>        pDvmDex-&gt;pDexFile-&gt;pClassLookup = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (ppDvmDex == <span class="hljs-literal">NULL</span> || !result) &#123;<br>        dvmDexFileFree(pDvmDex);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        *ppDvmDex = pDvmDex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ppClassLookup == <span class="hljs-literal">NULL</span> || !result) &#123;<br>        <span class="hljs-built_in">free</span>(pClassLookup);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        *ppClassLookup = pClassLookup;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="dvmDexFileOpenPartial"><a href="#dvmDexFileOpenPartial" class="headerlink" title="dvmDexFileOpenPartial"></a><strong>dvmDexFileOpenPartial</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 打开部分 DEX 文件并解析，返回一个 DvmDex 结构。</span><br><span class="hljs-comment"> * addr: DEX 数据的内存地址</span><br><span class="hljs-comment"> * len: DEX 数据的长度</span><br><span class="hljs-comment"> * ppDvmDex: 用于存储 DvmDex 对象的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dvmDexFileOpenPartial</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">int</span> len, DvmDex** ppDvmDex)</span><br>&#123;<br>    DvmDex* pDvmDex;        <span class="hljs-comment">// DvmDex 对象</span><br>    DexFile* pDexFile;      <span class="hljs-comment">// 解析得到的 DexFile 对象</span><br>    <span class="hljs-type">int</span> parseFlags = kDexParseDefault;  <span class="hljs-comment">// 解析标志</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;         <span class="hljs-comment">// 返回结果，-1 表示失败</span><br><br>    <span class="hljs-comment">// 解析 DEX 文件，得到 DexFile 对象</span><br>    pDexFile = dexFileParse((u1*)addr, len, parseFlags);<br>    <span class="hljs-keyword">if</span> (pDexFile == <span class="hljs-literal">NULL</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 解析失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 为解析后的 DexFile 分配附加结构（如类信息）</span><br>    pDvmDex = allocateAuxStructures(pDexFile);<br>    <span class="hljs-keyword">if</span> (pDvmDex == <span class="hljs-literal">NULL</span>) &#123;<br>        dexFileFree(pDexFile);  <span class="hljs-comment">// 分配失败时释放 pDexFile</span><br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 标记该 DvmDex 对象为只读映射（不做修改）</span><br>    pDvmDex-&gt;isMappedReadOnly = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 返回解析成功的 DvmDex 对象</span><br>    *ppDvmDex = pDvmDex;<br>    result = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 设置返回结果为成功</span><br>bail:<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="dexFileParse"><a href="#dexFileParse" class="headerlink" title="dexFileParse"></a><strong>dexFileParse</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 解析 DEX 文件的主要函数。</span><br><span class="hljs-comment"> * data: DEX 数据的内存地址</span><br><span class="hljs-comment"> * length: DEX 数据的长度</span><br><span class="hljs-comment"> * flags: 解析时使用的标志</span><br><span class="hljs-comment"> */</span><br>DexFile* <span class="hljs-title function_">dexFileParse</span><span class="hljs-params">(<span class="hljs-type">const</span> u1* data, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    DexFile* pDexFile = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 用于存储解析结果的 DexFile 结构</span><br>    <span class="hljs-type">const</span> DexHeader* pHeader;  <span class="hljs-comment">// DEX 文件的头部</span><br>    <span class="hljs-type">const</span> u1* magic;           <span class="hljs-comment">// 存储 DEX 魔术字符串</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;            <span class="hljs-comment">// 返回结果，默认为失败</span><br><br>    <span class="hljs-comment">// 检查文件大小是否足够容纳 DEX 文件头部</span><br>    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-keyword">sizeof</span>(DexHeader)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;文件过小，无法作为有效的 .dex 文件&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;  <span class="hljs-comment">// 文件格式错误</span><br>    &#125;<br>    <span class="hljs-comment">// 分配内存给 DexFile 结构</span><br>    pDexFile = (DexFile*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DexFile));<br>    <span class="hljs-keyword">if</span> (pDexFile == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">goto</span> bail;  <span class="hljs-comment">// 内存分配失败</span><br>    <span class="hljs-built_in">memset</span>(pDexFile, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(DexFile));<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果 DEX 文件包含优化头部，则处理该部分。</span><br><span class="hljs-comment">     * 优化头部信息会影响后续的解析过程。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(data, DEX_OPT_MAGIC, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>        magic = data;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(magic + <span class="hljs-number">4</span>, DEX_OPT_MAGIC_VERS, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>) &#123;<br>            ALOGE(<span class="hljs-string">&quot;优化版本不正确&quot;</span>);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        pDexFile-&gt;pOptHeader = (<span class="hljs-type">const</span> DexOptHeader*) data;  <span class="hljs-comment">// 设置优化头部</span><br>        ALOGV(<span class="hljs-string">&quot;优化头部有效，DEX 偏移：%d，flags：0x%02x&quot;</span>, pDexFile-&gt;pOptHeader-&gt;dexOffset, pDexFile-&gt;pOptHeader-&gt;flags);<br>        <span class="hljs-comment">// 解析优化数据</span><br>        <span class="hljs-keyword">if</span> (!dexParseOptData(data, length, pDexFile))<br>            <span class="hljs-keyword">goto</span> bail;<br>        <span class="hljs-comment">// 跳过优化头部，处理优化后的 DEX 数据</span><br>        data += pDexFile-&gt;pOptHeader-&gt;dexOffset;<br>        length -= pDexFile-&gt;pOptHeader-&gt;dexOffset;<br>        <span class="hljs-comment">// 校验文件的 DEX 长度是否符合预期</span><br>        <span class="hljs-keyword">if</span> (pDexFile-&gt;pOptHeader-&gt;dexLength &gt; length) &#123;<br>            ALOGE(<span class="hljs-string">&quot;文件被截断，存储长度与剩余长度不符&quot;</span>);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        <span class="hljs-comment">// 设置新的 DEX 数据长度</span><br>        length = pDexFile-&gt;pOptHeader-&gt;dexLength;<br>    &#125;<br>    <span class="hljs-comment">// 设置基本指针（如指向文件头部等）</span><br>    dexFileSetupBasicPointers(pDexFile, data);<br>    pHeader = pDexFile-&gt;pHeader;<br>    <span class="hljs-comment">// 检查 DEX 文件头的魔术字符串是否有效</span><br>    <span class="hljs-keyword">if</span> (!dexHasValidMagic(pHeader)) &#123;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 校验文件的校验和（ADLER32）</span><br>    <span class="hljs-keyword">if</span> (flags &amp; kDexParseVerifyChecksum) &#123;<br>        u4 adler = dexComputeChecksum(pHeader);  <span class="hljs-comment">// 计算校验和</span><br>        <span class="hljs-keyword">if</span> (adler != pHeader-&gt;checksum) &#123;  <span class="hljs-comment">// 校验失败</span><br>            ALOGE(<span class="hljs-string">&quot;校验和错误&quot;</span>);<br>            <span class="hljs-keyword">if</span> (!(flags &amp; kDexParseContinueOnError))  <span class="hljs-comment">// 根据标志决定是否继续</span><br>                <span class="hljs-keyword">goto</span> bail;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ALOGV(<span class="hljs-string">&quot;校验和验证通过&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果存在优化头部，校验其优化校验和</span><br>        <span class="hljs-type">const</span> DexOptHeader* pOptHeader = pDexFile-&gt;pOptHeader;<br>        <span class="hljs-keyword">if</span> (pOptHeader != <span class="hljs-literal">NULL</span>) &#123;<br>            adler = dexComputeOptChecksum(pOptHeader);  <span class="hljs-comment">// 计算优化校验和</span><br>            <span class="hljs-keyword">if</span> (adler != pOptHeader-&gt;checksum) &#123;  <span class="hljs-comment">// 校验失败</span><br>                ALOGE(<span class="hljs-string">&quot;优化校验和错误&quot;</span>);<br>                <span class="hljs-keyword">if</span> (!(flags &amp; kDexParseContinueOnError))  <span class="hljs-comment">// 根据标志决定是否继续</span><br>                    <span class="hljs-keyword">goto</span> bail;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ALOGV(<span class="hljs-string">&quot;优化校验和验证通过&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 校验文件大小是否匹配</span><br>    <span class="hljs-keyword">if</span> (pHeader-&gt;fileSize != length) &#123;<br>        ALOGE(<span class="hljs-string">&quot;文件大小不匹配&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!(flags &amp; kDexParseContinueOnError))  <span class="hljs-comment">// 根据标志决定是否继续</span><br>            <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 校验是否包含类定义</span><br>    <span class="hljs-keyword">if</span> (pHeader-&gt;classDefsSize == <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 文件没有类定义&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 解析成功，返回 DexFile 对象</span><br>    result = <span class="hljs-number">0</span>;<br>bail:<br>    <span class="hljs-comment">// 解析失败时，释放资源</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span> &amp;&amp; pDexFile != <span class="hljs-literal">NULL</span>) &#123;<br>        dexFileFree(pDexFile);<br>        pDexFile = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pDexFile;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="ART下Dex加载流程"><a href="#ART下Dex加载流程" class="headerlink" title="ART下Dex加载流程"></a>ART下Dex加载流程</h1><h2 id="android-5-7"><a href="#android-5-7" class="headerlink" title="android(5-7)"></a>android(5-7)</h2><h3 id="DexFile-openDexFileNative"><a href="#DexFile-openDexFileNative" class="headerlink" title="DexFile_openDexFileNative"></a>DexFile_openDexFileNative</h3><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241226155035606.png" alt="image-20241226155035606"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 尝试加载 Dex 文件  </span><br><span class="hljs-type">bool</span> success = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs, dex_files.get());<br></code></pre></td></tr></table></figure><h4 id="OpenDexFilesFromOat"><a href="#OpenDexFilesFromOat" class="headerlink" title="OpenDexFilesFromOat"></a>OpenDexFilesFromOat</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">1. 获取<span class="hljs-string">.dex</span>校验和 -&gt; 如果失败 -&gt; 设置为nullptr<br>2. 查找已打开的<span class="hljs-string">.oat</span>文件 -&gt; 如果已打开 -&gt; 使用它<br>3. 如果未找到<span class="hljs-string">.oat</span>文件:<br>   a) 锁定<span class="hljs-string">.oat</span>文件<br>   b) 查找<span class="hljs-string">.oat</span>文件<br>4. 从<span class="hljs-string">.oat</span>文件加载<span class="hljs-string">.dex</span>文件 -&gt; 如果成功 -&gt; 返回执行状态<br>5. 如果加载失败:<br>   a) 检查并生成<span class="hljs-string">.oat</span>文件<br>   b) 重新加载<span class="hljs-string">.dex</span>文件<br>6. 如果加载成功 -&gt; 返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h5 id="生成-oat"><a href="#生成-oat" class="headerlink" title="生成.oat"></a>生成.oat</h5><p><strong>这里简单介绍Dex2Oat和.oat文件</strong></p><p><code>Dex2Oat</code> 是 Android 中用于将 <code>.dex</code> 文件（Dalvik Executable）转换为 <code>.oat</code> 文件（Optimized Android Executable）的工具，它是 Android 操作系统的一部分，特别是 ART（Android Runtime）虚拟机的一部分。其主要作用是在应用程序首次安装或启动时将 <code>.dex</code> 文件转换为 ART 可执行文件 <code>.oat</code>，以便提高应用的启动速度和运行效率。<code>Dex2Oat</code> 由 Android 在启动时通过 <code>dexopt</code> 工具进行触发，通常在安装或首次运行时执行。</p><ul><li>当应用程序安装时，或者用户第一次启动应用时，Android 系统会使用 <code>Dex2Oat</code> 将 <code>.dex</code> 字节码转换为 ART 使用的 <code>.oat</code> 文件。</li><li>该转换是一次性的，也就是说，转换后的 <code>.oat</code> 文件会被缓存，并在后续的应用启动中直接使用，而不需要再进行转换。</li><li>转换过程包括对 <code>.dex</code> 字节码的优化，如方法内联、循环展开等，以提高运行时性能。</li></ul><p>而<code>.oat</code> 文件是 ART 虚拟机使用的优化过的 <code>.dex</code> 文件。它是经过 <code>Dex2Oat</code> 工具处理后生成的文件，其中包含了针对设备硬件架构优化的字节码，具体来说，它包括了：</p><ul><li>优化后的字节码。</li><li>预编译的代码和一些设备特定的信息。</li></ul><blockquote><p><code>.oat</code> 文件与 <code>.dex</code> 文件不同，<code>.dex</code> 文件是 Dalvik 虚拟机所使用的格式，而 <code>.oat</code> 文件是 ART 虚拟机的专有格式。ART 虚拟机使用 <code>.oat</code> 文件来提高应用的启动速度和运行效率，因为这些文件已经经过了针对特定设备架构的编译和优化。</p></blockquote><p>而这段代码里面初始化了一个oat的对象，然后对oat是否为空进行了检测，因为第一次调用的时候它里面肯定是空的，然后进入switch()里面执行了MakeUpToData()方法跟进去看一下</p><p><img src="https://s2.loli.net/2024/12/26/j1I7SZlUviHKtV6.png" alt="image-20241226173227337"></p><h6 id="MakeUpToData"><a href="#MakeUpToData" class="headerlink" title="MakeUpToData"></a>MakeUpToData</h6><p><img src="https://s2.loli.net/2024/12/26/uCfobliAh6k2xDs.png" alt="image-20241226173428360"></p><p>其中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据当前的 oat 文件信息、编译过滤器和类加载器上下文来判断是否需要执行 dex2oat 操作。</span><br> <span class="hljs-keyword">switch</span> (info.GetDexOptNeeded(<br>       target, profile_changed, <span class="hljs-comment">/*downgrade*/</span> <span class="hljs-literal">false</span>, class_loader_context)) &#123;<br>   <span class="hljs-comment">// 如果不需要 dex 优化，返回更新成功</span><br>   <span class="hljs-keyword">case</span> kNoDexOptNeeded:<br>     <span class="hljs-keyword">return</span> kUpdateSucceeded;<br><br>   <span class="hljs-comment">// 对于这些情况，总是从头生成 oat 文件，不进行其他检查</span><br>   <span class="hljs-keyword">case</span> kDex2OatFromScratch:<br>   <span class="hljs-keyword">case</span> kDex2OatForBootImage:<br>   <span class="hljs-keyword">case</span> kDex2OatForRelocation:<br>   <span class="hljs-keyword">case</span> kDex2OatForFilter:<br>     <span class="hljs-comment">// 生成 oat 文件并返回，不进行检查</span><br>     <span class="hljs-keyword">return</span> GenerateOatFileNoChecks(info, target, class_loader_context, error_msg);<br> &#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/26/iRftIkHoxhv7M2m.png" alt="image-20241226173705203"></p><p>进入该函数，进行了一些校验之后在下面我们可以看到有一个Dex2Oat()，这个函数名的意思很明确我们跟进去看一下</p><h6 id="Dex2Oat"><a href="#Dex2Oat" class="headerlink" title="Dex2Oat"></a>Dex2Oat</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">OatFileAssistant::Dex2Oat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; args,</span><br><span class="hljs-params">                               <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>  <span class="hljs-comment">// 获取当前的 Runtime 实例</span><br>  Runtime* runtime = Runtime::Current();<br><br>  <span class="hljs-comment">// 获取镜像文件的路径</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> image_location = ImageLocation();<br>  <span class="hljs-keyword">if</span> (image_location.empty()) &#123;<br>    *error_msg = <span class="hljs-string">&quot;No image location found for Dex2Oat.&quot;</span>;  <span class="hljs-comment">// 如果找不到镜像路径，返回错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 准备构建 dex2oat 的命令行参数</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; argv;<br>  <span class="hljs-comment">// 添加编译器可执行文件路径</span><br>  argv.push_back(runtime-&gt;GetCompilerExecutable());<br>  <span class="hljs-comment">// 如果 Java 运行时可调试，添加调试参数</span><br>  <span class="hljs-keyword">if</span> (runtime-&gt;IsJavaDebuggable()) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--debuggable&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 添加当前运行时的特性作为 dex2oat 参数</span><br>  runtime-&gt;AddCurrentRuntimeFeaturesAsDex2OatArguments(&amp;argv);<br>  <span class="hljs-comment">// 如果禁用了验证，设置编译器过滤器为 verify-none</span><br>  <span class="hljs-keyword">if</span> (!runtime-&gt;IsVerificationEnabled()) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--compiler-filter=verify-none&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 根据是否需要 relocatable，选择传递不同的运行时参数</span><br>  <span class="hljs-keyword">if</span> (runtime-&gt;MustRelocateIfPossible()) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--runtime-arg&quot;</span>);<br>    argv.push_back(<span class="hljs-string">&quot;-Xrelocate&quot;</span>);  <span class="hljs-comment">// 如果可能，进行 relocatable</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--runtime-arg&quot;</span>);<br>    argv.push_back(<span class="hljs-string">&quot;-Xnorelocate&quot;</span>);  <span class="hljs-comment">// 否则禁用 relocatable</span><br>  &#125;<br>  <span class="hljs-comment">// 如果不是目标构建，添加 --host 参数</span><br>  <span class="hljs-keyword">if</span> (!kIsTargetBuild) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--host&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 添加 boot image 的路径</span><br>  argv.push_back(<span class="hljs-string">&quot;--boot-image=&quot;</span> + image_location);<br>  <span class="hljs-comment">// 获取编译器的附加选项并加入到命令行参数中</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; compiler_options = runtime-&gt;GetCompilerOptions();<br>  argv.insert(argv.end(), compiler_options.begin(), compiler_options.end());<br>  <span class="hljs-comment">// 将传入的额外参数添加到命令行参数中</span><br>  argv.insert(argv.end(), args.begin(), args.end());<br>  <span class="hljs-comment">// 将所有的命令行参数连接成一个字符串</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">command_line</span><span class="hljs-params">(android::base::Join(argv, <span class="hljs-string">&#x27; &#x27;</span>))</span>;<br>  <span class="hljs-comment">// 执行命令并返回执行结果</span><br>  <span class="hljs-keyword">return</span> Exec(argv, error_msg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/26/x4mUZOhTseBzXD3.png" alt="image-20241226173853367"></p><h6 id="ExecAndReturnCode"><a href="#ExecAndReturnCode" class="headerlink" title="ExecAndReturnCode"></a>ExecAndReturnCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ExecAndReturnCode</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; arg_vector, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>  <span class="hljs-comment">// 将命令行参数数组转换为一个以空格分隔的字符串</span><br>  <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">command_line</span><span class="hljs-params">(android::base::Join(arg_vector, <span class="hljs-string">&#x27; &#x27;</span>))</span>;<br>  <span class="hljs-comment">// 确保命令行参数数量大于等于 1</span><br>  CHECK_GE(arg_vector.size(), <span class="hljs-number">1U</span>) &lt;&lt; command_line;<br>  <span class="hljs-comment">// 将 std::string 参数转换为 char* 数组，供 exec 系列函数使用</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* program = arg_vector[<span class="hljs-number">0</span>].c_str();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>*&gt; args;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arg_vector.size(); ++i) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; arg = arg_vector[i];<br>    <span class="hljs-type">char</span>* arg_str = const_cast&lt;<span class="hljs-type">char</span>*&gt;(arg.c_str());<br>    CHECK(arg_str != nullptr) &lt;&lt; i;  <span class="hljs-comment">// 确保每个参数都有效</span><br>    args.push_back(arg_str);<br>  &#125;<br>  args.push_back(nullptr);  <span class="hljs-comment">// execv/execve 需要以 null 指针结束参数列表</span><br>  <span class="hljs-comment">// fork 和 exec 操作</span><br>  <span class="hljs-type">pid_t</span> pid = fork();  <span class="hljs-comment">// 创建子进程</span><br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 子进程中执行</span><br>    <span class="hljs-comment">// 在 fork 和 exec 之间不能做内存分配，确保子进程环境干净</span><br>    <span class="hljs-comment">// 修改进程组，防止进程被 ProcessManager 收回</span><br>    setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 保护子进程不被 LD_LIBRARY_PATH 等环境变量的修改影响</span><br>    <span class="hljs-comment">// 使用运行时创建时的环境快照</span><br>    <span class="hljs-type">char</span>** envp = (Runtime::Current() == nullptr) ? nullptr : Runtime::Current()-&gt;GetEnvSnapshot();<br>    <span class="hljs-keyword">if</span> (envp == nullptr) &#123;<br>      <span class="hljs-comment">// 执行程序，不带额外环境变量</span><br>      execv(program, &amp;args[<span class="hljs-number">0</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 执行程序，带上环境变量</span><br>      execve(program, &amp;args[<span class="hljs-number">0</span>], envp);<br>    &#125;<br>    <span class="hljs-comment">// 如果 exec 失败，输出错误信息</span><br>    PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to execve(&quot;</span> &lt;&lt; command_line &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-comment">// 调用 _exit，避免子进程调用 atexit 钩子</span><br>    _exit(<span class="hljs-number">1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 父进程中执行</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 如果 fork 失败</span><br>      *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed to execv(%s) because fork failed: %s&quot;</span>,<br>                                command_line.c_str(), strerror(errno));<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 父进程等待子进程结束</span><br>    <span class="hljs-type">int</span> status = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">pid_t</span> got_pid = TEMP_FAILURE_RETRY(waitpid(pid, &amp;status, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (got_pid != pid) &#123;  <span class="hljs-comment">// 检查 waitpid 是否成功</span><br>      *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed after fork for execv(%s) because waitpid failed: &quot;</span><br>                                <span class="hljs-string">&quot;wanted %d, got %d: %s&quot;</span>,<br>                                command_line.c_str(), pid, got_pid, strerror(errno));<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查子进程是否正常退出</span><br>    <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>      <span class="hljs-comment">// 返回子进程的退出状态码</span><br>      <span class="hljs-keyword">return</span> WEXITSTATUS(status);<br>    &#125;<br>    <span class="hljs-comment">// 如果子进程没有正常退出，返回 -1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>进来这个函数之后，可以看到源码中创建新的进程来开始执行execve()来执行Dex2Oat的编译。</p><p><strong>在这整个流程当中如果我们把函数执行的流程进行了修改或者hook，就会导致Dex2Oat流程的结束。如果我们去强制结束这个Dex2Oat的流程是可以让DexClassLoader在第一次加载dex这个过程变得非常的快速，减省去执行Dex2Oat编译花费的时间。****如果要实现ART下的函数抽取技术，我们也就需要阻断掉Dex2Oat的流程。这就是ART下的函数抽取实现方案和Dalvik下的区别，因为在Dalvik下不存在Dex2Oat的编译流程。</strong></p><h5 id="直接重新加载-dex文件"><a href="#直接重新加载-dex文件" class="headerlink" title="直接重新加载.dex文件"></a>直接重新加载.dex文件</h5><p><img src="https://s2.loli.net/2024/12/26/keJ7Man28bSfsWB.png" alt="image-20241226160225305"></p><h6 id="Open"><a href="#Open" class="headerlink" title="Open()"></a>Open()</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>. 打开并读取文件魔数 <span class="hljs-punctuation">-&gt;</span> 如果失败 <span class="hljs-punctuation">-&gt;</span> 返回<span class="hljs-literal">false</span><br><span class="hljs-number">2</span>. 判断文件类型:<br>   a) 如果是.zip文件 <span class="hljs-punctuation">-&gt;</span> 调用 DexFile::<span class="hljs-title function_ invoke__">OpenZip</span>()<br>   b) 如果是.dex文件 <span class="hljs-punctuation">-&gt;</span> 调用 DexFile::<span class="hljs-title function_ invoke__">OpenFile</span>()<br><span class="hljs-number">3</span>. 如果成功加载.dex文件 <span class="hljs-punctuation">-&gt;</span> 将DexFile对象加入dex_files，并返回<span class="hljs-literal">true</span><br><span class="hljs-number">4</span>. 如果文件既不是.zip也不是.dex <span class="hljs-punctuation">-&gt;</span> 返回错误并返回<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>其中调用 DexFile::OpenFile()</p><p><img src="https://s2.loli.net/2024/12/26/tByco3XjExGmzUW.png" alt="image-20241226160502268"></p><h6 id="OpenFile"><a href="#OpenFile" class="headerlink" title="OpenFile()"></a>OpenFile()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> DexFile* <span class="hljs-title function_">DexFile::OpenFile</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* location, <span class="hljs-type">bool</span> verify,</span><br><span class="hljs-params">                                  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查 location 是否为空</span><br>    CHECK(location != nullptr);<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;MemMap&gt; <span class="hljs-built_in">map</span>;  <span class="hljs-comment">// 创建一个 MemMap 智能指针用于内存映射</span><br><br>    &#123;<br>        <span class="hljs-comment">// 延迟关闭文件描述符 fd</span><br>        ScopedFd <span class="hljs-title function_">delayed_close</span><span class="hljs-params">(fd)</span>;<br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">sbuf</span>;</span><br>        <span class="hljs-built_in">memset</span>(&amp;sbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sbuf));<br><br>        <span class="hljs-comment">// 2. 获取文件信息，判断文件大小及类型</span><br>        <span class="hljs-keyword">if</span> (fstat(fd, &amp;sbuf) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-comment">// 如果获取文件信息失败，返回错误信息</span><br>            *error_msg = StringPrintf(<span class="hljs-string">&quot;DexFile: fstat &#x27;%s&#x27; failed: %s&quot;</span>, location, strerror(errno));<br>            <span class="hljs-keyword">return</span> nullptr;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 判断文件是否是目录</span><br>        <span class="hljs-keyword">if</span> (S_ISDIR(sbuf.st_mode)) &#123;<br>            *error_msg = StringPrintf(<span class="hljs-string">&quot;Attempt to mmap directory &#x27;%s&#x27;&quot;</span>, location);<br>            <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 如果是目录，则返回错误</span><br>        &#125;<br><br>        <span class="hljs-type">size_t</span> length = sbuf.st_size;  <span class="hljs-comment">// 获取文件大小</span><br>        <span class="hljs-comment">// 4. 尝试将文件映射到内存</span><br>        <span class="hljs-built_in">map</span>.reset(MemMap::MapFile(length, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>, location, error_msg));<br><br>        <span class="hljs-comment">// 5. 检查内存映射是否成功</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.get() == nullptr) &#123;<br>            DCHECK(!error_msg-&gt;empty());<br>            <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 内存映射失败，返回错误</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 检查文件是否太小，无法包含有效的 Dex 文件头</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;Size() &lt; <span class="hljs-keyword">sizeof</span>(DexFile::Header)) &#123;<br>        *error_msg = StringPrintf(<br>            <span class="hljs-string">&quot;DexFile: failed to open dex file &#x27;%s&#x27; that is too short to have a header&quot;</span>, location);<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 如果文件小于 header 大小，认为它不是有效的 Dex 文件</span><br>    &#125;<br><br>    <span class="hljs-type">const</span> Header* dex_header = reinterpret_cast&lt;<span class="hljs-type">const</span> Header*&gt;(<span class="hljs-built_in">map</span>-&gt;Begin());  <span class="hljs-comment">// 获取 Dex 文件头</span><br><br>    <span class="hljs-comment">// 7. 尝试通过内存映射加载 Dex 文件</span><br>    <span class="hljs-type">const</span> DexFile* dex_file = OpenMemory(location, dex_header-&gt;checksum_, <span class="hljs-built_in">map</span>.release(), error_msg);<br>    <span class="hljs-keyword">if</span> (dex_file == nullptr) &#123;<br>        *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed to open dex file &#x27;%s&#x27; from memory: %s&quot;</span>, location,<br>                                  error_msg-&gt;c_str());<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 如果内存映射后的文件无效，返回错误</span><br>    &#125;<br><br>    <span class="hljs-comment">// 8. 如果需要验证文件，进行验证</span><br>    <span class="hljs-keyword">if</span> (verify &amp;&amp; !DexFileVerifier::Verify(dex_file, dex_file-&gt;Begin(), dex_file-&gt;Size(), location,<br>                                           error_msg)) &#123;<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 验证失败，返回错误</span><br>    &#125;<br><br>    <span class="hljs-comment">// 9. 返回加载成功的 Dex 文件</span><br>    <span class="hljs-keyword">return</span> dex_file;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="OpenMemory"><a href="#OpenMemory" class="headerlink" title="OpenMemory()"></a>OpenMemory()</h6><p><img src="https://s2.loli.net/2024/12/26/j16Vh2HeiZDEkSR.png" alt="image-20241226161042092"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> DexFile* <span class="hljs-title function_">DexFile::OpenMemory</span><span class="hljs-params">(<span class="hljs-type">const</span> byte* base,</span><br><span class="hljs-params">                                    <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                    <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; location,</span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> location_checksum,</span><br><span class="hljs-params">                                    MemMap* mem_map, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查内存对齐</span><br>    CHECK_ALIGNED(base, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 各种 Dex 文件结构体必须按 4 字节对齐</span><br>    <span class="hljs-comment">// 2. 创建新的 DexFile 对象</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(new DexFile(base, size, location, location_checksum, mem_map))</span>;<br>    <span class="hljs-comment">// 3. 初始化 DexFile</span><br>    <span class="hljs-keyword">if</span> (!dex_file-&gt;Init(error_msg)) &#123;<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 初始化失败，返回 nullptr</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> dex_file.release();  <span class="hljs-comment">// 初始化成功，释放并返回 DexFile 对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="android8以上"><a href="#android8以上" class="headerlink" title="android8以上"></a>android8以上</h2><h3 id="InMemoryDexClassLoader"><a href="#InMemoryDexClassLoader" class="headerlink" title="InMemoryDexClassLoader"></a>InMemoryDexClassLoader</h3><p><img src="https://s2.loli.net/2024/12/26/VOu2iCpNmkETaXh.png" alt="image-20241226163713231"></p><h3 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h3><p><img src="https://s2.loli.net/2024/12/26/f853BPYdhRMqtkH.png" alt="image-20241226164213816"></p><h4 id="DexPathList-1"><a href="#DexPathList-1" class="headerlink" title="DexPathList"></a>DexPathList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DexPathList</span><span class="hljs-params">(ClassLoader definingContext, ByteBuffer[] dexFiles)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查 definingContext 是否为 null</span><br>    <span class="hljs-keyword">if</span> (definingContext == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;definingContext == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2. 检查 dexFiles 是否为 null</span><br>    <span class="hljs-keyword">if</span> (dexFiles == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;dexFiles == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3. 检查 dexFiles 数组是否包含 null 元素</span><br>    <span class="hljs-keyword">if</span> (Arrays.stream(dexFiles).anyMatch(v -&gt; v == <span class="hljs-literal">null</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;dexFiles contains a null Buffer!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4. 初始化 definingContext</span><br>    <span class="hljs-built_in">this</span>.definingContext = definingContext;<br>    <span class="hljs-comment">// 5. 初始化 nativeLibraryDirectories 为一个空的列表</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 可能需要处理内存中的 dex 文件路径和本地库的关系</span><br>    <span class="hljs-built_in">this</span>.nativeLibraryDirectories = Collections.emptyList();<br>    <span class="hljs-comment">// 6. 获取并分割系统的本地库路径</span><br>    <span class="hljs-built_in">this</span>.systemNativeLibraryDirectories = <br>        splitPaths(System.getProperty(<span class="hljs-string">&quot;java.library.path&quot;</span>), <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 7. 创建本地库路径元素</span><br>    <span class="hljs-built_in">this</span>.nativeLibraryPathElements = makePathElements(<span class="hljs-built_in">this</span>.systemNativeLibraryDirectories);<br>    <span class="hljs-comment">// 8. 初始化 suppressedExceptions 用于存储抑制的 IO 异常</span><br>    ArrayList&lt;IOException&gt; suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IOException&gt;();<br>    <span class="hljs-comment">// 9. 创建 dex 元素，并将可能发生的异常记录到 suppressedExceptions 中</span><br>    <span class="hljs-built_in">this</span>.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);<br>    <span class="hljs-comment">// 10. 如果有抑制的异常，保存它们</span><br>    <span class="hljs-keyword">if</span> (suppressedExceptions.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.dexElementsSuppressedExceptions = <br>            suppressedExceptions.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>[suppressedExceptions.size()]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.dexElementsSuppressedExceptions = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="makeInMemoryDexElements"><a href="#makeInMemoryDexElements" class="headerlink" title="makeInMemoryDexElements"></a>makeInMemoryDexElements</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List&lt;IOException&gt; suppressedExceptions) &#123;<br>    <span class="hljs-comment">// 1. 初始化一个长度为 dexFiles 数组长度的 Element 数组</span><br>    Element[] elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>[dexFiles.length];<br>    <br>    <span class="hljs-comment">// 2. 初始化当前位置索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">elementPos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 3. 遍历 dexFiles 数组中的每个 ByteBuffer</span><br>    <span class="hljs-keyword">for</span> (ByteBuffer buf : dexFiles) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 4. 尝试通过 ByteBuffer 加载 DexFile</span><br>            <span class="hljs-type">DexFile</span> <span class="hljs-variable">dex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexFile</span>(buf);<br>            <span class="hljs-comment">// 5. 创建 Element 实例并加入到 elements 数组中</span><br>            elements[elementPos++] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>(dex);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException suppressed) &#123;<br>            <span class="hljs-comment">// 6. 如果加载 DexFile 时发生 IOException，将异常记录到 suppressedExceptions 中</span><br>            System.logE(<span class="hljs-string">&quot;Unable to load dex file: &quot;</span> + buf, suppressed);<br>            suppressedExceptions.add(suppressed);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 7. 如果成功加载的元素数量少于 dexFiles 数组的长度，调整 elements 数组的大小</span><br>    <span class="hljs-keyword">if</span> (elementPos != elements.length) &#123;<br>        elements = Arrays.copyOf(elements, elementPos);<br>    &#125;<br>    <span class="hljs-comment">// 8. 返回创建的 Element 数组</span><br>    <span class="hljs-keyword">return</span> elements;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="DexFile-1"><a href="#DexFile-1" class="headerlink" title="DexFile"></a>DexFile</h5><p><img src="https://s2.loli.net/2024/12/26/FY1RJeSbmKzTMo8.png" alt="image-20241226164655932"></p><h6 id="openInMemoryDexFile"><a href="#openInMemoryDexFile" class="headerlink" title="openInMemoryDexFile"></a>openInMemoryDexFile</h6><p><img src="https://s2.loli.net/2024/12/26/fU6zpP2sY5bDet8.png" alt="image-20241226164917021"></p><p>从内存缓冲区加载 <code>.dex</code> 文件的数据，并返回一个表示该文件的对象或标识符。通常来说，这个返回值是一个 <code>DexFileCookie</code>（或者类似的标识符类型）。这个标识符用于标记当前加载的 <code>.dex</code> 文件的状态和其它信息。</p><h6 id="createCookieWithDirectBuffter"><a href="#createCookieWithDirectBuffter" class="headerlink" title="createCookieWithDirectBuffter"></a>createCookieWithDirectBuffter</h6><p><img src="https://s2.loli.net/2024/12/26/WLAXUfQgpx5bis6.png" alt="image-20241226165108129"></p><h6 id="CreateSingleDexFileCookie"><a href="#CreateSingleDexFileCookie" class="headerlink" title="CreateSingleDexFileCookie"></a>CreateSingleDexFileCookie</h6><p><img src="https://s2.loli.net/2024/12/26/K6CiXIpOMwL5tSk.png" alt="image-20241226165147320"></p><h6 id="CreateDexFile"><a href="#CreateDexFile" class="headerlink" title="CreateDexFile"></a>CreateDexFile</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> DexFile* <span class="hljs-title function_">CreateDexFile</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;MemMap&gt; dex_mem_map)</span> &#123;<br>    <span class="hljs-comment">// 生成唯一的 dex 文件位置字符串</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> location = StringPrintf(<span class="hljs-string">&quot;Anonymous-DexFile@%p-%p&quot;</span>,<br>                                        dex_mem_map-&gt;Begin(),<br>                                        dex_mem_map-&gt;End());<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> error_message;<br>    <br>    <span class="hljs-comment">// 使用内存映射创建 DexFile</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">const</span> DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(DexFile::Open(location,</span><br><span class="hljs-params">                                                           <span class="hljs-number">0</span>,  <span class="hljs-comment">// location_checksum 不指定</span></span><br><span class="hljs-params">                                                           <span class="hljs-built_in">std</span>::move(dex_mem_map),</span><br><span class="hljs-params">                                                           <span class="hljs-comment">/* verify */</span> <span class="hljs-literal">true</span>,</span><br><span class="hljs-params">                                                           <span class="hljs-comment">/* verify_location */</span> <span class="hljs-literal">true</span>,</span><br><span class="hljs-params">                                                           &amp;error_message))</span>;<br>    <span class="hljs-comment">// 检查创建 DexFile 是否成功</span><br>    <span class="hljs-keyword">if</span> (dex_file == nullptr) &#123;<br>        <span class="hljs-comment">// 如果创建失败，则抛出异常</span><br>        ScopedObjectAccess <span class="hljs-title function_">soa</span><span class="hljs-params">(env)</span>;  <span class="hljs-comment">// 获取 JNI 环境的访问权限</span><br>        ThrowWrappedIOException(<span class="hljs-string">&quot;%s&quot;</span>, error_message.c_str());  <span class="hljs-comment">// 抛出 IO 异常</span><br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    <span class="hljs-comment">// 禁用写权限，使得 DexFile 变为只读</span><br>    <span class="hljs-keyword">if</span> (!dex_file-&gt;DisableWrite()) &#123;<br>        ScopedObjectAccess <span class="hljs-title function_">soa</span><span class="hljs-params">(env)</span>;<br>        ThrowWrappedIOException(<span class="hljs-string">&quot;Failed to make dex file read-only&quot;</span>);  <span class="hljs-comment">// 如果失败，抛出异常</span><br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回原始的 DexFile 指针</span><br>    <span class="hljs-keyword">return</span> dex_file.release();<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="Open-1"><a href="#Open-1" class="headerlink" title="Open"></a>Open</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DexFile::Open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename,</span><br><span class="hljs-params">                   <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; location,</span><br><span class="hljs-params">                   <span class="hljs-type">bool</span> verify_checksum,</span><br><span class="hljs-params">                   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg,</span><br><span class="hljs-params">                   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">const</span> DexFile&gt;&gt;* dex_files)</span> &#123;<br>  <span class="hljs-comment">// 使用 ScopedTrace 跟踪打开 Dex 文件的过程，以便于性能分析和调试</span><br>  ScopedTrace <span class="hljs-title function_">trace</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Open dex file &quot;</span>) + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(location))</span>;<br><br>  <span class="hljs-comment">// 检查输出参数 dex_files 是否为空，确保函数调用正确</span><br>  DCHECK(dex_files != nullptr) &lt;&lt; <span class="hljs-string">&quot;DexFile::Open: out-param is nullptr&quot;</span>;<br>  <br>  <span class="hljs-comment">// 定义魔术值变量，用于检测文件类型</span><br>  <span class="hljs-type">uint32_t</span> magic;<br><br>  <span class="hljs-comment">// 打开文件并读取魔术值，获取文件描述符 fd</span><br>  File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);<br><br>  <span class="hljs-comment">// 如果文件打开失败，返回 false 并设置错误消息</span><br>  <span class="hljs-keyword">if</span> (fd.Fd() == <span class="hljs-number">-1</span>) &#123;<br>    DCHECK(!error_msg-&gt;empty()); <span class="hljs-comment">// 确保错误消息不为空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 检查文件的魔术值，如果是 ZIP 文件格式，则调用 OpenZip 打开 ZIP 格式的 dex 文件</span><br>  <span class="hljs-keyword">if</span> (IsZipMagic(magic)) &#123;<br>    <span class="hljs-keyword">return</span> DexFile::OpenZip(fd.Release(), location, verify_checksum, error_msg, dex_files);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果是 Dex 文件格式，调用 OpenFile 打开 Dex 文件</span><br>  <span class="hljs-keyword">if</span> (IsDexMagic(magic)) &#123;<br>    <span class="hljs-comment">// 使用 OpenFile 打开 Dex 文件，并将其保存在 dex_file 中</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">const</span> DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(DexFile::OpenFile(fd.Release(),</span><br><span class="hljs-params">                                                              location,</span><br><span class="hljs-params">                                                              <span class="hljs-comment">/* verify */</span> <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 验证文件</span></span><br><span class="hljs-params">                                                              verify_checksum,  <span class="hljs-comment">// 验证校验和</span></span><br><span class="hljs-params">                                                              error_msg))</span>;<br>    <span class="hljs-comment">// 如果 Dex 文件打开成功，则将其添加到 dex_files 向量中，并返回 true</span><br>    <span class="hljs-keyword">if</span> (dex_file.get() != nullptr) &#123;<br>      dex_files-&gt;push_back(<span class="hljs-built_in">std</span>::move(dex_file));<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果 Dex 文件打开失败，返回 false</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果文件既不是 ZIP 文件也不是 Dex 文件，则返回错误</span><br>  *error_msg = StringPrintf(<span class="hljs-string">&quot;Expected valid zip or dex file: &#x27;%s&#x27;&quot;</span>, filename);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="OpenFile-1"><a href="#OpenFile-1" class="headerlink" title="OpenFile"></a>OpenFile</h6><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">const</span> DexFile&gt; <span class="hljs-title">DexFile::OpenFile</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; location,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">bool</span> verify,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">bool</span> verify_checksum,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 std::string* error_msg)</span> </span>&#123;<br>  <span class="hljs-comment">// 使用 ScopedTrace 跟踪打开 Dex 文件的过程，便于调试和性能分析</span><br>  <span class="hljs-function">ScopedTrace <span class="hljs-title">trace</span><span class="hljs-params">(std::string(<span class="hljs-string">&quot;Open dex file &quot;</span>) + std::string(location))</span></span>;<br><br>  <span class="hljs-comment">// 检查 location 是否为空，确保提供了有效的文件路径</span><br>  <span class="hljs-built_in">CHECK</span>(!location.<span class="hljs-built_in">empty</span>());<br><br>  std::unique_ptr&lt;MemMap&gt; map;<br>  &#123;<br>    <span class="hljs-comment">// 文件描述符延迟关闭，确保在作用域结束时自动关闭文件</span><br>    <span class="hljs-function">File <span class="hljs-title">delayed_close</span><span class="hljs-params">(fd, <span class="hljs-comment">/* check_usage */</span> <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sbuf;<br>    <span class="hljs-built_in">memset</span>(&amp;sbuf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(sbuf));<br><br>    <span class="hljs-comment">// 获取文件状态信息，检查文件是否存在</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fstat</span>(fd, &amp;sbuf) == <span class="hljs-number">-1</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;DexFile: fstat &#x27;%s&#x27; failed: %s&quot;</span>, location.<span class="hljs-built_in">c_str</span>(),<br>                                <span class="hljs-built_in">strerror</span>(errno));<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 如果获取文件状态失败，返回空指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果文件是一个目录，则返回错误</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISDIR</span>(sbuf.st_mode)) &#123;<br>      *error_msg = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Attempt to mmap directory &#x27;%s&#x27;&quot;</span>, location.<span class="hljs-built_in">c_str</span>());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件大小</span><br>    <span class="hljs-type">size_t</span> length = sbuf.st_size;<br><br>    <span class="hljs-comment">// 使用 `MemMap` 来映射文件内容到内存</span><br>    map.<span class="hljs-built_in">reset</span>(MemMap::<span class="hljs-built_in">MapFile</span>(length,<br>                              PROT_READ,  <span class="hljs-comment">// 只读映射</span><br>                              MAP_PRIVATE, <span class="hljs-comment">// 私有映射</span><br>                              fd,<br>                              <span class="hljs-number">0</span>,  <span class="hljs-comment">// 从文件开头开始映射</span><br>                              <span class="hljs-comment">/*low_4gb*/</span><span class="hljs-literal">false</span>,<br>                              location.<span class="hljs-built_in">c_str</span>(),<br>                              error_msg));<br><br>    <span class="hljs-comment">// 如果映射失败，返回错误信息</span><br>    <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">DCHECK</span>(!error_msg-&gt;<span class="hljs-built_in">empty</span>());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 检查映射的文件大小是否足够存储 Dex 文件头，文件过小则认为无效</span><br>  <span class="hljs-keyword">if</span> (map-&gt;<span class="hljs-built_in">Size</span>() &lt; <span class="hljs-built_in">sizeof</span>(DexFile::Header)) &#123;<br>    *error_msg = <span class="hljs-built_in">StringPrintf</span>(<br>        <span class="hljs-string">&quot;DexFile: failed to open dex file &#x27;%s&#x27; that is too short to have a header&quot;</span>,<br>        location.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 文件头大小不足，返回空指针</span><br>  &#125;<br><br>  <span class="hljs-comment">// 获取文件头信息</span><br>  <span class="hljs-type">const</span> Header* dex_header = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> Header*&gt;(map-&gt;<span class="hljs-built_in">Begin</span>());<br><br>  <span class="hljs-comment">// 调用 `OpenCommon` 函数加载 Dex 文件的具体数据，并验证其正确性</span><br>  std::unique_ptr&lt;DexFile&gt; dex_file = <span class="hljs-built_in">OpenCommon</span>(map-&gt;<span class="hljs-built_in">Begin</span>(), map-&gt;<span class="hljs-built_in">Size</span>(),location, dex_header-&gt;checksum_,kNoOatDexFile,  verify,  <span class="hljs-comment">// 是否验证文件</span><br>verify_checksum, <span class="hljs-comment">// 是否验证校验和</span><br>error_msg);<br>  <span class="hljs-comment">// 如果 Dex 文件打开成功，保存映射内存对象</span><br>  <span class="hljs-keyword">if</span> (dex_file != <span class="hljs-literal">nullptr</span>) &#123;<br>    dex_file-&gt;mem_map_ = std::<span class="hljs-built_in">move</span>(map);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dex_file; <span class="hljs-comment">// 返回打开的 Dex 文件</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="OpenCommon"><a href="#OpenCommon" class="headerlink" title="OpenCommon"></a>OpenCommon</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;DexFile&gt; <span class="hljs-title function_">DexFile::OpenCommon</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* base, <span class="hljs-type">size_t</span> size,  <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; location,<span class="hljs-type">uint32_t</span> location_checksum, <span class="hljs-type">const</span> OatDexFile* oat_dex_file,<span class="hljs-type">bool</span> verify, <span class="hljs-type">bool</span> verify_checksum,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg, VerifyResult* verify_result)</span> &#123;<br>  <span class="hljs-comment">// 如果 verify_result 非空，初始化其为未尝试验证的状态</span><br>  <span class="hljs-keyword">if</span> (verify_result != nullptr) &#123;<br>    *verify_result = VerifyResult::kVerifyNotAttempted;<br>  &#125;<br>  <span class="hljs-comment">// 创建一个新的 DexFile 对象，初始化它以指向给定的内存区域和相关信息</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(new DexFile(base,</span><br><span class="hljs-params">size,location,location_checksum,oat_dex_file))</span>;<br><br>  <span class="hljs-comment">// 如果 dex_file 创建失败，返回错误信息</span><br>  <span class="hljs-keyword">if</span> (dex_file == nullptr) &#123;<br>    *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed to open dex file &#x27;%s&#x27; from memory: %s&quot;</span>, location.c_str(),<br>                              error_msg-&gt;c_str());<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  <span class="hljs-comment">// 调用 Init 方法初始化 DexFile，如果初始化失败，则清空 dex_file 并返回 nullptr</span><br>  <span class="hljs-keyword">if</span> (!dex_file-&gt;Init(error_msg)) &#123;<br>    dex_file.reset();<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果需要验证（verify == true），则使用 DexFileVerifier 验证 Dex 文件的有效性</span><br>  <span class="hljs-keyword">if</span> (verify &amp;&amp; !DexFileVerifier::Verify(dex_file.get(),<br>                                         dex_file-&gt;Begin(),<br>                                         dex_file-&gt;Size(),<br>                                         location.c_str(),<br>                                         verify_checksum,<br>                                         error_msg)) &#123;<br>    <span class="hljs-comment">// 如果验证失败，更新 verify_result 状态并返回 nullptr</span><br>    <span class="hljs-keyword">if</span> (verify_result != nullptr) &#123;<br>      *verify_result = VerifyResult::kVerifyFailed;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果验证成功，将 verify_result 状态更新为成功</span><br>  <span class="hljs-keyword">if</span> (verify_result != nullptr) &#123;<br>    *verify_result = VerifyResult::kVerifySucceeded;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回已成功打开并验证的 DexFile 对象</span><br>  <span class="hljs-keyword">return</span> dex_file;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>不过InMemoryDexClassLoader()并没有对内存中的DEX信息进行编译生成OAT文件，这点和DexClassLoader()不同</p></blockquote><p>你说的很对，<code>InMemoryDexClassLoader</code> 和 <code>DexClassLoader</code> 确实在处理 DEX 文件的方式上存在一些不同，尤其是在是否会生成 OAT 文件这一点上。</p><h2 id="DexClassLoader-和-InMemoryDexClassLoader-的区别"><a href="#DexClassLoader-和-InMemoryDexClassLoader-的区别" class="headerlink" title="DexClassLoader 和 InMemoryDexClassLoader 的区别"></a><strong>DexClassLoader 和 InMemoryDexClassLoader 的区别</strong></h2><table><thead><tr><th>特性</th><th><strong>DexClassLoader</strong></th><th><strong>InMemoryDexClassLoader</strong></th></tr></thead><tbody><tr><td><strong>加载方式</strong></td><td>加载磁盘上的 <code>.dex</code> 文件</td><td>加载内存中的 <code>.dex</code> 数据</td></tr><tr><td><strong>OAT 文件生成</strong></td><td>会生成 OAT 文件，进行优化</td><td>不会生成 OAT 文件</td></tr><tr><td><strong>存储位置</strong></td><td>OAT 文件通常存储在 <code>dalvik-cache</code> 目录</td><td>仅加载内存中的 DEX 数据</td></tr><tr><td><strong>优化</strong></td><td>会进行 AOT 优化，生成特定于设备的机器代码</td><td>不进行 AOT 优化，只加载原始 DEX 数据</td></tr><tr><td><strong>使用场景</strong></td><td>用于动态加载外部 <code>.dex</code> 文件，适用于应用安装、升级等场景</td><td>用于加载内存中已有的 DEX 数据，适用于某些内存管理或动态加载的场景</td></tr></tbody></table><h3 id="为什么-InMemoryDexClassLoader-不生成-OAT-文件？"><a href="#为什么-InMemoryDexClassLoader-不生成-OAT-文件？" class="headerlink" title="为什么 InMemoryDexClassLoader 不生成 OAT 文件？"></a><strong>为什么 InMemoryDexClassLoader 不生成 OAT 文件？</strong></h3><p><code>InMemoryDexClassLoader</code> 设计上的不同使得它不生成 OAT 文件。它主要用于动态加载在内存中的 <code>.dex</code> 数据，通常在以下几种场景中使用：</p><ol><li><strong>插件化框架</strong>：比如某些插件化框架会将 DEX 文件在运行时从网络或者本地文件中加载到内存中，而不是依赖于传统的 <code>.apk</code> 安装方式。此时，<code>.dex</code> 文件本身可能并不存储在磁盘上，而是直接通过内存加载。</li><li><strong>调试与测试</strong>：在调试和测试中，可能需要直接将某些动态生成或修改过的 DEX 数据加载到应用中执行。为了避免频繁的磁盘 I&#x2F;O 和 OAT 文件的生成，可以直接使用 <code>InMemoryDexClassLoader</code> 来加速这一过程。</li><li><strong>资源管理</strong>：在某些特殊的内存管理场景下，可能只需要将 <code>.dex</code> 文件加载到内存中，并且不需要在磁盘上生成 OAT 文件。</li></ol><p>由于 <code>InMemoryDexClassLoader</code> 仅仅是将 <code>.dex</code> 字节码加载到内存中并通过 <code>DexFile</code> 进行解析，它不涉及到 <code>.dex</code> 到 <code>.oat</code> 的转换过程。这种方式适用于需要快速加载内存中 <code>.dex</code> 文件的场景，而不是依赖于 ART 的 AOT 编译。</p>]]></content>
    
    
    <categories>
      
      <category>逆向(android)</category>
      
      <category>文件格式/装载链接运行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向(android)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/2023/05/08/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2023/05/08/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这部分内容没有一定的实践,缺少一定的经验，故在次只了解些基本的概念，并提供一系列前辈的文章。以后时间充裕再一一完善</p></blockquote><p><strong>前景导读</strong></p><p>在MySQL数据库的使用过程中，随着数据量的增长和应用场景的复杂化，单一数据库或单个数据表往往会面临性能瓶颈。为了解决这些问题，采用<strong>分库分表</strong>技术成为一种常见的优化手段。<strong>分库分表</strong>的核心目的是将数据拆分到多个数据库或多个表中，从而提高数据库的性能、可扩展性和高可用性。</p><hr><h1 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h1><p><a href="https://blog.csdn.net/qq_40991313/article/details/133797658">一篇文章搞懂MySQL的分库分表，从拆分场景、目标评估、拆分方案、不停机迁移、一致性补偿等方面详细阐述MySQL数据库的分库分表方案_mysql分库分表-CSDN博客</a></p><p><a href="https://blog.csdn.net/wdcl2468/article/details/102911160">Mysql分库分表实战（一）——一文搞懂Mysql数据库分库分表_mysql 分库分表-CSDN博客</a></p><p><a href="https://blog.csdn.net/agonie201218/article/details/110823552">超详细的mysql分库分表方案_mysql大表分表方案-CSDN博客</a></p><p><a href="https://www.cnblogs.com/awan-note/p/13993917.html">亿级大表分库分表实战总结（万字干货，实战复盘） - 阿丸 - 博客园</a></p><p><a href="https://www.cnblogs.com/boonya/p/18557312">MySQL分库分表方案 - boonya - 博客园</a></p><p>[【MySQL】MySQL分库分表详解<a href="https://cloud.tencent.com/developer/article/2054754">通俗易懂]-腾讯云开发者社区-腾讯云</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF文件解析器编写</title>
    <link href="/2023/05/08/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/05/08/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要以x64架构为解析对象(x32功能实现相似)，使用C++编写ELF解析器，实现readel大多数功能。建议读者阅读前浏览官方ELF64文档：</p><p><a href="https://uclibc.org/docs/elf-64-gen.pdf">ELF-64 Object File Format</a></p><p>初次借着学习elf结构进行编写，如有纰漏请多指正</p></blockquote><h1 id="从源代码编写到最终生成可执行文件"><a href="#从源代码编写到最终生成可执行文件" class="headerlink" title="从源代码编写到最终生成可执行文件"></a>从源代码编写到最终生成可执行文件</h1><p><img src="https://s2.loli.net/2024/12/16/OnRbL8FDeEiHs9f.jpg" alt="1"></p><p>编译器原理：</p><p><img src="https://s2.loli.net/2024/12/16/KIi5EDF7JPkjyB9.jpg" alt="2"></p><p>汇编器原理：</p><p>汇编器将汇编代码作为输入并将其转换为可重定位的机器代码。汇编器检查每条指令的正确性并生成诊断消息。</p><p><img src="https://s2.loli.net/2024/12/16/PafYKlsAFJ8OWro.png" alt="image-20241216142318994"></p><h1 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h1><h2 id="ELF整体结构"><a href="#ELF整体结构" class="headerlink" title="ELF整体结构"></a>ELF整体结构</h2><p>如下图所示:</p><p><img src="https://s2.loli.net/2024/12/16/ct3oTXChOJZeDq2.png" alt="ELF文件格式"></p><p>更详细一点：</p><p><img src="https://s2.loli.net/2024/12/16/X5WAjmOb8e1fkls.png" alt="ELF文件格式"></p><p>注意：可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段 或者系统准备程序执行所必需的其它信息。程序头表描述了ELF文件中Segment在文件中的布局，描述了OS该如何装载可执行文件到内存</p><p>ELF 文件的基本结构由以下几个主要部分组成：</p><ol><li><strong>ELF Header（ELF 文件头）</strong></li><li><strong>Program Header Table（程序头表）</strong></li><li><strong>Section Header Table（节头表）</strong></li><li><strong>Data Sections（数据节）</strong></li><li><strong>Dynamic Section（动态节，针对共享库或动态加载的情况）</strong></li><li><strong>String Table（字符串表，通常存储符号名称、节名称等）</strong></li></ol><p>其中，<strong>Program Header Table</strong> 和 <strong>Section Header Table</strong> 是两种不同的表格，它们分别用于描述不同类型的信息：<code>Program Header</code> 用于描述文件加载到内存时的映射，而 <code>Section Header</code> 用于描述文件内部的具体内容（如代码段、数据段等）。</p><h3 id="1-ELF-Header（ELF-文件头）"><a href="#1-ELF-Header（ELF-文件头）" class="headerlink" title="1. ELF Header（ELF 文件头）"></a>1. ELF Header（ELF 文件头）</h3><p>ELF 文件的开头是一个固定大小的 ELF 文件头，它包含了文件格式和该文件结构的基本信息。主要字段有：</p><ul><li>**e_ident[16]**：一个 16 字节的数组，用于标识 ELF 文件的类型和版本信息。<ul><li><code>e_ident[0]</code> 和 <code>e_ident[1]</code> 为魔数，值为 <code>0x7f &#39;E&#39; &#39;L&#39; &#39;F&#39;</code>，用于标识 ELF 文件。</li><li><code>e_ident[4]</code> 为目标架构，值通常是 <code>ELF32</code> 或 <code>ELF64</code>。</li><li><code>e_ident[5]</code> 表示数据编码格式（如小端或大端）。</li><li><code>e_ident[6]</code> 为 ELF 版本号，通常为 1。</li><li><code>e_ident[7]</code> 为操作系统版本（通常是 0）。</li></ul></li><li><strong>e_type</strong>：表示 ELF 文件的类型，常见值有：<ul><li><code>ET_EXEC</code>：可执行文件（Executable File）。</li><li><code>ET_DYN</code>：共享库（Shared Object）。</li><li><code>ET_REL</code>：重定位文件（Relocatable File）。</li></ul></li><li><strong>e_machine</strong>：指定该 ELF 文件运行的目标架构，如 <code>EM_386</code> 表示 x86，<code>EM_X86_64</code> 表示 x86-64。</li><li><strong>e_version</strong>：文件版本号，通常是 1。</li><li><strong>e_entry</strong>：程序入口地址，指示程序执行开始的位置。</li><li><strong>e_phoff</strong>：程序头表的偏移量，指示程序头在文件中的位置。</li><li><strong>e_shoff</strong>：节头表的偏移量，指示节头表在文件中的位置。</li><li><strong>e_flags</strong>：架构相关的标志（例如，x86 处理器的标志）。</li><li><strong>e_ehsize</strong>：ELF 文件头的大小。</li><li><strong>e_phentsize</strong>：程序头表中每个条目的大小。</li><li><strong>e_phnum</strong>：程序头表的条目数量。</li><li><strong>e_shentsize</strong>：节头表中每个条目的大小。</li><li><strong>e_shnum</strong>：节头表的条目数量。</li><li><strong>e_shstrndx</strong>：节头表中字符串表的位置索引。</li></ul><h3 id="2-Program-Header-Table（程序头表）"><a href="#2-Program-Header-Table（程序头表）" class="headerlink" title="2. Program Header Table（程序头表）"></a>2. Program Header Table（程序头表）</h3><p>程序头表是 ELF 文件中的一个重要部分，描述了文件中每个可加载段的信息。每个条目包含以下信息：</p><ul><li><strong>p_type</strong>：段的类型，如 <code>PT_LOAD</code>（可加载段），<code>PT_DYNAMIC</code>（动态段），<code>PT_INTERP</code>（解释器段）等。</li><li><strong>p_offset</strong>：该段在 ELF 文件中的偏移量。</li><li><strong>p_vaddr</strong>：段在内存中的虚拟地址。</li><li><strong>p_paddr</strong>：段的物理地址（在大多数现代系统中为 0）。</li><li><strong>p_filesz</strong>：段在文件中的大小。</li><li><strong>p_memsz</strong>：段在内存中的大小。</li><li><strong>p_flags</strong>：段的访问权限标志，如可读（<code>PF_R</code>），可写（<code>PF_W</code>），可执行（<code>PF_X</code>）等。</li><li><strong>p_align</strong>：段在内存中的对齐要求。</li></ul><h3 id="3-Section-Header-Table（节头表）"><a href="#3-Section-Header-Table（节头表）" class="headerlink" title="3. Section Header Table（节头表）"></a>3. Section Header Table（节头表）</h3><p>节头表是一个包含 ELF 文件中各个节（Section）描述的表。每个节是 ELF 文件的一个独立部分，包含程序的代码、数据、符号表、调试信息等。每个节由一个节头描述，字段包括：</p><ul><li><p><strong>sh_name</strong>：节名称的字符串表索引。</p></li><li><p>sh_type</p><p>：节的类型，常见的类型包括：</p><ul><li><code>SHT_PROGBITS</code>：包含程序数据。</li><li><code>SHT_SYMTAB</code>：符号表。</li><li><code>SHT_STRTAB</code>：字符串表。</li><li><code>SHT_RELA</code>：重定位表。</li><li><code>SHT_DYNAMIC</code>：动态链接信息。</li></ul></li><li><p><strong>sh_flags</strong>：节的标志，如 <code>SHF_ALLOC</code>（该节需要在内存中加载），<code>SHF_EXECINSTR</code>（该节包含可执行代码）等。</p></li><li><p><strong>sh_addr</strong>：节在内存中的虚拟地址（如果该节需要加载到内存）。</p></li><li><p><strong>sh_offset</strong>：节在文件中的偏移量。</p></li><li><p><strong>sh_size</strong>：节的大小。</p></li><li><p><strong>sh_link</strong>：与该节相关联的其他节的索引（例如符号表和字符串表之间的关联）。</p></li><li><p><strong>sh_info</strong>：该字段的具体含义依赖于节的类型。</p></li><li><p><strong>sh_addralign</strong>：节的对齐要求。</p></li><li><p><strong>sh_entsize</strong>：节中每个条目的大小（如果适用）。</p></li></ul><h3 id="4-数据节（Data-Sections）"><a href="#4-数据节（Data-Sections）" class="headerlink" title="4. 数据节（Data Sections）"></a>4. 数据节（Data Sections）</h3><p>数据节包含 ELF 文件中各种数据和信息。例如：</p><ul><li><strong>.text</strong>：通常包含程序的可执行代码。</li><li><strong>.data</strong>：包含已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：包含未初始化的全局变量和静态变量（程序启动时会清零）。</li><li><strong>.rodata</strong>：只读数据，如常量字符串。</li><li><strong>.dynamic</strong>：动态链接信息（动态库相关的符号和重定位信息）。</li><li><strong>.symtab</strong>：符号表，用于存储符号名称和地址等信息。</li><li><strong>.strtab</strong>：字符串表，存储字符串数据，如符号表中符号的名称。</li></ul><h3 id="5-动态节（Dynamic-Section）"><a href="#5-动态节（Dynamic-Section）" class="headerlink" title="5. 动态节（Dynamic Section）"></a>5. 动态节（Dynamic Section）</h3><p>动态节在动态链接程序中非常重要，它存储与程序在运行时加载和链接相关的信息。常见字段有：</p><ul><li><strong>DT_NEEDED</strong>：需要的共享库。</li><li><strong>DT_SONAME</strong>：共享库的名称。</li><li><strong>DT_SYMBOLIC</strong>：指定共享库的符号是否应该全局可见。</li></ul><h3 id="6-字符串表（String-Table）"><a href="#6-字符串表（String-Table）" class="headerlink" title="6. 字符串表（String Table）"></a>6. 字符串表（String Table）</h3><p>ELF 文件使用字符串表存储符号、节、程序头等各种名称信息。它通常存储在一个 <code>.strtab</code> 节中。</p><h3 id="7-重定位信息"><a href="#7-重定位信息" class="headerlink" title="7. 重定位信息"></a>7. 重定位信息</h3><p>ELF 文件中的重定位节（如 <code>.rela</code> 或 <code>.rel</code> 节）用于动态链接时解决符号地址。重定位项包含了一个符号的地址，并指示程序在加载时如何进行修改。</p><p><img src="https://s2.loli.net/2024/11/28/jNrA5GCPpEOymML.png" alt="2052730-20220612221409797-515360683"></p><h2 id="ELF具体结构"><a href="#ELF具体结构" class="headerlink" title="ELF具体结构"></a>ELF具体结构</h2><h3 id="ELF头-ELF-Header"><a href="#ELF头-ELF-Header" class="headerlink" title="ELF头(ELF Header)"></a>ELF头(ELF Header)</h3><p><strong>概述文件结构和基本信息</strong>：ELF 文件头是 ELF 文件的入口，它包含描述文件布局和格式的关键信息。提取文件总体信息，指导后续程序头表、节头表等解析工作。</p><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf64_hdr</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> e_indet[EI_NIDENT];<span class="hljs-comment">//ELF文件的描述，是一个16字节的标识，表明当前文件的数据格式，位数等[16B]</span><br>    Elf64_Half e_type;<span class="hljs-comment">//文件的标识字段标识文件的类型；比如可执行文件，共享目标文件[2B]</span><br>    Elf64_Half e_machine;<span class="hljs-comment">//目标文件的体系结构(处理器架构)[2B]</span><br>    Elf64_Half e_version;<span class="hljs-comment">//当前文件的版本[2B]</span><br><br>    Elf64_Addr e_entry;<span class="hljs-comment">//程序的虚拟入口地址[8B]</span><br>    Elf64_Off  e_phoff;<span class="hljs-comment">//程序头表的偏移地址[8B]</span><br>    Elf64_Off  e_shoff;<span class="hljs-comment">//段表/节表的偏移[8B]</span><br><br>    Elf64_Word e_flags; <span class="hljs-comment">//处理器相关的标志位[4B]</span><br>    Elf64_Half e_ehsize; <span class="hljs-comment">//ELF文件头的大小[2B]</span><br><br>    Elf64_Half e_phentsize;<span class="hljs-comment">//程序头表的单项大小[2B]</span><br>    Elf64_Half e_phnum;<span class="hljs-comment">//程序头表的单项数目[2B]</span><br><br>    Elf64_Half e_shentsize;<span class="hljs-comment">//节表中单项的大小[2B]</span><br>    Elf64_Half e_shnum;<span class="hljs-comment">//节表中单项的数目[2B]</span><br>    Elf64_Half e_shstrndx;<span class="hljs-comment">//节表中节名的索引[2B]------- 存储节名称，它包含所有节头的名字，如 .text, .data, .bss, 等等。</span><br>&#125;Elf64_hdr;<br></code></pre></td></tr></table></figure><h4 id="解析代码："><a href="#解析代码：" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ElfHeaderParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fseek</span>(fp, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(elf64_hdr, <span class="hljs-built_in">sizeof</span>(Elf64_hdr), <span class="hljs-number">1</span>, fp);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Magic:\t\t\t&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; EI_NIDENT; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02x &quot;</span>, elf64_hdr-&gt;e_indet[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件格式:\t\t&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (elf64_hdr-&gt;e_type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知的文件格式\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;重定向文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;可执行文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;共享文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Core转储文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0xff00</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;特定处理器的文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0xffff</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;特定处理器的文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;处理器体系结构:\t\t&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (elf64_hdr-&gt;e_machine)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知体系结构\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AT&amp;T WE 32100\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SPARC\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Intel Architecture\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Motorola 68000\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Motorola 88000\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Intel 80860\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MIPS RS3000 Big-Endian\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MIPS RS4000 Big-Endian\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AMD x86-64 architecture\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">183</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AArch64 architecture\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;version:\t\t&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (elf64_hdr-&gt;e_version) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序入口虚拟地址:\t0x%016x\n&quot;</span>, elf64_hdr-&gt;e_entry);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序头表的偏移地址:\t0x%08x\n&quot;</span>, elf64_hdr-&gt;e_phoff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;段表/节表的编译地址：\t0x%08x\n&quot;</span>, elf64_hdr-&gt;e_shoff);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;处理器标志位:\t\t%x\n&quot;</span>, elf64_hdr-&gt;e_flags);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ELF文件头大小:\t\t%u bytes\n&quot;</span>, elf64_hdr-&gt;e_ehsize);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序头表的单项大小:\t%u bytes\n&quot;</span>, elf64_hdr-&gt;e_phentsize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序头表的单项数量:\t%u\n&quot;</span>, elf64_hdr-&gt;e_phnum);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节表的单项大小:\t%u bytes\n&quot;</span>, elf64_hdr-&gt;e_shentsize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节表的单项数量:\t%u\n&quot;</span>, elf64_hdr-&gt;e_shnum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串表在节头表中索引:\t%u\n&quot;</span>, elf64_hdr-&gt;e_shstrndx);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/iptQJ2Z4duKga5c.png" alt="image-20241222095101754"></p><h3 id="程序头表-Program-Header-Table"><a href="#程序头表-Program-Header-Table" class="headerlink" title="程序头表(Program Header Table)"></a>程序头表(Program Header Table)</h3><p><strong>描述程序的内存映射方式</strong>：用于运行时加载 ELF 文件的指令，告诉加载器哪些部分需要映射到内存。处理与加载相关的段，例如 <code>.text</code>（代码段）、<code>.data</code>（数据段）、<code>.dynamic</code>（动态段）等。用于动态链接器加载共享库或可执行文件。</p><h4 id="数据结构：-1"><a href="#数据结构：-1" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf64_phdr</span> &#123;<br>    Elf64_Word p_type;<span class="hljs-comment">//当前Segment的类型[4B]</span><br>    Elf64_Word p_flags;<span class="hljs-comment">//段相关的标志[4B]</span><br>    Elf32_Off  p_offset;<span class="hljs-comment">//当前段相对于文件起始位置的偏移量;[4B]</span><br>    Elf64_Addr      p_vaddr;<span class="hljs-comment">//段的第一个字节将被映射到到内存中的虚拟地址[8B]</span><br>    Elf64_Addr      p_paddr;<span class="hljs-comment">//此成员仅用于与物理地址相关的系统中。因为 System V 忽略所有应用程序的物理地址信息，此字段对与可执行文件和共享目标文件而言具体内容是指定的；[8B]</span><br>    Elf64_Xword     p_filesz;<span class="hljs-comment">//段在文件映像中所占的字节数[8B]</span><br>    Elf64_Xword     p_memsz;<span class="hljs-comment">//段在内存映像中占用的字节数</span><br>    Elf64_Xword     p_align;<span class="hljs-comment">//段在文件中和内存中如何对齐</span><br>&#125;Elf64_Phdr;<br></code></pre></td></tr></table></figure><h4 id="解析代码：-1"><a href="#解析代码：-1" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ElfProgramHeaderTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span></span><br><span class="hljs-function"></span>&#123;<br>    Elf64_Phdr phdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_phoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_phnum;<br>    <span class="hljs-built_in">fread</span>(phdr, <span class="hljs-built_in">sizeof</span>(Elf64_Phdr), count, fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d program headers, starting at offset 0x%04x:\n\n&quot;</span>, count, elf64_hdr-&gt;e_phoff);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;程序头表:&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;类型\t\t属性\t偏移量\t\t虚拟地址\t\t物理地址\t\t文件大小\t镜像大小\t对齐长度&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count;i++ )<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (phdr[i].p_type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_NULL\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前项未使用，项中的成员是未定义的，需要忽略当前项；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_LOAD\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前Segment是一个可装载的Segment，即可以被装载映射到内存中，其大小由p_filesz和p_memsz描述。如果p_memsz&gt;p_filesz则剩余的字节被置零，但是p_filesz&gt;p_memsz是非法的。动态库一般包含两个该类型的段：代码段和数据段；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_DYNAMIC\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//动态段，动态库特有的段，包含了动态链接必须的一些信息，比如需要链接的共享库列表、GOT等等</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_INTERP\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前段用于存储一段以NULL为结尾的字符串，该字符串表明了程序解释器的位置。且当前段仅仅对于可执行文件有实际意义</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_NOTE\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//用于保存与特定供应商或者系统相关的附加信息以便于兼容性、一致性检查，但是实际上只保存了操作系统的规范信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_SHLIB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保留段；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_PHDR\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保存程序头表本身的位置和大小，当前段不能在文件中出现一次以上，且仅仅当程序表头为内存映像的一部分时起作用，它必须在所有加载项目之前；</span><br>            <span class="hljs-comment">/*[PT_LPROC(0x70000000),PT_HIPROC(0x7fffffff)]：该范围内的值用作预留*/</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6474e550</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GNU_EH_FRAME\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6474e551</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GNU_STACK\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6474e552</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GNU_RELRO\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x70000000</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_LOPROC\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x7fffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_HIPROC\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\t&#x27;</span>);<br>        <span class="hljs-keyword">switch</span> (phdr[i].p_flags) &#123;<span class="hljs-comment">//段相关的标志(权限)；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;none&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;w&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wx&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;r&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rx&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rw&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rwx&quot;</span>); <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%08x&quot;</span>, phdr[i].p_offset);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%016x&quot;</span>, phdr[i].p_vaddr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%016x&quot;</span>, phdr[i].p_paddr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%6u bytes&quot;</span>, phdr[i].p_filesz);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%6u bytes&quot;</span>, phdr[i].p_memsz);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%08x&quot;</span>, phdr[i].p_align);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/lRgI7oCc9qTdDxh.png" alt="image-20241222095134236"></p><h3 id="节区头表-Section-Header-Table"><a href="#节区头表-Section-Header-Table" class="headerlink" title="节区头表(Section Header Table)"></a>节区头表(Section Header Table)</h3><p><strong>描述 ELF 文件的逻辑组织</strong>：包含每个节（如 <code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.symtab</code> 等）的信息。确定各个节的位置及内容，如符号表 <code>.symtab</code>、重定位表 <code>.rel</code> 等。提供调试和符号信息。</p><h4 id="数据结构：-2"><a href="#数据结构：-2" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf64_shrd</span> &#123;<br>    Elf64_Word sh_name;<span class="hljs-comment">//节名称在字符串表中的索引</span><br>    Elf64_Word sh_type;<span class="hljs-comment">//节的类型和语义</span><br>    Elf64_Xword sh_flags;<span class="hljs-comment">//1bit位的标志位</span><br><br>    Elf64_Addr sh_addr;<span class="hljs-comment">//如果当前节需要被装载到内存，则当前项存储当前节映射到内存的首地址，否则应该为0；[8B]</span><br>    Elf64_Off  sh_offset;<span class="hljs-comment">//当前节的首地址相对于文件的偏移；[8B]</span><br>    Elf64_Xword sh_size;<span class="hljs-comment">//节的大小[8B]</span><br><br>    Elf64_Word sh_link;<span class="hljs-comment">//[4B]符号表（.symtab 或 .dynsym）</span><br>    <span class="hljs-comment">//用途：sh_link 表示符号表关联的字符串表的节头表索引。</span><br>    <span class="hljs-comment">//原因：符号表中的每个符号名存储在字符串表中，而 sh_link 指向该字符串表的节。</span><br>    Elf64_Word sh_info;<span class="hljs-comment">//节的附加信息。对于特定的节有特定的含义，其他为0；[4B]</span><br>    Elf64_Xword sh_addralign;<span class="hljs-comment">//地址约束对齐，值应该为0或者2的幂次方，0和1表示未进行对齐；[8B]</span><br>    Elf64_Xword sh_entsize;<span class="hljs-comment">//如果该节包含一个表格（例如符号表、重定位表等），sh_entsize 表示表中每个条目的大小（以字节为单位）。</span><br>    <span class="hljs-comment">//如果该节不是一个表格（例如.text 节），sh_entsize 通常设置为 0，因为这些节不分条目，所有数据都连续存放。</span><br><br>&#125;Elf64_Shdr;<br><br></code></pre></td></tr></table></figure><h4 id="解析代码：-2"><a href="#解析代码：-2" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ElfSectionHeaderTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_shnum;<br>    <span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), count, fp);<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d section headers, starting at offset 0x%04x:\n\n&quot;</span>, count, elf64_hdr-&gt;e_shoff);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;节头表:&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[编号]\t名称\t\t\  类型\t\t属性\t虚拟地址\t\t偏移量\t\t大小\t\t索引值\t信息\t对齐长度\t表项大小\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>    &#123;<br>        <span class="hljs-comment">//&amp;strtable[shdr[i].sh_name] 表示获取该字符的地址，这实际上是偏移量对应的字符串在数组中的起始地址。</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%02d]\t%s&quot;</span>, i, &amp;strtable[shdr[i].sh_name]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">20</span> - <span class="hljs-built_in">strlen</span>(&amp;strtable[shdr[i].sh_name]); ++j) &#123;<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (shdr[i].sh_type)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_NULL\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前节是非活跃的，没有一个对应的具体的节内存；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_PROGBITS\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//包含了程序的指令信息、数据等程序运行相关的信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_SYMTAB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保存了符号信息，用于重定位；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_STRTAB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//一个字符串表，保存了每个节的节名称；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_RELA\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储可重定位表项，可能会有附加内容，目标文件可能有多个可重定位表项；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_HASH\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储符号哈希表，所有参与动态链接的目标只能包含一个哈希表，一个目标文件只能包含一个哈希表；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_DYAMIC\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储包含动态链接的信息，一个目标文件只能包含一个；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_NOTE\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储以某种形式标记文件的信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_NOBITS\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//这种类型的节不占据文件空间，但是成员sh_offset依然会包含对应的偏移；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_REL\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//包含可重定位表项，无附加内容，目标文件可能有多个可重定位表项；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_SHLIB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//：保留区，包含此节的程序与ABI不兼容</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_DYNSYM\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保存共享库导入动态符号信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x70000000</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_LOPROC&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x7fffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_HIPROC&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x80000000</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_LOUSER&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xffffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_HIUSER&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6ffffff6</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_GNU_HASH&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6fffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_GNU_versym&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6ffffffe</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_GNU_verneed&quot;</span>); <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%016x\t&quot;</span>, shdr[i].sh_addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%08x\t&quot;</span>, shdr[i].sh_offset);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4lu bytes\t&quot;</span>, shdr[i].sh_size);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\t&quot;</span>, shdr[i].sh_link);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\t&quot;</span>, shdr[i].sh_info);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2lu bytes\t&quot;</span>, shdr[i].sh_entsize);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4x\n&quot;</span>, shdr[i].sh_addralign);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-2"><a href="#结果：-2" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/KY7pl9Ln6ruy1fv.png" alt="image-20241222095159256"></p><h4 id="特殊的节"><a href="#特殊的节" class="headerlink" title="特殊的节"></a>特殊的节</h4><p>ELF 文件中有一些特定的节是预定义好的，其内容是指令代码或者控制信息</p><p>这些节专门为操作系统使用，对于不同的操作系统，这些节的类型和属性有所不同</p><table><thead><tr><th align="left">节名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><strong>.text</strong></td><td align="left"><strong>代码段</strong></td></tr><tr><td align="left"><strong>.data</strong></td><td align="left"><strong>保存已经初始化的全局变量和局部静态变量</strong></td></tr><tr><td align="left"><strong>.bss</strong></td><td align="left"><strong>保存未初始化的全局变量和局部静态变量</strong></td></tr><tr><td align="left">.rodata</td><td align="left">存放只读数据, 例如常量字符串</td></tr><tr><td align="left">.comment</td><td align="left">编译器版本信息</td></tr><tr><td align="left">.debug</td><td align="left">调试信息</td></tr><tr><td align="left"><strong>.dynamic</strong></td><td align="left"><strong>动态链接信息</strong>, linker解析该段以加载elf文件</td></tr><tr><td align="left">.hash</td><td align="left">符号哈希表 (可查导入和导出符号)</td></tr><tr><td align="left">.gnu.hash</td><td align="left">GNU哈希表 (只可查导出符号,导出表)</td></tr><tr><td align="left">.line</td><td align="left">调试行号表 即源代码行号与编译后指令的对应表</td></tr><tr><td align="left">.note</td><td align="left">额外的编译器信息 例如公司名,版本号</td></tr><tr><td align="left">.rel.dyn</td><td align="left">动态链接重定位表 存放全局变量重定位项</td></tr><tr><td align="left">.rel.plt</td><td align="left">动态链接函数跳转重定位表 存放plt重定位项</td></tr><tr><td align="left">.symtab</td><td align="left">符号表</td></tr><tr><td align="left">.dynsym</td><td align="left">动态链接符号表</td></tr><tr><td align="left">.strtab</td><td align="left">字符串表</td></tr><tr><td align="left">.shstrtab</td><td align="left">节名表</td></tr><tr><td align="left">.dynstr</td><td align="left">动态链接字符串表</td></tr><tr><td align="left">.plt</td><td align="left">动态链接跳转表</td></tr><tr><td align="left">.got</td><td align="left">动态链接全局偏移表</td></tr><tr><td align="left">.init</td><td align="left">程序初始化代码段(节)</td></tr><tr><td align="left">.fini</td><td align="left">程序结束代码段(节)</td></tr></tbody></table><h3 id="字符串表-String-Table"><a href="#字符串表-String-Table" class="headerlink" title="字符串表(String Table)"></a>字符串表(String Table)</h3><p><strong>存储字符串信息</strong>：供节头表、符号表等引用的字符串。解析 ELF 文件中字符串索引值，获取节名称、符号名称等人类可读的信息。</p><h4 id="数据结构：-3"><a href="#数据结构：-3" class="headerlink" title="数据结构："></a>数据结构：</h4><p>ELF文件中有很多字符串,例如段名,变量名等, 由于字符串长度往往不固定,所以使用固定结构描述比较困难，常见做法是将字符串集中起来存放到一张字符串表,然后通过索引查表来引用字符串</p><p>常见的有:</p><ol><li><p>.strtab(字符串表,保存普通字符串)</p><p>遍历section header, 查找type&#x3D;&#x3D;SHT_STRTAB的即为字符串表 (包括段表字符串表)</p></li><li><p>.shstrtab(段表字符串表,保存段表用到的字符串)</p><p>获取该表可以通过ELF Header的e_shstrndx成员做索引,查找ELF Section Header Table</p><p>即p_shstrtab&#x3D;ELFSectionHeaderTable[ELFHeader.e_shstrndx]</p></li></ol><h4 id="解析代码：-3"><a href="#解析代码：-3" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">StringTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is stringtable \n&quot;</span>);<br>    <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-type">uint8_t</span> stringBuffer[<span class="hljs-number">9999</span>]; <span class="hljs-comment">// 用于保存单个字符串表</span><br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_shnum;<br>    <span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), count, fp);<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">if</span> (shdr[i].sh_type == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t==========String Table %s==========\n&quot;</span>, &amp;strtable[shdr[i].sh_name]);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[i].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(stringBuffer, <span class="hljs-number">1</span>, shdr[i].sh_size, fp);<br>            <span class="hljs-type">uint32_t</span> pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (pos &lt; shdr[i].sh_size) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\n&quot;</span>, stringBuffer + pos);<br>                pos += <span class="hljs-built_in">strlen</span>((<span class="hljs-type">char</span>*)(stringBuffer + pos)) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 跳过当前字符串（加上末尾 &#x27;\0&#x27;）</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ELF String Table End\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-3"><a href="#结果：-3" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/kz4UueFKX9SCaD3.png" alt="image-20241222095217758"></p><h3 id="符号表信息-Symbol-Table"><a href="#符号表信息-Symbol-Table" class="headerlink" title="符号表信息(Symbol Table)"></a>符号表信息(Symbol Table)</h3><p><strong>存储符号信息</strong>：符号表保存了 ELF 文件中的全局和局部符号（如函数名、变量名）。为调试、链接提供符号信息。动态链接时，解析符号依赖（如函数地址的重定位）。符号表的作用是描述导入和导出符号,这里的符号可以是全局变量,函数,外部引用等，通过符号表和对应的字符串表可以得到符号名,符号大小,符号地址等信息</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">.dynsym //动态链接符号表<br>.symtab //符号表<br><br>.dynstr //动态链接符号表的字符串表<br>.strtab //符号表的字符串表<br></code></pre></td></tr></table></figure><h4 id="数据结构：-4"><a href="#数据结构：-4" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Word st_name; <span class="hljs-comment">/* Symbol name */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info; <span class="hljs-comment">/* Type and Binding attributes */</span><span class="hljs-comment">//符号的类型和属性, 高4bit标识了符号绑定(symbol binding), 低4bit标识了符号类型(symbol type), 组成符号信息(symbol information)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other; <span class="hljs-comment">/* Reserved */</span><br>    Elf64_Half st_shndx; <span class="hljs-comment">/* Section table index用于表示符号所在的段（Section）索引 */</span><br>    Elf64_Addr st_value; <span class="hljs-comment">/* Symbol value */</span><br>    Elf64_Xword st_size; <span class="hljs-comment">/* Size of object (e.g., common) */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><p>注意：st_info</p><p>符号的类型和属性,高4bit标识了符号绑定(symbol binding), 低4bit标识了符号类型(symbol type),组成符号信息(symbol information)</p><p>有3个宏分别读取这三个属性值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_ST_BIND(val)      (((unsigned char) (val)) &gt;&gt; 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_ST_TYPE(val)      ((val) &amp; 0xf)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_ST_INFO(bind, type)   (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span><br></code></pre></td></tr></table></figure><p>具体类型值:</p><p><img src="https://s2.loli.net/2024/12/22/2K6AaGHtlMyXIRo.png" alt="image-20241222093256869"></p><p><img src="https://s2.loli.net/2024/12/22/Hkc5sdLWTNfeb3E.png" alt="image-20241222093313451"></p><h4 id="解析代码：-4"><a href="#解析代码：-4" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getSymbolBindingString</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> symbolBinding)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (symbolBinding) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LOCAL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GLOBAL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WEAK&quot;</span>;<br>    <span class="hljs-comment">/*case STB_NUM:          return &quot;STB_NUM&quot;;</span><br><span class="hljs-comment">    case STB_GNU_UNIQUE:   return &quot;GNU_UNIQUE&quot;;*/</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STB_HIOS&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STB_LOPROC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STB_HIPROC&quot;</span>;<br>    <span class="hljs-keyword">default</span>:               <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getSymbolTypeString</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> symbolType)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (symbolType) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NOTYPE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OBJECT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FUNC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SECTION&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FILE&quot;</span>;<br>    <span class="hljs-comment">//case STT_COMMON:    return &quot;COMMON&quot;;</span><br>    <span class="hljs-comment">//case STT_TLS:       return &quot;TLS&quot;;</span><br>    <span class="hljs-comment">//case STT_NUM:       return &quot;STT_NUM&quot;;</span><br>    <span class="hljs-comment">//case STT_GNU_IFUNC: return &quot;GNU_IFUNC&quot;;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LOOS&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HIOS&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LOPROC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HIPROC&quot;</span>;<br>    <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getSymbolVisibility</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> st_other)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> visibility = st_other &amp; <span class="hljs-number">0x03</span>;<br>    <span class="hljs-keyword">switch</span> (visibility) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEFAULT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INTERNAL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HIDDEN&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PROTECTED&quot;</span>;<br>    <span class="hljs-keyword">default</span>:           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SymbolTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>    <span class="hljs-type">char</span> str_table[<span class="hljs-number">9999</span>];<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_shnum;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), count, fp) != count) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Failed to read section headers&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fread</span>(str_table, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp) != shdr[elf64_hdr-&gt;e_shstrndx].sh_size) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Failed to read string table&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">if</span> (shdr[i].sh_type == <span class="hljs-number">2</span> || shdr[i].sh_type == <span class="hljs-number">11</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t==========symbol Table %s==========\n&quot;</span>, &amp;strtable[shdr[i].sh_name]);<br>            <span class="hljs-keyword">if</span> (shdr[i].sh_entsize == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            Elf64_Xword symbolnum = shdr[i].sh_size / shdr[i].sh_entsize;<br><br>            <span class="hljs-comment">// 加载符号表段</span><br>            Elf64_Sym* pSymbolTable = (Elf64_Sym*)<span class="hljs-built_in">malloc</span>(shdr[i].sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[i].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pSymbolTable, <span class="hljs-number">1</span>, shdr[i].sh_size, fp);<br><br>            <span class="hljs-comment">// 加载关联的字符串表</span><br>            <span class="hljs-type">char</span>* str_table = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(shdr[shdr[i].sh_link].sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[shdr[i].sh_link].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(str_table, <span class="hljs-number">1</span>, shdr[shdr[i].sh_link].sh_size, fp);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tNum \tValue\t\tSize\t\tIndex\t\tName\n&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; symbolnum; j++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%04d&quot;</span>, j);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pSymbolTable[j].st_value);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pSymbolTable[j].st_size);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%04x&quot;</span>, pSymbolTable[j].st_shndx);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\n&quot;</span>, str_table + pSymbolTable[j].st_name);<br>            &#125;<br><br>            <span class="hljs-built_in">free</span>(pSymbolTable);<br>            <span class="hljs-built_in">free</span>(str_table);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-4"><a href="#结果：-4" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/ILUkq2hCuRD5aAt.png" alt="image-20241222095255525"></p><h3 id="重定位表信息-Relocation-Table"><a href="#重定位表信息-Relocation-Table" class="headerlink" title="重定位表信息(Relocation Table)"></a>重定位表信息(Relocation Table)</h3><p><strong>处理动态链接和地址调整</strong>：用于修改可执行代码和数据的地址（例如修正指针或调用目标地址）。修正动态库或共享库的符号引用地址。实现位置无关代码（PIC）。</p><p>一般有两张重定位表:</p><ol><li><strong>.rel.plt</strong> 修复外部函数地址</li><li><strong>.rel.dyn</strong> 修复全局变量地址</li></ol><p>重定位表有SHT_REL, SHT_RELA, SHT_RELR三种类型。</p><h4 id="数据结构：-5"><a href="#数据结构：-5" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Addr r_offset; <span class="hljs-comment">/* 引用地址（需要重定位的位置） */</span><br>    Elf64_Xword r_info;  <span class="hljs-comment">/* 符号索引和重定位类型（编码信息） */</span><br>&#125;Elf64_Rel;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Addr r_offset;     <span class="hljs-comment">/* 引用地址（需要重定位的位置） */</span><br>    Elf64_Xword r_info;      <span class="hljs-comment">/* 符号索引和重定位类型（编码信息） */</span><br>    Elf64_Sxword r_addend;   <span class="hljs-comment">/* 表达式中的常量部分 */</span><br>&#125;Elf64_Rela;<br></code></pre></td></tr></table></figure><h4 id="解析代码：-5"><a href="#解析代码：-5" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getRelocationTypeString64</span><span class="hljs-params">(Elf64_Word value)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (value) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_NONE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PC32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOT32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PLT32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_COPY&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GLOB_DAT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_JMP_SLOT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_RELATIVE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOTOFF&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOTPC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_32PLT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_TPOFF&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_IE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GOTIE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_16&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">21</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PC16&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_8&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PC8&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_PUSH&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">26</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_CALL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_POP&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_PUSH&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_CALL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_POP&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDO_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_IE_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LE_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DTPMOD32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">36</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DTPOFF32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">37</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_TPOFF32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_SIZE32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GOTDESC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DESC_CALL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DESC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">42</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_IRELATIVE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">43</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOT32X&quot;</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unknown relocation type&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">RelocationTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sectionNum = elf64_hdr-&gt;e_shnum;<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), sectionNum, fp);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Relocation Tables:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sectionNum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (shdr[i].sh_type == <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 检查是否为重定位表</span><br>            Elf64_Shdr* pRelocationTableHeader = &amp;shdr[i];<br>            Elf64_Rel* pRelocationTable = (Elf64_Rel*)<span class="hljs-built_in">malloc</span>(pRelocationTableHeader-&gt;sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, pRelocationTableHeader-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pRelocationTable, pRelocationTableHeader-&gt;sh_size, <span class="hljs-number">1</span>, fp);<br><br>            Elf64_Word relocItemNum = pRelocationTableHeader-&gt;sh_size / pRelocationTableHeader-&gt;sh_entsize;<br><br>            <span class="hljs-comment">// 符号表头部</span><br>            Elf64_Shdr* pSymbolTableHeader = &amp;shdr[pRelocationTableHeader-&gt;sh_link];<br>            Elf64_Sym* pSymbolTable = (Elf64_Sym*)<span class="hljs-built_in">malloc</span>(pSymbolTableHeader-&gt;sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, pSymbolTableHeader-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pSymbolTable, pSymbolTableHeader-&gt;sh_size, <span class="hljs-number">1</span>, fp);<br><br>            <span class="hljs-comment">// 符号表的字符串表</span><br>            <span class="hljs-type">char</span>* pSymbolTableStringTable = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(shdr[pSymbolTableHeader-&gt;sh_link].sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[pSymbolTableHeader-&gt;sh_link].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pSymbolTableStringTable, shdr[pSymbolTableHeader-&gt;sh_link].sh_size, <span class="hljs-number">1</span>, fp);<br><br>            <span class="hljs-comment">// 段名字符串表</span><br>            <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Relocation Section &#x27;%s&#x27; at offset contains %d entries\n&quot;</span>, (<span class="hljs-type">char</span>*)strtable + shdr[i].sh_name, relocItemNum);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tOffset\t\tInfo\t\tType\t\t\t\tSym.value\t\tSym.name\n&quot;</span>);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; relocItemNum; j++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pRelocationTable[j].r_offset);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pRelocationTable[j].r_info);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\t&quot;</span>, <span class="hljs-built_in">getRelocationTypeString32</span>(<span class="hljs-built_in">ELF64_R_TYPE</span>(pRelocationTable[j].r_info)));<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx\t&quot;</span>, pSymbolTable[<span class="hljs-built_in">ELF64_R_SYM</span>(pRelocationTable[j].r_info)].st_value);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\n&quot;</span>, &amp;pSymbolTableStringTable[pSymbolTable[<span class="hljs-built_in">ELF64_R_SYM</span>(pRelocationTable[j].r_info)].st_name]);<br>            &#125;<br><br>            <span class="hljs-comment">// 释放动态内存</span><br>            <span class="hljs-built_in">free</span>(pRelocationTable);<br>            <span class="hljs-built_in">free</span>(pSymbolTable);<br>            <span class="hljs-built_in">free</span>(pSymbolTableStringTable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-5"><a href="#结果：-5" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/bv1kTzN6wXH2UeF.png" alt="image-20241222095355945"></p><h3 id="动态段-Dynamic-Segment"><a href="#动态段-Dynamic-Segment" class="headerlink" title="动态段(Dynamic Segment)"></a><strong>动态段(Dynamic Segment)</strong></h3><p>如果目标文件参与动态链接,必定包含一个类型为 PT_DYNAMIC 的Program表项, 对应节名为 .dynamic (type&#x3D;SHT_DYNAMIC)</p><p>动态段的作用是提供动态链接器所需要的信息,比如依赖哪些共享库文件,动态链接符号表的位置,动态链接重定位表的位置等</p><h4 id="数据结构：-6"><a href="#数据结构：-6" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//提供动态链接器所需要的信息,</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Sxword d_tag;<br>    <span class="hljs-keyword">union</span> &#123;<br>        Elf64_Xword d_val;<br>        Elf64_Addr d_ptr;<br>    &#125; d_un;<br>&#125; Elf64_Dyn;<br><span class="hljs-keyword">extern</span> Elf64_Dyn _DYNAMIC[];<br></code></pre></td></tr></table></figure><h4 id="解析代码：-6"><a href="#解析代码：-6" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_VAL 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_PTR 1</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getDynamicType</span><span class="hljs-params">(Elf64_Xword value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0x60000000</span> &amp;&amp; value &lt;= <span class="hljs-number">0x6fffffff</span>) <span class="hljs-comment">// DT_LOOS 和 DT_HIOS 的范围</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OS-Specific&quot;</span>;<br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0x70000000</span> &amp;&amp; value &lt;= <span class="hljs-number">0x7fffffff</span>) <span class="hljs-comment">// DT_LOPROC 和 DT_HIPROC 的范围</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Processor-Specific&quot;</span>;<br>    <span class="hljs-keyword">switch</span> (value) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  <span class="hljs-comment">// DT_NULL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NEEDED&quot;</span>;  <span class="hljs-comment">// DT_NEEDED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTRELSZ&quot;</span>;  <span class="hljs-comment">// DT_PLTRELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTGOT&quot;</span>;  <span class="hljs-comment">// DT_PLTGOT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HASH&quot;</span>;  <span class="hljs-comment">// DT_HASH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STRTAB&quot;</span>;  <span class="hljs-comment">// DT_STRTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMTAB&quot;</span>;  <span class="hljs-comment">// DT_SYMTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELA&quot;</span>;  <span class="hljs-comment">// DT_RELA</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELASZ&quot;</span>;  <span class="hljs-comment">// DT_RELASZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELAENT&quot;</span>;  <span class="hljs-comment">// DT_RELAENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STRSZ&quot;</span>;  <span class="hljs-comment">// DT_STRSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMENT&quot;</span>;  <span class="hljs-comment">// DT_SYMENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INIT&quot;</span>;  <span class="hljs-comment">// DT_INIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FINI&quot;</span>;  <span class="hljs-comment">// DT_FINI</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SONAME&quot;</span>;  <span class="hljs-comment">// DT_SONAME</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RPATH&quot;</span>;  <span class="hljs-comment">// DT_RPATH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMBOLIC&quot;</span>;  <span class="hljs-comment">// DT_SYMBOLIC</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;REL&quot;</span>;  <span class="hljs-comment">// DT_REL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELSZ&quot;</span>;  <span class="hljs-comment">// DT_RELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELENT&quot;</span>;  <span class="hljs-comment">// DT_RELENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTREL&quot;</span>;  <span class="hljs-comment">// DT_PLTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">21</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG&quot;</span>;  <span class="hljs-comment">// DT_DEBUG</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TEXTREL&quot;</span>;  <span class="hljs-comment">// DT_TEXTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;JMPREL&quot;</span>;  <span class="hljs-comment">// DT_JMPREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;BIND_NOW&quot;</span>;  <span class="hljs-comment">// DT_BIND_NOW</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INIT_ARRAY&quot;</span>;  <span class="hljs-comment">// DT_INIT_ARRAY</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">26</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FINI_ARRAY&quot;</span>;  <span class="hljs-comment">// DT_FINI_ARRAY</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INIT_ARRAYSZ&quot;</span>;  <span class="hljs-comment">// DT_INIT_ARRAYSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FINI_ARRAYSZ&quot;</span>;  <span class="hljs-comment">// DT_FINI_ARRAYSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RUNPATH&quot;</span>;  <span class="hljs-comment">// DT_RUNPATH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FLAGS&quot;</span>;  <span class="hljs-comment">// DT_FLAGS</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ENCODING&quot;</span>;  <span class="hljs-comment">// DT_ENCODING</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMTAB_SHNDX&quot;</span>;  <span class="hljs-comment">// DT_SYMTAB_SHNDX</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELRSZ&quot;</span>;  <span class="hljs-comment">// DT_RELRSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELR&quot;</span>;  <span class="hljs-comment">// DT_RELR</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELRENT&quot;</span>;  <span class="hljs-comment">// DT_RELRENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">36</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NUM&quot;</span>;  <span class="hljs-comment">// DT_NUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">37</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VALRNGLO&quot;</span>;  <span class="hljs-comment">// DT_VALRNGLO</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_PRELINKED&quot;</span>;  <span class="hljs-comment">// DT_GNU_PRELINKED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_CONFLICTSZ&quot;</span>;  <span class="hljs-comment">// DT_GNU_CONFLICTSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_LIBLISTSZ&quot;</span>;  <span class="hljs-comment">// DT_GNU_LIBLISTSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CHECKSUM&quot;</span>;  <span class="hljs-comment">// DT_CHECKSUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">42</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTPADSZ&quot;</span>;  <span class="hljs-comment">// DT_PLTPADSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">43</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MOVEENT&quot;</span>;  <span class="hljs-comment">// DT_MOVEENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">44</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MOVESZ&quot;</span>;  <span class="hljs-comment">// DT_MOVESZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">45</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FEATURE_1&quot;</span>;  <span class="hljs-comment">// DT_FEATURE_1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">46</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;POSFLAG_1&quot;</span>;  <span class="hljs-comment">// DT_POSFLAG_1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">47</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMINSZ&quot;</span>;  <span class="hljs-comment">// DT_SYMINSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">48</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMINENT&quot;</span>;  <span class="hljs-comment">// DT_SYMINENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">49</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ADDRRNGLO&quot;</span>;  <span class="hljs-comment">// DT_ADDRRNGLO</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">50</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_HASH&quot;</span>;  <span class="hljs-comment">// DT_GNU_HASH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">51</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TLSDESC_PLT&quot;</span>;  <span class="hljs-comment">// DT_TLSDESC_PLT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">52</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TLSDESC_GOT&quot;</span>;  <span class="hljs-comment">// DT_TLSDESC_GOT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">53</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_CONFLICT&quot;</span>;  <span class="hljs-comment">// DT_GNU_CONFLICT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">54</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_LIBLIST&quot;</span>;  <span class="hljs-comment">// DT_GNU_LIBLIST</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">55</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CONFIG&quot;</span>;  <span class="hljs-comment">// DT_CONFIG</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">56</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEPAUDIT&quot;</span>;  <span class="hljs-comment">// DT_DEPAUDIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">57</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AUDIT&quot;</span>;  <span class="hljs-comment">// DT_AUDIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">58</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTPAD&quot;</span>;  <span class="hljs-comment">// DT_PLTPAD</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">59</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MOVETAB&quot;</span>;  <span class="hljs-comment">// DT_MOVETAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">60</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMINFO&quot;</span>;  <span class="hljs-comment">// DT_SYMINFO</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">61</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERSYM&quot;</span>;  <span class="hljs-comment">// DT_VERSYM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELACOUNT&quot;</span>;  <span class="hljs-comment">// DT_RELACOUNT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">63</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELCOUNT&quot;</span>;  <span class="hljs-comment">// DT_RELCOUNT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FLAGS_1&quot;</span>;  <span class="hljs-comment">// DT_FLAGS_1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">65</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERDEF&quot;</span>;  <span class="hljs-comment">// DT_VERDEF</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">66</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERDEFNUM&quot;</span>;  <span class="hljs-comment">// DT_VERDEFNUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">67</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERNEED&quot;</span>;  <span class="hljs-comment">// DT_VERNEED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">68</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERNEEDNUM&quot;</span>;  <span class="hljs-comment">// DT_VERNEEDNUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">69</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AUXILIARY&quot;</span>;  <span class="hljs-comment">// DT_AUXILIARY</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">70</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FILTER&quot;</span>;  <span class="hljs-comment">// DT_FILTER</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unknown Type&quot;</span>;  <span class="hljs-comment">// Unknown DT type</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">getDynamicDunType</span><span class="hljs-params">(Elf64_Xword value)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (value) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// DT_NULL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// DT_NEEDED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// DT_PLTRELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-comment">// DT_RELASZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-comment">// DT_RELAENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-comment">// DT_STRSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: <span class="hljs-comment">// DT_SYMENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-comment">// DT_SONAME</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: <span class="hljs-comment">// DT_RPATH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: <span class="hljs-comment">// DT_SYMBOLIC</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: <span class="hljs-comment">// DT_RELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>: <span class="hljs-comment">// DT_RELENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>: <span class="hljs-comment">// DT_PLTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">21</span>: <span class="hljs-comment">// DT_TEXTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">24</span>: <span class="hljs-comment">// DT_BIND_NOW</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x70000000</span>: <span class="hljs-comment">// DT_LOPROC</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x7fffffff</span>: <span class="hljs-comment">// DT_HIPROC</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// DT_VAL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// DT_PLTGOT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// DT_HASH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-comment">// DT_STRTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-comment">// DT_SYMTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-comment">// DT_RELA</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: <span class="hljs-comment">// DT_INIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: <span class="hljs-comment">// DT_FINI</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">23</span>: <span class="hljs-comment">// DT_JMPREL</span><br>    <span class="hljs-comment">//case 21: // DT_DEBUG</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>: <span class="hljs-comment">// DT_REL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// DT_PTR</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// DT_VAL</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">printDynamicSegment64</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取 ELF 文件中的节头表信息</span><br>    Elf64_Shdr* pSectionHeader = (Elf64_Shdr*)<span class="hljs-built_in">malloc</span>(elf64_hdr-&gt;e_shnum * <span class="hljs-built_in">sizeof</span>(Elf64_Shdr));<br>    <span class="hljs-keyword">if</span> (!pSectionHeader) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for section header failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(pSectionHeader, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), elf64_hdr-&gt;e_shnum, fp);<br><br>    <span class="hljs-comment">// 获取节头字符串表</span><br>    <span class="hljs-type">char</span>* pSectionHeaderStringTable = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(pSectionHeader[elf64_hdr-&gt;e_shstrndx].sh_size);<br>    <span class="hljs-keyword">if</span> (!pSectionHeaderStringTable) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for section header string table failed&quot;</span>);<br>        <span class="hljs-built_in">free</span>(pSectionHeader);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, pSectionHeader[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(pSectionHeaderStringTable, <span class="hljs-number">1</span>, pSectionHeader[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>    <span class="hljs-comment">// 处理动态节</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elf64_hdr-&gt;e_shnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (pSectionHeader[i].sh_type == <span class="hljs-number">6</span>) &#123;  <span class="hljs-comment">// SHT_DYNAMIC == 6</span><br>            Elf64_Shdr* pDynamicSection = &amp;pSectionHeader[i];<br>            Elf64_Word dynamicItemNum = pDynamicSection-&gt;sh_size / pDynamicSection-&gt;sh_entsize;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dynamic Section At File Offset %#lx Contains %d Entries:\n&quot;</span>, pDynamicSection-&gt;sh_offset, dynamicItemNum);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tTag \t\tType\t\t\t\tName/Value\n&quot;</span>);<br><br>            <span class="hljs-comment">// 动态段表项</span><br>            Elf64_Dyn* pDynamicTable = (Elf64_Dyn*)<span class="hljs-built_in">malloc</span>(pDynamicSection-&gt;sh_size);<br>            <span class="hljs-keyword">if</span> (!pDynamicTable) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for dynamic table failed&quot;</span>);<br>                <span class="hljs-built_in">free</span>(pSectionHeader);<br>                <span class="hljs-built_in">free</span>(pSectionHeaderStringTable);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 获取动态字符串表</span><br>            Elf64_Shdr* pDynamicStringTableHeader = &amp;pSectionHeader[pDynamicSection-&gt;sh_link];<br>            <span class="hljs-type">char</span>* pDynamicStringTable = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(pDynamicStringTableHeader-&gt;sh_size);<br>            <span class="hljs-keyword">if</span> (!pDynamicStringTable) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for dynamic string table failed&quot;</span>);<br>                <span class="hljs-built_in">free</span>(pSectionHeader);<br>                <span class="hljs-built_in">free</span>(pSectionHeaderStringTable);<br>                <span class="hljs-built_in">free</span>(pDynamicTable);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 读取动态表项和字符串表数据</span><br>            <span class="hljs-built_in">fseek</span>(fp, pDynamicSection-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pDynamicTable, <span class="hljs-built_in">sizeof</span>(Elf64_Dyn), dynamicItemNum, fp);<br><br>            <span class="hljs-built_in">fseek</span>(fp, pDynamicStringTableHeader-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pDynamicStringTable, <span class="hljs-number">1</span>, pDynamicStringTableHeader-&gt;sh_size, fp);<br><br>            <span class="hljs-comment">// 打印动态表项</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dynamicItemNum; j++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pDynamicTable[j].d_tag);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%-16s&quot;</span>, <span class="hljs-built_in">getDynamicType</span>(pDynamicTable[j].d_tag));<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx\t&quot;</span>, pDynamicTable[j].d_un.d_val);<br><br>                <span class="hljs-comment">// 判断指针类型并输出特殊处理</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getDynamicDunType</span>(pDynamicTable[j].d_tag) == DT_PTR) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(PTR)&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// 如果是共享库路径或者 soname，则输出字符串</span><br>                <span class="hljs-keyword">switch</span> (pDynamicTable[j].d_tag) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// DT_NEEDED</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-comment">// DT_SONAME</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s]&quot;</span>, pDynamicStringTable + pDynamicTable[j].d_un.d_val);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 释放动态表和字符串表内存</span><br>            <span class="hljs-built_in">free</span>(pDynamicTable);<br>            <span class="hljs-built_in">free</span>(pDynamicStringTable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放节头表和节头字符串表内存</span><br>    <span class="hljs-built_in">free</span>(pSectionHeader);<br>    <span class="hljs-built_in">free</span>(pSectionHeaderStringTable);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-6"><a href="#结果：-6" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/hXzbduwpFji7Vrs.png" alt="image-20241222095317517"></p><p>完整代码放在github上：<a href="https://github.com/wangxiaobai08/ELFReader.git">https://github.com/wangxiaobai08/ELFReader.git</a></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/SpiritiualWander/p/17903141.html">《程序员的自我修养——链接、装载与库》（作者：俞子甲）读书笔记 - 逝玄 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/GrayOnDream/article/details/124564129">ELF文件格式简介_elf文件格式详解-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45896211/article/details/138139225">可执行文件格式：ELF_elf文件-CSDN博客</a></p><p><a href="https://www.52pojie.cn/thread-1985443-1-1.html#51841344_symbol-table">ELF文件结构浅析-解析器和加载器实现 - 吾爱破解 - 52pojie.cn</a></p>]]></content>
    
    
    <categories>
      
      <category>逆向(android)</category>
      
      <category>文件格式/装载链接运行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向(android)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务</title>
    <link href="/2023/05/06/%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/05/06/%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要有事务？"><a href="#为什么要有事务？" class="headerlink" title="为什么要有事务？"></a>为什么要有事务？</h1><p>事务会把数据库从一种一致状态转换为另一种一致状态，简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</p><blockquote><p>最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p></blockquote><h1 id="事务的四个特征-ACID"><a href="#事务的四个特征-ACID" class="headerlink" title="事务的四个特征(ACID)"></a>事务的四个特征(ACID)</h1><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. <strong>原子性</strong></h3><ul><li><strong>定义</strong>：事务中的操作要么全部完成，要么全部不做。事务是最小的操作单元，不能拆分。如果事务执行过程中出现问题，数据库将回滚到事务开始之前的状态，所有对数据库的修改都会撤销。</li><li><strong>例子</strong>：在银行转账过程中，如果账户A转账给账户B的操作由多个步骤组成（如扣款、存款），其中任何一步失败，所有操作都会回滚，确保不会出现“扣款成功但存款失败”的不一致状态。</li><li><strong>关键点</strong>：<ul><li>如果事务中的任何操作失败，所有操作都应回滚。</li><li>提供了”要么全做，要么全不做”的保证。</li></ul></li></ul><h3 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2. 一致性"></a>2. <strong>一致性</strong></h3><ul><li><strong>定义</strong>：事务必须使数据库从一个一致的状态转变到另一个一致的状态。也就是说，事务的执行不能违反数据库的约束、规则和业务逻辑。事务开始前和完成后，数据库中的数据都必须符合预定的完整性约束。</li><li><strong>例子</strong>：在银行系统中，数据库的账户余额字段应该是非负数，转账操作执行前后，账户余额不会违反这一规则。如果事务开始前余额为10元，扣款10元后，余额应为0元。</li><li><strong>关键点</strong>：<ul><li>事务执行的结果不能导致数据库违反完整性约束（如外键、唯一性、检查约束等）。</li><li>一致性确保了数据库中的数据始终是有效且符合规则的。</li></ul></li></ul><h3 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3. 隔离性"></a>3. <strong>隔离性</strong></h3><ul><li><strong>定义</strong>：事务的执行不应该受到其他并发事务的干扰。每个事务应该像在独立的数据库上执行一样，不会看到其他事务未提交的数据。隔离性防止了并发事务之间的数据干扰（如脏读、不可重复读、幻读等问题）。</li><li><strong>例子</strong>：两个事务同时对同一条记录进行操作时，事务A修改了某个字段，而事务B也在操作同一字段。事务B不会看到事务A的未提交结果，只有事务A提交后，事务B才会看到事务A的更改。</li><li><strong>关键点</strong>：<ul><li>隔离性控制并发事务间的干扰。</li><li>隔离级别（如：读未提交、读已提交、可重复读、串行化）决定了并发事务的具体行为。</li><li>常见的问题：脏读、不可重复读、幻读。</li></ul></li></ul><h3 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4. 持久性"></a>4. <strong>持久性</strong></h3><ul><li><strong>定义</strong>：一旦事务提交，事务对数据库的修改将永久保存在数据库中，即使系统崩溃，数据也不会丢失。数据库会保证所有提交的事务结果都会持久化到磁盘，且不会被丢失。</li><li><strong>例子</strong>：假设一个转账事务已成功提交，虽然系统突然崩溃，转账的记录仍然会保存在数据库中，恢复后能看到该事务的影响。</li><li><strong>关键点</strong>：<ul><li>事务提交后，修改会永久保存。</li><li>即使在发生硬件故障、系统崩溃等情况下，已提交的事务数据也不会丢失。</li></ul></li></ul><h1 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h1><p>MySQL 中的事务通常依赖于存储引擎，最常用的是 <strong>InnoDB</strong> 引擎。事务的实现依赖于以下几个方面：</p><ol><li><strong>锁机制</strong>：<ul><li>MySQL 在处理事务时会使用锁机制来实现隔离性，主要有行锁、表锁等。InnoDB 默认使用行锁，这能够提高并发性。</li><li>锁的类型有 <strong>共享锁 (S Lock)</strong> 和 **排它锁 (X Lock)**。共享锁允许其他事务读取，但不能修改；排它锁则禁止其他事务访问该数据。</li></ul></li><li><strong>日志机制</strong>：<ul><li>**Redo Log (重做日志)**：用于保证事务的持久性，确保事务提交后能够恢复数据。</li><li>**Undo Log (回滚日志)**：用于保证事务的原子性和一致性，保证事务回滚时能够恢复到原始状态。</li></ul></li></ol><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><blockquote><p>具体可参考：</p><p>[03 事务隔离：为什么你改了我还看不见？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/03">https://learn.lianglianglee.com/专栏/MySQL实战45讲/03</a>  事务隔离：为什么你改了我还看不见？.md)</p><p><a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">事务隔离级别是怎么实现的？ | 小林coding</a></p><p>其中事务隔离性的前提还需了解：视图机制</p></blockquote><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>锁类型</strong></th><th><strong>性能影响</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td><strong>允许</strong></td><td><strong>允许</strong></td><td><strong>允许</strong></td><td>没有锁或共享锁</td><td>性能最好</td><td>性能要求高，不关心一致性的场景，如日志分析、缓存等</td></tr><tr><td><strong>READ COMMITTED</strong></td><td><strong>禁止</strong></td><td><strong>允许</strong></td><td><strong>允许</strong></td><td>共享锁、排他锁</td><td>较高</td><td>一般应用场景，平衡性能与一致性，如查询数据库</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td><strong>禁止</strong></td><td><strong>禁止</strong></td><td><strong>允许</strong></td><td>共享锁、间隙锁</td><td>较低</td><td>需要多次读取同一数据的一致性场景，如账单查询</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td><strong>禁止</strong></td><td><strong>禁止</strong></td><td><strong>禁止</strong></td><td>排他锁、间隙锁</td><td>性能最差</td><td>极高一致性要求的场景，如银行转账、库存管理等</td></tr></tbody></table><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>定义</strong></th><th><strong>问题</strong></th><th><strong>锁机制</strong></th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>事务可以读取其他事务未提交的数据（脏读），即使数据最后回滚，也可能被读取。</td><td><strong>脏读</strong>：读取未提交的数据，可能导致不一致。<strong>不可重复读</strong>：事务执行过程中数据发生变化。<strong>幻读</strong>：同一查询执行多次结果不同。</td><td><strong>没有锁</strong>，或使用 <strong>共享锁</strong>。多个事务可以同时读、写相同数据。</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>事务只能读取其他事务已提交的数据。避免了脏读，但会出现不可重复读问题。</td><td><strong>不可重复读</strong>：同一事务中两次读取相同数据可能得到不同结果。<strong>幻读</strong>：事务内多次查询，结果集会因其他事务的插入或删除而发生变化。</td><td><strong>共享锁</strong>：读取数据时加锁，写入数据时加排他锁。</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>事务内的所有读取都不会被其他事务修改，避免了脏读和不可重复读问题，但可能出现幻读。</td><td><strong>幻读</strong>：事务内的两次相同查询结果可能因其他事务插入数据而不同。</td><td><strong>共享锁</strong>：事务内的读取操作加共享锁；<strong>间隙锁</strong>：防止幻读。</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>事务完全串行执行，确保事务互不干扰，避免了脏读、不可重复读和幻读。</td><td>无，但性能大幅降低。适用于极高一致性要求的场景。</td><td><strong>排他锁</strong>：事务操作的数据被完全锁定，防止其他事务访问。</td></tr></tbody></table><h3 id="每个隔离级别的具体行为"><a href="#每个隔离级别的具体行为" class="headerlink" title="每个隔离级别的具体行为"></a>每个隔离级别的具体行为</h3><table><thead><tr><th><strong>事务隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>锁机制</strong></th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>允许其他事务读取未提交的数据</td><td>允许，数据可能发生变化</td><td>允许，可能导致不一致</td><td>无锁或共享锁，事务间并发性非常高</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>禁止，事务只能读取已提交数据</td><td>允许，数据可能发生变化</td><td>允许，其他事务可插入数据</td><td>使用共享锁保证已提交数据的读取，写入时加排他锁</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>禁止，事务读取的数据不会变化</td><td>禁止，读取的数据稳定</td><td>允许，其他事务可插入数据</td><td>使用共享锁防止数据变动，使用间隙锁防止幻读</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>禁止，事务完全串行化</td><td>禁止，数据读取不受干扰</td><td>禁止，所有数据完全隔离</td><td>排他锁，确保事务串行执行，不能同时有其他事务执行</td></tr></tbody></table><h3 id="事务隔离级别对性能的影响"><a href="#事务隔离级别对性能的影响" class="headerlink" title="事务隔离级别对性能的影响"></a>事务隔离级别对性能的影响</h3><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>并发性能</strong></th><th><strong>事务提交的延迟</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>最高</td><td>最低</td><td>临时查询、数据分析、日志等</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>高</td><td>较低</td><td>普通数据查询和更新操作</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>中等</td><td>中等</td><td>需要保证数据一致性但又不要求极端隔离的场景</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>最差</td><td>最高</td><td>对数据一致性要求极高的场景</td></tr></tbody></table><h1 id="事务的控制语句"><a href="#事务的控制语句" class="headerlink" title="事务的控制语句"></a>事务的控制语句</h1><p>在关系型数据库管理系统（RDBMS）中，事务用于确保数据库操作的 <strong>原子性（Atomicity）</strong>、<strong>一致性（Consistency）</strong>、<strong>隔离性（Isolation）</strong> 和 <strong>持久性（Durability）</strong>，统称为 <strong>ACID</strong> 属性。事务控制语句用于管理事务的开始、提交、回滚等操作，确保数据库操作的可靠性和一致性。</p><h2 id="常用事务控制语句"><a href="#常用事务控制语句" class="headerlink" title="常用事务控制语句"></a>常用事务控制语句</h2><ol><li><p><strong>BEGIN TRANSACTION &#x2F; START TRANSACTION</strong></p><ul><li><p>用于开始一个事务。</p></li><li><p>启动一个新的事务，所有在此之后执行的操作都属于该事务，直到事务被提交或回滚。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><span class="hljs-comment">-- 或</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>COMMIT</strong></p><ul><li><p>用于提交事务。</p></li><li><p>提交当前事务，使得事务内的所有操作永久性地保存到数据库中。</p></li><li><p>一旦事务提交，所做的更改无法撤销。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>ROLLBACK</strong></p><ul><li><p>用于回滚事务。</p></li><li><p>回滚当前事务，撤销事务内的所有操作，将数据库恢复到事务开始前的状态。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>SAVEPOINT</strong></p><ul><li><p>用于设置一个事务中的保存点。</p></li><li><p>保存点是事务内的一种标记，可以回滚到该保存点，而不是回滚整个事务。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SAVEPOINT</span> savepoint_name;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>ROLLBACK TO SAVEPOINT</strong></p><ul><li><p>用于回滚到某个保存点。</p></li><li><p>如果事务中的某部分操作不需要完全回滚，可以通过回滚到某个保存点，保留前面操作的结果。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> savepoint_name;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>RELEASE SAVEPOINT</strong></p><ul><li><p>用于释放某个保存点。</p></li><li><p>释放保存点后，无法再回滚到该保存点。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> savepoint_name;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>SET TRANSACTION</strong></p><ul><li><p>用于设置事务的隔离级别、读写模式等属性。</p></li><li><p>常用于修改事务的默认行为，如设置事务隔离级别、是否只读等。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br><span class="hljs-comment">-- 设置事务隔离级别为 SERIALIZABLE</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="事务控制语句的例子"><a href="#事务控制语句的例子" class="headerlink" title="事务控制语句的例子"></a>事务控制语句的例子</h2><ol><li><p><strong>基本事务操作：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><br><span class="hljs-comment">-- 执行一系列数据库操作</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> account_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> account_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，两个 <code>UPDATE</code> 语句操作了账户余额，只有在两个操作都成功时，事务才会提交。如果有任何一条语句失败，可以通过 <code>ROLLBACK</code> 回滚整个事务。</p></li><li><p><strong>使用 SAVEPOINT 和回滚到保存点：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><br><span class="hljs-keyword">SAVEPOINT</span> savepoint1;<br><br><span class="hljs-comment">-- 执行操作1</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> account_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">SAVEPOINT</span> savepoint2;<br><br><span class="hljs-comment">-- 执行操作2</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> account_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">-- 如果操作2失败，回滚到savepoint2</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> savepoint2;<br><br><span class="hljs-comment">-- 如果操作1失败，回滚到savepoint1</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> savepoint1;<br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>设置事务隔离级别：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br><br><span class="hljs-comment">-- 执行事务操作</span><br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure></li></ol><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p>[03 事务隔离：为什么你改了我还看不见？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/03">https://learn.lianglianglee.com/专栏/MySQL实战45讲/03</a>  事务隔离：为什么你改了我还看不见？.md)</p><p>[08 事务到底是隔离的还是不隔离的？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/08">https://learn.lianglianglee.com/专栏/MySQL实战45讲/08</a>  事务到底是隔离的还是不隔离的？.md)</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础知识</title>
    <link href="/2023/05/02/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Redis/"/>
    <url>/2023/05/02/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="动态简单字符串"><a href="#动态简单字符串" class="headerlink" title="动态简单字符串"></a>动态简单字符串</h2><h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h3><p><img src="https://s2.loli.net/2025/01/08/P74I2eQMcAXvbFx.png" alt="image-20250108101459074"></p><p>SDS 不仅可以保存文本数据，还可以保存二进制数据</p><ul><li>因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据；</li><li>所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据；</li></ul><h3 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h3><p>SDS 获取字符串长度的时间复杂度是 O(1)</p><ul><li>因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；</li><li>而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>；</li></ul><h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p><strong>减少内存重分配的策略</strong>：</p><ul><li><strong>逐步增长</strong>：每次增加字符串长度时，SDS会选择适度增加内存而非立即扩展至精确所需的大小。通过这种“宽松”的增长策略，避免了每次修改都进行内存重分配。</li><li><strong>空闲空间复用</strong>：当缩短字符串时（比如执行<code>SDS</code>的<code>del</code>操作），SDS会适当地释放多余的空间，而不是立即重分配内存，这样可以避免不必要的内存分配。</li></ul><p><img src="https://s2.loli.net/2025/01/08/7OjrIDkK125ZNYw.png" alt="image-20250108102200324"></p><p><img src="https://s2.loli.net/2025/01/08/QzcqNtF1ZgwJ3Io.png" alt="image-20250108102236926"></p><h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</p><ul><li>因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题</li></ul><p><img src="https://s2.loli.net/2025/01/08/qZKYH2mak68sTie.png" alt="image-20250108102343775"></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表的基本知识请参考之前文章：<a href="https://wangxiaobai08.github.io/2023/01/12/%E9%93%BE%E8%A1%A8/">链表 - The Peak Tower</a></p><h3 id="链表节点结构"><a href="#链表节点结构" class="headerlink" title="链表节点结构"></a>链表节点结构</h3><p><img src="https://s2.loli.net/2025/01/08/OrnBQJhKvtjVp3S.png" alt="image-20250108103200782"></p><h3 id="链表整体结构"><a href="#链表整体结构" class="headerlink" title="链表整体结构"></a>链表整体结构</h3><p><img src="https://s2.loli.net/2025/01/08/ZdspeMYvUmIboXl.png" alt="image-20250108103320907"></p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><img src="https://s2.loli.net/2025/01/08/Mi6vglG9WNY8ReZ.png" alt="image-20250108103409751"></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="https://s2.loli.net/2025/01/08/wDmJNq1CnFV8aer.png" alt="image-20250108103918249"></p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p><img src="https://s2.loli.net/2025/01/08/qpE2uZV1ixYRrMj.png" alt="image-20250108104003217"></p><h3 id="字典实现"><a href="#字典实现" class="headerlink" title="字典实现"></a>字典实现</h3><p><img src="https://s2.loli.net/2025/01/08/otZE71fJMAOW5NH.png" alt="image-20250108104115162"></p><p><img src="https://s2.loli.net/2025/01/08/YAcCskLvFjTy9rQ.png" alt="image-20250108104130623"></p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/lzhcoder/article/details/122539972">Redis 跳跃表的原理和实现_redis跳表原理-CSDN博客</a></p></blockquote><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/m0_51504545/article/details/117391204">Redis - ziplist (压缩列表) 图文详解-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/375414918">redis 压缩列表ziplist、quicklist - 知乎</a></p></blockquote><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/hunternet/p/11268067.html">Redis数据结构——整数集合 - 随心所于 - 博客园</a></p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/chenssy/article/details/118280266">【死磕 Redis】—– Redis 数据结构：对象（RedisObject）-CSDN博客</a></p><p><a href="https://www.cnblogs.com/wind-snow/p/11172832.html">Redis 学习笔记（篇五）：对象（RedisObject） - 风中抚雪 - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/389165715">Redis进阶 - 数据结构：对象机制详解，一文深入底层分析 - 知乎</a></p><p><a href="https://cloud.tencent.com/developer/article/2447041">深入浅出Redis（一）：对象与数据结构-腾讯云开发者社区-腾讯云</a></p></blockquote><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><blockquote><p>参考<a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/2.Redis-%E5%9F%BA%E7%A1%80%E7%AF%87-02-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html">Redis-基础篇-②线程模型 | 一人の境</a></p></blockquote><h1 id="过期删除策略和内存淘汰策略"><a href="#过期删除策略和内存淘汰策略" class="headerlink" title="过期删除策略和内存淘汰策略"></a>过期删除策略和内存淘汰策略</h1><blockquote><p>参考<a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/2.Redis/2.Redis-%E5%9F%BA%E7%A1%80%E7%AF%87-03-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html#_1-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">Redis-基础篇-③过期删除策略和内存淘汰策略 | 一人の境</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备份与恢复</title>
    <link href="/2023/05/01/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <url>/2023/05/01/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这部分内容没有一定的实践,缺少一定的经验，故在次只了解些基本的概念，并提供一系列前辈的文章阅读。以后时间充裕再一一完善</p></blockquote><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><h2 id="前景导读"><a href="#前景导读" class="headerlink" title="前景导读"></a>前景导读</h2><p>备份的顾名思义是指将 MySQL 数据库中的数据和结构保存到一个外部存储介质（如文件、云存储等）中，以便在数据丢失、系统崩溃、误操作或其他灾难性事件发生时，能够恢复数据库的内容。</p><p>备份的主要目的是确保数据的安全性和可恢复性，它是数据库管理中的一项重要工作。如果更详细一点，可能是：</p><ol><li><strong>防止数据丢失</strong>：例如硬盘故障、误删除、病毒攻击等，都可能导致数据丢失。</li><li><strong>系统恢复</strong>：在服务器崩溃或操作系统出问题时，数据库备份可以帮助快速恢复。</li><li><strong>数据迁移</strong>：将数据库迁移到新服务器或者升级时，备份可以确保数据的完整性。</li><li><strong>版本管理</strong>：通过备份可以保留不同时间点的数据库快照，方便查找历史数据。</li></ol><hr><h2 id="备份什么？"><a href="#备份什么？" class="headerlink" title="备份什么？"></a>备份什么？</h2><p>MySQL 数据库的备份不仅仅包括存储在数据库中的数据，还包括数据库的结构（表结构、索引、视图等）。备份的内容通常分为以下几类：</p><ol><li><strong>数据</strong>：包括表中的记录。</li><li><strong>结构</strong>：表的定义（列的名称、数据类型、索引等）。</li><li><strong>存储过程和触发器</strong>：如果数据库使用了存储过程、函数或触发器，它们也需要备份。</li><li><strong>配置文件</strong>：MySQL 配置文件（如 <code>my.cnf</code>）可以包含数据库的配置参数。</li></ol><h2 id="备份的方式"><a href="#备份的方式" class="headerlink" title="备份的方式"></a>备份的方式</h2><h3 id="1-按照不同类型来划分备份"><a href="#1-按照不同类型来划分备份" class="headerlink" title="1.按照不同类型来划分备份"></a>1.按照不同类型来划分备份</h3><table><thead><tr><th>类型</th><th>说明</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>热备</strong></td><td>在数据库运行的同时进行备份（在线备份）。</td><td>备份过程不会中断数据库的正常运行。</td><td>适用于大规模、高可用性要求的生产环境。</td></tr><tr><td><strong>冷备</strong></td><td>在数据库停机的情况下进行备份（离线备份）。</td><td>需要停止数据库服务，确保数据一致性。</td><td>适用于不要求高可用性的小规模或低负载环境。</td></tr><tr><td><strong>温备</strong></td><td>介于热备和冷备之间，部分数据在备份过程中保持可访问状态。</td><td>一些数据或表可能处于备份状态，但数据库仍然部分可用。</td><td>适用于需要一定停机时间，但仍希望减少系统停机时间的场景。</td></tr></tbody></table><h3 id="2-按照备份后文件的内容"><a href="#2-按照备份后文件的内容" class="headerlink" title="2. 按照备份后文件的内容"></a>2. 按照备份后文件的内容</h3><table><thead><tr><th>类型</th><th>说明</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>逻辑备份</strong></td><td>将数据库的表结构、数据、视图、存储过程等导出为 SQL 文件。</td><td>备份文件为 SQL 脚本，容易迁移和恢复，通常生成一个可执行的 SQL 文件。</td><td>适用于小型数据库的备份，或需要迁移到不同类型数据库时。</td></tr><tr><td><strong>裸文件备份</strong></td><td>直接复制数据库的物理文件（如 <code>.ibd</code>、<code>.frm</code>、<code>.myd</code> 等文件）。</td><td>备份过程较为快速，但恢复时要求数据库处于一致性状态。</td><td>适用于大规模数据库，备份和恢复速度要求较高的场景。</td></tr></tbody></table><h3 id="3-按照备份数据库的内容"><a href="#3-按照备份数据库的内容" class="headerlink" title="3. 按照备份数据库的内容"></a>3. 按照备份数据库的内容</h3><table><thead><tr><th>类型</th><th>说明</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>完全备份</strong></td><td>对整个数据库进行完整的备份，包括所有表、数据、索引等。</td><td>创建完整的数据副本，恢复时恢复全部数据。</td><td>适用于定期进行备份，并确保数据完全恢复的场景。</td></tr><tr><td><strong>增量备份</strong></td><td>仅备份自上次备份以来发生变化的数据。</td><td>可以节省存储空间，并提高备份效率，但恢复时需要先恢复完全备份。</td><td>适用于数据量较大，需要节省存储的场景。</td></tr><tr><td><strong>日志备份</strong></td><td>备份数据库的事务日志或二进制日志（如 MySQL 的 binlog）。</td><td>适合记录数据库操作的日志，通常用于恢复到某个时间点。</td><td>用于数据恢复，尤其是需要恢复到某一特定时间点时。</td></tr></tbody></table><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/1.MySQL/5.MySQL-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87-05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.html#_2-%E6%97%A0%E6%8D%9F%E8%BF%81%E7%A7%BB-%E4%B8%8D%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB">MySQL-高可用篇-⑤数据迁移 | 一人の境</a></p><p><a href="https://blog.csdn.net/weixin_43612842/article/details/141607434">MySQL数据库的备份与恢复-超详细_mysql备份和还原数据库-CSDN博客</a></p><p><a href="https://www.myfreax.com/how-to-back-up-and-restore-mysql-databases-with-mysqldump/#">如何使用Mysqldump备份和还原MySQL数据库 | myfreax</a></p><p><a href="https://blog.csdn.net/zhang_yazhou/article/details/108107424">MySQL数据库的备份与恢复【完整备份、增量备份、差异备份】_mysql数据库备份增量全量差异如何选择-CSDN博客</a></p><p><a href="https://www.cnblogs.com/cherishthepresent/p/17446529.html">MySQL数据迁移、热备份及冷还原 - 往事已成昨天 - 博客园</a></p><p><a href="https://blog.csdn.net/weixin_42146230/article/details/113903427">mysql热备温备_数据库备份之热备，冷备，温备-CSDN博客</a></p><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>MySQL 复制是指通过将一个 MySQL 数据库（主服务器）的数据复制到另一个 MySQL 数据库（从服务器）来实现数据的同步。它主要用于数据冗余、负载均衡和高可用性。MySQL 复制是一种异步复制机制，但也可以配置为半同步复制。</p><h2 id="MySQL-复制的主要模式"><a href="#MySQL-复制的主要模式" class="headerlink" title="MySQL 复制的主要模式"></a>MySQL 复制的主要模式</h2><ol><li><strong>主从复制（Master-Slave Replication）</strong><ul><li><strong>主服务器（Master）</strong>：主服务器处理所有写入操作，所有的数据修改都会先写入主数据库。</li><li><strong>从服务器（Slave）</strong>：从服务器从主服务器读取二进制日志（binlog），并将这些日志中的操作应用到自己的数据库，从而保持与主服务器的数据同步。</li></ul></li><li><strong>主主复制（Master-Master Replication）</strong><ul><li>这是两台 MySQL 服务器相互作为主服务器和从服务器的模式。每个服务器既能进行数据写入，又能接收来自另一个服务器的写入操作。</li></ul></li><li><strong>半同步复制（Semi-Synchronous Replication）</strong><ul><li>这是 MySQL 5.5 及以后版本提供的增强型复制模式。在这种模式下，主服务器会等待至少一个从服务器确认已接收到数据后才会提交事务，保证主从数据一致性。</li></ul></li></ol><h2 id="MySQL-复制的基本工作原理"><a href="#MySQL-复制的基本工作原理" class="headerlink" title="MySQL 复制的基本工作原理"></a>MySQL 复制的基本工作原理</h2><ol><li><strong>主服务器记录 binlog</strong>：当在主服务器上执行数据修改操作（如插入、更新或删除数据）时，主服务器会将这些操作记录到一个二进制日志（binlog）中。</li><li><strong>从服务器请求日志</strong>：从服务器通过 I&#x2F;O 线程从主服务器请求 binlog。</li><li><strong>从服务器应用日志</strong>：从服务器将主服务器的 binlog 日志应用到自己的数据库（SQL 线程）。</li></ol><h2 id="具体内容-1"><a href="#具体内容-1" class="headerlink" title="具体内容"></a>具体内容</h2><p><a href="https://noob.holic-x.com/md/rebirth/2.%E6%95%B0%E6%8D%AE%E5%BA%93/1.MySQL/5.MySQL-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87-05-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.html#_2-%E6%97%A0%E6%8D%9F%E8%BF%81%E7%A7%BB-%E4%B8%8D%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB">MySQL-高可用篇-⑤数据迁移 | 一人の境</a></p><p>[23 MySQL是怎么保证数据不丢的？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/23">https://learn.lianglianglee.com/专栏/MySQL实战45讲/23</a>  MySQL是怎么保证数据不丢的？.md)</p><p>[41 怎么最快地复制一张表？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/41">https://learn.lianglianglee.com/专栏/MySQL实战45讲/41</a>  怎么最快地复制一张表？.md)</p><p>[24 MySQL是怎么保证主备一致的？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/24">https://learn.lianglianglee.com/专栏/MySQL实战45讲/24</a>  MySQL是怎么保证主备一致的？.md)</p><p>[25 MySQL是怎么保证高可用的？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/25">https://learn.lianglianglee.com/专栏/MySQL实战45讲/25</a>  MySQL是怎么保证高可用的？.md)</p><p>[26 备库为什么会延迟好几个小时？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/26">https://learn.lianglianglee.com/专栏/MySQL实战45讲/26</a>  备库为什么会延迟好几个小时？.md)</p><p>[27 主库出问题了，从库怎么办？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/27">https://learn.lianglianglee.com/专栏/MySQL实战45讲/27</a>  主库出问题了，从库怎么办？.md)</p><p>[28 读写分离有哪些坑？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/28">https://learn.lianglianglee.com/专栏/MySQL实战45讲/28</a>  读写分离有哪些坑？.md)</p><p><a href="https://blog.csdn.net/m0_53150398/article/details/144139581">mysql主从复制完整教程_mysql开启主从复制-CSDN博客</a></p><p><a href="https://blog.csdn.net/jianghuchuang/article/details/141779089">Mysql8 主从复制&amp;主从切换(超详细)_mysql8主从复制配置-CSDN博客</a></p><h1 id="备份与复制的对比"><a href="#备份与复制的对比" class="headerlink" title="备份与复制的对比"></a>备份与复制的对比</h1><ul><li><strong>备份</strong> 主要用于<strong>数据恢复</strong>，它是一个静态的过程，确保数据在丢失或损坏后能恢复。备份通常需要存储空间、可能会影响性能，并且恢复过程是手动的，恢复时间较长。它适用于灾难恢复、合规要求以及数据迁移等场景。</li><li><strong>复制</strong> 主要用于<strong>高可用性和负载均衡</strong>，它是一个动态的过程，能够实时或接近实时地同步数据。复制不需要像备份那样存储备份文件，而是通过自动化的方式保持主从数据库的数据一致性。它适用于高可用性架构、分布式部署等场景。</li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>备份（Backup）</strong></th><th><strong>复制（Replication）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>将数据库的数据或结构保存到外部存储介质，以便在数据丢失或损坏时进行恢复。</td><td>将数据库的一个实例（主数据库）数据同步到另一个数据库实例（从数据库）。</td></tr><tr><td><strong>目的</strong></td><td>防止数据丢失，确保灾难恢复和数据安全。</td><td>提高系统的可用性、冗余、负载均衡和故障转移。</td></tr><tr><td><strong>操作模式</strong></td><td>通常是定期执行，生成静态的备份文件（如全量、增量备份）。</td><td>自动持续执行，实时同步主服务器的数据到从服务器。</td></tr><tr><td><strong>一致性</strong></td><td>备份时保证数据一致性，特别是全备时。</td><td>数据同步过程中，可能会有延迟，从服务器滞后于主服务器。</td></tr><tr><td><strong>恢复方式</strong></td><td>需要恢复备份文件，手动操作，恢复时间较长。</td><td>数据无需恢复，复制自动进行，不会丢失数据。</td></tr><tr><td><strong>手动恢复</strong></td><td>需要手动恢复备份，恢复过程可能需要停机。</td><td>无需手动恢复，系统自动同步。</td></tr><tr><td><strong>容错性与高可用性</strong></td><td>主要用于灾难恢复，确保在数据丢失时能够恢复。</td><td>实时数据冗余，主服务器故障时可以进行故障转移。</td></tr><tr><td><strong>恢复时间</strong></td><td>恢复过程通常较慢，需要手动操作和较长的恢复时间。</td><td>恢复过程迅速，自动切换或通过从服务器提高可用性。</td></tr><tr><td><strong>性能影响</strong></td><td>备份过程（特别是全量备份）可能会影响数据库性能。</td><td>主服务器性能可能会受到影响，尤其是在高负载时。</td></tr><tr><td><strong>存储需求</strong></td><td>需要额外的存储空间来保存备份文件（全量备份、增量备份）。</td><td>需要从服务器存储数据，通常是主服务器数据的副本。</td></tr><tr><td><strong>存储空间需求</strong></td><td>存储空间需求较高，特别是全量备份。</td><td>存储需求相对较小，只保存主服务器数据的实时副本。</td></tr><tr><td><strong>容灾功能</strong></td><td>在数据丢失或损坏时，从备份中恢复数据。</td><td>如果主服务器崩溃，可以通过将从服务器提升为主服务器来恢复服务。</td></tr><tr><td><strong>适用场景</strong></td><td>用于灾难恢复、数据迁移和合规要求。</td><td>用于高可用性、负载均衡和分布式架构。</td></tr><tr><td><strong>应用举例</strong></td><td>数据丢失后恢复、跨地域的数据库迁移。</td><td>主从架构、主主架构、分布式数据库、负载均衡。</td></tr><tr><td><strong>适用范围</strong></td><td>灾难恢复、合规性要求、数据迁移。</td><td>高可用性、数据同步、负载均衡、故障转移。</td></tr><tr><td><strong>主从角色</strong></td><td>不涉及主从角色，通常是静态备份数据。</td><td>明确有主服务器和从服务器的角色，数据从主到从同步。</td></tr><tr><td><strong>备份周期</strong></td><td>根据需求定期进行，如每日、每周、每月等。</td><td>持续同步，几乎实时或接近实时。</td></tr><tr><td><strong>维护成本</strong></td><td>备份和恢复需要存储设备和操作时间，手动介入多。</td><td>配置和监控复制过程，保持主从同步，自动化程度较高。</td></tr><tr><td><strong>可扩展性</strong></td><td>可以通过增加备份频率、采用增量备份等方式提高灵活性。</td><td>可以通过增加从服务器实现负载均衡和容错。</td></tr><tr><td><strong>数据完整性</strong></td><td>确保备份时数据的一致性和完整性，特别是在全备时。</td><td>在高负载或异步复制时，可能出现数据延迟或不一致的问题。</td></tr><tr><td><strong>恢复的完整性</strong></td><td>可以恢复到特定时间点的数据（全量、增量备份）。</td><td>无法指定恢复到某个时间点，而是通过从服务器的实时数据进行恢复。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁机制</title>
    <link href="/2023/04/29/%E9%94%81/"/>
    <url>/2023/04/29/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2025/01/04/BhfgxmkNuO8Fp2P.png" alt="2024-01-04_214520"></p><h1 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h1><p>有并发的对一个资源进行操作的地方就有锁，作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。锁也是正确并发执行的前提条件</p><p>但与控制多线程并发访问临界资源的锁不同，MySQL中的锁的对象是事务。</p><p><img src="https://s2.loli.net/2025/01/02/gTt7CKReduyH4GD.png" alt="image-20250102161853031"></p><h1 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h1><h2 id="关键导读"><a href="#关键导读" class="headerlink" title="关键导读"></a>关键导读</h2><p><em><strong>我们知道通过锁机制可以实现事务的隔离性要求，使得事务可以并发地工作。锁提高了并发，但是却会带来潜在的问题，不过因为事务隔离性的要求，并发只会带来三种问题。如果可以防止这三种问题，就不会发生异常。</strong></em></p><hr><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>脏读是指一个事务读取了另一个事务未提交的数据。换句话说，某个事务读取了其他事务尚未提交的数据，这可能导致读取的数据不一致或者在后续操作中出现错误。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>假设有两个事务，<strong>事务 A</strong> 和 <strong>事务 B</strong>：</p><ul><li><strong>事务 A</strong> 修改了数据，并尚未提交。</li><li><strong>事务 B</strong> 在<strong>事务 A</strong> 提交之前读取了这个数据。</li></ul><p>此时，<strong>事务 B</strong> 就读取了<strong>事务 A</strong> 中未提交的“脏数据”，如果<strong>事务 A</strong> 后续回滚了，则<strong>事务 B</strong> 读到的数据是无效的（因为事务 A 实际上并没有修改数据）。</p><h2 id="幻读-不可重复读"><a href="#幻读-不可重复读" class="headerlink" title="幻读(不可重复读)"></a>幻读(不可重复读)</h2><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>幻读（也叫不可重复读）是指在一个事务中，两次读取相同的查询条件时，查询结果发生了变化。具体地说，事务在读取某些数据时，另一个事务可以插入、删除或修改这些数据，使得后续的读取结果与之前不同。幻读通常发生在<strong>SELECT</strong> 查询操作中。</p><h4 id="举个例子：-1"><a href="#举个例子：-1" class="headerlink" title="举个例子："></a>举个例子：</h4><p>假设有两个事务，<strong>事务 A</strong> 和 <strong>事务 B</strong>：</p><ul><li><strong>事务 A</strong> 执行了一个查询 <code>SELECT * FROM table WHERE amount &gt; 100</code>，假设返回了 3 条数据。</li><li><strong>事务 B</strong> 在 <strong>事务 A</strong> 查询后，向数据库中插入了新的数据（<code>amount &gt; 100</code>）。</li><li><strong>事务 A</strong> 再次执行相同的查询时，返回的数据条数发生了变化，变成了 4 条。</li></ul><p>此时，<strong>事务 A</strong> 在同一个事务中读取的结果发生了变化，这种情况就是幻读。</p><h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h4><p>丢失更新是指两个事务并发更新同一数据时，其中一个事务的更新操作被另一个事务的更新覆盖，导致其中一个更新丢失了。</p><h4 id="举个例子：-2"><a href="#举个例子：-2" class="headerlink" title="举个例子："></a>举个例子：</h4><p>假设有两个事务，<strong>事务 A</strong> 和 <strong>事务 B</strong>：</p><ul><li><strong>事务 A</strong> 读取了数据 <code>x = 100</code>，并将其更新为 <code>x = 150</code>。</li><li><strong>事务 B</strong> 读取了相同的数据 <code>x = 100</code>，并将其更新为 <code>x = 120</code>。</li><li>最后，<strong>事务 A</strong> 提交，而 <strong>事务 B</strong> 提交，导致 <strong>事务 A</strong> 的更新被<strong>事务 B</strong> 覆盖，最终数据库中保存的值是 <code>120</code>，而不是 <code>150</code>。</li></ul><p>这种情况发生在两个事务并发地读取相同的数据并分别修改它们时，最终一个事务的更新会丢失。</p><h1 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h1><h2 id="锁机制的分类"><a href="#锁机制的分类" class="headerlink" title="锁机制的分类"></a>锁机制的分类</h2><hr><h3 id="关键导读-1"><a href="#关键导读-1" class="headerlink" title="关键导读"></a>关键导读</h3><p><em><strong>在上面我们谈到锁机制确保了并发执行，但却也会带来一定的并发问题，而解决这些问题的关键是事务隔离级别和锁的粒度：</strong></em></p><ul><li><em><strong>高隔离级别（如 Serializable）通过锁机制可以避免脏读、不可重复读和幻读，但会牺牲性能。</strong></em></li><li><em><strong>合理的锁粒度（如行级锁和间隙锁）可以尽量减少锁的冲突，从而提高并发性。</strong></em></li></ul><p><em><strong>其中事务隔离级别将在事务篇学习，在本篇有必要聊一聊锁的粒度问题。</strong></em></p><hr><h3 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h3><p>以操作类型的维度划分：</p><ul><li>读锁：查询数据时使用的锁。</li><li>写锁：执行插入、删除、修改、<code>DDL</code>语句时使用的锁。</li></ul><p>以加锁方式的维度划分：</p><ul><li>显示锁：编写<code>SQL</code>语句时，手动指定加锁的粒度。</li><li>隐式锁：执行<code>SQL</code>语句时，根据隔离级别自动为<code>SQL</code>操作加锁。</li></ul><p>其中以操作类型维度划分是历史遗留叫法，现在一般被升级或改造成共享锁和排他锁。而以加锁方式划分基本包含在一下分类中。以上两种在提高时指出就行，不单独赘述。</p><p>以下是锁分类的表格，按粒度、互斥性和思想的维度进行划分：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>锁类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>锁粒度的维度</strong></td><td><strong>表锁</strong></td><td>- <strong>全局锁</strong>：加锁后整个数据库只能读，不能写。</td></tr><tr><td></td><td></td><td>- <strong>元数据锁 &#x2F; MDL锁</strong>：基于表的元数据加锁，锁定表的结构，阻止其他事务修改表结构。</td></tr><tr><td></td><td></td><td>- <strong>意向锁</strong>：为了支持多粒度的锁，兼容行锁和表锁的存在。</td></tr><tr><td></td><td></td><td>- <strong>自增锁 &#x2F; AUTO-INC锁</strong>：为了提升自增ID的并发插入性能而设计的锁。</td></tr><tr><td></td><td><strong>页面锁</strong></td><td>针对数据页的加锁，数据页是InnoDB存储引擎中物理存储的基本单位。</td></tr><tr><td></td><td><strong>行锁</strong></td><td>- <strong>记录锁 &#x2F; Record锁</strong>：锁定单个数据行。</td></tr><tr><td></td><td></td><td>- <strong>间隙锁 &#x2F; Gap锁</strong>：锁住两个记录之间的间隙，防止幻读。</td></tr><tr><td></td><td></td><td>- <strong>临建锁 &#x2F; Next-Key锁</strong>：结合记录锁和间隙锁，既锁定数据行，又锁定行之间的间隙。</td></tr><tr><td><strong>互斥性的维度</strong></td><td><strong>共享锁 &#x2F; S锁</strong></td><td>允许多个事务同时获取该锁，不会相互排斥，通常用于读取数据时，允许多个事务并发读取同一行数据。</td></tr><tr><td></td><td><strong>排他锁 &#x2F; X锁</strong></td><td>不允许其他事务获得该锁，当前事务持有锁时，其他事务无法获取该锁，通常用于写操作。</td></tr><tr><td></td><td><strong>共享排他锁 &#x2F; SX锁</strong></td><td>允许多个事务获得共享锁，但当事务需要升级为排他锁时，会排斥其他事务的共享锁，主要用于解决SMO（共享-排他模式）问题。</td></tr><tr><td><strong>思想的维度</strong></td><td><strong>乐观锁</strong></td><td>认为事务可以顺利执行，事务开始时不立即加锁，而是执行时检查数据是否已被修改，若数据冲突，则回滚。</td></tr><tr><td></td><td><strong>悲观锁</strong></td><td>假定其他事务会影响当前事务的操作，事务开始时即加锁，直到事务完成才释放锁，确保事务的独占性。</td></tr></tbody></table><hr><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><blockquote><p>其实有些地方也将共享锁称之为读锁，排他锁称之为写锁，这乍一听并没啥问题，毕竟对同一数据做读操作是可以共享的，写则是不允许。但这个说法并不完全正确，因为读操作也可以是排他锁，即读操作发生时也不允许其他线程操作，而<code>MySQL</code>中也的的确确有这类场景，比如：<br> 一条线程在读数据时加了一把锁（读锁），此时当另外一条线程来尝试对相同数据做写操作时，这条线程会陷入阻塞，因为<code>MySQL</code>中一条线程在读时不允许其他线程改。<br> 在上述这个案例中，读锁明显也会存在排斥写操作，因此前面说法并不正确，<strong>共享锁就是共享锁，排他锁就是排他锁，不能与读锁、写锁混为一谈</strong>。</p></blockquote><p><strong>共享锁</strong>顾名思义不同事务之间不会排斥，可以同时获取锁并执行，注意这里的共享是指允许多个事务同时读取数据，但<strong>不允许其他事务修改</strong>数据。只有在所有持有共享锁的事务释放锁后，其他事务才能获取写锁并修改数据。</p><p><strong>排他锁</strong>（也称独占锁）当一个事务获得锁时，<strong>其他事务不能读取或修改</strong>相同的数据，直到当前事务释放该锁。</p><blockquote><p>问题：数据库中的锁针对的是线程还是事务？</p></blockquote><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p><strong>表锁是数据库中一种锁定粒度较大的锁，通常用于</strong>锁定整张表，当事务对某个表加上表锁时，整个表会被锁定，其他事务在该表上的操作（无论是读取还是写入）都将被阻塞，直到表锁被释放。</p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p><strong>元数据锁（MDL）</strong> 是数据库管理系统中用于保护数据库表的结构和元数据的一种锁。它主要用于在执行DDL（数据定义语言）操作时，保证表结构（例如表、索引、列的增加、删除或修改等）的一致性，防止其他事务在元数据修改过程中对该表进行数据操作（如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等）。</p><h5 id="MDL-锁的特点"><a href="#MDL-锁的特点" class="headerlink" title="MDL 锁的特点"></a><strong>MDL 锁的特点</strong></h5><ol><li><strong>只锁定元数据</strong>：MDL 锁只锁定表的元数据（如表的结构、字段定义等），而不是实际的数据行。因此，它不会阻塞其他事务读取数据，但会阻止数据操作。</li><li><strong>非阻塞的读取操作</strong>：其他事务仍然可以对表进行<strong>只读操作（SELECT）</strong>，但是不能进行修改操作（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）。</li><li><strong>加锁时机</strong>：在执行 DDL 操作时，MySQL 会自动为表加上 MDL 锁，以保证表的结构一致性。这个锁是由数据库管理系统自动控制的，不需要用户显式地操作。</li><li><strong>阻止数据修改操作</strong>：MDL 锁会阻止其他事务执行 DML（数据操作语言）操作，如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>。然而，<strong>MDL 锁不会阻止读取（SELECT）操作</strong>，这也是与行锁和表锁的区别之一。</li></ol><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p><strong>意向锁（Intent Lock，简称 IL）</strong> 是一种用来解决多级锁竞争问题的锁机制，尤其是在数据库中，主要用于在行级锁和表级锁之间进行协调，避免不同级别的锁之间产生冲突。意向锁属于一种<strong>细粒度的锁</strong>，它不会直接阻止对数据的操作，而是通过标记当前事务对某些行或表进行操作的意图，来避免其他事务在更高层级的锁（如表锁）和更低层级的锁（如行锁）之间产生冲突。</p><h5 id="意向锁的使用场景"><a href="#意向锁的使用场景" class="headerlink" title="意向锁的使用场景"></a><strong>意向锁的使用场景</strong></h5><p>行级锁与表级锁配合使用</p><ul><li>当数据库的锁粒度为行级锁时，意向锁作为辅助锁来处理行级锁和表级锁之间的协调。例如，假设一个事务想要对表中的某些行加排他锁，系统就可以通过意向排他锁来提示其他事务，这样其他事务就会避免对该表加排他锁，从而避免潜在的冲突。</li></ul><p>多事务并发操作同一表</p><ul><li>在并发高的环境中，多个事务同时进行数据操作时，意向锁可以减少行级锁与表级锁之间的冲突，使得多个事务可以并发地进行数据访问，从而提高数据库的性能和吞吐量。</li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul><li><p><strong>事务T1</strong> 在对ID&#x3D;8888888加行锁之前，会在表上加一个<strong>意向锁</strong>（共享锁或排他锁），例如意向共享锁（IS）表示它将对某些行加共享锁，意向排他锁（IX）表示它将对某些行加排他锁。</p></li><li><p>事务T2</p><p> 在请求表级写锁时，会先检查表是否已有意向锁。如果表上有意向锁，T2会根据意向锁类型判断是否冲突：</p><ul><li>如果T2要加<strong>表级写锁</strong>，而表上已有<strong>意向排他锁（IX）</strong>，则会发生冲突，T2会被阻塞，直到T1释放锁。</li><li>如果T2要加<strong>表级读锁</strong>，而表上已有<strong>意向共享锁（IS）</strong>，则可以共享访问，不会产生冲突。</li></ul></li></ul><p><strong>意向锁避免了在检查锁时需要遍历所有行，提高了效率，且防止了行锁与表锁之间的冲突，提升了并发性。</strong></p><blockquote><p>假设一张表中有一千万条数据，现在事务<code>T1</code>对<code>ID=8888888</code>的这条数据加了一个行锁，此时来了一个事务<code>T2</code>，想要获取这张表的表级别写锁，经过前面的一系列讲解，大家应该知道写锁必须为排他锁，也就是在同一时刻内，只允许当前事务操作，如果表中存在其他事务已经获取了锁，目前事务就无法满足“独占性”，因此不能获取锁。</p><p>由于<code>T1</code>是对<code>ID=8888888</code>的数据加了行锁，那<code>T2</code>获取表锁时，得先判断一下表中是否存在其他事务在操作.但因为<code>InnoDB</code>中有行锁的概念，所以表中任何一行数据上都有可能存在事务加锁操作，为了能精准的知道答案，<code>MySQL</code>就得将整张表的<code>1000W</code>条数据全部遍历一次，然后逐条查看是否有锁存在，那这个效率自然会非常的低。</p></blockquote><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p>自增锁，是专门为了提升自增ID的并发插入性能而设计的，通常情况下咱们在建表时，都会对一张表的主键设置自增特性。</p><p>当对一个字段设置<code>AUTO_INCREMENT</code>自增后，意味着后续插入数据时无需为其赋值，系统会自动赋上顺序自增的值。但想一想，比如目前表中最大的<code>ID=88</code>，如果两个并发事务一起对表执行插入语句，由于是并发执行的原因，所以有可能会导致插入两条<code>ID=89</code>的数据。因此这里必须要加上一个排他锁，确保并发插入时的安全性，但也由于锁的原因，插入的效率也就因此降低了，毕竟将所有写操作串行化了。</p><p>为了改善插入数据时的性能，自增锁诞生了，自增锁也是一种特殊的表锁，但它仅为具备<code>AUTO_INCREMENT</code>自增字段的表服务，同时自增锁也分成了不同的级别，可以通过<code>innodb_autoinc_lock_mode</code>参数控制。</p><p><strong>自增锁主要负责维护并发事务下自增列的顺序</strong>，也就是说，每当一个事务想向表中插入数据时，都要先获取自增锁先分配一个自增的顺序值，但不同模式下的自增锁也会有些许不同。</p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁其实是一种尤为特殊的表锁，其实将它称之为库锁也许更合适，因为全局锁是基于整个数据库来加锁的，加上全局锁之后，整个数据库只能允许读，不允许做任何写操作，一般全局锁是在对整库做数据备份时使用。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p><code>Record Lock</code>记录锁，实际上就是行锁，一行表数据、一条表记录本身就是同一个含义，因此行锁也被称为记录锁，两个称呼最终指向的是同一类型的锁。</p><p>如果你的<code>SQL</code>能命中索引数据，那也就自然加的就是行锁，反之则是表锁。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p><strong>间隙锁</strong> 是数据库中一种锁机制，主要用于防止<strong>幻读</strong>（phantom reads）现象。在使用 <strong>InnoDB</strong> 存储引擎时，间隙锁锁定的不是实际存在的行，而是<strong>两个存在行之间的“间隙”</strong>，即在某个值范围内可能插入的新数据。</p><p>间隙锁的目的是阻止其他事务在已存在数据之间插入数据，从而避免出现幻读问题。</p><h5 id="间隙锁工作原理"><a href="#间隙锁工作原理" class="headerlink" title="间隙锁工作原理"></a><strong>间隙锁工作原理</strong></h5><ol><li><strong>锁定范围：</strong><ul><li>间隙锁锁定的是行与行之间的空隙（如：A行与B行之间），防止其他事务在该范围内插入新的行。</li><li>它不直接锁定现有的行数据，而是锁定<strong>某个范围</strong>，防止该范围内有新的记录插入。</li></ul></li><li><strong>防止幻读：</strong><ul><li>间隙锁通过阻止插入操作来避免幻读。幻读是指一个事务在两次查询中，第二次查询返回的结果集比第一次查询多，因而产生了“幻影”数据。</li></ul></li></ol><h5 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a><strong>案例说明</strong></h5><p>假设有一张员工表 <code>employees</code>，结构如下：</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>30</td></tr><tr><td>3</td><td>Bob</td><td>25</td></tr><tr><td>5</td><td>Carol</td><td>28</td></tr></tbody></table><p><strong>事务1：</strong></p><p>事务1执行以下操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p>这会返回：</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>30</td></tr><tr><td>3</td><td>Bob</td><td>25</td></tr><tr><td>5</td><td>Carol</td><td>28</td></tr></tbody></table><p>此时，事务1在查询结果的范围（20到30岁之间）锁定了一个“间隙”，即锁定了 <code>age</code> 在 20 到 30 之间的所有可能插入的记录。数据库系统会使用<strong>间隙锁</strong>锁定这个区间，防止其他事务在此区间插入新的数据。</p><p><strong>事务2：</strong></p><p>假设事务2此时执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees (id, name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;David&#x27;</span>, <span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><p>由于事务1在范围 <code>(20, 30)</code> 上加了间隙锁，事务2不能在该区间插入新行（<code>age = 27</code> 的记录）。即使数据表中没有锁定的行，间隙锁仍然阻止了新数据的插入。</p><h4 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h4><p><strong>临键锁</strong>是 <strong>InnoDB</strong> 存储引擎的一种锁机制，结合了 <strong>行锁</strong> 和 <strong>间隙锁</strong>，用于防止<strong>幻读</strong>并确保数据的一致性。</p><p><strong>临键锁</strong>的主要特点是锁定的是<strong>行加间隙的组合</strong>，它不仅锁定当前的行数据，还会锁定该行与前一行之间的间隙，防止其他事务在此范围内插入新数据或修改已存在的行数据。</p><p>临键锁是间隙锁的<code>Plus</code>版本，或者可以说成是一种由记录锁+间隙锁组成的锁：</p><ul><li>记录锁：锁定的范围是表中具体的一条行数据。</li><li>间隙锁：锁定的范围是左右开区间，但不包含当前这一条真实数据，只锁间隙区域。</li></ul><p>而临键锁则是两者的结合体，加锁后，即锁定左开右闭的区间，也会锁定当前行数据。</p><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>插入意向锁，听起来似乎跟前面的表级别意向锁有些类似，但实际上插入意向锁是一种间隙锁，这种锁是一种隐式锁，也就是咱们无法手动的获取这种锁。通常在<code>MySQL</code>中插入数据时，是并不会产生锁的，但在插入前会先简单的判断一下，当前事务要插入的位置有没有存在间隙锁或临键锁，如果存在的话，当前插入数据的事务则需阻塞等待，直到拥有临键锁的事务提交。</p><p>简单来说就是：能够真正执行的插入语句，绝对是通过了唯一检测的，因此插入时可以让多事务并发执行，同时如果设置了自增<code>ID</code>，也会获取自增锁确保安全性，所以当多个事务要向一个区间插入数据时，插入意向锁是不会排斥其他事务的，从这种角度而言，插入意向锁也是一种共享锁。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁也好，乐观锁也罢，实际上仅是一种锁的思想，如下：</p><ul><li>乐观锁：每次执行都认为只会有自身一条线程操作，因此无需拿锁直接执行。</li><li>悲观锁：每次执行都认为会有其他线程一起来操作，因此每次都需要先拿锁再执行。</li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p><strong>原理</strong>：假设并发冲突少，事务不加锁，提交时检查数据是否修改过。</p><p><strong>实现方式</strong>：</p><ul><li><strong>版本号机制</strong>：每行数据有版本号，提交时检查版本号是否一致。</li><li><strong>时间戳机制</strong>：每行数据有时间戳，提交时检查时间戳是否改变。</li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p><strong>原理</strong>：假设并发冲突多，事务执行期间加锁，防止其他事务访问数据。</p><p><strong>实现方式</strong>：</p><ul><li><strong>行级锁</strong>：锁定某一行数据。</li><li><strong>表级锁</strong>：锁定整个表。</li><li><strong>悲观读锁（共享锁）</strong>：允许读但不允许写。</li><li><strong>悲观写锁（排他锁）</strong>：既不允许读也不允许写。</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table><thead><tr><th>特性</th><th>乐观锁</th><th>悲观锁</th></tr></thead><tbody><tr><td><strong>锁机制</strong></td><td>事务不加锁，提交时验证冲突</td><td>事务期间加锁，阻塞其他事务</td></tr><tr><td><strong>适用场景</strong></td><td>读多写少，冲突少的场景</td><td>写多冲突多的场景</td></tr><tr><td><strong>性能</strong></td><td>高并发时性能好，但冲突多时重试</td><td>并发性能差，可能导致死锁</td></tr><tr><td><strong>事务失败</strong></td><td>可能因冲突失败，需重试</td><td>不易失败，但可能阻塞或死锁</td></tr><tr><td><strong>死锁风险</strong></td><td>无死锁风险</td><td>可能导致死锁</td></tr></tbody></table><h2 id="锁的存储表示？"><a href="#锁的存储表示？" class="headerlink" title="锁的存储表示？"></a>锁的存储表示？</h2><p>具体可参考：<a href="https://juejin.cn/post/7156111610589741063#heading-9">(十)全解MySQL之死锁问题分析、事务隔离与锁机制的底层原理剖析MySQL事务隔离与锁机制是一个老生常谈的话题，但似乎 - 掘金</a></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote><p>具体参考：<a href="https://xiaolincoding.com/mysql/lock/deadlock.html#%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F">MySQL 死锁了，怎么办？ | 小林coding</a></p></blockquote><p>死锁是指在两个或多个事务（进程）执行过程中，因争夺资源而造成的一种相互等待的现象。每个事务都在等待其他事务释放资源，且这些事务彼此都在等待对方的资源，形成一个环形依赖，导致系统无法继续执行下去。</p><h2 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a><strong>死锁的条件</strong></h2><p>发生死锁必须满足以下四个条件：</p><ol><li><strong>互斥条件</strong>：至少有一个资源必须处于非共享模式，即某一资源在同一时刻只能被一个事务（进程）占用。</li><li><strong>请求与保持条件</strong>：事务（进程）在占有了至少一个资源的情况下，仍然提出新的资源请求，而此资源已被其他事务（进程）占有，且当前事务（进程）没有释放已占有的资源。</li><li><strong>不剥夺条件</strong>：已分配给事务（进程）的资源，在未使用完之前，不能被其他事务（进程）强行剥夺。</li><li><strong>环路等待条件</strong>：事务（进程）之间形成一个循环等待的链条，其中每个事务都在等待下一个事务占有的资源。</li></ol><h2 id="死锁的示例"><a href="#死锁的示例" class="headerlink" title="死锁的示例"></a><strong>死锁的示例</strong></h2><p>假设有两个事务 T1 和 T2，两个资源 R1 和 R2：</p><ul><li>事务 T1 占有资源 R1，等待资源 R2。</li><li>事务 T2 占有资源 R2，等待资源 R1。 由于两者形成了环形依赖，导致无法继续执行，形成死锁。</li></ul><h2 id="死锁的检测与解决方法"><a href="#死锁的检测与解决方法" class="headerlink" title="死锁的检测与解决方法"></a><strong>死锁的检测与解决方法</strong></h2><ol><li><strong>死锁预防</strong>：通过破坏死锁的某个条件来防止死锁的发生。<ul><li><strong>破坏互斥条件</strong>：让资源支持共享访问，但并不适用于所有资源。</li><li><strong>破坏请求与保持条件</strong>：避免事务占有部分资源时再请求其他资源，可以要求事务一次性请求所需的所有资源，避免中途请求。</li><li><strong>破坏不剥夺条件</strong>：允许事务释放一些资源，使其他事务能够获得资源。</li><li><strong>破坏环路等待条件</strong>：采用优先级控制、资源排序等策略，避免出现环形等待。</li></ul></li><li><strong>死锁避免</strong>：通过动态检测系统的资源分配情况，避免进入死锁状态。常用算法：<ul><li><strong>银行家算法</strong>：事务在请求资源时，系统会判断资源请求是否安全（即是否会导致系统进入死锁状态）。如果安全，则允许请求，否则拒绝。</li><li><strong>资源分配图</strong>：通过图模型表示事务与资源的关系，实时检测是否存在环路。</li></ul></li><li><strong>死锁检测与恢复</strong>：<ul><li>定期检查是否发生死锁，可以通过资源分配图或等待图来识别死锁。</li><li>恢复方式<ul><li><strong>回滚事务</strong>：通过回滚某个事务来解除死锁。</li><li><strong>终止事务</strong>：强制终止某个事务，释放资源。</li><li><strong>重启系统</strong>：极端情况下，可以通过重启系统来清除死锁。</li></ul></li></ul></li><li><strong>死锁超时</strong>：通过设置事务的超时时间，若事务在规定时间内未能获得所需资源，就强制中止该事务，避免死锁。</li></ol><h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><p><strong>锁升级</strong>是指在数据库中，事务持有较低级别的锁（如行锁或共享锁），然后在事务执行过程中，逐渐将锁提升到更高等级的锁（如表锁或排他锁）。锁升级主要是为了避免锁的粒度过细导致的性能损耗，但它也可能引发锁竞争或死锁等问题。</p><h3 id="锁升级的类型"><a href="#锁升级的类型" class="headerlink" title="锁升级的类型"></a>锁升级的类型</h3><ol><li>行锁升级为表锁<ul><li><strong>情况</strong>：事务在某些情况下可能持有行锁，随着数据操作的增多，可能需要更高层级的锁来保护整个表，防止其他事务干扰。</li><li><strong>特点</strong>：行锁的粒度较细，效率较高，但在某些情况下可能无法满足事务的需求，因此会自动或手动升级为表锁。</li><li><strong>问题</strong>：行锁升级为表锁后，其他事务无法访问该表，这会导致并发性下降。</li></ul></li><li>共享锁（S锁）升级为排他锁（X锁）<ul><li><strong>情况</strong>：在某些数据库引擎中，事务持有共享锁后，在某些操作（如更新）时需要升级为排他锁。</li><li><strong>问题</strong>：共享锁只能允许其他事务读取数据，而排他锁则不允许其他事务读写数据，因此共享锁到排他锁的升级会带来并发性降低。</li></ul></li></ol><h3 id="锁升级的原因"><a href="#锁升级的原因" class="headerlink" title="锁升级的原因"></a>锁升级的原因</h3><ul><li><strong>性能优化</strong>：行锁在高并发情况下会增加大量的锁管理和上下文切换，升级为表锁可以减少锁的管理开销，提升性能。</li><li><strong>防止死锁</strong>：在多锁共存的情况下，事务可能会持有多个较低级别的锁，导致死锁。通过升级锁级别，可以减少锁的数量，降低死锁的概率。</li></ul><h3 id="锁升级的缺点"><a href="#锁升级的缺点" class="headerlink" title="锁升级的缺点"></a>锁升级的缺点</h3><ul><li><strong>性能下降</strong>：锁升级为更高级别的锁时，会阻塞更多的事务，导致并发性降低。</li><li><strong>死锁风险</strong>：锁级别的升级可能导致事务之间的锁依赖关系更加复杂，增加了死锁的风险。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设事务 T1 在对某个表进行查询时，首先对行级别的数据加了行锁（<code>ROW LOCK</code>）。随着操作的进行，T1 可能发现需要对整个表加锁，这时行锁会升级为表锁（<code>TABLE LOCK</code>），而且此时其他事务 T2 无法访问该表的数据，导致并发性下降。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://juejin.cn/post/7153869469394305061#heading-15">(八)MySQL锁机制：高并发场景下该如何保证数据读写的安全性？MySQL内部采用多线程执行业务SQL，但多线程虽然性能 - 掘金</a></p><p><a href="https://juejin.cn/post/7155359629050904584">(九)MySQL之MVCC机制：为什么你改了的数据我还看不见？增、删、改是数据库中十分常见的操作，但为什么一个事务对一条 - 掘金</a></p><p>[08 事务到底是隔离的还是不隔离的？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/08">https://learn.lianglianglee.com/专栏/MySQL实战45讲/08</a>  事务到底是隔离的还是不隔离的？.md)</p><p><a href="https://www.cnblogs.com/better-farther-world2099/articles/14955475.html">彻底搞懂 MySQL 中的锁机制 - 字节悦动 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志系统</title>
    <link href="/2023/04/25/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/04/25/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一条SQL查询语句如何执行"><a href="#一条SQL查询语句如何执行" class="headerlink" title="一条SQL查询语句如何执行?"></a>一条SQL查询语句如何执行?</h1><p><img src="https://s2.loli.net/2025/01/02/ryoAi4qlcFJN5DT.png" alt="image-20250102100753739"></p><p><code>MySQL</code>中数据是以页为单数存储，当你查询一条记录时，硬盘会把一整页的数据加载出来，加载出来的数据叫做数据页，会放到<code>Buffer Pool</code>中。此后MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>这里丁虎前辈，在《mysql45讲》中提到：</p><blockquote><p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">mysql&gt; <span class="hljs-keyword">select</span> SQL_CACHE * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID=<span class="hljs-number">10</span>；<br></code></pre></td></tr></table></figure><p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p></blockquote><h1 id="重做日志-redo"><a href="#重做日志-redo" class="headerlink" title="重做日志(redo)"></a>重做日志(redo)</h1><p>redo log称为重做日志，用来保证事务的原子性和一致性.</p><p>现在想象mysql天地初开，没有redo日志时，每次事务提交都会触发磁盘写操作，事务的提交必须等待数据成功写入磁盘后才完成。由于磁盘 I&#x2F;O 操作（特别是随机写）速度较慢，频繁的写操作会导致系统性能下降。尤其在高并发场景下，大量事务的提交可能会因磁盘写入而形成瓶颈。</p><blockquote><p>同样丁虎前辈举了个《孔乙己》中老板与粉板的例子，当生意忙时，先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</p></blockquote><p>对应的是：当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>同时有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><blockquote><p>可以说是一箭双雕，即保证了数据提交的效率，也保证了数据恢复</p></blockquote><h2 id="整个更改数据流程"><a href="#整个更改数据流程" class="headerlink" title="整个更改数据流程"></a>整个更改数据流程</h2><p><strong>接下来我们梳理一下整个流程：</strong></p><p>假设 <code>account</code> 表的 <code>id=2</code> 原数据如下：</p><table><thead><tr><th>id</th><th>balance</th></tr></thead><tbody><tr><td>2</td><td>1000</td></tr></tbody></table><p>执行语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ol><li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面。</li><li>在步骤3中，执行器通过引擎更新了内存中的数据页，同时 <strong>Redo Log</strong> 记录了这一修改。此时，数据页已经发生了更改，但这些修改 <strong>只在内存中</strong>，尚未持久化到磁盘。因为数据页在内存中的内容已经被修改，所以该数据页被 <strong>标记为脏页（Dirty Page）</strong>。脏页是指已经被修改过，但尚未写回磁盘的页面。</li><li>在执行器调用引擎接口将数据更新后，<strong>Redo Log</strong> 会首先被写入磁盘，以保证事务的持久性。即使数据页的修改尚未写回磁盘，只要 <strong>Redo Log</strong> 已经被刷写到磁盘，事务的修改也能在系统崩溃后通过日志恢复。这是 <strong>事务提交</strong> 的关键步骤：事务提交时，相关的修改会记录到 <strong>Redo Log Buffer</strong>，并在事务提交后将其刷新到磁盘上的 <strong>Redo Log 文件</strong>（如 <code>ib_logfile0</code>、<code>ib_logfile1</code> 等）中。</li><li>数据页的持久化通常是通过 <strong>Checkpoint</strong> 机制来触发的。Checkpoint 是 InnoDB 用来控制脏页写回磁盘的机制，它的目的是定期将内存中的脏页（修改过的数据页）写回磁盘，确保数据库磁盘上的数据文件是最新的，并避免日志文件无限增长。</li></ol><blockquote><p><strong>Checkpoint 触发条件：</strong></p><ul><li>当 <strong>Buffer Pool</strong> 中的脏页达到一定数量时。</li><li>当系统空闲时，InnoDB 会主动触发 Checkpoint，减少内存中的脏页积累。</li><li>操作系统或数据库配置的 <strong>定时触发</strong>。</li></ul><p><strong>写回数据页：</strong></p><ul><li>在 <strong>Checkpoint</strong> 触发时，InnoDB 会将脏页写回磁盘，即将内存中的修改过的数据页刷新到磁盘上的数据文件（通常是 <code>.ibd</code> 文件）。通过这种方式，<strong>数据页被持久化到磁盘</strong>。</li></ul></blockquote><ol start="7"><li>在数据页成功刷回磁盘后，这些数据页会从 <strong>脏页</strong> 转变为 <strong>干净页</strong>。此时，Buffer Pool 中的脏页已经持久化到磁盘，数据库能够保证磁盘上的数据文件与内存中的数据一致。此时，数据库也会更新 <strong>Checkpoint LSN</strong>，记录下所有已刷写的数据的最新修改点。这有助于在发生崩溃时进行恢复，确保系统能够从最近的 Checkpoint 点恢复数据。、</li></ol><p>此时产生两个个问题：</p><p><strong>redo log存储在哪里？</strong></p><p>答：redo由两个部分组成：一个是内存中的重做日志缓存(redo log buffer)，其是易失的；二是重做日志文件（redo log file），其是持久的。</p><p>答案显而易见，把更新好的值放入日志缓存(redo log buffer)中。找时机在刷入磁盘中</p><p><strong>redo log存储格式是什么样的？</strong></p><p>答：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成。就上面的例子中：</p><p>假设：</p><ul><li>表空间号为 <code>3</code>（<code>TABLESPACE_ID=3</code>）。</li><li>页号为 <code>1024</code>（<code>PAGE_ID=1024</code>）。</li><li>修改的数据位于该页偏移量 <code>80</code> 字节处（<code>OFFSET=80</code>）。</li><li>修改数据的长度为 <code>8</code> 字节（<code>LENGTH=8</code>，假设 <code>DECIMAL</code> 类型占 8 字节）。</li><li>新的余额值为 <code>800.00</code>（<code>MODIFIED_DATA=0x0000C800</code>，存储为二进制形式）。</li></ul><p>Redo Log 的记录内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">LSN=10002345 | TABLESPACE_ID=3 | PAGE_ID=1024 | OFFSET=80 | LENGTH=8 | MODIFIED_DATA=0x0000C800<br></code></pre></td></tr></table></figure><p><strong>记录差异值与最终值的区别：</strong></p><ul><li>在 InnoDB 中的 <strong>Redo Log</strong> 记录有时会直接记录<strong>修改后的新值</strong>，特别是在某些情况下，<strong>修改数据的完整值</strong>（即操作后数据的值）会被存储在 Redo Log 中，尤其是在 <code>DECIMAL</code> 类型（如您的例子）和其他简单类型的操作时。这样做是为了简化恢复过程并减少对磁盘和内存的额外开销。</li><li>对于一些更复杂的数据类型或其他操作（如增量操作），InnoDB 会记录变更的差值，而不是直接记录最终值。例如，如果执行了 <code>balance = balance - 100</code>，则 Redo Log 会记录 <strong>差异值</strong> <code>-100</code>，而不是新值。</li></ul><p><strong>为什么会存储修改后的值？</strong></p><ul><li>在 InnoDB 中，尤其是对于 <strong>简单的数据类型</strong>（如 <code>DECIMAL</code>、<code>INT</code> 等），<strong>Redo Log</strong> 可能直接记录更新后的值。这种做法提高了恢复效率，因为恢复时不需要进行复杂的差值计算，而是直接通过记录的新值恢复数据。</li><li>对于更复杂的操作或数据类型（如字符串、BLOB 或执行某些计算的操作），InnoDB 则更多依赖差异值的记录。</li></ul><h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a><strong>举个例子：</strong></h3><p>假设在数据库崩溃之前，执行了如下操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>并且该事务已经提交，但是数据页还没有来得及刷写到磁盘。</p><ol><li><p><strong>在日志中存储的内容：</strong></p><ul><li><p>假设原来的 <code>balance</code> 值是 500，变更值为 -100。</p></li><li><p>在 Redo Log 中，可能会记录类似：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Transaction ID</span>] Update <span class="hljs-keyword">on</span> page X, offset Y: balance - <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure></li><li><p><code>balance</code> 从 500 变为 500 - 100（即 400）。<strong>Redo Log</strong> 仅记录了 <code>balance</code> 变更的部分（-100），而没有记录 400 这个最终的值。</p></li></ul></li></ol><hr><p>此时，在重做日志缓存中我们已经将数据更新过了。</p><p><strong>接下来要解决的是什么时候刷入磁盘进行持久化？</strong></p><h2 id="刷入磁盘"><a href="#刷入磁盘" class="headerlink" title="刷入磁盘"></a>刷入磁盘</h2><p>注意根据 MySQL 配置的刷盘策略(innodb_flush_log_at_trx_commit)的不同,会有不同的情况。另外，InnoDB 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p><p><img src="https://s2.loli.net/2025/01/02/7mY8JVAROlZyIEH.png" alt="image-20250102140653719"></p><h3 id="设置为0的时候，每次提交事务时不刷盘。"><a href="#设置为0的时候，每次提交事务时不刷盘。" class="headerlink" title="设置为0的时候，每次提交事务时不刷盘。"></a>设置为0的时候，每次提交事务时不刷盘。</h3><p><img src="https://s2.loli.net/2025/01/02/UehSYB9jnk3yG1V.png" alt="image-20250102140618528"></p><h3 id="设置为1的时候，每次提交事务时刷盘。"><a href="#设置为1的时候，每次提交事务时刷盘。" class="headerlink" title="设置为1的时候，每次提交事务时刷盘。"></a>设置为1的时候，每次提交事务时刷盘。</h3><p><code>innodb_flush_log_at_trx_commit</code>参数默认为1，当事务提交的时候会调用<code>fsync</code>对<code>redo log</code>进行刷盘，将<code>redo log buffer</code>写入<code>redo log</code>文件中。</p><p>另外，<code>Innodb</code>存储引擎有一个后台线程，每隔<code>1</code>秒，就会把会<code>redo log buffer</code>中的内容写入到文件系统缓存<code>page cache</code>，然后调用<code>fsync</code>刷盘。</p><p><img src="https://s2.loli.net/2025/01/02/rETVdAXYasGjef4.png" alt="image-20250102140137097"></p><p>如上图，只要事务提交成功，<code>redo log</code>记录就一定在磁盘里，不会有任务数据丢失。如果执行事务的时候<code>MySQL</code>挂了或者宕机了，这部分日志丢失了，但是因为事务没有提交，所以日志丢了也不会有损失。</p><h3 id="设置为2的时候，每次提交事务时都只把redo-log-buffer写入page-cache"><a href="#设置为2的时候，每次提交事务时都只把redo-log-buffer写入page-cache" class="headerlink" title="设置为2的时候，每次提交事务时都只把redo log buffer写入page cache"></a>设置为2的时候，每次提交事务时都只把<code>redo log buffer</code>写入<code>page cache</code></h3><p><img src="https://s2.loli.net/2025/01/02/mI5ZW92KCquL8tn.png" alt="image-20250102140529253"></p><p>此时redo 成功刷入磁盘，实现了数据的持久化</p><h2 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h2><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 redo log 日志文件组可以记录<code>4G</code>的内容。它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p><img src="https://s2.loli.net/2025/01/02/t3pXPzLbSahCNVv.png" alt="image-20250102142405641" style="zoom:50%;" /><p>在这个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p><ul><li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li><li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。每次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 redo log 记录，并把 <code>checkpoint</code> 后移更新。<code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 redo log 记录。</p><p><img src="https://s2.loli.net/2025/01/02/ni1TSy7ep9xlNbt.png" alt="image-20250102142500510"></p><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><p><img src="https://s2.loli.net/2025/01/02/rVZP1AiSWxEmeYK.png" alt="image-20250102142521358"></p><h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><p>上面详细介绍了redo log日志，不免好奇它是怎么恢复数据的？</p><p><strong>Redo Log 恢复数据的过程</strong> 是 InnoDB 在数据库崩溃后用于保证数据一致性和持久性的关键机制。下面我们将详细解释在数据库崩溃后 <strong>Redo Log</strong> 是如何用于恢复数据的。</p><h3 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a><strong>背景知识：</strong></h3><ol><li><strong>Redo Log</strong> 记录了数据库对数据的所有修改操作，主要包括：<ul><li><strong>事务提交时的修改操作</strong>。</li><li>数据页的修改（如插入、更新、删除等）。</li><li><strong>Redo Log</strong> 本身是顺序写入的，通常被存储在磁盘上的一组日志文件中。</li></ul></li><li><strong>数据页</strong> 是数据库存储的基本单位，所有的修改操作都会先在内存中修改数据页，并通过 <strong>Redo Log</strong> 将修改操作记录下来，最终这些修改会被写回到磁盘。</li><li>当数据库崩溃（例如突然掉电、硬件故障等）时，数据库可能已经有一些修改的数据页没有写回磁盘，但对应的修改记录已经存在于 <strong>Redo Log</strong> 中。为了保证数据的一致性和持久性，需要依赖 <strong>Redo Log</strong> 来恢复这些未持久化的数据。</li></ol><hr><h3 id="Redo-Log-恢复过程"><a href="#Redo-Log-恢复过程" class="headerlink" title="Redo Log 恢复过程"></a><strong>Redo Log 恢复过程</strong></h3><ol><li><strong>数据库重启后，Redo Log 恢复机制的启动：</strong><ul><li>当数据库重启时，InnoDB 会检查 <strong>Redo Log</strong> 文件。Redo Log 记录了所有已提交事务的修改操作，因此它包含了数据库在崩溃前的最后修改记录。</li><li>通过扫描 <strong>Redo Log</strong>，数据库能够恢复已提交的事务的修改内容，确保数据的一致性。</li></ul></li><li><strong>恢复的三个阶段：</strong> 恢复过程通常分为 <strong>三个阶段</strong>：<ul><li><strong>分析阶段（Analysis Phase）</strong>：</li><li><strong>重做阶段（Redo Phase）</strong>：</li><li><strong>撤销阶段（Undo Phase）</strong>（在需要时使用）：</li></ul></li></ol><hr><h3 id="1-分析阶段（Analysis-Phase）"><a href="#1-分析阶段（Analysis-Phase）" class="headerlink" title="1. 分析阶段（Analysis Phase）"></a><strong>1. 分析阶段（Analysis Phase）</strong></h3><ul><li><strong>目的</strong>：识别哪些事务已经提交，哪些事务没有提交，系统需要恢复哪些操作。</li><li><strong>过程</strong>：<ul><li>数据库会从 <strong>Redo Log</strong> 中的最后一个 <strong>Checkpoint</strong> LSN（日志序列号）开始。</li><li><strong>Checkpoint</strong> LSN 是记录数据库最后一次刷写到磁盘的数据的日志标记，它帮助数据库确定哪些操作已经在磁盘上持久化。</li><li>从 Checkpoint LSN 后，数据库会扫描 Redo Log 文件，分析每个事务的状态：<ul><li>如果某个事务已经提交，那么它所做的修改需要被 <strong>重做（Redo）</strong>。</li><li>如果某个事务没有提交，它的修改需要被 <strong>撤销（Undo）</strong>。</li></ul></li></ul></li><li><strong>分析阶段的结果</strong>：<ul><li>数据库会生成一个 <strong>恢复图</strong>，该图包含了所有需要恢复的事务和操作。</li><li>如果事务已经提交，它的操作需要被重做；如果事务没有提交，它的操作需要被撤销。</li></ul></li></ul><hr><h3 id="2-重做阶段（Redo-Phase）"><a href="#2-重做阶段（Redo-Phase）" class="headerlink" title="2. 重做阶段（Redo Phase）"></a><strong>2. 重做阶段（Redo Phase）</strong></h3><ul><li><strong>目的</strong>：将已提交事务的修改应用到数据库，确保所有的已提交事务都在数据库中被正确执行。</li><li><strong>过程</strong>：<ul><li>数据库从 <strong>Checkpoint LSN</strong> 开始扫描 <strong>Redo Log</strong>，并 <strong>重做</strong> 所有已经提交的事务操作。</li><li>通过 <strong>Redo Log</strong> 中的记录，InnoDB 会重新执行那些已经提交的事务操作，修改数据页，将它们恢复到崩溃时的状态。</li></ul></li><li><strong>具体操作</strong>：<ul><li>如果事务在崩溃时已经修改了某些数据页，但这些修改还未刷写到磁盘，那么 InnoDB 会重新应用这些操作，确保数据页中的数据与 <strong>Redo Log</strong> 中的记录一致。</li><li>重做的操作会一直进行，直到 <strong>Redo Log</strong> 文件中的所有需要重做的操作都被执行完。</li></ul></li><li><strong>重做的过程通常是顺序执行的</strong>，每次读取 <strong>Redo Log</strong> 中的一条记录，恢复数据库对应的数据页。</li></ul><hr><h3 id="3-撤销阶段（Undo-Phase）"><a href="#3-撤销阶段（Undo-Phase）" class="headerlink" title="3. 撤销阶段（Undo Phase）"></a><strong>3. 撤销阶段（Undo Phase）</strong></h3><ul><li><strong>目的</strong>：撤销未提交事务的修改，确保数据库中不存在任何未提交的事务所做的更改。</li><li><strong>过程</strong>：<ul><li>数据库通过分析 <strong>Redo Log</strong> 中未提交事务的操作，识别出它们对数据的修改。</li><li>如果一个事务没有提交，InnoDB 会根据 <strong>Undo Log</strong> 记录，将该事务做出的所有修改 <strong>撤销</strong>，恢复数据到事务开始前的状态。</li></ul></li><li><strong>撤销的操作</strong>：<ul><li><strong>Undo Log</strong> 是专门记录事务修改前的值的日志。它是用来在事务回滚时撤销操作的。</li><li>如果某个事务的修改没有提交（即崩溃前事务未完成），那么在恢复过程中，InnoDB 会用 <strong>Undo Log</strong> 中的记录，撤销该事务对数据页的修改。</li></ul></li><li><strong>撤销阶段的结束</strong>：撤销操作完成后，系统将确保所有的未提交事务的修改被回滚，数据处于一致的状态。</li></ul><hr><h3 id="4-完成恢复"><a href="#4-完成恢复" class="headerlink" title="4. 完成恢复"></a><strong>4. 完成恢复</strong></h3><ul><li>恢复过程完成后，数据库的状态将一致，所有已经提交的事务的修改都会被 <strong>重做</strong>，并且任何未提交的事务的修改都会被 <strong>撤销</strong>。</li><li>此时，数据库将处于崩溃恢复后的持久一致性状态，可以继续正常操作。</li></ul><hr><h3 id="一个具体的例子："><a href="#一个具体的例子：" class="headerlink" title="一个具体的例子："></a><strong>一个具体的例子：</strong></h3><p>假设有一个事务在崩溃前执行了以下操作：</p><ol><li>事务 A 执行了 <code>UPDATE account SET balance = balance - 100 WHERE id = 1</code>，修改了数据页。</li><li>事务 A 提交，但数据库还没有来得及将数据页写回磁盘。</li><li>系统崩溃。</li></ol><p>崩溃后，数据库启动并进行恢复：</p><ol><li><strong>分析阶段</strong>：通过扫描 <strong>Redo Log</strong>，系统发现事务 A 已经提交，因此它需要重做事务 A 的操作（即更新 <code>account</code> 表的数据页）。</li><li><strong>重做阶段</strong>：系统重新执行事务 A 的更新操作，将数据页从内存中的修改写回磁盘。</li><li><strong>撤销阶段</strong>：如果有其他未提交的事务（例如事务 B），则它们的操作会被撤销。</li></ol><p>最终，数据库恢复到崩溃前的状态，事务 A 的修改被保留，而未提交的事务 B 的修改被撤销。</p><h1 id="归档日志-Binlog"><a href="#归档日志-Binlog" class="headerlink" title="归档日志(Binlog)"></a>归档日志(Binlog)</h1><p>redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。那 binlog 到底是用来干嘛的？可以说 MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性。</p><p><img src="https://s2.loli.net/2025/01/02/9WqUsjLz4KIxPdA.png" alt="image-20250102144858539"></p><p>binlog 会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><p>简单的来说，Binlog 记录的是对数据库的所有事务修改。每次事务执行时，相关的操作（如对表的更改）会被记录在 binlog 中，确保即使数据库崩溃或丢失数据，也能通过重放 binlog 恢复到一致的状态。</p><p>其记录的格式：</p><p><img src="https://s2.loli.net/2025/01/02/qWPRJgkNrL4FhbI.png" alt="image-20250102150139608"></p><p><code>binlog</code>日志刷盘流程如下：</p><p><img src="https://s2.loli.net/2025/01/02/6v12gTGSKoAExnh.webp" alt="4002541299-4954a0ceba1c49a4_fix732"></p><p>具体可见：<a href="https://www.cnblogs.com/ScarecrowAnBird/p/18163444">MySQL三大日志(binlog,redolog,undolog)详解 - 落叶已归根 - 博客园</a></p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p><img src="https://s2.loli.net/2025/01/02/Ppiq681YL5oRtzG.png" alt="2e5bff4910ec189fe1ee6e2ecc7b4bbe"></p><blockquote><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的 update 语句来做例子。假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p></blockquote><p>具体可参考：<a href="https://www.cnblogs.com/seven97-top/p/18545057">Mysql篇-三大日志 - seven97_top - 博客园</a></p><h1 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志(undo log)"></a>回滚日志(undo log)</h1><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/444298770">详解MySQL InnoDB之UNDO Log - 知乎</a></p><p><a href="https://cloud.tencent.com/developer/article/2220871">图文结合带你搞定MySQL日志之Undo log(回滚日志)-腾讯云开发者社区-腾讯云</a></p></blockquote><p>想要保证事务的原子性，就需要在发生异常时，对已经执行的操作进行回滚，在<code>MySQL</code>中恢复机制是通过<code>undo log</code>（回滚日志）实现的，所有事务进行的修改都会先被记录到这个回滚日志，然后再执行其他相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子。并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外，<code>MVCC</code>的实现依赖：隐藏字段、<code>Read View</code>、<code>undo log</code>。在底层实现中，<code>InnoDB</code>通过数据行的<code>DB_TRX_ID</code>和<code>Read View</code>来判断数据的可见性，如不可见，则通过数据行<code>DB_ROLL_PTR</code>找到<code>undo log</code>中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事物里，用户只能看到该事务创建<code>Read View</code>之前已经提交的修改和该事务本身做的修改。</p><p><strong>Undo Log</strong> 记录的是对数据页的物理修改操作，而不是 SQL 语句本身。</p><p>它记录了事务对数据的修改前的状态（即旧值），确保事务能够回滚时恢复数据。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p>[02 日志系统：一条SQL更新语句是如何执行的？](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/02">https://learn.lianglianglee.com/专栏/MySQL实战45讲/02</a>  日志系统：一条SQL更新语句是如何执行的？.md)</p><p><a href="https://javaguide.cn/database/mysql/mysql-logs.html#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6">MySQL三大日志(binlog、redo log和undo log)详解 | JavaGuide</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL</title>
    <link href="/2023/04/22/SQL%E8%AF%AD%E8%A8%80/"/>
    <url>/2023/04/22/SQL%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、SQL-概述"><a href="#一、SQL-概述" class="headerlink" title="一、SQL 概述"></a>一、SQL 概述</h2><h3 id="1、什么是-SQL"><a href="#1、什么是-SQL" class="headerlink" title="1、什么是 SQL"></a>1、什么是 SQL</h3><p>SQL（Structured Query Language，结构化查询语言）是一种用于管理关系型数据库的编程语言。它用于执行查询、插入、更新、删除等数据库操作。SQL 是标准化的语言，可以用于与不同的数据库系统（如 MySQL、PostgreSQL、SQL Server、Oracle 等）交互。</p><h3 id="2、语法要求"><a href="#2、语法要求" class="headerlink" title="2、语法要求"></a>2、语法要求</h3><ul><li><strong>大小写不敏感</strong>：SQL 关键字如 <code>SELECT</code>、<code>FROM</code>、<code>WHERE</code> 等不区分大小写，虽然通常建议使用大写来增强可读性。</li><li><strong>查询语句结束符</strong>：SQL 语句通常以分号 (<code>;</code>) 结束，尤其在需要执行多个语句时。</li><li><strong>空格与换行</strong>：空格和换行用来分隔SQL语句中的不同部分，增加可读性，SQL 引擎会忽略多余的空格和换行。</li><li><strong>字符串的引号</strong>：在 SQL 中，字符串常量使用单引号（<code>&#39;</code>）括起来，例如 <code>&#39;Hello World&#39;</code>。</li><li><strong>表名和列名</strong>：可以用反引号（&#96;&#96;&#96;）或双引号（<code>&quot;</code>）括起来，避免与SQL关键字冲突。</li></ul><p>在 SQL 中，查询语句的关键字执行顺序并不是按语句书写的顺序，而是按照特定的逻辑顺序执行的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> LIMIT<span class="hljs-operator">/</span><span class="hljs-keyword">OFFSET</span><br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">JOIN</span> departments <span class="hljs-keyword">ON</span> employees.dept_id <span class="hljs-operator">=</span> departments.id<br><span class="hljs-keyword">WHERE</span> employees.age <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> departments.name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">50000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">10</span>;<br><br></code></pre></td></tr></table></figure><hr><h2 id="二、SQL-分类"><a href="#二、SQL-分类" class="headerlink" title="二、SQL 分类"></a>二、SQL 分类</h2><ul><li><p>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</p></li><li><p>DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</p></li><li><p>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</p></li><li><p>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）</p></li></ul><h2 id="三、DDL（Data-Definition-Language）：数据定义语言"><a href="#三、DDL（Data-Definition-Language）：数据定义语言" class="headerlink" title="三、DDL（Data Definition Language）：数据定义语言"></a>三、DDL（Data Definition Language）：数据定义语言</h2><table><thead><tr><th><strong>操作</strong></th><th><strong>SQL 语句</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>查看所有数据库</strong></td><td><code>SHOW DATABASES;</code></td><td>显示当前系统中的所有数据库</td></tr><tr><td><strong>切换数据库</strong></td><td><code>USE mydb1;</code></td><td>切换到名为 <code>mydb1</code> 的数据库</td></tr><tr><td><strong>创建数据库</strong></td><td><code>CREATE DATABASE mydb1;</code></td><td>创建一个名为 <code>mydb1</code> 的数据库，如果已存在则报错</td></tr><tr><td><strong>创建数据库（如果不存在时）</strong></td><td><code>CREATE DATABASE IF NOT EXISTS mydb1;</code></td><td>如果数据库 <code>mydb1</code> 不存在，则创建该数据库</td></tr><tr><td><strong>删除数据库</strong></td><td><code>DROP DATABASE mydb1;</code></td><td>删除名为 <code>mydb1</code> 的数据库，如果不存在则报错</td></tr><tr><td><strong>删除数据库（如果存在时）</strong></td><td><code>DROP DATABASE IF EXISTS mydb1;</code></td><td>如果数据库 <code>mydb1</code> 存在，则删除它，否则不报错</td></tr><tr><td><strong>修改数据库编码</strong></td><td><code>ALTER DATABASE mydb1 CHARACTER SET utf8;</code></td><td>修改 <code>mydb1</code> 数据库的字符集为 <code>utf8</code> 编码</td></tr></tbody></table><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h3><p>MySQL 与 Java、C 一样，也有数据类型MySQL 中数据类型主要应用在列上。<br> 常用类型：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>int</strong></td><td>整型，适用于存储整数。</td></tr><tr><td><strong>double</strong></td><td>浮点型，适用于存储带有小数的数字，例如 <code>double(5,2)</code> 表示最多 5 位数字，其中有 2 位小数。</td></tr><tr><td><strong>decimal</strong></td><td>精确的浮动小数类型，常用于存储财务数据等要求高精度的数值，不会丢失精度。</td></tr><tr><td><strong>char</strong></td><td>固定长度字符串类型。输入的字符串长度不够时会自动补充空格。</td></tr><tr><td><strong>varchar</strong></td><td>可变长度字符串类型，适用于存储长度不固定的字符串。</td></tr><tr><td><strong>text</strong></td><td>长文本类型，存储大量的字符数据。</td></tr><tr><td><strong>blob</strong></td><td>字节类型，通常用于存储二进制数据（如图片、音频等）。</td></tr><tr><td><strong>date</strong></td><td>日期类型，格式为 <code>yyyy-MM-dd</code>，用于存储日期值。</td></tr><tr><td><strong>time</strong></td><td>时间类型，格式为 <code>hh:mm:ss</code>，用于存储时间值。</td></tr><tr><td><strong>timestamp</strong></td><td>时间戳类型，存储从 1970 年 1 月 1 日以来的秒数，用于记录时间的变化。</td></tr></tbody></table><h3 id="3-操作表"><a href="#3-操作表" class="headerlink" title="3.操作表"></a>3.操作表</h3><table><thead><tr><th><strong>操作</strong></th><th><strong>SQL 语句</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>创建表</strong></td><td><code>sql CREATE TABLE stu( sid CHAR(6), sname VARCHAR(20), age INT, gender VARCHAR(10) ); </code></td><td>创建一个名为 <code>stu</code> 的表，包含 <code>sid</code>、<code>sname</code>、<code>age</code> 和 <code>gender</code> 四个字段。</td></tr><tr><td><strong>查看表的结构</strong></td><td><code>sql DESC stu; </code></td><td>查看 <code>stu</code> 表的结构，包括字段名、数据类型等信息。</td></tr><tr><td><strong>删除表</strong></td><td><code>sql DROP TABLE stu; </code></td><td>删除 <code>stu</code> 表。</td></tr><tr><td><strong>添加列</strong></td><td><code>sql ALTER TABLE stu ADD (classname VARCHAR(100)); </code></td><td>给 <code>stu</code> 表添加一个新的列 <code>classname</code>，类型为 <code>VARCHAR(100)</code>。</td></tr><tr><td><strong>修改列的数据类型</strong></td><td><code>sql ALTER TABLE stu MODIFY gender CHAR(2); </code></td><td>修改 <code>stu</code> 表中的 <code>gender</code> 列的类型为 <code>CHAR(2)</code>。</td></tr><tr><td><strong>修改列名</strong></td><td><code>sql ALTER TABLE stu CHANGE gender sex CHAR(2); </code></td><td>修改 <code>stu</code> 表中的 <code>gender</code> 列名为 <code>sex</code>，并将数据类型改为 <code>CHAR(2)</code>。</td></tr><tr><td><strong>删除列</strong></td><td><code>sql ALTER TABLE stu DROP classname; </code></td><td>删除 <code>stu</code> 表中的 <code>classname</code> 列。</td></tr><tr><td><strong>修改表名称</strong></td><td><code>sql ALTER TABLE stu RENAME TO student; </code></td><td>将 <code>stu</code> 表的名称修改为 <code>student</code>。</td></tr></tbody></table><h2 id="四、DML（Data-Manipulation-Language）：数据操作语言"><a href="#四、DML（Data-Manipulation-Language）：数据操作语言" class="headerlink" title="四、DML（Data Manipulation Language）：数据操作语言"></a>四、DML（Data Manipulation Language）：数据操作语言</h2><p>以下是插入数据、修改数据、删除数据的常见 SQL 语法，以及代码解读的表格：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>SQL 语句</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>插入数据（指定列）</strong></td><td><code>sql INSERT INTO stu(sid, sname, age, gender) VALUES(&#39;s_1001&#39;, &#39;zhangSan&#39;, 23, &#39;male&#39;); </code></td><td>向 <code>stu</code> 表插入一行数据，指定插入的列及其对应的值。</td></tr><tr><td><strong>插入数据（指定部分列）</strong></td><td><code>sql INSERT INTO stu(sid, sname) VALUES(&#39;s_1001&#39;, &#39;zhangSan&#39;); </code></td><td>向 <code>stu</code> 表插入一行数据，仅指定了部分列（<code>sid</code> 和 <code>sname</code>）。其他列会使用默认值或 <code>NULL</code>。</td></tr><tr><td><strong>插入数据（不指定列）</strong></td><td><code>sql INSERT INTO stu VALUES(&#39;s_1002&#39;, &#39;liSi&#39;, 32, &#39;female&#39;); </code></td><td>向 <code>stu</code> 表插入一行数据，按照表中列的顺序插入所有列的值。</td></tr><tr><td><strong>修改数据</strong></td><td><code>sql UPDATE stu SET sname=&#39;zhangSanSan&#39;, age=32, gender=&#39;female&#39; WHERE sid=&#39;s_1001&#39;; </code></td><td>更新 <code>stu</code> 表中 <code>sid</code> 为 <code>s_1001</code> 的记录，将 <code>sname</code>、<code>age</code> 和 <code>gender</code> 修改为新值。</td></tr><tr><td><strong>修改数据（条件更新）</strong></td><td><code>sql UPDATE stu SET sname=&#39;liSi&#39;, age=20 WHERE age&gt;50 AND gender=&#39;male&#39;; </code></td><td>更新 <code>stu</code> 表中所有年龄大于 50 且性别为 <code>male</code> 的记录，将 <code>sname</code> 改为 <code>liSi</code>，<code>age</code> 改为 20。</td></tr><tr><td><strong>修改数据（多条件更新）</strong></td><td><code>sql UPDATE stu SET sname=&#39;wangWu&#39;, age=30 WHERE age&gt;60 OR gender=&#39;female&#39;; </code></td><td>更新 <code>stu</code> 表中所有年龄大于 60 或性别为 <code>female</code> 的记录，将 <code>sname</code> 改为 <code>wangWu</code>，<code>age</code> 改为 30。</td></tr><tr><td><strong>修改数据（NULL 检查）</strong></td><td><code>sql UPDATE stu SET gender=&#39;female&#39; WHERE gender IS NULL; </code></td><td>将 <code>stu</code> 表中所有性别为空（NULL）的记录的 <code>gender</code> 字段更新为 <code>female</code>。</td></tr><tr><td><strong>修改数据（递增更新）</strong></td><td><code>sql UPDATE stu SET age=age+1 WHERE sname=&#39;zhaoLiu&#39;; </code></td><td>将 <code>stu</code> 表中所有 <code>sname</code> 为 <code>zhaoLiu</code> 的记录的 <code>age</code> 字段加 1。</td></tr><tr><td><strong>删除数据（指定条件）</strong></td><td><code>sql DELETE FROM stu WHERE sid=&#39;s_1001&#39;; </code></td><td>删除 <code>stu</code> 表中 <code>sid</code> 为 <code>s_1001</code> 的记录。</td></tr><tr><td><strong>删除数据（多个条件）</strong></td><td><code>sql DELETE FROM stu WHERE sname=&#39;chenQi&#39; OR age &gt; 30; </code></td><td>删除 <code>stu</code> 表中 <code>sname</code> 为 <code>chenQi</code> 或年龄大于 30 的记录。</td></tr><tr><td><strong>删除数据（删除所有记录）</strong></td><td><code>sql DELETE FROM stu; </code></td><td>删除 <code>stu</code> 表中的所有记录，但表结构不变，删除的记录可以回滚（事务）。</td></tr><tr><td><strong>快速删除所有记录</strong></td><td><code>sql TRUNCATE TABLE stu; </code></td><td>删除 <code>stu</code> 表中的所有记录，并且该操作无法回滚，效率比 <code>DELETE</code> 高。</td></tr></tbody></table><h2 id="五、DCL（Data-Control-Language）：数据控制语言"><a href="#五、DCL（Data-Control-Language）：数据控制语言" class="headerlink" title="五、DCL（Data Control Language）：数据控制语言"></a>五、DCL（Data Control Language）：数据控制语言</h2><table><thead><tr><th><strong>操作</strong></th><th><strong>SQL 语句</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>创建用户</strong></td><td><code>sql CREATE USER &#39;user1&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123&#39;; </code></td><td>创建一个用户名为 <code>user1</code>，并且限制只能从 <code>localhost</code> 登录的用户，密码为 <code>123</code>。</td></tr><tr><td></td><td><code>sql CREATE USER &#39;user2&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;; </code></td><td>创建一个用户名为 <code>user2</code>，允许从任何地址 (<code>%</code> 代表所有 IP 地址) 登录的用户，密码为 <code>123</code>。</td></tr><tr><td><strong>给用户授权</strong></td><td><code>sql GRANT CREATE, ALTER, DROP, INSERT, UPDATE, DELETE, SELECT ON mydb1.* TO &#39;user1&#39;@&#39;localhost&#39;; </code></td><td>授予 <code>user1</code> 在 <code>mydb1</code> 数据库上的多种权限，包括 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。</td></tr><tr><td></td><td><code>sql GRANT ALL ON mydb1.* TO &#39;user2&#39;@&#39;localhost&#39;; </code></td><td>授予 <code>user2</code> 在 <code>mydb1</code> 数据库上的所有权限。</td></tr><tr><td><strong>撤销授权</strong></td><td><code>sql REVOKE CREATE, ALTER, DROP ON mydb1.* FROM &#39;user1&#39;@&#39;localhost&#39;; </code></td><td>撤销 <code>user1</code> 在 <code>mydb1</code> 数据库上的 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code> 权限。</td></tr><tr><td><strong>查看用户权限</strong></td><td><code>sql SHOW GRANTS FOR &#39;user1&#39;@&#39;localhost&#39;; </code></td><td>查看 <code>user1</code> 用户在 <code>localhost</code> 上的授权权限。</td></tr><tr><td><strong>删除用户</strong></td><td><code>sql DROP USER &#39;user1&#39;@&#39;localhost&#39;; </code></td><td>删除 <code>user1</code> 用户。</td></tr><tr><td><strong>修改用户密码（以root身份）</strong></td><td><code>sql USE mysql; </code></td><td>切换到 <code>mysql</code> 系统数据库，在该数据库下管理用户及权限。</td></tr><tr><td></td><td><code>sql ALTER USER &#39;user1&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;newpassword&#39;; </code></td><td>修改 <code>user1</code> 用户的密码为 <code>newpassword</code>。</td></tr></tbody></table><hr><h2 id="六、DQL（Data-Query-Language）：数据查询语言"><a href="#六、DQL（Data-Query-Language）：数据查询语言" class="headerlink" title="六、DQL（Data Query Language）：数据查询语言"></a>六、DQL（Data Query Language）：数据查询语言</h2><p>数据库执行 DQL 语句不会对数据进行改变，而是让数据库发送结果集给客户端。</p><p>语法：<br> select 列名 —-&gt; 要查询的列名称<br> from 表名 —-&gt; 要查询的表名称<br> where 条件 —-&gt; 行条件<br> group by 分组列 —-&gt; 对结果分组<br> having 分组条件 —-&gt; 分组后的行条件<br> order by 排序列 —-&gt; 对结果分组<br> limit 起始行, 行数 —-&gt; 结果限定</p><h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1. 基础查询"></a>1. <strong>基础查询</strong></h3><h4 id="查询所有列"><a href="#查询所有列" class="headerlink" title="查询所有列"></a>查询所有列</h4><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p><code>*</code>是通配符，表示查询表中的所有列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu;<br></code></pre></td></tr></table></figure><p>这条查询语句会返回<code>stu</code>表中的所有列和所有记录。</p><h4 id="查询指定列"><a href="#查询指定列" class="headerlink" title="查询指定列"></a>查询指定列</h4><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>, ... <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p>如果你只关心表中的某些列，可以在查询中指定列名，而不是使用<code>*</code>来查询所有列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sid, sname, age <span class="hljs-keyword">FROM</span> stu;<br></code></pre></td></tr></table></figure><p>这条查询语句只会返回<code>stu</code>表中的<code>sid</code>、<code>sname</code>和<code>age</code>这三列。</p><h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2. 条件查询"></a>2. <strong>条件查询</strong></h3><h4 id="使用运算符"><a href="#使用运算符" class="headerlink" title="使用运算符"></a>使用运算符</h4><p>SQL提供了多种运算符来在<code>WHERE</code>子句中进行条件过滤：</p><ul><li><code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> 等。</li><li><code>BETWEEN … AND</code>：用于查询某个值在两个值之间的记录。</li><li><code>IN (值列表)</code>：用于查询某个字段值在指定列表中的记录。</li><li><code>IS NULL</code>：用于检查字段是否为NULL。</li><li><code>AND</code>, <code>OR</code>, <code>NOT</code>：用于组合多个条件。</li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>查询性别为“女”，并且年龄小于50的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;female&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>查询学号为 <code>S_1001</code> 或者姓名为 <code>liSi</code> 的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;S_1001&#x27;</span> <span class="hljs-keyword">OR</span> sname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;liSi&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询学号为 <code>S_1001</code>、<code>S_1002</code>、<code>S_1003</code> 的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sid <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;S_1001&#x27;</span>, <span class="hljs-string">&#x27;S_1002&#x27;</span>, <span class="hljs-string">&#x27;S_1003&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查询学号不是 <code>S_1001</code>、<code>S_1002</code>、<code>S_1003</code> 的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sid <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;S_1001&#x27;</span>, <span class="hljs-string">&#x27;S_1002&#x27;</span>, <span class="hljs-string">&#x27;S_1003&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查询年龄为 <code>NULL</code> 的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p>查询年龄在 20 到 40 之间的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure><p>查询性别非“男”的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;male&#x27;</span>;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;male&#x27;</span>;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;male&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询姓名不为 <code>NULL</code> 的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sname <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3. 模糊查询"></a>3. <strong>模糊查询</strong></h3><p>模糊查询是通过 <code>LIKE</code> 操作符来进行的，主要用于字符串匹配。SQL提供两种匹配模式：</p><ul><li><code>%</code>：匹配任意长度的字符串（包括零个字符）。</li><li><code>_</code>：匹配单个字符。</li></ul><h4 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h4><p>查询姓名由5个字母构成的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_____&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询姓名由5个字母构成，并且第5个字母为“i”的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;____i&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询姓名以“z”开头的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;z%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询姓名中第2个字母为“i”的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_i%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询姓名中包含“a”字母的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">WHERE</span> sname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%a%&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="4-字段控制查询"><a href="#4-字段控制查询" class="headerlink" title="4. 字段控制查询"></a>4. <strong>字段控制查询</strong></h3><h4 id="去掉重复记录"><a href="#去掉重复记录" class="headerlink" title="去掉重复记录"></a>去掉重复记录</h4><p>使用 <code>DISTINCT</code> 去除查询结果中的重复记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> sal <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>这条查询将返回<code>emp</code>表中所有不同的薪水（去除重复）。</p><h4 id="查看月薪与佣金之和"><a href="#查看月薪与佣金之和" class="headerlink" title="查看月薪与佣金之和"></a>查看月薪与佣金之和</h4><p>如果 <code>sal</code> 和 <code>comm</code> 是数值类型，可以直接加和。如果 <code>comm</code> 存在NULL值，我们可以使用<code>IFNULL</code>函数来避免计算错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, sal <span class="hljs-operator">+</span> IFNULL(comm, <span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>此查询将返回所有员工的工资和佣金之和（如果<code>comm</code>为NULL，则视为0）。</p><h4 id="给列名添加别名"><a href="#给列名添加别名" class="headerlink" title="给列名添加别名"></a>给列名添加别名</h4><p>可以使用 <code>AS</code> 为查询结果中的列起别名，使其更具可读性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, sal <span class="hljs-operator">+</span> IFNULL(comm, <span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>也可以省略 <code>AS</code>，直接写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, sal <span class="hljs-operator">+</span> IFNULL(comm, <span class="hljs-number">0</span>) total <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><h3 id="5-排序"><a href="#5-排序" class="headerlink" title="5. 排序"></a>5. <strong>排序</strong></h3><h4 id="升序排序"><a href="#升序排序" class="headerlink" title="升序排序"></a>升序排序</h4><p>查询所有学生记录，按年龄升序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br></code></pre></td></tr></table></figure><h4 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h4><p>查询所有学生记录，按年龄降序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> stu <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h4 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h4><p>查询所有雇员，按月薪降序排序，如果月薪相同，则按编号升序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sal <span class="hljs-keyword">DESC</span>, empno <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h3 id="6-聚合函数"><a href="#6-聚合函数" class="headerlink" title="6. 聚合函数"></a>6. <strong>聚合函数</strong></h3><p>聚合函数用于对一组数据进行纵向运算。常用的聚合函数包括：</p><ul><li><code>COUNT()</code>：统计记录的数量。</li><li><code>MAX()</code>：计算最大值。</li><li><code>MIN()</code>：计算最小值。</li><li><code>SUM()</code>：计算总和。</li><li><code>AVG()</code>：计算平均值。</li></ul><h4 id="举例说明-2"><a href="#举例说明-2" class="headerlink" title="举例说明"></a>举例说明</h4><p>查询<code>emp</code>表的记录数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>查询<code>emp</code>表中有佣金的员工数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(comm) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>查询所有员工月薪的总和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(sal) <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>查询所有员工月薪和佣金的总和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(sal), <span class="hljs-built_in">SUM</span>(comm) <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>查询所有员工的平均月薪：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(sal) <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><p>查询最高工资和最低工资：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(sal), <span class="hljs-built_in">MIN</span>(sal) <span class="hljs-keyword">FROM</span> emp;<br></code></pre></td></tr></table></figure><h3 id="7-分组查询"><a href="#7-分组查询" class="headerlink" title="7. 分组查询"></a>7. <strong>分组查询</strong></h3><h4 id="使用-GROUP-BY-进行分组查询"><a href="#使用-GROUP-BY-进行分组查询" class="headerlink" title="使用 GROUP BY 进行分组查询"></a>使用 <code>GROUP BY</code> 进行分组查询</h4><p>当需要按某个字段分组时，可以使用 <code>GROUP BY</code> 子句。通常与聚合函数一起使用。</p><p>查询每个部门的部门编号和工资总和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">SUM</span>(sal) <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno;<br></code></pre></td></tr></table></figure><p>查询每个部门的部门编号和人数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno;<br></code></pre></td></tr></table></figure><p>查询每个部门的部门编号和工资大于1500的员工人数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> sal <span class="hljs-operator">&gt;</span> <span class="hljs-number">1500</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno;<br></code></pre></td></tr></table></figure><h4 id="使用-HAVING-子句"><a href="#使用-HAVING-子句" class="headerlink" title="使用 HAVING 子句"></a>使用 <code>HAVING</code> 子句</h4><p><code>HAVING</code> 用于对分组后的结果进行过滤，通常与 <code>GROUP BY</code> 一起使用。</p><p>查询工资总和大于9000的部门编号和工资总和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">SUM</span>(sal) <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">SUM</span>(sal) <span class="hljs-operator">&gt;</span> <span class="hljs-number">9000</span>;<br></code></pre></td></tr></table></figure><h3 id="8-LIMIT：限制查询结果的行数"><a href="#8-LIMIT：限制查询结果的行数" class="headerlink" title="8. LIMIT：限制查询结果的行数"></a>8. <strong>LIMIT：限制查询结果的行数</strong></h3><p><code>LIMIT</code> 用于限制查询结果的起始行和返回的行数。</p><p>查询5行记录，从第0行开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>查询10行记录，从第3行开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp LIMIT <span class="hljs-number">3</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>分页查询：</p><ul><li>第一页：<code>LIMIT 0, 10</code></li><li>第二页：<code>LIMIT 10, 10</code></li><li>第三页：<code>LIMIT 20, 10</code></li></ul><h3 id="9-多表连接查询"><a href="#9-多表连接查询" class="headerlink" title="9. 多表连接查询"></a>9. <strong>多表连接查询</strong></h3><p>表连接分为<strong>内连接</strong>（INNER JOIN）和<strong>外连接</strong>（OUTER JOIN）。内连接只返回匹配的记录，外连接则返回所有记录，包括没有匹配的部分。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> staff.name, deptname <span class="hljs-keyword">FROM</span> staff, deptno <span class="hljs-keyword">WHERE</span> staff.name <span class="hljs-operator">=</span> deptno.name;<br></code></pre></td></tr></table></figure><p>这条查询返回<code>staff</code>表和<code>deptno</code>表中<code>name</code>列匹配的记录。</p><h4 id="外连接（左连接和右连接）"><a href="#外连接（左连接和右连接）" class="headerlink" title="外连接（左连接和右连接）"></a>外连接（左连接和右连接）</h4><p><strong>左连接</strong>：返回左表所有记录，右表没有匹配的记录显示为<code>NULL</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> staff.name, deptname <span class="hljs-keyword">FROM</span> staff <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> deptno <span class="hljs-keyword">ON</span> staff.name <span class="hljs-operator">=</span> deptno.name;<br></code></pre></td></tr></table></figure><p><strong>右连接</strong>：返回右表所有记录，左表没有匹配的记录显示为<code>NULL</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> deptname, deptno.name <span class="hljs-keyword">FROM</span> staff <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> deptno <span class="hljs-keyword">ON</span> deptno.name <span class="hljs-operator">=</span> staff.name;<br></code></pre></td></tr></table></figure><p>这些是常见的 SQL 查询操作，涵盖了从基础查询到高级聚合和连接查询的知识。                        </p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表结构</title>
    <link href="/2023/04/18/%E8%A1%A8/"/>
    <url>/2023/04/18/%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h1><p><img src="https://s2.loli.net/2025/01/01/y9DfaelpWu8LV5Z.png" alt="image-20250101203832500"></p><h1 id="页"><a href="#页" class="headerlink" title="页"></a>页</h1><p><img src="https://s2.loli.net/2025/01/01/qwH4pS9BC7PeZTn.jpg" alt="81c1d2533296a7ccfcb45655fdbfdab07b238c"></p><p>关于页的存储及在查找中的过程可以参考</p><p><a href="https://zhuanlan.zhihu.com/p/382375842">MySQL 页完全指南——浅入深出页的原理 - 知乎</a></p><p><a href="https://cloud.tencent.com/developer/article/1818381">一文理解 MySQL 中的 page 页-腾讯云开发者社区-腾讯云</a></p><p>这篇文章，这两位前辈已经总结的很到位了，我就不再赘述</p><p><img src="https://s2.loli.net/2025/01/01/c6GnyJrh2OVRWTo.png" alt="5bd62da36a3b41d2a96db199002fb505"></p><h1 id="区"><a href="#区" class="headerlink" title="区"></a>区</h1><p>通过页其实已经形成了完整的功能。</p><p>B+树的每一层中的页都会形成一个双向链表，如果是以页为单位 来分配存储空间的话，双向链表相邻的两个页之间的 物理位置可能离得非常远。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远就是所谓的 随机I&#x2F;O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机I&#x2F;O是非常慢 的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的 顺序I&#x2F;O。</p><p>引入区的概念，一个区就是在物理位置上连续的64个页。因为innoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D; 1MB 。在表中 数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照 区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成 一点点空间的浪费(数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机IO，功大于过!区是属于某一个段的（或者是混合）</p><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以innoDB 对 B+ 树的叶节点和叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段( segment )，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个 叶子节点段，一个非叶子节点段。</p><p> 除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、 回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。<br>在innoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。<br>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><p>段由多个区组成，段的入口记录在 <code>FSP_HDR</code> 和 <code>Inode Page</code> 中。</p><h2 id="碎片区"><a href="#碎片区" class="headerlink" title="碎片区"></a>碎片区</h2><p>默认情况下，假如我们新建一个索引就会生成两个段（叶子节点段和非叶子节点段），而一个段中至少包含一个区，也就是需要2MB的空间，假如我们这个表压根没有多少数据，那么一次就要申请2MB的空间明显是浪费的。为了解决这个问题，设计者提出了碎片区的概念，碎片区中的页可能属于不同的段，也可以用于不同的目的，至于如何控制应不应该给一个段申请专属的区，会进行以下控制：</p><ol><li><p>刚开始向表插入数据，都是从某一个碎片区以页为单位来分配存储空间。</p></li><li><p>当一个段占用的空间达到了32个碎片区的页之后，就会开始给这个段申请专属的区。</p></li></ol><p>当段中存储的区小于32时，是会利用隶属于表空间的碎片区进行存储的。</p><p>流程：</p><ul><li>新插入的页寻找空闲区进行存储，如何快速寻找到表空间的空闲碎片区呢？<ul><li>表空间会维护一个FREE状态的链表和FREE_FREG状态的链表以及FULL_FRAG状态的链表。</li><li>如果空闲的碎片区还存在就会找出链表中取出一个插入，如果满了就改变其状态将其放入FULL_FRAG的链表中。</li><li>如果没有空闲的碎片区，就会从FREE中取出一个来将其转变为空闲碎片区状态放入FREE_FREG状态的链表中。</li></ul></li></ul><h2 id="区分类"><a href="#区分类" class="headerlink" title="区分类"></a>区分类</h2><p>我们现在知道表空间是由若干个区组成的，这些区可以分成以下的4中类型：</p><ol><li>FREE：没有用到这个区的任何一个页面。</li><li>FREE_FRAG：有剩余空闲页的碎片区。</li><li>FULL_FRAG：没有剩余空闲页的碎片区。</li><li>FSEG：专属某一个段的区。</li></ol><h2 id="XDES-Entry"><a href="#XDES-Entry" class="headerlink" title="XDES Entry"></a>XDES Entry</h2><p>为了管理各种各样的区，设计者提成了一个XDES Entry结构。</p><p><img src="https://s2.loli.net/2025/01/01/YTdrFCvW8sGEfVg.png" alt="image-20250101213814204"></p><ul><li><p>Segment ID：每一个段都有自己的编号，如果一个XDES Entry属于一个段，就是所在段的编号，如果是碎片区，则这个属性没有意义。</p></li><li><p>State：四种类型的标识。</p></li><li><p>Page State Bitmap：16字节，128位，每两位对应一个区中的页。第一位标识是否空闲，第二位没有用到。</p></li><li><p>List Node：若干个XDES Entry形成链表。</p></li></ul><h3 id="XDES-Entry链表"><a href="#XDES-Entry链表" class="headerlink" title="XDES Entry链表"></a>XDES Entry链表</h3><p>当我们需要某一个类型的XDES Entry时候，如何快速的拿到，这就跟XDES Entry形成的链表有关了，对于属于表的三种类型 FREE，FREE_FRAG，FULL_FRAG，会生成三个链表：</p><ol><li><p>当我们插入一条新记录时，如果FREE_FRAG链表不为空，在FREE_FRAG链表中拿到一个XDES Entry并取得一个页添加数据。如果FREE_FRAG链表为空，在FREE链表拿到一个XDES Entry并取得一个页添加数据，之后把XDES Entry移动到FREE_FRAG链表里。</p></li><li><p>如果使用FREE_FRAG链表中的XDES Entry是发现满了，就把XDES Entry移动到FULL_FRAG链表里。</p></li></ol><h3 id="FSEG区"><a href="#FSEG区" class="headerlink" title="FSEG区"></a>FSEG区</h3><p>我们前面说了FREE，FREE_FRAG，FULL_FRAG三种类型的链表，这三种类型是针对碎片区的，而对于段专属的区类型FSEG，也会形成三种类型的链表，这三个链表属于段，存在段结构中。</p><ul><li><p>FREE：属于同一个段的空闲FSEG区会形成这个链表。</p></li><li><p>NOT_FULL：属于同一个段的还有空闲页的FSEG区会形成这个链表。</p></li><li><p>FULL：属于同一个段的没有空闲页的FSEG区会形成这个链表。</p></li></ul><h1 id="再谈段结构"><a href="#再谈段结构" class="headerlink" title="再谈段结构"></a>再谈段结构</h1><blockquote><p>在区章节里我们简单介绍了段的由来，这这里续上。</p></blockquote><p>段不是一个物理上连续的空间，而是一个逻辑上的概念，一个段包含若干零散的页面还有自己专属的FSEG区，这些FSEG区形成FREE, NOT_FULL, FULL三种链表保存在段上，像XDES Entry一样，设计者也给段定义了一个结构INODE Entry。</p><p><img src="https://s2.loli.net/2025/01/01/81ufetNkM3QZ2wp.png" alt="image-20250101214259591"></p><ul><li><p>Segment ID：该段（INODE Entry结构）的编号ID。</p></li><li><p>NOT_FULL_N_USED：NOT_FULL链表中使用了多少个页面。</p></li><li><p>List Base Node：是INODE Entry给FSEG链表定义的一个结构，通过这个结构可以直接找到链头，链尾。</p></li><li><p>Magic Number：表示这个INODE Entry是否已经被初始化。</p></li><li><p>Fragment Array Entry：前面说过只有使用了32个碎片区的页之后，才会开始申请专属的FSEG区，而32个碎片页就是靠这个属性来定位的。</p></li></ul><p><strong>由此看来：段是一些零散页和完整区的结合。</strong><br>在段中，碎片区的引用是在最底下，而专属区的引用是在链表中链着的。</p><h1 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h1><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>在 InnoDB 中，<strong>组</strong> 是一组连续的区（Extent）的集合。一个组由 <strong>256 个区</strong> 组成。每个区的大小是 <strong>1MB</strong>，因此一个组的大小为 <strong>256MB</strong>（256 * 1MB）。每个组管理着一部分表空间中的数据区域。表空间本身并不直接管理区，而是通过组来组织和管理。</p><h4 id="组和区的关系："><a href="#组和区的关系：" class="headerlink" title="组和区的关系："></a><strong>组和区的关系：</strong></h4><ul><li><strong>1 个组 &#x3D; 256 个区（Extents） &#x3D; 256MB</strong></li><li>表空间是由多个组组成的。</li><li>每个区都被分配给一个组，区内存储的是实际的数据或索引。</li></ul><h4 id="组的管理结构"><a href="#组的管理结构" class="headerlink" title="组的管理结构"></a><strong>组的管理结构</strong></h4><ul><li><strong>组的管理结构</strong> 用于管理该组内所有区的元数据。每个组会有一个专门的管理区域，用来存储与该组相关的 <strong>XDES Entry</strong> 和其他元数据。</li><li>这些元数据包括：区的分配状态、是否被使用、是否属于数据段、是否属于索引段等信息。</li><li>这种设计确保了 InnoDB 在处理数据时能够快速定位每个区的元数据，而不需要遍历每个区。</li></ul><h2 id="区的存储"><a href="#区的存储" class="headerlink" title="区的存储"></a>区的存储</h2><p>XDES Entry保存了有关区的消息，大小为40字节，而我们说一个区大小是1MB，由64个页组成，16KB * 64 &#x3D; 1024KB 刚好1MB，也就是没有额外的40字节来存储XDES Entry了，<strong>那这些XDES Entry到底是存放在哪的？</strong><br>前面我们有说过组的概念，组由256个区组成。表空间由组组成，组中包含了XDES Entry等信息。<br><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250101214708887.png" alt="image-20250101214708887"></p><p>以上我们可以理解为一个表空间的组成，有组1，组2，我们之前所说的各种信息，都会保存在每一组的第一个区中的前面几个页里面。而作为表空间的第一个组，则要另外保存与表相关的信息。</p><blockquote><p>表空间第一个组第一个区：第一页FSP_HDR页，第二页IBUF_BITMAP页，第三页INODE页<br>其他组第一个区：第一页XDES页，第二页IBUF_BITMAP页</p></blockquote><h3 id="FSP-HDR"><a href="#FSP-HDR" class="headerlink" title="FSP_HDR"></a>FSP_HDR</h3><p><img src="https://s2.loli.net/2025/01/01/ZD1abqeSwmJsXFi.png" alt="image-20250101214850816"></p><ul><li>File Space Header：存储表相关的信息，比如我们之前说的属于表的三个链表（FREE，FREE_FRAG，FULL_FRAG）就会存储在这个区域。</li><li>XDES Entry 0 - XDES Entry 255：该组下的256个XDES Entry结构。</li></ul><h2 id="File-Space-Header"><a href="#File-Space-Header" class="headerlink" title="File Space Header"></a>File Space Header</h2><p><img src="C:/Users/11252/Desktop%E6%A1%8C%E9%9D%A2/2254995-20220521171053794-1771626332.png" alt="2254995-20220521171053794-1771626332"></p><ul><li>Space ID 表示表空间的ID</li><li>Size 表空间页的大小</li><li>Free Limit 就是当前已经使用的页到多少了，下次直接从这个地址开始分配页面</li><li>FRAG_N_USED 表示碎片区已经使用的页</li><li>接下来的for FREE List 和for FREE_FRAG List和for FULL_FRAG List 表示表空间维护的三个有关碎片区的链表</li><li>Next Unuser Segment ID 表示下一个未分配的段ID，方便分配一个新的段ID</li><li>for SEG_INODES_FULL 和 for SEG_INODES_FREE 表示已经放满了INODE Entry 的INODE节点和空闲的INODE节点。（记住是存放INODE Entry也就是段结构的INODE节点）</li></ul><h3 id="XDES"><a href="#XDES" class="headerlink" title="XDES"></a>XDES</h3><p>与FSP_HDR页一样，只是没有File Space Header。</p><h3 id="IBUF-BITMAP"><a href="#IBUF-BITMAP" class="headerlink" title="IBUF_BITMAP"></a>IBUF_BITMAP</h3><p>当发生记录的增删改时，聚餐索引会发生相应的变化，如果也二级索引的B+树也要发生相应的调整，而这些对应的页往往都不在内存中，如果要修改必须发生磁盘IO，把对应的二级索引页也给读到内存中进行修改，这样就增加了IO的次数，影响性能。<br>IBUF_BITMAP页的作用就是缓存这些操作，等到下一次MySQL刚好把这些要修改的页读取到内存的时候，顺便修改。</p><h3 id="INODE"><a href="#INODE" class="headerlink" title="INODE"></a>INODE</h3><p>一个索引有两个段，一个段会对应INODE Entry结构，这个页就是用来保存这个表空间所有的INODE Entry结构的。<br><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250101215636939.png" alt="image-20250101215636939"></p><p>INODE类型结构就是为了存储INODE Entry节点的，最多存储85个段。</p><p>结构中List Node for INODE Page List 就是指向上一个INODE节点和下一个INODE节点。我们就是在这个INODE中存储段的INODE Entry节点的。</p><p>如果该页存储满了，就会在上面提到的List Base Node for SEG_INODES_FREE 就是空闲INODE页的基节点的链表引用，取出一个，空的话从碎片区中申请一个页来存放。</p><h1 id="怎么找到索引的页？"><a href="#怎么找到索引的页？" class="headerlink" title="怎么找到索引的页？"></a>怎么找到索引的页？</h1><p>在数据页是有两个引用，在页结构的Page Header中有如下两个结构</p><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250101220358081.png" alt="image-20250101220358081"></p><p>这两个结构就是Segment Header这个结构</p><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250101220416458.png" alt="image-20250101220416458"></p><ul><li>Space ID of the INODE Entry 就是INODE对应的表空间</li><li>Page Number of the INODE Entry 就是INODE对应的表空间下对应的页号</li><li>Byte Offset of the INODE Entry 就是INODE对应的页中对应段的偏移量。</li></ul><p>我们就可以通过在索引的ROOT节点存储一个这样的结构，可以找到对应的段。包括叶子段和非叶子段，就是两个这个结构，然后去表空间中找到这两个段的地址即可。</p><h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><p>数据字典即系统表空间中存放了一些固定的数据，以及数据库中的表，表名，列，列属于那个表等等基本信息。还有一些已经用了的最大的表ID，最大的索引ID，最大的表空间ID，就是方便下次创建表啊索引啊这一些更方便一点，直接将值进行增加等操作进行赋值即可。</p><h3 id="InnoDB数据字典"><a href="#InnoDB数据字典" class="headerlink" title="InnoDB数据字典"></a>InnoDB数据字典</h3><p>每当我们向一个表中插入一条记录的时候，MySQL校验过程 如下<br>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说:</p><ul><li><p>某个表属于哪个表空间，表里边有多少列</p></li><li><p>表对应的每一个列的类型是什么</p></li><li><p>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</p></li><li><p>该表有哪些外键，外键对应哪个表的哪些列</p></li><li><p>某个表空间对应文件系统上文件路径是什么</p></li><li><p>……………..</p></li></ul><p>上述这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为 <strong>元数据</strong>。lnnoDB存储引擎特意定义了一些列的 **内部系统表 (internalsystem table)**来记录这些这些元数据:</p><p><img src="https://s2.loli.net/2025/01/01/uRwTAHfxjSrch7k.png" alt="image-20250101205220066"></p><p>这些系统表也被称为 数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中 SYS_TABLES   SYS_COLUMNS </p><p>SYS_INDEXES   SYS_FIELDS 这四个表尤其重要，称之为基本系统表 (basic system tables)。</p><blockquote><p>注意:用户是不能直接访问 innoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。</p></blockquote><p><img src="https://s2.loli.net/2025/01/01/RIhNTom2ZvibtWL.png" alt="2254995-20220521171005098-123864628"></p><h1 id="行"><a href="#行" class="headerlink" title="行"></a>行</h1><p>页里保存的是一行一行的数据，我们自然要看看行的存储格式：</p><blockquote><p>具体参考：</p><p><a href="https://zhuanlan.zhihu.com/p/266060894">MySQL之InnoDB存储引擎：Row Format行格式 - 知乎</a></p><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#mysql-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%96%87%E4%BB%B6">MySQL 一行记录是怎么存储的？ | 小林coding</a></p><p><a href="https://blog.csdn.net/qq_42435377/article/details/124951046">【MySql进阶】行格式详解：COMPACT、Dynamic_mysql dynamic-CSDN博客</a></p><p><a href="https://www.cnblogs.com/wilburxu/p/9435818.html">MySQL InnoDB 行记录格式（ROW_FORMAT） - WilburXu - 博客园</a></p></blockquote><p><img src="https://s2.loli.net/2025/01/02/JPsOqfB6MHGyuK5.png" alt="image-20250102091119367"></p><hr><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/Alex_cf/article/details/128409529">Mysql ——区、段、表空间 、碎片区_mysql 段-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webbench压测源码分析</title>
    <link href="/2023/03/26/%E5%8E%8B%E6%B5%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/26/%E5%8E%8B%E6%B5%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="webbench压测源码分析"><a href="#webbench压测源码分析" class="headerlink" title="webbench压测源码分析"></a>webbench压测源码分析</h1><p>Webbench是知名的网站压力测试工具，它是由Lionbridge公司开发。Web Bench 是用于对 WWW 或代理服务器进行基准测试的非常简单的工具。使用 fork() 模拟多个客户端，可以使用 HTTP&#x2F;0.9-HTTP&#x2F;1.1 请求。这个基准测试不是很现实，但它可以测试您的 HTTPD 是否真的可以一次处理那么多客户端（尝试运行一些 CGI）而无需关闭您的机器。</p><hr><p>Webbench源码代码量虽小(500行左右)，但麻雀虽小五脏俱全。这其中包含了LInux下的网络Socket编程，HTTP报文，进程通信的信号与管道等系统编程知识，对于正在学习Linux环境下服务器编程的学习者来说可以是很好的入门源码分析对象。本文只起到抛砖引玉的作用。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Linux网络编程基本流程"><a href="#Linux网络编程基本流程" class="headerlink" title="Linux网络编程基本流程"></a>Linux网络编程基本流程</h3><p><img src="https://s2.loli.net/2024/05/28/zOQbgrUGXWMuVt4.png" alt="20190618104623551"></p><h3 id="套接字地址结构体"><a href="#套接字地址结构体" class="headerlink" title="套接字地址结构体"></a>套接字地址结构体</h3><p><img src="https://s2.loli.net/2024/05/28/Cblm86NPkXQBWph.png" alt="20210603143753607"></p><p>在Linux下进行套接字（Socket）编程时，主要涉及以下几个结构体：</p><ol><li><p><strong>struct sockaddr</strong>：</p><ul><li>用于表示通用的套接字地址结构体。</li><li>包含地址族（address family）和地址数据等信息。</li></ul></li><li><p><strong>struct sockaddr_in</strong>：</p><ul><li>用于表示 IPv4 的套接字地址结构体。</li><li>是在 <code>netinet/in.h</code> 头文件中定义的，常用于 IPv4 套接字编程。</li><li>包含了 IPv4 的地址和端口等信息。</li></ul></li><li><p><strong>struct sockaddr_in6</strong>：</p><ul><li>用于表示 IPv6 的套接字地址结构体。</li><li>是在 <code>netinet/in.h</code> 头文件中定义的，用于 IPv6 套接字编程。</li><li>包含了 IPv6 的地址和端口等信息。</li></ul></li><li><p><code>sockaddr_un</code> 是用于 Unix 域套接字（Unix Domain Socket）的结构体，用于表示 Unix 域套接字的地址信息。在 Linux 系统中，Unix 域套接字是一种特殊的套接字类型，用于在同一台主机上的进程间通信，而不需要经过网络协议栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span> sun_family;    <span class="hljs-comment">// 地址族，通常设置为 AF_UNIX</span><br>    <span class="hljs-type">char</span>        sun_path[UNIX_PATH_MAX];   <span class="hljs-comment">// 套接字路径名，UNIX_PATH_MAX 是路径名的最大长度限制</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sa_family_t</code> 是用于表示套接字地址族（Address Family）的数据类型，通常是一个无符号整数类型。在套接字编程中，地址族用于指定套接字的类型或协议族。常见的地址族包括：</p><ul><li><code>AF_INET</code>：IPv4 地址族，用于 Internet 套接字。</li><li><code>AF_INET6</code>：IPv6 地址族，用于 Internet 套接字。</li><li><code>AF_UNIX</code>：Unix 域地址族，用于本地进程间通信的 Unix 域套接字。</li><li><code>AF_PACKET</code>：用于原始套接字的地址族，可用于发送和接收数据帧。Socket函数</li></ul></li></ol><hr><h2 id="Socket函数"><a href="#Socket函数" class="headerlink" title="Socket函数"></a>Socket函数</h2><p>该函数的作用是根据指定的主机名和端口号创建一个 TCP 套接字，并尝试连接到指定的主机和端口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Socket</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">int</span> clientPort)</span><br>&#123;<br>    <span class="hljs-type">int</span> sock;                         <span class="hljs-comment">// 定义套接字描述符</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> inaddr;             <span class="hljs-comment">// 存储主机地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ad</span>;</span>            <span class="hljs-comment">// 定义套接字地址结构体</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">hp</span>;</span>               <span class="hljs-comment">// 存储主机信息</span><br><br>    <span class="hljs-built_in">memset</span>(&amp;ad, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ad));       <span class="hljs-comment">// 初始化套接字地址结构体为零</span><br>    ad.sin_family = AF_INET;          <span class="hljs-comment">// 设置地址族为 IPv4</span><br><br>    inaddr = inet_addr(host);         <span class="hljs-comment">// 将主机名转换为网络字节序的 IP 地址</span><br>    <span class="hljs-keyword">if</span> (inaddr != INADDR_NONE)<br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="hljs-keyword">sizeof</span>(inaddr));  <span class="hljs-comment">// 如果转换成功，则将地址复制到地址结构体中</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        hp = gethostbyname(host);     <span class="hljs-comment">// 如果转换失败，则获取主机信息</span><br>        <span class="hljs-keyword">if</span> (hp == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                 <span class="hljs-comment">// 如果获取失败，则返回错误码 -1</span><br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);  <span class="hljs-comment">// 将获取到的地址复制到地址结构体中</span><br>    &#125;<br>    ad.sin_port = htons(clientPort);  <span class="hljs-comment">// 将客户端端口号转换为网络字节序，并存储在地址结构体中</span><br><br>    sock = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 创建一个 TCP 套接字</span><br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> sock;                   <span class="hljs-comment">// 如果创建失败，则返回错误码</span><br><br>    <span class="hljs-keyword">if</span> (connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;ad, <span class="hljs-keyword">sizeof</span>(ad)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                     <span class="hljs-comment">// 尝试连接到指定主机和端口，如果失败则返回错误码 -1</span><br><br>    <span class="hljs-keyword">return</span> sock;                       <span class="hljs-comment">// 如果连接成功，则返回套接字描述符</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><blockquote><p>在这里使用memcpy而不是&#x3D;的目的是将 <code>inaddr</code> 中的内容复制到 <code>ad.sin_addr</code> 中。尽管 <code>inaddr</code> 和 <code>ad.sin_addr</code> 都是 <code>unsigned long</code> 类型的变量，但它们可能在内存中的存储方式或大小端字节序上有所不同。</p><p><code>memcpy</code> 函数可以确保在不同类型之间进行字节级别的拷贝，而不受内存布局或字节序的影响。这样可以确保在复制数据时保持数据的准确性和完整性。</p><p>另外，<code>inaddr</code> 可能是在 <code>host</code> 为点分十进制 IP 地址时使用 <code>inet_addr</code> 函数转换的，而 <code>ad.sin_addr</code> 是 <code>struct sockaddr_in</code> 结构体中的字段，直接赋值可能会导致类型不匹配或数据不一致的问题，因此使用 <code>memcpy</code> 更为安全和可靠。</p></blockquote><hr><h2 id="webbench主函数"><a href="#webbench主函数" class="headerlink" title="webbench主函数"></a>webbench主函数</h2><h3 id="HTTP基础知识"><a href="#HTTP基础知识" class="headerlink" title="HTTP基础知识"></a>HTTP基础知识</h3><h4 id="HTTP请求报文结构"><a href="#HTTP请求报文结构" class="headerlink" title="HTTP请求报文结构"></a>HTTP请求报文结构</h4><p><img src="https://s2.loli.net/2024/05/28/J5hwdAEK4zVCUBf.webp" alt="4"></p><h5 id="HTTP-GET和POST方法之间的区别"><a href="#HTTP-GET和POST方法之间的区别" class="headerlink" title="HTTP GET和POST方法之间的区别"></a>HTTP GET和POST方法之间的区别</h5><ol><li><strong>GET 方法</strong>：<ul><li>用于请求从服务器获取数据。</li><li>参数在 URL 中传递，通过查询字符串（Query String）的形式附加在 URL 后面。</li><li>GET 请求可以被缓存，可以被书签收藏，并且可以被历史记录保存。</li><li>GET 请求的长度有限制，因为参数会附加在 URL 上，因此可能受到 URL 长度限制的影响。</li><li>不安全敏感的数据（如密码）不应该通过 GET 请求发送，因为它们会显示在 URL 中，可能被截获或泄露。</li></ul></li><li><strong>POST 方法</strong>：<ul><li>用于向服务器提交数据，通常用于提交表单数据。</li><li>参数在请求体中传递，而不是在 URL 中。因此，POST 请求可以发送大量数据，并且不受 URL 长度限制。</li><li>POST 请求不会被缓存，不会被保存在历史记录中。</li><li>POST 请求在用户交互后可能会显示一个警告对话框，提示用户是否要重新发送数据。</li><li>POST 请求更安全，适合发送敏感信息，因为参数不会显示在 URL 中。</li></ul></li></ol><p><em><strong>总的来说，GET 方法用于获取数据，通常是读取操作；而 POST 方法用于提交数据，通常是写入操作。</strong></em></p><h5 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h5><p><img src="https://s2.loli.net/2024/05/28/Y61zuPms7MSEG2H.png" alt="d3bd60168c43458a85dec80c2253f187"></p><h4 id="HTTP响应报文结构"><a href="#HTTP响应报文结构" class="headerlink" title="HTTP响应报文结构"></a>HTTP响应报文结构</h4><p><img src="https://s2.loli.net/2024/05/28/y8WvP3kSftibTE7.webp" alt="3"></p><hr><h3 id="构造请求报文"><a href="#构造请求报文" class="headerlink" title="构造请求报文"></a>构造请求报文</h3><p>这段代码主要是根据传入的URL和其他参数构建一个HTTP请求字符串，其中包括请求方法、协议版本、主机名、端口号等信息。根据不同的情况，拼接不同的信息到请求字符串中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">build_request</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url)</span><br>&#123;<br>  <span class="hljs-type">char</span> tmp[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 临时存储的字符数组</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// 用于循环计数的变量</span><br><br>  bzero(host,MAXHOSTNAMELEN); <span class="hljs-comment">// 清空host数组</span><br>  bzero(request,REQUEST_SIZE); <span class="hljs-comment">// 清空request数组</span><br><br>  <span class="hljs-keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="hljs-literal">NULL</span> &amp;&amp; http10&lt;<span class="hljs-number">1</span>) http10=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(method==METHOD_HEAD &amp;&amp; http10&lt;<span class="hljs-number">1</span>) http10=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(method==METHOD_OPTIONS &amp;&amp; http10&lt;<span class="hljs-number">2</span>) http10=<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(method==METHOD_TRACE &amp;&amp; http10&lt;<span class="hljs-number">2</span>) http10=<span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">switch</span>(method) <span class="hljs-comment">// 根据请求方法类型选择相应的字符串</span><br>  &#123;<br>  <span class="hljs-keyword">default</span>:<br>  <span class="hljs-keyword">case</span> METHOD_GET: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;GET&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// GET请求</span><br>  <span class="hljs-keyword">case</span> METHOD_HEAD: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;HEAD&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// HEAD请求</span><br>  <span class="hljs-keyword">case</span> METHOD_OPTIONS: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;OPTIONS&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// OPTIONS请求</span><br>  <span class="hljs-keyword">case</span> METHOD_TRACE: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;TRACE&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// TRACE请求</span><br>  &#125;<br>  <br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 在请求字符串后面拼接空格</span><br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==<span class="hljs-built_in">strstr</span>(url,<span class="hljs-string">&quot;://&quot;</span>)) <span class="hljs-comment">// 检查URL是否包含&quot;://&quot;</span><br>  &#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n%s: is not a valid URL.\n&quot;</span>,url); <span class="hljs-comment">// 输出错误信息</span><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(url)&gt;<span class="hljs-number">1500</span>) <span class="hljs-comment">// 检查URL长度是否超过1500</span><br>  &#123;<br>         <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;URL is too long.\n&quot;</span>); <span class="hljs-comment">// 输出错误信息</span><br> <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(proxyhost==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 如果没有设置代理</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>!=strncasecmp(<span class="hljs-string">&quot;http://&quot;</span>,url,<span class="hljs-number">7</span>)) <span class="hljs-comment">// 如果URL不以&quot;http://&quot;开头</span><br>   &#123; <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;\nOnly HTTP protocol is directly supported, set --proxy for others.\n&quot;</span>); <span class="hljs-comment">// 输出错误信息</span><br>             <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>           &#125;<br>  <span class="hljs-comment">/* protocol/host delimiter */</span><br>  i=<span class="hljs-built_in">strstr</span>(url,<span class="hljs-string">&quot;://&quot;</span>)-url+<span class="hljs-number">3</span>; <span class="hljs-comment">// 获取协议和主机名的分隔位置</span><br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strchr</span>(url+i,<span class="hljs-string">&#x27;/&#x27;</span>)==<span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 检查URL是否包含&#x27;/&#x27;</span><br>                                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;\nInvalid URL syntax - hostname don&#x27;t ends with &#x27;/&#x27;.\n&quot;</span>); <span class="hljs-comment">// 输出错误信息</span><br>                                <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>                              &#125;<br>  <span class="hljs-keyword">if</span>(proxyhost==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 如果没有设置代理</span><br>  &#123;<br>   <span class="hljs-comment">/* get port from hostname */</span><br>   <span class="hljs-keyword">if</span>(index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)!=<span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-comment">// 如果URL包含端口号</span><br>      index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)&lt;index(url+i,<span class="hljs-string">&#x27;/&#x27;</span>))<br>   &#123;<br>   <span class="hljs-built_in">strncpy</span>(host,url+i,<span class="hljs-built_in">strchr</span>(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)-url-i); <span class="hljs-comment">// 获取主机名</span><br>   bzero(tmp,<span class="hljs-number">10</span>); <span class="hljs-comment">// 清空临时数组</span><br>   <span class="hljs-built_in">strncpy</span>(tmp,index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)+<span class="hljs-number">1</span>,<span class="hljs-built_in">strchr</span>(url+i,<span class="hljs-string">&#x27;/&#x27;</span>)-index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)<span class="hljs-number">-1</span>); <span class="hljs-comment">// 获取端口号</span><br>   proxyport=atoi(tmp); <span class="hljs-comment">// 将端口号转换为整数</span><br>   <span class="hljs-keyword">if</span>(proxyport==<span class="hljs-number">0</span>) proxyport=<span class="hljs-number">80</span>; <span class="hljs-comment">// 如果端口号为0，默认设为80</span><br>   &#125; <span class="hljs-keyword">else</span><br>   &#123;<br>     <span class="hljs-built_in">strncpy</span>(host,url+i,<span class="hljs-built_in">strcspn</span>(url+i,<span class="hljs-string">&quot;/&quot;</span>)); <span class="hljs-comment">// 获取主机名</span><br>   &#125;<br>   <span class="hljs-built_in">strcat</span>(request+<span class="hljs-built_in">strlen</span>(request),url+i+<span class="hljs-built_in">strcspn</span>(url+i,<span class="hljs-string">&quot;/&quot;</span>)); <span class="hljs-comment">// 拼接请求字符串</span><br>  &#125; <span class="hljs-keyword">else</span><br>  &#123;<br>   <span class="hljs-built_in">strcat</span>(request,url); <span class="hljs-comment">// 如果设置了代理，直接将URL拼接到请求字符串中</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(http10==<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot; HTTP/1.0&quot;</span>); <span class="hljs-comment">// 如果是HTTP/1.0版本，拼接到请求字符串中</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (http10==<span class="hljs-number">2</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot; HTTP/1.1&quot;</span>); <span class="hljs-comment">// 如果是HTTP/1.1版本，拼接到请求字符串中</span><br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 拼接回车换行符</span><br>  <span class="hljs-keyword">if</span>(http10&gt;<span class="hljs-number">0</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;User-Agent: WebBench &quot;</span>PROGRAM_VERSION<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 拼接用户代理信息</span><br>  <span class="hljs-keyword">if</span>(proxyhost==<span class="hljs-literal">NULL</span> &amp;&amp; http10&gt;<span class="hljs-number">0</span>)<br>  &#123;<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;Host: &quot;</span>); <span class="hljs-comment">// 拼接主机名</span><br>  <span class="hljs-built_in">strcat</span>(request,host);<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="hljs-literal">NULL</span>)<br>  &#123;<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;Pragma: no-cache\r\n&quot;</span>); <span class="hljs-comment">// 拼接Pragma信息</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(http10&gt;<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;Connection: close\r\n&quot;</span>); <span class="hljs-comment">// 如果是HTTP/1.1，拼接Connection信息</span><br>  <span class="hljs-comment">/* add empty line at end */</span><br>  <span class="hljs-keyword">if</span>(http10&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;\r\n&quot;</span>);  <span class="hljs-comment">// 拼接最后的空行</span><br>  <span class="hljs-comment">// printf(&quot;Req=%s\n&quot;,request); // 打印请求字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="进程通信基础知识"><a href="#进程通信基础知识" class="headerlink" title="进程通信基础知识"></a>进程通信基础知识</h3><blockquote><p>这一部分其实需要了解一定的操作系统知识，这里只是简单的阐述一些webbench源码中的关键点。</p><p>具体参考：</p><p>[进程的基本属性|父子进程关系](<a href="https://developer.aliyun.com/article/1363183">【Linux】进程的基本属性|父子进程关系-阿里云开发者社区 (aliyun.com)</a>)</p><p><a href="%5B%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E4%BB%A5fork()%E4%B8%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Ffork-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/Bossfrank/article/details/136706625)">以fork()为例详解进程的创建过程与父子进程关系</a></p><p><a href="https://blog.csdn.net/JMW1407/article/details/107700451#:~:text=1%E3%80%81%E5%AE%9A%E4%B9%89%EF%BC%88%E6%B0%B4%E7%AE%A1%EF%BC%88pipe%EF%BC%89%EF%BC%89%201%20%E7%AE%A1%E9%81%93%E6%98%AF%E4%B8%80%E7%A7%8D%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E3%80%82%20%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A7%B0%E4%B8%BA%E4%B8%80%E4%B8%AA%E2%80%9C%E7%AE%A1%E9%81%93%E2%80%9D%EF%BC%8C%E9%80%9A%E5%B8%B8%E6%98%AF%E7%94%A8%E4%BD%9C,%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BE%93%E5%87%BA%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BE%93%E5%85%A5%20%E3%80%82%202%20%E7%AE%A1%E9%81%93%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E5%86%85%E6%A0%B8%E7%9A%84%E4%B8%80%E5%9D%97%E7%BC%93%E5%AD%98%20%EF%BC%8C%E5%86%85%E6%A0%B8%E7%BB%B4%E6%8A%A4%E4%BA%86%E4%B8%80%E5%9D%97%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%AE%A1%E9%81%93%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%81%94%EF%BC%8C%E5%AF%B9%E7%AE%A1%E9%81%93%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%A2%AB%E5%86%85%E6%A0%B8%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%BF%99%E5%9D%97%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82">管道通信</a></p></blockquote><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><p>在 Unix 和 Linux中，每个进程都有一个唯一的进程标识符（PID），以及一个父进程标识符（PPID），这两个值使得子进程能够知道它们的父进程是什么。</p><ol><li><strong>PID（Process ID）</strong>：这是操作系统分配给每个进程的唯一标识符。每个进程都有一个唯一的 PID。</li><li><strong>PPID（Parent Process ID）</strong>：这是进程的父进程的 PID。PPID 指示了哪个进程创建了当前进程。</li></ol><p>当进程 A 调用 <code>fork()</code> 时，会创建一个子进程 B。对于子进程 B，它的 PPID 会被设置为进程 A 的 PID。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Process</span> A: PID = <span class="hljs-number">12345</span><br>Parent process: PID = <span class="hljs-number">12345</span>, Child PID = <span class="hljs-number">12346</span><br>Child process: PID = <span class="hljs-number">12346</span>, PPID = <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p><strong>同时父进程会获得一个非零的PID（子进程的PID），而子进程会获得0作为返回值。这使得我们可以通过检查返回值的大小来区分父子进程</strong></p><p><strong>注意这里的返回0并不是将子进程PID设为0</strong>，而是出于以下方面考虑：</p><ul><li><p><strong>区分父进程和子进程的执行流</strong></p><p>当调用 <code>fork()</code> 时，会创建一个新的子进程。<code>fork()</code> 在父进程中返回子进程的 PID，而在子进程中返回 0。这种设计让同一段代码能够在两个不同的进程中执行不同的逻辑。</p></li><li><p><strong>简化错误处理</strong></p><p>如果 <code>fork()</code> 返回一个负值（通常是 -1），这表明进程创建失败。父进程可以立即检查这个返回值并进行相应的错误处理。</p></li><li><p><strong>方便进程间通信和同步</strong></p><p>由于 <code>fork()</code> 在子进程中返回 0，父进程可以使用返回的子进程 PID 来进行进程间的通信和同步操作。例如，父进程可以等待子进程结束，或者通过信号与子进程进行通信。</p></li><li><p><strong>实现多进程并发</strong></p><p><code>fork()</code> 机制使得多进程并发编程变得简单。父进程可以连续调用 <code>fork()</code> 多次，创建多个子进程来处理不同的任务或相同任务的不同部分，从而实现并发处理。</p></li></ul><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="https://s2.loli.net/2024/05/29/lKU72cAyIfePCkz.png" alt="ef5085c798d54fc081611d0d488dfeb1"></p><blockquote><p><strong>信号</strong>：信号是 Linux 进程间通信的一种简单机制。它是由操作系统或进程向另一个进程发送的软件中断，用于通知进程发生了某种事件。</p><p><strong>信号处理程序</strong>：每个信号都与一个信号处理程序相关联，用于在收到信号时执行特定的操作。信号处理程序可以是预定义的函数，也可以是用户自定义的函数。</p><p><strong>信号的发送和接收</strong>：信号可以由内核、其他进程或进程自身发送。接收信号的进程可以选择忽略信号、执行默认操作或安装自定义的信号处理程序。</p><p><strong>常见的信号</strong>：Linux 系统定义了许多标准信号，如 SIGALRM（定时器到期）、SIGINT（终端中断）、SIGKILL（强制终止进程）等。</p><p><strong>信号的处理方式</strong>：每个进程都有一个信号处理表，记录了每个信号的处理方式。可以通过 <code>sigaction()</code> 函数来修改信号处理方式。</p><p><strong>信号的异步性</strong>：信号是异步事件，即进程可能在任何时刻接收到信号，而不一定是在某个特定的程序点。因此，编写信号处理程序时需要注意处理信号的竞态条件和可重入性。</p></blockquote><h5 id="使用Linux信号机制具体步骤："><a href="#使用Linux信号机制具体步骤：" class="headerlink" title="使用Linux信号机制具体步骤："></a>使用Linux信号机制具体步骤：</h5><ol><li><strong>定义信号处理程序</strong>：编写一个函数来处理特定的信号。</li><li><strong>注册信号处理程序</strong>：使用 <code>signal()</code> 或 <code>sigaction()</code> 函数将信号处理程序与特定的信号关联起来。</li><li><strong>触发信号</strong>：通过特定的操作或系统调用触发信号，或使用 <code>kill()</code> 函数向自己或其他进程发送信号。</li></ol><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 定义信号处理程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGINT) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGINT (Ctrl+C). Exiting gracefully...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sig == SIGALRM) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGALRM. Performing scheduled task...\n&quot;</span>);<br>        <span class="hljs-comment">// 在这里执行你需要的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注册信号处理程序</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    sa.sa_handler = signal_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    sigemptyset(&amp;sa.sa_mask);<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGINT handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGALRM handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个定时器，5秒后发送 SIGALRM 信号</span><br>    alarm(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 无限循环，等待信号</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for signals...\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h4><p>Linux的管道机制允许一个进程的输出直接作为另一个进程的输入，从而实现进程间的通信（IPC）。管道有两种：无名管道和命名管道（FIFO）。无名管道通常用于具有亲缘关系的进程之间的通信（如父子进程），而命名管道可以用于任意两个进程之间的通信。</p><h5 id="管道的工作原理"><a href="#管道的工作原理" class="headerlink" title="管道的工作原理"></a>管道的工作原理</h5><p>管道在内核中创建一个缓冲区，一个进程可以向缓冲区写入数据，另一个进程可以从缓冲区读取数据。管道是单向的，即数据只能单方向流动。</p><p><img src="https://s2.loli.net/2024/05/29/WOejUv2nhb1Rqox.png" alt="20200730212919317"></p><h5 id="管道通信与共享内存通信有何区别？"><a href="#管道通信与共享内存通信有何区别？" class="headerlink" title="管道通信与共享内存通信有何区别？"></a>管道通信与共享内存通信有何区别？</h5><p>管道通信适用于有亲缘关系的进程，适合简单的数据传输；而共享内存通信适用于无亲缘关系的进程，适合大量数据共享和对性能要求较高的场景</p><h5 id="管道通信："><a href="#管道通信：" class="headerlink" title="管道通信："></a><strong>管道通信：</strong></h5><ol><li><ul><li>管道是一种半双工的通信机制，只能在具有亲缘关系的进程之间使用（例如父子进程）。</li><li>管道是基于 I&#x2F;O 流的通信方式，数据写入管道的一端，从另一端读出。</li><li>管道通信是通过操作系统提供的管道文件进行的，可以是匿名管道（只存在于进程间）或命名管道（存在于文件系统中）。</li><li>管道通信适用于需要在两个相关进程之间进行简单数据传输的场景。</li></ul></li><li><strong>共享内存通信：</strong><ul><li>共享内存是一种进程间通信的机制，可以在无亲缘关系的进程之间使用。</li><li>共享内存允许多个进程访问同一块物理内存空间，因此可以实现高效的数据共享。</li><li>共享内存通信需要使用操作系统提供的共享内存 API，通过映射共享内存区域来实现进程间数据共享。</li><li>共享内存通信适用于需要大量数据交换且对性能要求较高的场景，因为它避免了数据复制的开销。</li></ul></li></ol><h5 id="使用管道的步骤"><a href="#使用管道的步骤" class="headerlink" title="使用管道的步骤"></a>使用管道的步骤</h5><ol><li><strong>创建管道</strong>：使用 <code>pipe()</code> 系统调用创建一个无名管道。</li><li><strong>创建子进程</strong>：使用 <code>fork()</code> 创建子进程。</li><li><strong>重定向输入&#x2F;输出</strong>：使用 <code>dup2()</code> 将管道的读或写端重定向到标准输入或标准输出。</li><li><strong>关闭不需要的管道端</strong>：父进程和子进程都要关闭各自不需要使用的管道端。</li><li><strong>执行程序</strong>：使用 <code>execlp()</code> 或其他 <code>exec</code> 函数执行新程序。</li></ol><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello from parent process!&quot;</span>;<br><br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">if</span> (pipe(pipe_fd) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br><br>        <span class="hljs-comment">// 读取管道</span><br>        <span class="hljs-type">ssize_t</span> nbytes = read(pipe_fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// 打印读取到的消息</span><br>        buf[nbytes] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child received message: %s\n&quot;</span>, buf);<br><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br><br>        <span class="hljs-comment">// 写入管道</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[<span class="hljs-number">1</span>], msg, <span class="hljs-built_in">strlen</span>(msg)) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        wait(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>pipe()</code> 创建一个无名管道，<code>pipe_fd</code> 是一个包含两个文件描述符的数组，<code>pipe_fd[0]</code> 是读端，<code>pipe_fd[1]</code> 是写端。</p><p>在这个示例中没有使用 <code>dup2()</code> 重定向输入&#x2F;输出，而是直接使用文件描述符进行读写。你也可以通过 <code>dup2(pipe_fd[0], STDIN_FILENO)</code> 或 <code>dup2(pipe_fd[1], STDOUT_FILENO)</code> 来重定向标准输入&#x2F;输出。</p><p><strong>注意:当父进程fork()出子进程时，子进程会继承父进程的文件描述符。因此，子进程可以直接使用这些继承而来的文件描述符来读取或写入数据，从而与父进程进行通信。而无需使用<code>dup2()</code>来重定向输入&#x2F;输出。</strong></p><p>将管道的读端重定向到标准输入或将管道的写端重定向到标准输出是实现进程间通信的一种常见方式。这种方法可以实现多个进程之间的数据传输，而无需使用临时文件进行交换。</p><p>例如，如果一个进程需要从另一个进程中读取数据，可以通过将管道的读端重定向到标准输入来实现。这样，另一个进程输出的数据就会被发送到管道中，而第一个进程可以通过标准输入读取这些数据。</p><p>这种方法的好处在于，它提供了一种简单而高效的方式让不同的进程之间进行数据交换，而不需要创建临时文件或者复杂的通信协议。这对于实现诸如管道、重定向、过滤器等功能非常有用，同时也能够方便地实现进程间的通信和协作。</p><hr><h3 id="网络压力测试函数"><a href="#网络压力测试函数" class="headerlink" title="网络压力测试函数"></a>网络压力测试函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">benchcore</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *req)</span><br>&#123;<br>    <span class="hljs-type">int</span> rlen;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1500</span>];<br>    <span class="hljs-type">int</span> s, i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br><br>    <span class="hljs-comment">/* 设置闹钟信号处理器 */</span><br>    sa.sa_handler = alarm_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br>    alarm(benchtime);<br><br>    rlen = <span class="hljs-built_in">strlen</span>(req);  <span class="hljs-comment">// 计算请求字符串的长度</span><br>nexttry:<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (timerexpired)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (failed &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">/* 通过信号纠正失败次数 */</span><br>                failed--;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 建立与主机的连接</span><br>        s = Socket(host, port);<br>        <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 发送请求到服务器</span><br>        <span class="hljs-keyword">if</span> (rlen != write(s, req, rlen))<br>        &#123;<br>            failed++;<br>            close(s);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果使用 HTTP/1.0，关闭写入端</span><br>        <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (shutdown(s, <span class="hljs-number">1</span>))<br>            &#123;<br>                failed++;<br>                close(s);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不强制关闭连接，读取服务器的响应数据</span><br>        <span class="hljs-keyword">if</span> (force == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 从套接字中读取所有可用的数据 */</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (timerexpired)<br>                    <span class="hljs-keyword">break</span>;<br><br>                i = read(s, buf, <span class="hljs-number">1500</span>);<br><br>                <span class="hljs-comment">/* 检查读取结果 */</span><br>                <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    failed++;<br>                    close(s);<br>                    <span class="hljs-keyword">goto</span> nexttry;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    bytes += i;  <span class="hljs-comment">// 记录读取的字节数</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭套接字连接</span><br>        <span class="hljs-keyword">if</span> (close(s))<br>        &#123;<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        speed++;  <span class="hljs-comment">// 成功请求次数计数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>benchcore</code> 函数的主要作用是对指定的主机和端口发送 HTTP 请求，并记录响应数据以进行性能测试。这是一个典型的网络压力测试函数。具体步骤如下：</p><ol><li><strong>设置信号处理器</strong>：<ul><li>使用 <code>sigaction</code> 设置闹钟信号处理器 <code>alarm_handler</code>，并启动定时器 <code>alarm(benchtime)</code> 来控制测试时间。</li></ul></li><li><strong>循环发送请求并处理响应</strong>：<ul><li>在 <code>while</code> 循环中不断向服务器发送请求，直到定时器到期 (<code>timerexpired</code> 为 <code>true</code>)。</li><li>调用 <code>Socket</code> 函数建立与服务器的连接，若连接失败，增加 <code>failed</code> 计数并继续下一次尝试。</li><li>使用 <code>write</code> 将请求发送到服务器，如果写入失败，增加 <code>failed</code> 计数并关闭套接字，继续下一次尝试。</li><li>如果使用 HTTP&#x2F;1.0 协议，通过 <code>shutdown</code> 关闭写入端。</li><li>如果 <code>force</code> 为 <code>0</code>，则读取服务器的响应数据并累计读取的字节数 <code>bytes</code>。</li><li>关闭套接字连接，若关闭失败，增加 <code>failed</code> 计数并继续下一次尝试。</li><li>每次成功处理一个请求后，增加 <code>speed</code> 计数。</li></ul></li></ol><p>通过这个函数，可以对服务器进行压力测试，统计在指定时间内成功处理的请求数 (<code>speed</code>) 和失败的请求数 (<code>failed</code>)，以及累计读取的字节数 (<code>bytes</code>)。</p><hr><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p><code>bench</code> 函数的主要作用是执行基准测试，通过创建子进程并分发任务来模拟多个客户端对服务器的并发请求，并统计测试结果。具体步骤如下：</p><ol><li><strong>检查目标服务器的可用性</strong>：<ul><li>调用 <code>Socket</code> 函数尝试连接目标服务器，若连接失败则终止基准测试。</li></ul></li><li><strong>创建管道</strong>：<ul><li>使用 <code>pipe</code> 函数创建一个管道，用于子进程和父进程之间的通信。</li></ul></li><li><strong>分叉子进程</strong>：<ul><li>使用 <code>fork</code> 函数创建指定数量的子进程，并在子进程中执行任务。</li></ul></li><li><strong>子进程执行任务</strong>：<ul><li>每个子进程调用 <code>benchcore</code> 函数执行基准测试任务，并将结果写入管道。</li></ul></li><li><strong>父进程读取子进程的结果</strong>：<ul><li>父进程从管道中读取各个子进程执行任务的结果，并统计总体性能指标。</li></ul></li><li><strong>输出测试结果</strong>：<ul><li>输出基准测试的结果，包括请求速度、传输速率以及成功和失败的请求数量。</li></ul></li></ol><p>通过这个函数，可以模拟多个并发用户对服务器进行压力测试，并获取测试结果以评估服务器的性能表现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bench</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">pid_t</span> pid = <span class="hljs-number">0</span>;<br>    FILE *f;<br><br>    <span class="hljs-comment">/* 检查目标服务器的可用性 */</span><br>    i = Socket(proxyhost == <span class="hljs-literal">NULL</span> ? host : proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n连接服务器失败。终止基准测试。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    close(i);<br><br>    <span class="hljs-comment">/* 创建管道 */</span><br>    <span class="hljs-keyword">if</span> (pipe(mypipe))<br>    &#123;<br>        perror(<span class="hljs-string">&quot;pipe failed.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 分叉子进程 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; clients; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt;= (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 子进程或出错 */</span><br>            sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">/* 使子进程更快 */</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;forking worker no. %d 出现问题\n&quot;</span>, i);<br>        perror(<span class="hljs-string">&quot;fork failed.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 我是一个子进程 */</span><br>        <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span>)<br>            benchcore(host, proxyport, request);<br>        <span class="hljs-keyword">else</span><br>            benchcore(proxyhost, proxyport, request);<br><br>        <span class="hljs-comment">/* 将结果写入管道 */</span><br>        f = fdopen(mypipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;w&quot;</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;打开管道写入失败。&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-comment">/* fprintf(stderr,&quot;Child - %d %d\n&quot;,speed,failed); */</span><br>        <span class="hljs-built_in">fprintf</span>(f, <span class="hljs-string">&quot;%d %d %d\n&quot;</span>, speed, failed, bytes);<br>        fclose(f);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        f = fdopen(mypipe[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;打开管道读取失败。&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br>        setvbuf(f, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br>        speed = <span class="hljs-number">0</span>;<br>        failed = <span class="hljs-number">0</span>;<br>        bytes = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            pid = <span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;i, &amp;j, &amp;k);<br>            <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们的一些子进程已经退出。\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            speed += i;<br>            failed += j;<br>            bytes += k;<br>            <span class="hljs-comment">/* fprintf(stderr,&quot;*Knock* %d %d read=%d\n&quot;,speed,failed,pid); */</span><br>            <span class="hljs-keyword">if</span> (--clients == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        fclose(f);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n速度=%d 页面/分钟，%d 字节/秒。\n请求数: %d 成功，%d 失败。\n&quot;</span>,<br>               (<span class="hljs-type">int</span>)((speed + failed) / (benchtime / <span class="hljs-number">60.0f</span>)),<br>               (<span class="hljs-type">int</span>)(bytes / (<span class="hljs-type">float</span>)benchtime),<br>               speed,<br>               failed);<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p><code>main</code> 函数是 Webbench 工具的主要入口点，负责解析命令行参数、构建 HTTP 请求、执行基准测试，并输出测试结果。具体步骤如下：</p><ol><li><strong>解析命令行参数</strong>：<ul><li>使用 <code>getopt_long</code> 函数解析命令行参数，支持短选项（如 <code>-f</code>, <code>-r</code>, <code>-t</code>）和长选项（如 <code>--help</code>, <code>--version</code>）。</li><li>根据解析结果设置相应的全局变量，如 <code>force</code>、<code>force_reload</code>、<code>benchtime</code> 等。</li></ul></li><li><strong>构建 HTTP 请求</strong>：<ul><li>调用 <code>build_request</code> 函数根据用户提供的 URL 构建相应的 HTTP 请求，包括请求方法、协议版本等信息。</li></ul></li><li><strong>执行基准测试</strong>：<ul><li>调用 <code>bench</code> 函数执行基准测试，该函数会模拟多个并发客户端向目标服务器发起请求</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> options_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> *tmp = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果没有提供任何参数，则显示用法信息并返回</span><br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>)<br>    &#123;<br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 解析命令行参数</span><br>    <span class="hljs-keyword">while</span> ((opt = getopt_long(argc, argv, <span class="hljs-string">&quot;912Vfrt:p:c:?h&quot;</span>, long_options, &amp;options_index)) != EOF)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (opt)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>            force = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>            force_reload = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:<br>            http10 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>            http10 = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>            http10 = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(PROGRAM_VERSION <span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            benchtime = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:<br>            <span class="hljs-comment">/* 代理服务器解析 server:port */</span><br>            tmp = <span class="hljs-built_in">strrchr</span>(optarg, <span class="hljs-string">&#x27;:&#x27;</span>);<br>            proxyhost = optarg;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp == optarg)<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;错误的选项 --proxy %s: 缺少主机名。\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp == optarg + <span class="hljs-built_in">strlen</span>(optarg) - <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;错误的选项 --proxy %s: 缺少端口号。\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>            *tmp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            proxyport = atoi(tmp + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>            usage();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>            clients = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有提供 URL，则显示错误信息并返回</span><br>    <span class="hljs-keyword">if</span> (optind == argc)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;webbench: 缺少 URL！\n&quot;</span>);<br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置默认客户端数量和测试时长</span><br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">0</span>)<br>        clients = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (benchtime == <span class="hljs-number">0</span>)<br>        benchtime = <span class="hljs-number">60</span>;<br><br>    <span class="hljs-comment">// 版权声明</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Webbench - 简单的 Web 基准测试 &quot;</span> PROGRAM_VERSION <span class="hljs-string">&quot;\n&quot;</span><br>                    <span class="hljs-string">&quot;版权所有 (C) Radim Kolar 1997-2004, GPL 开源软件。\n&quot;</span>);<br><br>    <span class="hljs-comment">// 构建 HTTP 请求</span><br>    build_request(argv[optind]);<br><br>    <span class="hljs-comment">// 打印基准测试信息</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n正在进行基准测试: &quot;</span>);<br>    <span class="hljs-keyword">switch</span> (method)<br>    &#123;<br>    <span class="hljs-keyword">case</span> METHOD_GET:<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GET&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_OPTIONS:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_HEAD:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HEAD&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_TRACE:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;TRACE&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s&quot;</span>, argv[optind]);<br>    <span class="hljs-keyword">switch</span> (http10)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; (使用 HTTP/0.9)&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; (使用 HTTP/1.1)&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 个客户端&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 个客户端&quot;</span>, clients);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 运行 %d 秒&quot;</span>, benchtime);<br>    <span class="hljs-keyword">if</span> (force)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 提前关闭套接字&quot;</span>);<br>    <span class="hljs-keyword">if</span> (proxyhost != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 通过代理服务器 %s:%d&quot;</span>, proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (force_reload)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 强制重新加载&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.\n&quot;</span>);<br><br>    <span class="hljs-comment">// 执行基准测试</span><br>    <span class="hljs-keyword">return</span> bench();<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>完！</strong></em></p><hr>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx时间管理与定时器</title>
    <link href="/2023/03/07/Nginx%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/03/07/Nginx%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx数据结构"><a href="#nginx数据结构" class="headerlink" title="nginx数据结构"></a>nginx数据结构</h1><p><img src="https://s2.loli.net/2024/05/25/qrI7kPjaR5mlwKu.png" alt="20210709173511720"></p><h3 id="整型数据类型ngx-int-t"><a href="#整型数据类型ngx-int-t" class="headerlink" title="整型数据类型ngx_int_t"></a>整型数据类型ngx_int_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">intptr_t</span>        <span class="hljs-type">ngx_int_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uintptr_t</span>       <span class="hljs-type">ngx_uint_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">intptr_t</span>        <span class="hljs-type">ngx_flag_t</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>intptr_t</code> 和 <code>uintptr_t</code> 是标准库 <code>stdint.h</code> 中定义的整数类型，它们用于存储指针值。它们的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span>   <span class="hljs-type">intptr_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">uintptr_t</span>;<br></code></pre></td></tr></table></figure><ol><li><ul><li>**<code>intptr_t</code>**：这是一个有符号整数类型，能够存储一个指针。它的大小与指针相同，可以安全地存储和操作指针值。</li><li>**<code>uintptr_t</code>**：这是一个无符号整数类型，能够存储一个指针。与 <code>intptr_t</code> 类似，它的大小也与指针相同。</li></ul></li></ol><h4 id="基础巩固"><a href="#基础巩固" class="headerlink" title="基础巩固"></a><strong>基础巩固</strong></h4><p><strong>什么是有符号整数类型和无符号整数类型？</strong></p><blockquote><h4 id="有符号整数类型"><a href="#有符号整数类型" class="headerlink" title="有符号整数类型"></a>有符号整数类型</h4><p>有符号整数类型（Signed Integer Type）是可以表示正数、负数和零的整数类型。它的最高位通常用作符号位（0 表示正，1 表示负）。在 C 语言中，常见的有符号整数类型包括 <code>int</code>、<code>short</code>、<code>long</code> 等。</p><p>例如，在一个 8 位（1 字节）的有符号整数中：</p><ul><li>最高位是符号位。</li><li>值范围是从 -128 到 127。</li></ul><p>二进制表示：</p><ul><li><code>01111111</code> (127)</li><li><code>10000000</code> (-128)</li></ul><h4 id="无符号整数类型"><a href="#无符号整数类型" class="headerlink" title="无符号整数类型"></a>无符号整数类型</h4><p>无符号整数类型（Unsigned Integer Type）只能表示非负整数（正数和零）。所有位都用于表示数值，因此可以表示更大的正数范围。常见的无符号整数类型包括 <code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code> 等。</p><p>例如，在一个 8 位（1 字节）的无符号整数中：</p><ul><li>没有符号位，所有位都用于表示数值。</li><li>值范围是从 0 到 255。</li></ul><p>二进制表示：</p><ul><li><code>00000000</code> (0)</li><li><code>11111111</code> (255)</li></ul></blockquote><p><strong>为什么是<code>intptr_t</code>和uintptr_t 而不是  int ？</strong></p><p>对于 C 语言的实现，<code>intptr_t</code> 和 <code>uintptr_t</code> 是定义为与平台的指针大小相同的有符号和无符号整数类型。这意味着在 32 位平台上，它们通常是 32 位整数，而在 64 位平台上，它们通常是 64 位整数。</p><p>这种类型的定义是为了确保在不同平台上具有相同的大小，从而使得代码在不同平台上具有可移植性</p><p><strong>整数类型与指针的关系？</strong></p><blockquote><ul><li><strong>指针类型</strong>：指针类型用于存储内存地址，表示变量或数据在内存中的位置。指针的大小取决于系统架构（例如，32 位系统上的指针为 4 字节，64 位系统上的指针为 8 字节）。</li><li><strong>整数类型与指针</strong>：在某些情况下，可以使用整数类型来存储或操作指针值。例如，<code>intptr_t</code> 和 <code>uintptr_t</code> 是标准库中定义的类型，用于存储可以容纳指针值的有符号和无符号整数。这在需要将指针转化为整数或将整数转化为指针的操作中很有用。</li></ul></blockquote><p><strong>整数类型在不同的系统架构（如 32 位和 64 位）有何区别？</strong></p><blockquote><h4 id="32-位系统"><a href="#32-位系统" class="headerlink" title="32 位系统"></a>32 位系统</h4><ul><li><strong>整数类型</strong>：典型地，<code>int</code> 为 4 字节，<code>long</code> 为 4 字节，<code>pointer</code> 为 4 字节。</li><li><strong>指针类型</strong>：指针占用 4 字节，能够表示的地址范围是 0 到 2^32 - 1（4 GB）。</li></ul><h4 id="64-位系统"><a href="#64-位系统" class="headerlink" title="64 位系统"></a>64 位系统</h4><ul><li><strong>整数类型</strong>：<code>int</code> 仍然通常为 4 字节，<code>long</code> 和 <code>pointer</code> 为 8 字节。</li><li><strong>指针类型</strong>：指针占用 8 字节，能够表示的地址范围是 0 到 2^64 - 1（16 EB）。</li></ul></blockquote><h3 id="字符串数据类型ngx-str-t"><a href="#字符串数据类型ngx-str-t" class="headerlink" title="字符串数据类型ngx_str_t"></a>字符串数据类型ngx_str_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">size_t</span>      len;    <span class="hljs-comment">/* 字符串的长度 */</span><br>    u_char     *data;   <span class="hljs-comment">/* 指向字符串的第一个字符 */</span><br>&#125; <span class="hljs-type">ngx_str_t</span>;<br></code></pre></td></tr></table></figure><h4 id="结构体成员"><a href="#结构体成员" class="headerlink" title="结构体成员"></a>结构体成员</h4><ul><li><strong><code>size_t len</code></strong>: 这是一个无符号整数类型，用于存储字符串的长度。<code>size_t</code> 类型通常用于表示对象的大小或数组的长度，它的大小依赖于具体的系统架构（在32位系统上通常是4字节，在64位系统上通常是8字节）。</li><li><strong><code>u_char *data</code></strong>: 这是一个指向字符串第一个字符的指针。<code>u_char</code> 通常是 <code>unsigned char</code> 的别名，表示无符号字符类型。这种类型保证了字符的值在 0 到 255 之间。</li></ul><h4 id="设计优点"><a href="#设计优点" class="headerlink" title="设计优点"></a>设计优点</h4><p><strong>为什么这里要附加一个字符串长度【len】相比较于传统string的优点？</strong></p><p>其实这种字符串处理方式在高性能场景下非常有用，尤其是在需要频繁处理字符串的网络服务器中，例如，再看redis的字符串设计：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-comment">//被使用的长度</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-comment">//除去头跟空终止符分配的空间</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-comment">//标识字符，3位用于类型，5位未使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-comment">//使用存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>它不依赖于以 <code>&#39;\0&#39;</code> 结尾来标识字符串的结束，而是明确地记录了字符串的长度。这种设计有几个优势：</p><ol><li><strong>性能优化</strong>：操作字符串时不需要遍历整个字符串寻找 <code>&#39;\0&#39;</code>，可以直接通过长度进行操作。</li><li><strong>支持二进制数据</strong>：能够处理包含 <code>&#39;\0&#39;</code> 字节的字符串或二进制数据，因为长度是显式存储的。</li><li><strong>更好的安全性</strong>：避免了因缺少字符串结束符导致的缓冲区溢出等安全问题。</li></ol><h5 id="基础巩固-1"><a href="#基础巩固-1" class="headerlink" title="基础巩固"></a>基础巩固</h5><p><strong>是否熟悉以下数据类型？</strong></p><blockquote><p><strong><code>size_t</code></strong> 是一种无符号整数类型，用于表示对象的大小或数组的长度。它的具体大小取决于系统架构，在 32 位系统上通常是 4 字节，在 64 位系统上通常是 8 字节。</p><p>**<code>unsigned int</code>**：无符号整型，在大多数平台上为 4 字节。</p><p>**<code>unsigned long</code>**：无符号长整型，在 32 位系统上通常为 4 字节，在 64 位系统上通常为 8 字节。</p><p><strong><code>u_char</code></strong> 通常是 <code>unsigned char</code> 的别名，用于表示无符号字符类型。它可以存储 0 到 255 之间的整数。大多数情况下，<code>uint8_t</code> 和 <code>unsigned char</code> 可以互换使用。</p><p><strong><code>uint8_t</code></strong> 是一种标准整数类型，主要优势在于它的跨平台一致性。无论是在 32 位系统还是 64 位系统上，<code>uint8_t</code> 总是表示 8 位无符号整数</p><p>**<code>uint16_t</code>**：表示 16 位无符号整数，取值范围为 0 到 65535。它保证在所有平台上都是 16 位，因此非常适合用于需要明确双字节大小的场合，如某些文件格式和协议字段等。</p><p>**<code>unsigned short</code>**：在许多平台上，<code>unsigned short</code> 通常是 16 位无符号整数，取值范围也是 0 到 65535。</p><p>**<code>uint_least16_t</code>**：确保至少有 16 位的无符号整数类型。</p><p>**<code>uint_fast16_t</code>**：确保至少有 16 位且运算速度最快的无符号整数类型。</p></blockquote><h3 id="内存池数据类型ngx-pool-s"><a href="#内存池数据类型ngx-pool-s" class="headerlink" title="内存池数据类型ngx_pool_s"></a>内存池数据类型ngx_pool_s</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 分配内存空间的大小</span><br><span class="hljs-comment">// 分配内存空间</span><br>ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>.......<br><span class="hljs-built_in">free</span>(ptr);<br></code></pre></td></tr></table></figure><p>当我们使用malloc为程序申请内存时，会无法避免的出现<a href="https://www.cnblogs.com/zhaoyl/p/3820852.html">内存碎片</a>问题。</p><p><img src="https://s2.loli.net/2024/05/25/sk9HIyUFvebqcP8.png" alt="内存碎片"></p><p>这对于长时间运行的系统或者需要高性能的系统是致命的。</p><blockquote><ol><li><strong>内存浪费</strong>: 内存碎片导致一些内存无法被有效利用，即使整体上有足够的可用内存，但无法分配给大块连续的内存请求。这种情况下，系统实际可用内存会减少，造成内存资源的浪费。</li><li><strong>性能下降</strong>: 内存碎片可能导致内存分配效率下降。当请求大块连续内存时，系统需要搜索并合并碎片化的内存块，这可能会增加内存分配的开销和时间。此外，内存碎片也可能导致页面置换算法的性能下降，因为系统需要更频繁地进行页面换入换出操作。</li><li><strong>内存泄漏</strong>: 内存碎片可能导致内存泄漏问题的难以发现和排查。即使系统中存在大量的可用内存，但如果这些内存被分散成了小块碎片，而且这些碎片被长期占用而未被释放，就会导致整体内存资源的浪费和不足。</li><li><strong>系统稳定性降低</strong>: 当内存碎片达到一定程度时，可能会导致系统出现内存耗尽的情况，从而导致系统崩溃或者运行异常。特别是在长时间运行的系统中，内存碎片可能会逐渐积累，最终导致系统的稳定性降低。</li></ol></blockquote><p>解决方案之一就是使用<strong>内存池</strong>，这里推荐大家一个手写<a href="https://zhuanlan.zhihu.com/p/435427939">内存池项目</a> </p><p>简短的来说，内存池通过预先分配一定大小的内存块，并按需分配和释放这些内存块，以减少内存碎片的产生。</p><p>现在再回到Nginx的内存池上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 文件 core/ngx_palloc.h */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_s</span>            <span class="hljs-title">ngx_pool_t</span>;</span><br><span class="hljs-comment">//指向以 void *data 作为参数并且没有返回值的函数的指针。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*ngx_pool_cleanup_pt)</span><span class="hljs-params">(<span class="hljs-type">void</span> *data)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_cleanup_s</span>  <span class="hljs-title">ngx_pool_cleanup_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_cleanup_s</span> &#123;</span><br>    ngx_pool_cleanup_pt   handler;  <span class="hljs-comment">// 清理函数指针，用于在释放内存时执行清理操作</span><br>    <span class="hljs-type">void</span>                 *data;     <span class="hljs-comment">// 清理函数的参数</span><br>    <span class="hljs-type">ngx_pool_cleanup_t</span>   *next;     <span class="hljs-comment">// 指向下一个清理结构体的指针，构成清理链表</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_large_s</span>  <span class="hljs-title">ngx_pool_large_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_large_s</span> &#123;</span><br>    <span class="hljs-type">ngx_pool_large_t</span>     *next;     <span class="hljs-comment">// 指向下一个大块内存结构体的指针，构成大块内存链表</span><br>    <span class="hljs-type">void</span>                 *alloc;    <span class="hljs-comment">// 分配的大块内存的指针</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    u_char               *last;     <span class="hljs-comment">// 当前内存分配的结束位置，下一段可分配内存的起始位置</span><br>    u_char               *end;      <span class="hljs-comment">// 内存池的结束位置</span><br>    <span class="hljs-type">ngx_pool_t</span>           *next;     <span class="hljs-comment">// 指向下一个内存池的指针</span><br>    <span class="hljs-type">ngx_uint_t</span>            failed;   <span class="hljs-comment">// 记录内存池内存分配失败的次数</span><br>&#125; <span class="hljs-type">ngx_pool_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_s</span> &#123;</span><br>    <span class="hljs-type">ngx_pool_data_t</span>       d;        <span class="hljs-comment">// 内存池的数据块，包括可分配内存的起始位置、结束位置和下一个内存池的指针等信息</span><br>    <span class="hljs-type">size_t</span>                max;      <span class="hljs-comment">// 内存池数据块的最大值</span><br>    <span class="hljs-type">ngx_pool_t</span>           *current;  <span class="hljs-comment">// 指向当前内存池的指针</span><br>    <span class="hljs-type">ngx_chain_t</span>          *chain;    <span class="hljs-comment">// 指向一个数据链表的指针</span><br>    <span class="hljs-type">ngx_pool_large_t</span>     *large;    <span class="hljs-comment">// 指向一个大块内存链表的指针</span><br>    <span class="hljs-type">ngx_pool_cleanup_t</span>   *cleanup;  <span class="hljs-comment">// 指向内存池清理结构体的指针，用于执行内存清理操作</span><br>    <span class="hljs-type">ngx_log_t</span>            *<span class="hljs-built_in">log</span>;      <span class="hljs-comment">// 内存分配相关的日志信息</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_fd_t</span>              fd;       <span class="hljs-comment">// 文件描述符</span><br>    u_char               *name;     <span class="hljs-comment">// 文件名</span><br>    <span class="hljs-type">ngx_log_t</span>            *<span class="hljs-built_in">log</span>;      <span class="hljs-comment">// 内存分配相关的日志信息</span><br>&#125; <span class="hljs-type">ngx_pool_cleanup_file_t</span>;<br><br></code></pre></td></tr></table></figure><p>内存池各组件结构之间的关系：</p><p><img src="https://s2.loli.net/2024/05/25/wdyTRUqcJVDAibK.webp" alt="nginx内存池">其中这里的ngx_pool_cleanup_pt是一个比较好的设计，通过定义这种类型的函数指针，可以将不同的清理函数关联到内存池中，以便在内存池销毁时调用。比如说：处理内存池销毁时需要执行的清理任务。例如，关闭打开的文件，释放分配的资源等。</p><p>关于内存池相关的函数，可能以后会具体开一章讲解。这里先附上执行流程图</p><p><img src="https://s2.loli.net/2024/05/25/V9XjNOhx6avRmez.webp" alt="nginx内存池函数流程"></p><p>这里说一个在内存池设计中，常见的方法：以特定对齐方式分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//调用 posix_memalign 函数，该函数会尝试以特定的对齐方式 alignment 分配指定大小 size 的内存块，并将分配的内存地址存储在 p 中。</span><br>posix_memalign(&amp;p, alignment, size)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/qtUulxvAwfbhRz2.webp" alt="内存对齐"></p><blockquote><p>在内存中我们一般读取数据不是按内存来读取，一般都是按内存块来读取。</p><p>未对齐的情况下，当需要访问int类型的数据时，需要CPU访问2次内存块（内存块1和内存块2）</p><p>对齐的情况下，当访问int类型的数据时，只需要CPU访问1次内存块（内存块2）即可</p><p>是一种空间换时间的做法 </p></blockquote><h3 id="缓冲区数据类型ngx-buf-s"><a href="#缓冲区数据类型ngx-buf-s" class="headerlink" title="缓冲区数据类型ngx_buf_s"></a>缓冲区数据类型ngx_buf_s</h3><p><img src="https://s2.loli.net/2024/05/25/x5qdZ1vDyGVt37J.png" alt="nginx缓冲区"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> *            <span class="hljs-type">ngx_buf_tag_t</span>;  <span class="hljs-comment">// 缓冲区标签类型，用于标识缓冲区的特定类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_buf_s</span>  <span class="hljs-title">ngx_buf_t</span>;</span>  <span class="hljs-comment">// Nginx 缓冲区结构体</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_buf_s</span> &#123;</span><br>    u_char          *pos;            <span class="hljs-comment">// 缓冲区数据在内存的起始位置</span><br>    u_char          *last;           <span class="hljs-comment">// 缓冲区数据在内存的结束位置</span><br>    <span class="hljs-type">off_t</span>            file_pos;       <span class="hljs-comment">// 文件读取偏移量</span><br>    <span class="hljs-type">off_t</span>            file_last;      <span class="hljs-comment">// 文件读取结束位置</span><br><br>    u_char          *start;          <span class="hljs-comment">/* 缓冲区的起始地址 */</span><br>    u_char          *end;            <span class="hljs-comment">/* 缓冲区的结束地址 */</span><br>    <span class="hljs-type">ngx_buf_tag_t</span>    tag;            <span class="hljs-comment">// 缓冲区的标签</span><br>    <span class="hljs-type">ngx_file_t</span>      *file;           <span class="hljs-comment">// 缓冲区关联的文件对象</span><br>    <span class="hljs-type">ngx_buf_t</span>       *shadow;         <span class="hljs-comment">// 当前缓冲区的影子缓冲区</span><br>    <span class="hljs-type">unsigned</span>         temporary:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 缓冲区数据可以被修改的标志</span><br>    <span class="hljs-type">unsigned</span>         memory:<span class="hljs-number">1</span>;       <span class="hljs-comment">// 缓冲区数据在内存中的标志，且不可修改</span><br>    <span class="hljs-type">unsigned</span>         mmap:<span class="hljs-number">1</span>;         <span class="hljs-comment">// 缓冲区数据是通过 mmap 映射的，且不可修改</span><br>    <span class="hljs-type">unsigned</span>         recycled:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否已经被回收</span><br>    <span class="hljs-type">unsigned</span>         in_file:<span class="hljs-number">1</span>;      <span class="hljs-comment">// 缓冲区的数据是否在文件中</span><br>    <span class="hljs-type">unsigned</span>         flush:<span class="hljs-number">1</span>;        <span class="hljs-comment">// 缓冲区是否需要刷新</span><br>    <span class="hljs-type">unsigned</span>         sync:<span class="hljs-number">1</span>;         <span class="hljs-comment">// 缓冲区是否需要同步</span><br>    <span class="hljs-type">unsigned</span>         last_buf:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否为最后一个缓冲区</span><br>    <span class="hljs-type">unsigned</span>         last_in_chain:<span class="hljs-number">1</span>; <span class="hljs-comment">// 缓冲区是否是链表中的最后一个</span><br>    <span class="hljs-type">unsigned</span>         last_shadow:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 缓冲区是否是影子缓冲区链表中的最后一个</span><br>    <span class="hljs-type">unsigned</span>         temp_file:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否是临时文件</span><br>    <span class="hljs-comment">/* STUB */</span> <span class="hljs-type">int</span>   num;             <span class="hljs-comment">// 缓冲区编号（占位符）</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_chain_s</span> &#123;</span><br>    <span class="hljs-type">ngx_buf_t</span>    *buf;               <span class="hljs-comment">// 缓冲区指针</span><br>    <span class="hljs-type">ngx_chain_t</span>  *next;              <span class="hljs-comment">// 下一个链表节点指针</span><br>&#125; <span class="hljs-type">ngx_chain_t</span>;                        <span class="hljs-comment">// Nginx 链表节点结构体</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_int_t</span>    num;                <span class="hljs-comment">// 缓冲区数量</span><br>    <span class="hljs-type">size_t</span>       size;               <span class="hljs-comment">// 缓冲区大小</span><br>&#125; <span class="hljs-type">ngx_bufs_t</span>;                        <span class="hljs-comment">// 缓冲区参数结构体</span><br><br></code></pre></td></tr></table></figure><p>其中，ngx_chain_t 数据类型是与缓冲区类型 ngx_buf_t 相关的链表结构，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_chain_s</span> &#123;</span><br>    <span class="hljs-type">ngx_buf_t</span>    *buf;  <span class="hljs-comment">/* 指向当前缓冲区 */</span><br>    <span class="hljs-type">ngx_chain_t</span>  *next; <span class="hljs-comment">/* 指向下一个chain，形成chain链表 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/xl8P7vMTdfLkWJO.png" alt="chain链表"></p><h3 id="动态数组数据结构ngx-array-t"><a href="#动态数组数据结构ngx-array-t" class="headerlink" title="动态数组数据结构ngx_array_t"></a>动态数组数据结构ngx_array_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span>        *elts;  <span class="hljs-comment">/* 指向数组数据区域的首地址 */</span><br>    <span class="hljs-type">ngx_uint_t</span>   nelts; <span class="hljs-comment">/* 数组实际数据的个数 */</span><br>    <span class="hljs-type">size_t</span>       size;  <span class="hljs-comment">/* 单个元素所占据的字节大小 */</span><br>    <span class="hljs-type">ngx_uint_t</span>   nalloc;<span class="hljs-comment">/* 数组容量 */</span><br>    <span class="hljs-type">ngx_pool_t</span>  *pool;  <span class="hljs-comment">/* 数组对象所在的内存池 */</span><br>&#125; <span class="hljs-type">ngx_array_t</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/A1FD3mMUQvSaGCi.png" alt="动态数组"></p><p>整个动态数组的创建，使用，销毁过程中都是基于上文的内存池数据类型进行的。</p><h4 id="设计优点-1"><a href="#设计优点-1" class="headerlink" title="设计优点"></a>设计优点</h4><p>1，<strong>动态扩容</strong></p><ul><li><code>ngx_array_t</code> 是动态分配内存的，它的大小可以根据需要自动增长，而普通的数组在定义时就需要确定大小，无法动态改变大小。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_array_push(<span class="hljs-type">ngx_array_t</span> *a)<br>&#123;<br>    <span class="hljs-type">void</span>        *elt, *new;<br>    <span class="hljs-type">size_t</span>       size;<br>    <span class="hljs-type">ngx_pool_t</span>  *p;<br>    <br>    <span class="hljs-comment">//函数会检查数组是否已满（即已存储的元素个数 nelts 是否等于数组的容量 nalloc）。如果数组已满，则需要进行扩容操作：</span><br>    <span class="hljs-keyword">if</span> (a-&gt;nelts == a-&gt;nalloc) &#123;<br><br>        <span class="hljs-comment">//计算当前数组的总大小（size = a-&gt;size * a-&gt;nalloc）</span><br>        size = a-&gt;size * a-&gt;nalloc;<br><br>        p = a-&gt;pool;<br>        <br>        <span class="hljs-comment">//检查内存池是否有足够的空间用于扩容，如果内存池的末尾可以容纳新的数组分配，并且内存池的末尾加上新的数组分配大小不会超出内存池的结束位置，则在内存池的末尾直接分配新的数组空间。</span><br>        <span class="hljs-keyword">if</span> ((u_char *) a-&gt;elts + size == p-&gt;d.last<br>            &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)<br>        &#123;<br>            p-&gt;d.last += a-&gt;size;<br>            a-&gt;nalloc++;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果内存池无法容纳新的数组分配，则需要重新分配一个新的数组空间，大小是当前数组大小的两倍，并将原数组数据复制到新数组中。</span><br>            new = ngx_palloc(p, <span class="hljs-number">2</span> * size);<br>            <span class="hljs-keyword">if</span> (new == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br><br>            ngx_memcpy(new, a-&gt;elts, size);<br>            a-&gt;elts = new;<br>            a-&gt;nalloc *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//最后，将新元素添加到数组末尾，并更新已存储的元素个数 nelts。</span><br>    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;<br>    a-&gt;nelts++;<br><br>    <span class="hljs-keyword">return</span> elt;<br>&#125;<br></code></pre></td></tr></table></figure><p>2，<strong>内存管理</strong></p><ul><li><code>ngx_array_t</code> 使用内存池进行内存分配，而不是直接调用系统的 <code>malloc()</code> 函数，这样可以减少内存碎片的产生，提高内存管理的效率。可以在内存池的生命周期内进行动态的内存分配和释放，而普通的数组需要手动管理内存的分配和释放。</li></ul><p>3，<strong>数组元数据</strong></p><ul><li><code>ngx_array_t</code> 中的 <code>nelts</code> 表示当前数组中实际存储的元素个数，<code>nalloc</code> 表示数组的容量（即分配的内存空间可以容纳的元素个数），通过这两个值可以确定数组的使用情况，从而进行动态的内存管理。</li></ul><h4 id="扩展视野"><a href="#扩展视野" class="headerlink" title="扩展视野"></a>扩展视野</h4><p>类似的自动扩容设计在redis上的动态字符串(sds)也有出现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">//记录buf数组中已使用字节的数量</span><br>    <span class="hljs-comment">//等于SDS所保存字符串的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-comment">//记录buf数组中未使用字节的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br><br>    <span class="hljs-comment">//char数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/F7UquTgPlARjeX5.png" alt="sds"></p><p>自动扩容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">sds _sdsMakeRoomFor(sds s, <span class="hljs-type">size_t</span> addlen, <span class="hljs-type">int</span> greedy) &#123;<br>    <span class="hljs-type">void</span> *sh, *newsh; <span class="hljs-comment">// 分别为原始字符串头部和新字符串头部的指针</span><br>    <span class="hljs-type">size_t</span> avail = sdsavail(s); <span class="hljs-comment">// 可用空间大小</span><br>    <span class="hljs-type">size_t</span> len, newlen, reqlen; <span class="hljs-comment">// 分别为字符串当前长度、新长度、所需长度</span><br>    <span class="hljs-type">char</span> type, oldtype = s[<span class="hljs-number">-1</span>] &amp; SDS_TYPE_MASK; <span class="hljs-comment">// 分别为新类型和旧类型</span><br>    <span class="hljs-type">int</span> hdrlen; <span class="hljs-comment">// 头部长度</span><br>    <span class="hljs-type">size_t</span> usable; <span class="hljs-comment">// 实际可用空间大小</span><br><br>    <span class="hljs-comment">/* Return ASAP if there is enough space left. */</span><br>    <span class="hljs-keyword">if</span> (avail &gt;= addlen) <span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 如果可用空间大于等于所需空间，则直接返回原字符串</span><br><br>    len = sdslen(s); <span class="hljs-comment">// 获取当前字符串长度</span><br>    sh = (<span class="hljs-type">char</span>*)s-sdsHdrSize(oldtype); <span class="hljs-comment">// 计算原字符串头部位置</span><br>    reqlen = newlen = (len+addlen); <span class="hljs-comment">// 计算所需长度为当前长度加上新增长度</span><br>    assert(newlen &gt; len);   <span class="hljs-comment">/* Catch size_t overflow */</span> <span class="hljs-comment">// 检查 size_t 溢出</span><br><br>    <span class="hljs-keyword">if</span> (greedy == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC) <span class="hljs-comment">// 如果新长度小于最大预分配长度，则将新长度翻倍</span><br>            newlen *= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            newlen += SDS_MAX_PREALLOC; <span class="hljs-comment">// 否则直接增加最大预分配长度</span><br>    &#125;<br><br>    type = sdsReqType(newlen); <span class="hljs-comment">// 获取新类型</span><br><br>    <span class="hljs-comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span><br><span class="hljs-comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span><br><span class="hljs-comment">     * at every appending operation. */</span><br>    <span class="hljs-keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8; <span class="hljs-comment">// 如果新类型为 5，则改为 8，因为 5 类型无法记录空闲空间</span><br><br>    hdrlen = sdsHdrSize(type); <span class="hljs-comment">// 计算新头部长度</span><br>    assert(hdrlen + newlen + <span class="hljs-number">1</span> &gt; reqlen);  <span class="hljs-comment">/* Catch size_t overflow */</span> <span class="hljs-comment">// 检查 size_t 溢出</span><br><br>    <span class="hljs-keyword">if</span> (oldtype==type) &#123; <span class="hljs-comment">// 如果新旧类型相同</span><br>        newsh = s_realloc_usable(sh, hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable); <span class="hljs-comment">// 重新分配空间</span><br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分配失败则返回空指针</span><br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen; <span class="hljs-comment">// 更新字符串指针位置</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Since the header size changes, need to move the string forward,</span><br><span class="hljs-comment">         * and can&#x27;t use realloc */</span><br>        newsh = s_malloc_usable(hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable); <span class="hljs-comment">// 分配新空间</span><br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分配失败则返回空指针</span><br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span>*)newsh+hdrlen, s, len+<span class="hljs-number">1</span>); <span class="hljs-comment">// 将原字符串拷贝到新空间</span><br>        s_free(sh); <span class="hljs-comment">// 释放原空间</span><br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen; <span class="hljs-comment">// 更新字符串指针位置</span><br>        s[<span class="hljs-number">-1</span>] = type; <span class="hljs-comment">// 更新新类型</span><br>        sdssetlen(s, len); <span class="hljs-comment">// 更新字符串长度</span><br>    &#125;<br>    usable = usable-hdrlen<span class="hljs-number">-1</span>; <span class="hljs-comment">// 计算实际可用空间</span><br>    <span class="hljs-keyword">if</span> (usable &gt; sdsTypeMaxSize(type)) <span class="hljs-comment">// 如果实际可用空间大于类型最大限制，则设置为类型最大限制</span><br>        usable = sdsTypeMaxSize(type);<br>    sdssetalloc(s, usable); <span class="hljs-comment">// 设置字符串实际分配空间大小</span><br>    <span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 返回更新后的字符串</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="链表数据结构-ngx-list-t"><a href="#链表数据结构-ngx-list-t" class="headerlink" title="链表数据结构 ngx_list_t"></a>链表数据结构 ngx_list_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个结构体类型 ngx_list_part_s，并将其别名定义为 ngx_list_part_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_list_part_s</span>  <span class="hljs-title">ngx_list_part_t</span>;</span><br><br><span class="hljs-comment">// 定义结构体 ngx_list_part_s。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_list_part_s</span> &#123;</span><br>    <span class="hljs-type">void</span>             *elts;   <span class="hljs-comment">// 指向元素的指针，每个元素的类型未指定。</span><br>    <span class="hljs-type">ngx_uint_t</span>        nelts;  <span class="hljs-comment">// 当前存储的元素个数。</span><br>    <span class="hljs-type">ngx_list_part_t</span>  *next;   <span class="hljs-comment">// 指向下一个链表部分的指针。</span><br>&#125;;<br><br><span class="hljs-comment">// 定义一个链表结构 ngx_list_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_list_part_t</span>  *last;    <span class="hljs-comment">// 指向链表的最后一个部分的指针。</span><br>    <span class="hljs-type">ngx_list_part_t</span>   part;    <span class="hljs-comment">// 链表的第一个部分，包含元素和指向下一个部分的指针。</span><br>    <span class="hljs-type">size_t</span>            size;    <span class="hljs-comment">// 每个元素的大小。</span><br>    <span class="hljs-type">ngx_uint_t</span>        nalloc;  <span class="hljs-comment">// 每个部分可以存储的元素个数。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;    <span class="hljs-comment">// 指向内存池的指针，用于分配链表部分的内存。</span><br>&#125; <span class="hljs-type">ngx_list_t</span>;<br></code></pre></td></tr></table></figure><p>链表数据结构如下图所示：</p><p><img src="https://s2.loli.net/2024/05/25/ADgYxOuqIMfl2nJ.png" alt="nginx链表"></p><p>链表主要函数:</p><p><img src="https://s2.loli.net/2024/05/25/ZbEYmN4V7nW9cJH.png" alt="image-20240524181000980"></p><p>需要注意的是：由于链表的内存分配是基于内存池，所有内存的销毁由内存池进行，即链表没有销毁操作。</p><p>其中主要是的内存分配函数就是*<em>ngx_palloc(ngx_pool_t <em>pool, size_t size)</em></em></p><h4 id="基础巩固-2"><a href="#基础巩固-2" class="headerlink" title="基础巩固"></a><strong>基础巩固</strong></h4><h5 id="什么是static？"><a href="#什么是static？" class="headerlink" title="什么是static？"></a>什么是static？</h5><h4 id="1-static-变量"><a href="#1-static-变量" class="headerlink" title="1.  static 变量"></a>1.  static 变量</h4><ul><li><p><strong>在函数内</strong>：</p><ul><li>当 <code>static</code> 变量在函数内部声明时，它是一个局部变量，但与普通局部变量不同的是，它的生命周期是整个程序运行期间。它只在第一次执行到声明语句时初始化，以后即使函数多次调用也不会重新初始化，并且其值在函数调用之间保持不变。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只在第一次调用时初始化</span><br>    count++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在文件作用域内</strong>：</p><ul><li>当 <code>static</code> 变量在文件的顶层（即不在任何函数内）声明时，它的作用域仅限于该文件。它不能被其他文件访问，即使在其他文件中有相同名字的变量也不会冲突。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> global_count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只能在该文件中访问</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-static-函数"><a href="#2-static-函数" class="headerlink" title="2. static 函数"></a>2. <code>static</code> 函数</h4><ul><li><p>在文件作用域内：</p><ul><li>当 <code>static</code> 函数在文件中定义时，它的作用域也仅限于该文件。其他文件不能调用这个函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">helper_function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 只能在该文件中调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="什么是inline"><a href="#什么是inline" class="headerlink" title="什么是inline?"></a>什么是inline?</h5><h4 id="1-inline-函数"><a href="#1-inline-函数" class="headerlink" title="1. inline 函数"></a>1. <code>inline</code> 函数</h4><ul><li><p>在函数声明前使用 <code>inline</code>：</p><ul><li><code>inline</code> 关键字用于建议编译器在调用函数时将函数体内联展开，而不是进行正常的函数调用。这样可以减少函数调用的开销，尤其是在小函数和频繁调用的情况下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>需要注意的是，<code>inline</code> 只是一个建议，编译器可能会忽略它，特别是当函数体太大或者包含复杂的逻辑时。</li></ul></li></ul><h4 id="2-inline-和多重定义"><a href="#2-inline-和多重定义" class="headerlink" title="2. inline 和多重定义"></a>2. <code>inline</code> 和多重定义</h4><ul><li><p>在头文件中定义 <code>inline</code> 函数：</p><ul><li>当 <code>inline</code> 函数在头文件中定义并在多个源文件中包含时，通常不会导致重复定义错误，因为每个源文件的 <code>inline</code> 函数都被认为是独立的。编译器会处理这种情况以避免链接错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// header.h</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="队列链表结构ngx-queue-t"><a href="#队列链表结构ngx-queue-t" class="headerlink" title="队列链表结构ngx_queue_t"></a>队列链表结构ngx_queue_t</h3><p><img src="https://s2.loli.net/2024/05/25/jXQoYbiV8NpS7s1.png" alt="队列链表"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个结构体类型 ngx_queue_s，并将其别名定义为 ngx_queue_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_queue_s</span>  <span class="hljs-title">ngx_queue_t</span>;</span><br><br><span class="hljs-comment">// 定义结构体 ngx_queue_s，用于实现双向循环链表。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_queue_s</span> &#123;</span><br>    <span class="hljs-type">ngx_queue_t</span>  *prev; <span class="hljs-comment">// 指向前一个队列节点的指针</span><br>    <span class="hljs-type">ngx_queue_t</span>  *next; <span class="hljs-comment">// 指向下一个队列节点的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>通过观察ngx_queue_s结构体可以看出与我们普通的双向链表的区别在于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义双向链表节点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> data;           <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">prev</span>;</span>  <span class="hljs-comment">// 指向前一个节点的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一个节点的指针</span><br>&#125; Node;<br></code></pre></td></tr></table></figure><p>1.这里的双向链表中的节点是没有数据区的，只有两个指向节点的指针</p><p>2.同样队列链表时选择不使用内存池管理</p><p>个人认为这样的设计主要从这几各方面考虑：</p><ol><li><strong>节省内存</strong>：在某些情况下，队列节点本身并不需要携带数据，而只需包含指向数据的指针。如果每个节点都分配一定大小的数据区域，将会造成内存浪费。通过不为节点分配数据区域，可以节省内存，并使得队列更加轻量级。</li><li><strong>减少数据拷贝</strong>：通过在节点中存储指向数据的指针，而不是存储数据本身，可以减少数据在内存中的拷贝次数。这对于处理大量数据或频繁操作数据的场景下，能够提高性能和效率。</li><li><strong>灵活性</strong>：将数据存储在节点外部，允许队列节点更通用。这样设计使得节点可以存储不同类型的数据，从而提高了队列的灵活性。这样的设计适用于 Nginx 中很多情况下需要处理各种类型数据的场景。</li><li>内存池适用于大量的、相对固定大小的对象分配，例如 HTTP 请求和响应的内存管理。但对于一些特殊的数据结构，如队列链表，其大小不固定，每个节点的内存消耗可能不同，因此直接使用内存池可能不够灵活。</li></ol><p>当然，在使用时这种节点通常与实际数据结构结合使用，通过嵌入 <code>ngx_queue_t</code> 结构体来实现链表操作。例如，一个实际的数据结构可能如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_queue_t</span> <span class="hljs-built_in">queue</span>; <span class="hljs-comment">// 嵌入 ngx_queue_t 用于链表操作</span><br>    <span class="hljs-type">int</span> data;          <span class="hljs-comment">// 实际数据</span><br>&#125; <span class="hljs-type">my_data_t</span>;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表结构ngx-hash-t"><a href="#哈希表结构ngx-hash-t" class="headerlink" title="哈希表结构ngx_hash_t"></a>哈希表结构ngx_hash_t</h3><h4 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表?"></a>什么是哈希表?</h4><p>哈希表（Hash Table）是一种用于实现关联数组（键值对存储）的数据结构。它利用哈希函数将键映射到表中的位置，从而实现快速的数据存取。哈希表支持高效的插入、删除和查找操作，通常时间复杂度为O(1)。</p><p><strong>哈希表的基本概念</strong></p><ol><li><strong>键（Key）和值（Value）</strong>：哈希表通过键来存储和检索相应的值。</li><li><strong>哈希函数（Hash Function）</strong>：将键转换为哈希值（通常是一个整数），然后用这个哈希值确定在表中的位置。</li><li><strong>哈希冲突（Hash Collision）</strong>：不同的键可能会映射到同一个位置，这种情况称为冲突。哈希表需要处理冲突以确保每个键值对都能被正确存储和访问。</li></ol><p><strong>哈希表的结构</strong></p><p>哈希表通常由一个数组和一个哈希函数组成。数组的每个位置称为一个桶（bucket）。</p><p><strong>哈希冲突解决方法</strong></p><ol><li><strong>链地址法（Chaining）</strong>：每个桶中存储一个链表，所有映射到同一桶的元素都放入这个链表中。</li><li><strong>开放地址法（Open Addressing）</strong>：当冲突发生时，寻找下一个空桶来存储元素。常见的探查方式包括线性探查、二次探查和双重哈希。</li></ol><p><img src="https://s2.loli.net/2024/05/25/6STaUCZkpLjY1IR.png" alt="hashtab"></p><p>接着我们来看nginx是如何设计哈希表的。</p><p><img src="https://s2.loli.net/2024/05/25/ezxEjR6AU8utkWT.jpg" alt="img"></p><p>可以看出nginx的哈希表是由三层结构组成而来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 指向存储在哈希表中的值，可以是任何类型。</span><br>    u_short           len;       <span class="hljs-comment">// name字段的长度。</span><br>    u_char            name[<span class="hljs-number">1</span>];   <span class="hljs-comment">// 键的第一个字符，后续的字符在分配时动态决定，这是一个灵活数组成员。</span><br>&#125; <span class="hljs-type">ngx_hash_elt_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_elt_t</span>  **buckets;   <span class="hljs-comment">// 指向哈希表桶数组的指针，每个桶是一个链表的头节点。</span><br>    <span class="hljs-type">ngx_uint_t</span>        size;      <span class="hljs-comment">// 哈希表中桶的数量。</span><br>&#125; <span class="hljs-type">ngx_hash_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>        hash;      <span class="hljs-comment">// 嵌入的ngx_hash_t结构，用于存储哈希表。</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 指向存储在通配符哈希表中的值，可以是任何类型。</span><br>&#125; <span class="hljs-type">ngx_hash_wildcard_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_str_t</span>         key;       <span class="hljs-comment">// 键，字符串类型。</span><br>    <span class="hljs-type">ngx_uint_t</span>        key_hash;  <span class="hljs-comment">// 键的哈希值。</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 与键关联的值，可以是任何类型。</span><br>&#125; <span class="hljs-type">ngx_hash_key_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">ngx_uint_t</span> <span class="hljs-params">(*ngx_hash_key_pt)</span> <span class="hljs-params">(u_char *data, <span class="hljs-type">size_t</span> len)</span>;  <span class="hljs-comment">// 函数指针类型，指向一个哈希函数，该函数接受一个字符数组（键）和其长度作为参数，返回一个无符号整数类型的哈希值。</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>            hash;      <span class="hljs-comment">// 嵌入的ngx_hash_t结构，用于存储哈希表。</span><br>    <span class="hljs-type">ngx_hash_wildcard_t</span>  *wc_head;   <span class="hljs-comment">// 指向通配符哈希表的头部。</span><br>    <span class="hljs-type">ngx_hash_wildcard_t</span>  *wc_tail;   <span class="hljs-comment">// 指向通配符哈希表的尾部。</span><br>&#125; <span class="hljs-type">ngx_hash_combined_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>       *hash;         <span class="hljs-comment">// 指向一个ngx_hash_t结构的指针，用于存储初始化后的哈希表。</span><br>    ngx_hash_key_pt   key;          <span class="hljs-comment">// 指向一个哈希函数的指针，用于计算键的哈希值。</span><br><br>    <span class="hljs-type">ngx_uint_t</span>        max_size;     <span class="hljs-comment">// 哈希表允许的最大键数量。</span><br>    <span class="hljs-type">ngx_uint_t</span>        bucket_size;  <span class="hljs-comment">// 每个桶的大小。</span><br><br>    <span class="hljs-type">char</span>             *name;         <span class="hljs-comment">// 哈希表的名称，用于调试或日志记录。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;         <span class="hljs-comment">// 指向一个内存池，用于分配哈希表所需的内存。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *temp_pool;    <span class="hljs-comment">// 指向一个临时内存池，用于在哈希表初始化过程中分配临时内存。</span><br>&#125; <span class="hljs-type">ngx_hash_init_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>        hsize;              <span class="hljs-comment">// 哈希表的大小，即桶的数量。</span><br><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;               <span class="hljs-comment">// 内存池，用于分配哈希表所需的内存。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *temp_pool;          <span class="hljs-comment">// 临时内存池，用于在哈希表初始化过程中分配临时内存。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       keys;               <span class="hljs-comment">// 存储普通键的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *keys_hash;          <span class="hljs-comment">// 指向哈希表中的普通键数组。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       dns_wc_head;        <span class="hljs-comment">// 存储DNS通配符键（头部）的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *dns_wc_head_hash;   <span class="hljs-comment">// 指向哈希表中的DNS通配符键（头部）数组。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       dns_wc_tail;        <span class="hljs-comment">// 存储DNS通配符键（尾部）的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *dns_wc_tail_hash;   <span class="hljs-comment">// 指向哈希表中的DNS通配符键（尾部）数组。</span><br>&#125; <span class="hljs-type">ngx_hash_keys_arrays_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_table_elt_s</span>  <span class="hljs-title">ngx_table_elt_t</span>;</span>  <span class="hljs-comment">// 前向声明结构类型ngx_table_elt_t。</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_table_elt_s</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>        hash;           <span class="hljs-comment">// 键的哈希值。</span><br>    <span class="hljs-type">ngx_str_t</span>         key;            <span class="hljs-comment">// 键，字符串类型。</span><br>    <span class="hljs-type">ngx_str_t</span>         value;          <span class="hljs-comment">// 与键关联的值，字符串类型。</span><br>    u_char           *lowcase_key;    <span class="hljs-comment">// 存储小写形式的键，用于不区分大小写的查找。</span><br>    <span class="hljs-type">ngx_table_elt_t</span>  *next;           <span class="hljs-comment">// 指向下一个元素的指针，形成链表，用于处理哈希冲突。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：Nginx 的哈希表设计主要是为了高效地存储和查找键值对。</p><h4 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作:"></a>初始化操作:</h4><p>hash 初始化由 ngx_hash_init() 函数完成，其 names 参数是 ngx_hash_key_t 结构的数组，即键-值对 &lt;key,value&gt; 数组，nelts 表示该数组元素的个数。该函数初始化的结果就是将 names 数组保存的键-值对&lt;key,value&gt;，通过 hash 的方式将其存入相应的一个或多个 hash 桶(即代码中的 buckets )中。hash 桶里面存放的是 ngx_hash_elt_t 结构的指针(hash元素指针)，该指针指向一个基本连续的数据区。该数据区中存放的是经 hash 之后的键-值对&lt;key’,value’&gt;，即 ngx_hash_elt_t 结构中的字段 &lt;name,value&gt;。每一个这样的数据区存放的键-值对&lt;key’,value’&gt;可以是一个或多个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NGX_HASH_ELT_SIZE(name)                                               \</span><br><span class="hljs-meta">    (sizeof(void *) + ngx_align((name)-&gt;key.len + 2, sizeof(void *)))</span><br><br><span class="hljs-comment">/* 初始化hash结构函数 */</span><br><span class="hljs-comment">/* 参数hinit是hash表初始化结构指针；</span><br><span class="hljs-comment"> * name是指向待添加在hash表结构的元素数组；</span><br><span class="hljs-comment"> * nelts是待添加元素数组中元素的个数；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_hash_init</span><span class="hljs-params">(<span class="hljs-type">ngx_hash_init_t</span> *hinit, <span class="hljs-type">ngx_hash_key_t</span> *names, <span class="hljs-type">ngx_uint_t</span> nelts)</span><br>&#123;<br>    u_char          *elts;<br>    <span class="hljs-type">size_t</span>           len;<br>    u_short         *test;<br>    <span class="hljs-type">ngx_uint_t</span>       i, n, key, size, start, bucket_size;<br>    <span class="hljs-type">ngx_hash_elt_t</span>  *elt, **buckets;<br><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-comment">/* 若每个桶bucket的内存空间不足以存储一个关键字元素，则出错返回</span><br><span class="hljs-comment">         * 这里考虑到了每个bucket桶最后的null指针所需的空间，即该语句中的sizeof(void *)，</span><br><span class="hljs-comment">         * 该指针可作为查找过程中的结束标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (hinit-&gt;bucket_size &lt; NGX_HASH_ELT_SIZE(&amp;names[n]) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *))<br>        &#123;<br>            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;could not build the %s, you should &quot;</span><br>                          <span class="hljs-string">&quot;increase %s_bucket_size: %i&quot;</span>,<br>                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 临时分配sizeof(u_short)*max_size的test空间，即test数组总共有max_size个元素，即最大bucket的数量，</span><br><span class="hljs-comment">     * 每个元素会累计落到相应hash表位置的关键字长度，</span><br><span class="hljs-comment">     * 当大于256字节，即u_short所表示的字节大小，</span><br><span class="hljs-comment">     * 则表示bucket较少</span><br><span class="hljs-comment">     */</span><br>    test = ngx_alloc(hinit-&gt;max_size * <span class="hljs-keyword">sizeof</span>(u_short), hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>);<br>    <span class="hljs-keyword">if</span> (test == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    <span class="hljs-comment">/* 每个bucket桶实际容纳的数据大小，</span><br><span class="hljs-comment">     * 由于每个bucket的末尾结束标志是null，</span><br><span class="hljs-comment">     * 所以bucket实际容纳的数据大小必须减去一个指针所占的内存大小</span><br><span class="hljs-comment">     */</span><br>    bucket_size = hinit-&gt;bucket_size - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *);<br><br>    <span class="hljs-comment">/* 估计hash表最少bucket数量；</span><br><span class="hljs-comment">     * 每个关键字元素需要的内存空间是 NGX_HASH_ELT_SIZE(&amp;name[n])，至少需要占用两个指针的大小即2*sizeof(void *)</span><br><span class="hljs-comment">     * 这样来估计hash表所需的最小bucket数量</span><br><span class="hljs-comment">     * 因为关键字元素内存越小，则每个bucket所容纳的关键字元素就越多</span><br><span class="hljs-comment">     * 那么hash表的bucket所需的数量就越少，但至少需要一个bucket</span><br><span class="hljs-comment">     */</span><br>    start = nelts / (bucket_size / (<span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)));<br>    start = start ? start : <span class="hljs-number">1</span>;<br><br>    <br>    <span class="hljs-keyword">if</span> (hinit-&gt;max_size &gt; <span class="hljs-number">10000</span> &amp;&amp; nelts &amp;&amp; hinit-&gt;max_size / nelts &lt; <span class="hljs-number">100</span>) &#123;<br>        start = hinit-&gt;max_size - <span class="hljs-number">1000</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 以前面估算的最小bucket数量start，通过测试数组test估算hash表容纳 nelts个关键字元素所需的bucket数量</span><br><span class="hljs-comment">     * 根据需求适当扩充bucket的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (size = start; size &lt;= hinit-&gt;max_size; size++) &#123;<br><br>        ngx_memzero(test, size * <span class="hljs-keyword">sizeof</span>(u_short));<br><br>        <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>            <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* 根据关键字元素的hash值计算存在到测试数组test对应的位置中，即计算bucket在hash表中的编号key,key取值为0～size-1 */</span><br>            key = names[n].key_hash % size;<br>            test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: %ui %ui \&quot;%V\&quot;&quot;</span>,<br>                          size, key, test[key], &amp;names[n].key);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">/* test数组中对应的内存大于每个桶bucket最大内存，则需扩充bucket的数量</span><br><span class="hljs-comment">             * 即在start的基础上继续增加size的值</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (test[key] &gt; (u_short) bucket_size) &#123;<br>                <span class="hljs-keyword">goto</span> next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 若size个bucket桶可以容纳name数组的所有关键字元素，则表示找到合适的bucket数量大小即为size */</span><br>        <span class="hljs-keyword">goto</span> found;<br><br>    next:<br><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    ngx_log_error(NGX_LOG_WARN, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                  <span class="hljs-string">&quot;could not build optimal %s, you should increase &quot;</span><br>                  <span class="hljs-string">&quot;either %s_max_size: %i or %s_bucket_size: %i; &quot;</span><br>                  <span class="hljs-string">&quot;ignoring %s_bucket_size&quot;</span>,<br>                  hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size,<br>                  hinit-&gt;name, hinit-&gt;bucket_size, hinit-&gt;name);<br><br>found:<br><br>    <span class="hljs-comment">/* 到此已经找到合适的bucket数量，即为size</span><br><span class="hljs-comment">     * 重新初始化test数组元素，初始值为一个指针大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        test[i] = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *);<br>    &#125;<br><br>    <span class="hljs-comment">/* 计算每个bucket中关键字所占的空间，即每个bucket实际所容纳数据的大小，</span><br><span class="hljs-comment">     * 必须注意的是：test[i]中还有一个指针大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 根据hash值计算出关键字放在对应的test[key]中，即test[key]的大小增加一个关键字元素的大小 */</span><br>        key = names[n].key_hash % size;<br>        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br>    &#125;<br><br>    len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 调整成对齐到cacheline的大小，并记录所有元素的总长度 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (test[i] == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        test[i] = (u_short) (ngx_align(test[i], ngx_cacheline_size));<br><br>        len += test[i];<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 向内存池申请bucket元素所占的内存空间，</span><br><span class="hljs-comment">     * 注意：若前面没有申请hash表头结构，则在这里将和ngx_hash_wildcard_t一起申请</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (hinit-&gt;hash == <span class="hljs-literal">NULL</span>) &#123;<br>        hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_wildcard_t</span>)<br>                                             + size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_elt_t</span> *));<br>        <span class="hljs-keyword">if</span> (hinit-&gt;hash == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_free(test);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">/* 计算buckets的起始位置 */</span><br>        buckets = (<span class="hljs-type">ngx_hash_elt_t</span> **)<br>                      ((u_char *) hinit-&gt;hash + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_wildcard_t</span>));<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        buckets = ngx_pcalloc(hinit-&gt;pool, size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_elt_t</span> *));<br>        <span class="hljs-keyword">if</span> (buckets == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_free(test);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 分配elts，对齐到cacheline大小 */</span><br>    elts = ngx_palloc(hinit-&gt;pool, len + ngx_cacheline_size);<br>    <span class="hljs-keyword">if</span> (elts == <span class="hljs-literal">NULL</span>) &#123;<br>        ngx_free(test);<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    elts = ngx_align_ptr(elts, ngx_cacheline_size);<br><br>    <span class="hljs-comment">/* 将buckets数组与相应的elts对应起来，即设置每个bucket对应实际数据的地址 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (test[i] == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        buckets[i] = (<span class="hljs-type">ngx_hash_elt_t</span> *) elts;<br>        elts += test[i];<br><br>    &#125;<br><br>    <span class="hljs-comment">/* 清空test数组，以便用来累计实际数据的长度，这里不计算结尾指针的长度 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        test[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 依次向各个bucket中填充实际数据 */</span><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        key = names[n].key_hash % size;<br>        elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ((u_char *) buckets[key] + test[key]);<br><br>        elt-&gt;value = names[n].value;<br>        elt-&gt;len = (u_short) names[n].key.len;<br><br>        ngx_strlow(elt-&gt;name, names[n].key.data, names[n].key.len);<br><br>        <span class="hljs-comment">/* test[key]记录当前bucket内容的填充位置，即下一次填充的起始位置 */</span><br>        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br>    &#125;<br><br>    <span class="hljs-comment">/* 设置bucket结束位置的null指针 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buckets[i] == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ((u_char *) buckets[i] + test[i]);<br><br>        elt-&gt;value = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    ngx_free(test);<br><br>    hinit-&gt;hash-&gt;buckets = buckets;<br>    hinit-&gt;hash-&gt;size = size;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-type">ngx_str_t</span>   val;<br>        <span class="hljs-type">ngx_uint_t</span>  key;<br><br>        elt = buckets[i];<br><br>        <span class="hljs-keyword">if</span> (elt == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: NULL&quot;</span>, i);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (elt-&gt;value) &#123;<br>            val.len = elt-&gt;len;<br>            val.data = &amp;elt-&gt;name[<span class="hljs-number">0</span>];<br><br>            key = hinit-&gt;key(val.data, val.len);<br><br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: %p \&quot;%V\&quot; %ui&quot;</span>, i, elt, &amp;val, key);<br><br>            elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ngx_align_ptr(&amp;elt-&gt;name[<span class="hljs-number">0</span>] + elt-&gt;len,<br>                                                   <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找操作—-ngx-hash-find"><a href="#查找操作—-ngx-hash-find" class="headerlink" title="查找操作—-&gt;ngx_hash_find"></a>查找操作—-&gt;ngx_hash_find</h4><img src="https://s2.loli.net/2024/05/25/gt5cvWXzsrhHKYm.png" alt="image-20240525123018812" style="zoom: 33%;" /><p><strong>处理链表</strong>：在哈希表中，哈希桶可能是通过链表实现的。在遍历链表时，需要确保从正确的位置开始访问下一个元素。由于每个元素的长度不固定（因为键的长度不同），所以不能简单地使用固定的偏移量来访问下一个元素，而需要进行对齐操作以确保指针的正确位置。</p><p>其中注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_align_ptr(p, a)                                                   \</span><br><span class="hljs-meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span><br></code></pre></td></tr></table></figure><blockquote><p>宏的实现逻辑如下：</p><p>将指针 p 转换为 uintptr_t 类型，以获取指针的无符号整数表示。<br>将对齐方式 a 减 1，得到比对齐方式小一个单位的值。<br>将指针加上 a - 1 的值，相当于向上取整到最近的对齐倍数。<br>使用按位与操作符 &amp; 将结果与 ~(a - 1) 进行按位与运算，将低位的偏移部分清零，从而实现对齐到指定的对齐方式。<br>最后将结果转换回 u_char * 类型，并返回对齐后的指针。</p></blockquote><h3 id="红黑树结构-ngx-rbtree-t"><a href="#红黑树结构-ngx-rbtree-t" class="headerlink" title="红黑树结构 ngx_rbtree_t"></a>红黑树结构 ngx_rbtree_t</h3><p><strong>附上红黑树的四条规则：</strong></p><ul><li>必须为二叉搜索树（左&lt;根&lt;右）</li><li>根和叶子结点都是黑色</li><li>不存在连续的两个红色结点</li><li>任意到根节点路径上的黑色结点数目相同</li></ul><p><strong>红黑树删除结点流程：</strong></p><p><img src="https://s2.loli.net/2024/05/25/wt4UXuV2s6z7v51.png" alt="image-20240525151542705"></p><h5 id="红黑树结构"><a href="#红黑树结构" class="headerlink" title="红黑树结构"></a>红黑树结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_node_s</span>  <span class="hljs-title">ngx_rbtree_node_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_node_s</span> &#123;</span><br>    <span class="hljs-type">ngx_rbtree_key_t</span>       key;     <span class="hljs-comment">/* 节点的键值 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *left;    <span class="hljs-comment">/* 节点的左孩子 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *right;   <span class="hljs-comment">/* 节点的右孩子 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *parent;  <span class="hljs-comment">/* 节点的父亲 */</span><br>    u_char                 color;   <span class="hljs-comment">/* 节点的颜色 */</span><br>    u_char                 data;    <span class="hljs-comment">/* */</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_s</span>  <span class="hljs-title">ngx_rbtree_t</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*ngx_rbtree_insert_pt)</span> <span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *root,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span>;<br><br><span class="hljs-comment">/* 红黑树结构 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_s</span> &#123;</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *root;    <span class="hljs-comment">/* 指向树的根节点 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *sentinel;<span class="hljs-comment">/* 指向树的叶子节点NIL */</span><br>    ngx_rbtree_insert_pt   insert;  <span class="hljs-comment">/* 添加元素节点的函数指针，解决具有相同键值，但不同颜色节点的冲突问题；</span><br><span class="hljs-comment">                                     * 该函数指针决定新节点的行为是新增还是替换原始某个节点*/</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="红黑树的操作"><a href="#红黑树的操作" class="headerlink" title="红黑树的操作"></a>红黑树的操作</h4><h5 id="初始化操作-1"><a href="#初始化操作-1" class="headerlink" title="初始化操作"></a>初始化操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 给节点着色，1表示红色，0表示黑色  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_red(node)               ((node)-&gt;color = 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_black(node)             ((node)-&gt;color = 0)</span><br><span class="hljs-comment">/* 判断节点的颜色 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_is_red(node)            ((node)-&gt;color)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_is_black(node)          (!ngx_rbt_is_red(node))</span><br><span class="hljs-comment">/* 复制某个节点的颜色 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_copy_color(n1, n2)      (n1-&gt;color = n2-&gt;color)</span><br><br><span class="hljs-comment">/* 节点着黑色的宏定义 */</span><br><span class="hljs-comment">/* a sentinel must be black */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbtree_sentinel_init(node)  ngx_rbt_black(node)</span><br><br><span class="hljs-comment">/* 初始化红黑树，即为空的红黑树 */</span><br><span class="hljs-comment">/* tree 是指向红黑树的指针，</span><br><span class="hljs-comment"> * s 是红黑树的一个NIL节点，</span><br><span class="hljs-comment"> * i 表示函数指针，决定节点是新增还是替换</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbtree_init(tree, s, i)                                           \</span><br><span class="hljs-meta">    ngx_rbtree_sentinel_init(s);                                              \</span><br><span class="hljs-meta">    (tree)-&gt;root = s;                                                         \</span><br><span class="hljs-meta">    (tree)-&gt;sentinel = s;                                                     \</span><br><span class="hljs-meta">    (tree)-&gt;insert = i</span><br><br></code></pre></td></tr></table></figure><h5 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h5><p>同平衡二叉树(AVL)的旋转逻辑相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 左旋转操作 */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_left_rotate</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> **root, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;right;<span class="hljs-comment">/* temp为node节点的右孩子 */</span><br>    node-&gt;right = temp-&gt;left;<span class="hljs-comment">/* 设置node节点的右孩子为temp的左孩子 */</span><br><br>    <span class="hljs-keyword">if</span> (temp-&gt;left != sentinel) &#123;<br>        temp-&gt;left-&gt;parent = node;<br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<br><br>    <span class="hljs-keyword">if</span> (node == *root) &#123;<br>        *root = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>        node-&gt;parent-&gt;left = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;parent-&gt;right = temp;<br>    &#125;<br><br>    temp-&gt;left = node;<br>    node-&gt;parent = temp;<br>&#125;<br><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_right_rotate</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> **root, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;left;<br>    node-&gt;left = temp-&gt;right;<br><br>    <span class="hljs-keyword">if</span> (temp-&gt;right != sentinel) &#123;<br>        temp-&gt;right-&gt;parent = node;<br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<br><br>    <span class="hljs-keyword">if</span> (node == *root) &#123;<br>        *root = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;right) &#123;<br>        node-&gt;parent-&gt;right = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;parent-&gt;left = temp;<br>    &#125;<br><br>    temp-&gt;right = node;<br>    node-&gt;parent = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 获取红黑树键值最小的节点 */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">ngx_rbtree_node_t</span> *<br><span class="hljs-title function_">ngx_rbtree_min</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *node, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (node-&gt;left != sentinel) &#123;<br>        node = node-&gt;left;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">/* 插入节点 */</span><br><span class="hljs-comment">/* 插入节点的步骤：</span><br><span class="hljs-comment"> * 1、首先按照二叉查找树的插入操作插入新节点；</span><br><span class="hljs-comment"> * 2、然后把新节点着色为红色（避免破坏红黑树性质5）；</span><br><span class="hljs-comment"> * 3、为维持红黑树的性质，调整红黑树的节点（着色并旋转），使其满足红黑树的性质；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert</span><span class="hljs-params">(ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span> *tree,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **root, *temp, *sentinel;<br><br>    <span class="hljs-comment">/* a binary tree insert */</span><br><br>    root = (<span class="hljs-type">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<br>    sentinel = tree-&gt;sentinel;<br><br>    <span class="hljs-comment">/* 若红黑树为空，则比较简单，把新节点作为根节点，</span><br><span class="hljs-comment">     * 并初始化该节点使其满足红黑树性质</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (*root == sentinel) &#123;<br>        node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>        node-&gt;left = sentinel;<br>        node-&gt;right = sentinel;<br>        ngx_rbt_black(node);<br>        *root = node;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若红黑树不为空，则按照二叉查找树的插入操作进行</span><br><span class="hljs-comment">     * 该操作由函数指针提供</span><br><span class="hljs-comment">     */</span><br>    tree-&gt;insert(*root, node, sentinel);<br><br>    <span class="hljs-comment">/* re-balance tree */</span><br><br>    <span class="hljs-comment">/* 调整红黑树，使其满足性质，</span><br><span class="hljs-comment">     * 其实这里只是破坏了性质4：若一个节点是红色，则孩子节点都为黑色；</span><br><span class="hljs-comment">     * 若破坏了性质4，则新节点 node 及其父亲节点 node-&gt;parent 都为红色；</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (node != *root &amp;&amp; ngx_rbt_is_red(node-&gt;parent)) &#123;<br><br>        <span class="hljs-comment">/* 若node的父亲节点是其祖父节点的左孩子 */</span><br>        <span class="hljs-keyword">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left) &#123;<br>            temp = node-&gt;parent-&gt;parent-&gt;right;<span class="hljs-comment">/* temp节点为node的叔叔节点 */</span><br><br>            <span class="hljs-comment">/* case1：node的叔叔节点是红色 */</span><br>            <span class="hljs-comment">/* 此时，node的父亲及叔叔节点都为红色；</span><br><span class="hljs-comment">             * 解决办法：将node的父亲及叔叔节点着色为黑色，将node祖父节点着色为红色；</span><br><span class="hljs-comment">             * 然后沿着祖父节点向上判断是否会破会红黑树的性质；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(temp)) &#123;<br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_black(temp);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* case2：node的叔叔节点是黑色且node是父亲节点的右孩子 */</span><br>                <span class="hljs-comment">/* 则此时，以node父亲节点进行左旋转，使case2转变为case3；</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;right) &#123;<br>                    node = node-&gt;parent;<br>                    ngx_rbtree_left_rotate(root, sentinel, node);<br>                &#125;<br><br>                <span class="hljs-comment">/* case3：node的叔叔节点是黑色且node是父亲节点的左孩子 */</span><br>                <span class="hljs-comment">/* 首先，将node的父亲节点着色为黑色，祖父节点着色为红色；</span><br><span class="hljs-comment">                 * 然后以祖父节点进行一次右旋转；</span><br><span class="hljs-comment">                 */</span><br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                ngx_rbtree_right_rotate(root, sentinel, node-&gt;parent-&gt;parent);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 若node的父亲节点是其祖父节点的右孩子 */</span><br>            <span class="hljs-comment">/* 这里跟上面的情况是对称的，就不再进行讲解了</span><br><span class="hljs-comment">             */</span><br>            temp = node-&gt;parent-&gt;parent-&gt;left;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(temp)) &#123;<br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_black(temp);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>                    node = node-&gt;parent;<br>                    ngx_rbtree_right_rotate(root, sentinel, node);<br>                &#125;<br><br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                ngx_rbtree_left_rotate(root, sentinel, node-&gt;parent-&gt;parent);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 根节点必须为黑色 */</span><br>    ngx_rbt_black(*root);<br>&#125;<br><br><span class="hljs-comment">/* 这里只是将节点插入到红黑树中，并没有判断是否满足红黑树的性质；</span><br><span class="hljs-comment"> * 类似于二叉查找树的插入操作，这个函数为红黑树插入操作的函数指针；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert_value</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *temp, <span class="hljs-type">ngx_rbtree_node_t</span> *node,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **p;<br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br><br>        <span class="hljs-comment">/* 判断node节点键值与temp节点键值的大小，以决定node插入到temp节点的左子树还是右子树 */</span><br>        p = (node-&gt;key &lt; temp-&gt;key) ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class="hljs-keyword">if</span> (*p == sentinel) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br><br>    <span class="hljs-comment">/* 初始化node节点，并着色为红色 */</span><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    ngx_rbt_red(node);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert_timer_value</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *temp, <span class="hljs-type">ngx_rbtree_node_t</span> *node,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **p;<br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Timer values</span><br><span class="hljs-comment">         * 1) are spread in small range, usually several minutes,</span><br><span class="hljs-comment">         * 2) and overflow each 49 days, if milliseconds are stored in 32 bits.</span><br><span class="hljs-comment">         * The comparison takes into account that overflow.</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/*  node-&gt;key &lt; temp-&gt;key */</span><br><br>        p = ((<span class="hljs-type">ngx_rbtree_key_int_t</span>) (node-&gt;key - temp-&gt;key) &lt; <span class="hljs-number">0</span>)<br>            ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class="hljs-keyword">if</span> (*p == sentinel) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    ngx_rbt_red(node);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 删除节点 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_delete</span><span class="hljs-params">(ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span> *tree,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_uint_t</span>           red;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **root, *sentinel, *subst, *temp, *w;<br><br>    <span class="hljs-comment">/* a binary tree delete */</span><br><br>    root = (<span class="hljs-type">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<br>    sentinel = tree-&gt;sentinel;<br><br>    <span class="hljs-comment">/* 下面是获取temp节点值，temp保存的节点是准备替换节点node ；</span><br><span class="hljs-comment">     * subst是保存要被替换的节点的后继节点；</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* case1：若node节点没有左孩子（这里包含了存在或不存在右孩子的情况）*/</span><br>    <span class="hljs-keyword">if</span> (node-&gt;left == sentinel) &#123;<br>        temp = node-&gt;right;<br>        subst = node;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node-&gt;right == sentinel) &#123;<span class="hljs-comment">/* case2：node节点存在左孩子，但是不存在右孩子 */</span><br>        temp = node-&gt;left;<br>        subst = node;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* case3：node节点既有左孩子，又有右孩子 */</span><br>        subst = ngx_rbtree_min(node-&gt;right, sentinel);<span class="hljs-comment">/* 获取node节点的后续节点 */</span><br><br>        <span class="hljs-keyword">if</span> (subst-&gt;left != sentinel) &#123;<br>            temp = subst-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp = subst-&gt;right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若被替换的节点subst是根节点，则temp直接替换subst称为根节点 */</span><br>    <span class="hljs-keyword">if</span> (subst == *root) &#123;<br>        *root = temp;<br>        ngx_rbt_black(temp);<br><br>        <span class="hljs-comment">/* DEBUG stuff */</span><br>        node-&gt;left = <span class="hljs-literal">NULL</span>;<br>        node-&gt;right = <span class="hljs-literal">NULL</span>;<br>        node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>        node-&gt;key = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* red记录subst节点的颜色 */</span><br>    red = ngx_rbt_is_red(subst);<br><br>    <span class="hljs-comment">/* temp节点替换subst 节点 */</span><br>    <span class="hljs-keyword">if</span> (subst == subst-&gt;parent-&gt;left) &#123;<br>        subst-&gt;parent-&gt;left = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        subst-&gt;parent-&gt;right = temp;<br>    &#125;<br><br>    <span class="hljs-comment">/* 根据subst是否为node节点进行处理 */</span><br>    <span class="hljs-keyword">if</span> (subst == node) &#123;<br><br>        temp-&gt;parent = subst-&gt;parent;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;parent == node) &#123;<br>            temp-&gt;parent = subst;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp-&gt;parent = subst-&gt;parent;<br>        &#125;<br><br>        <span class="hljs-comment">/* 复制node节点属性 */</span><br>        subst-&gt;left = node-&gt;left;<br>        subst-&gt;right = node-&gt;right;<br>        subst-&gt;parent = node-&gt;parent;<br>        ngx_rbt_copy_color(subst, node);<br><br>        <span class="hljs-keyword">if</span> (node == *root) &#123;<br>            *root = subst;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>                node-&gt;parent-&gt;left = subst;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;parent-&gt;right = subst;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;left != sentinel) &#123;<br>            subst-&gt;left-&gt;parent = subst;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;right != sentinel) &#123;<br>            subst-&gt;right-&gt;parent = subst;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* DEBUG stuff */</span><br>    node-&gt;left = <span class="hljs-literal">NULL</span>;<br>    node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    node-&gt;key = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (red) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 下面开始是调整红黑树的性质 */</span><br>    <span class="hljs-comment">/* a delete fixup */</span><br><br>    <span class="hljs-comment">/* 根据temp节点进行处理 ，若temp不是根节点且为黑色 */</span><br>    <span class="hljs-keyword">while</span> (temp != *root &amp;&amp; ngx_rbt_is_black(temp)) &#123;<br><br>        <span class="hljs-comment">/* 若temp是其父亲节点的左孩子 */</span><br>        <span class="hljs-keyword">if</span> (temp == temp-&gt;parent-&gt;left) &#123;<br>            w = temp-&gt;parent-&gt;right;<span class="hljs-comment">/* w为temp的兄弟节点 */</span><br><br>            <span class="hljs-comment">/* case A：temp兄弟节点为红色 */</span><br>            <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">             * 1、改变w节点及temp父亲节点的颜色；</span><br><span class="hljs-comment">             * 2、对temp父亲节的做一次左旋转，此时，temp的兄弟节点是旋转之前w的某个子节点，该子节点颜色为黑色；</span><br><span class="hljs-comment">             * 3、此时，case A已经转换为case B、case C 或 case D；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(w)) &#123;<br>                ngx_rbt_black(w);<br>                ngx_rbt_red(temp-&gt;parent);<br>                ngx_rbtree_left_rotate(root, sentinel, temp-&gt;parent);<br>                w = temp-&gt;parent-&gt;right;<br>            &#125;<br><br>            <span class="hljs-comment">/* case B：temp的兄弟节点w是黑色，且w的两个子节点都是黑色 */</span><br>            <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">             * 1、改变w节点的颜色；</span><br><span class="hljs-comment">             * 2、把temp的父亲节点作为新的temp节点；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left) &amp;&amp; ngx_rbt_is_black(w-&gt;right)) &#123;<br>                ngx_rbt_red(w);<br>                temp = temp-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* case C：temp的兄弟节点是黑色，且w的左孩子是红色，右孩子是黑色 */</span><br>                <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">                 * 1、将改变w及其左孩子的颜色；</span><br><span class="hljs-comment">                 * 2、对w节点进行一次右旋转；</span><br><span class="hljs-comment">                 * 3、此时，temp新的兄弟节点w有着一个红色右孩子的黑色节点，转为case D；</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;right)) &#123;<br>                    ngx_rbt_black(w-&gt;left);<br>                    ngx_rbt_red(w);<br>                    ngx_rbtree_right_rotate(root, sentinel, w);<br>                    w = temp-&gt;parent-&gt;right;<br>                &#125;<br><br>                <span class="hljs-comment">/* case D：temp的兄弟节点w为黑色，且w的右孩子为红色 */</span><br>                <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">                 * 1、将w节点设置为temp父亲节点的颜色，temp父亲节点设置为黑色；</span><br><span class="hljs-comment">                 * 2、w的右孩子设置为黑色；</span><br><span class="hljs-comment">                 * 3、对temp的父亲节点做一次左旋转；</span><br><span class="hljs-comment">                 * 4、最后把根节点root设置为temp节点；*/</span><br>                ngx_rbt_copy_color(w, temp-&gt;parent);<br>                ngx_rbt_black(temp-&gt;parent);<br>                ngx_rbt_black(w-&gt;right);<br>                ngx_rbtree_left_rotate(root, sentinel, temp-&gt;parent);<br>                temp = *root;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 这里针对的是temp节点为其父亲节点的左孩子的情况 */</span><br>            w = temp-&gt;parent-&gt;left;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(w)) &#123;<br>                ngx_rbt_black(w);<br>                ngx_rbt_red(temp-&gt;parent);<br>                ngx_rbtree_right_rotate(root, sentinel, temp-&gt;parent);<br>                w = temp-&gt;parent-&gt;left;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left) &amp;&amp; ngx_rbt_is_black(w-&gt;right)) &#123;<br>                ngx_rbt_red(w);<br>                temp = temp-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left)) &#123;<br>                    ngx_rbt_black(w-&gt;right);<br>                    ngx_rbt_red(w);<br>                    ngx_rbtree_left_rotate(root, sentinel, w);<br>                    w = temp-&gt;parent-&gt;left;<br>                &#125;<br><br>                ngx_rbt_copy_color(w, temp-&gt;parent);<br>                ngx_rbt_black(temp-&gt;parent);<br>                ngx_rbt_black(w-&gt;left);<br>                ngx_rbtree_right_rotate(root, sentinel, temp-&gt;parent);<br>                temp = *root;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ngx_rbt_black(temp);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层</title>
    <link href="/2023/02/20/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2023/02/20/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早年在知乎发的文章，现转载到博客上</p></blockquote><p>个人以为该章的重点在于<strong>了解计算机在物理层中的数据通信过程</strong>和<strong>信道复用技术</strong>，故其他部分只是一笔带过，具体需要时可翻书复习。</p><h2 id="1-数据通信模型"><a href="#1-数据通信模型" class="headerlink" title="1.数据通信模型"></a>1.数据通信模型</h2><p><img src="https://pic2.zhimg.com/v2-516e211258fd86bd27c4ea0f211f2d1f_1440w.jpg" alt="img"></p><h3 id="常用术语："><a href="#常用术语：" class="headerlink" title="常用术语："></a>常用术语：</h3><ol><li>信道：</li></ol><p>信道（Channel）是指在通信系统中用于传输信息的介质或路径。它可以是物理媒介（如电缆、光纤）或无线媒介（如空气中的无线电波）。信道承载着数据、声音、图像等信息，将其从发送方传输到接收方。</p><p>信道可以是单向的（只支持单向传输），也可以是双向的（同时支持双向传输）。在单向信道中，信息只能从发送方流向接收方，而在双向信道中，信息可以在两个方向上进行传输。</p><p>信道根据传输方式和特性的不同可以分为模拟信道和数字信道：</p><ol><li>模拟信道（Analog Channel）：模拟信道传输的是连续的模拟信号。它的传输特点受到噪声、衰减和失真等因素的影响，需要采取衰减补偿、均衡和滤波等技术来保证信号的质量。</li><li>数字信道（Digital Channel）：数字信道传输的是离散的数字信号，在信道中通过调制和解调技术将数字信号转换为模拟信号进行传输。数字信道具有较强的抗干扰能力和误码纠正能力，可以提供更可靠的数据传输。</li></ol><p>在通信系统中，为了提高信道的可靠性和传输效率，常常会采用多路复用、编码调制、差错检测纠正等技术来进行信道管理和优化。通过合理设计和优化信道，可以实现高质量的信息传输和通信服务。</p><p>2.带宽：</p><p>带宽（Bandwidth）是指在特定的信号传输系统或通信信道中，能够传输的最高数据率或频率范围。在数字通信中，带宽通常用于表示信号或通道能够传输的频率范围。</p><p>在模拟信号中，带宽是指一个信号的频率范围，通常以赫兹（Hz）作为单位。例如，对于音频信号而言，常见的带宽范围是20 Hz到20 kHz。这意味着音频信号中包含的频率范围从20 Hz到20 kHz，超过或低于这个范围的频率将无法被传输。</p><p>在数字通信中，带宽表示单位时间内可以传输的数据量。通常以比特每秒（bps）或千比特每秒（Kbps）、兆比特每秒（Mbps）等单位来表示。带宽越高，表示在单位时间内可以传输更多的数据，从而提高了数据传输速率。</p><p>需要注意的是，带宽并不等同于数据传输速率。带宽是指信号传输的频率范围或信道的能力，而数据传输速率取决于信号调制、编码和其他因素，可能会受到实际传输环境和设备性能的影响。</p><p>3.码元：</p><p>码元（Symbol）是指数字通信中表示信息的最基本、不可分割的单位。在数字通信系统中，信息经过编码处理后被转换成一系列离散的符号或信号，这些离散的符号即为码元。</p><p>码元可以是数字信号的离散取值，也可以是模拟信号的一组采样值。它代表了一定的信息量或符号，可以表示一位或多位的二进制数据。根据具体的编码方式和调制方法，码元可以有不同的取值和持续时间。</p><p>常用的二进制码元有两个取值：0和1，分别表示低电平和高电平、低功率和高功率、无振幅和有振幅等。除了二进制码元外，还存在多进制码元，如四进制（0、1、2、3）或八进制（0~7）等，在相同时间内传输更多的信息。</p><p>在数字通信系统中，通过调制技术将码元映射到特定的物理信号上，例如调幅（AM）、调频（FM）、调相（PM）等。接收端根据调制方式进行解调还原出码元，进而恢复出原始的信息数据。</p><p>码元的持续时间决定了系统的速率和带宽。如果一个码元的持续时间较短，意味着系统传输速率较高，但同时需要更宽的带宽来支持传输。因此，在设计数字通信系统时需要考虑码元的选择、调制方式和带宽等因素，以实现高效可靠的数据传输。</p><p>3.其他：</p><p>来自信源的信号常称为<strong>基带信号</strong>（即基本频带信号）。像计算机输出的代表各种文字图像文件的数据信号都属于基带信号。基带信号往往包含较多的低频分量，甚至有直流分而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号行调制（modulation）。</p><p>调制可分为两大类。一类是仅仅对基带信号的波形进行变换，使它能够与信道特性适应。变换后的信号仍然是基带信号。这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此大家更愿意把这种过程称为<strong>编码</strong>（coding）。另一类调制则需要使用<strong>载波</strong>（carrier）进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>（即仅在一段频率范围内能够通过信道），而使用载波的调制称为<strong>带通调制</strong>。</p><h3 id="常见编码方式"><a href="#常见编码方式" class="headerlink" title="常见编码方式"></a>常见编码方式</h3><ol><li>不归零制</li><li>归零制</li><li>曼彻斯特编码</li><li>差分曼彻斯特编码</li></ol><h3 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h3><ol><li>调幅</li><li>调频</li><li>调相</li></ol><h2 id="2-信道"><a href="#2-信道" class="headerlink" title="2.信道"></a>2.信道</h2><p>在前面信道的术语阐述里，信道的物理实现可以是：双绞线，同轴电缆，光缆，无线电波等</p><p>在开启下面有关信道的内容时，请先容我提出一个关于快递系统问题：</p><p>小明，小红，小蓝分别从a,b,c地寄各自的快递x,y,z到A,B,C地,问如何用最少的资源，最短的时间将快递顺利送达？</p><p><strong>答案是显而易见的：</strong></p><p><strong>最少的资源实现方法：在a,b,c之间，A，B，C之间各建立一个分拣中心，统一收发快递。快递车只需负责送往两地分拣中心即可</strong></p><p><strong>最短的时间实现方法：要么快递车一次性多装点货物要么提高快递车的速度要么同时增加快递车的数量。</strong></p><h2 id="3-信道的复用技术："><a href="#3-信道的复用技术：" class="headerlink" title="3.信道的复用技术："></a>3.信道的复用技术：</h2><p>为什么要信道复用？</p><p>信道复用是指在有限的信道资源中，通过合理的方式同时传输多个通信信号。这样做的目的是为了提高信道的利用效率和容量，实现多用户同时进行通信而不相互干扰。</p><p>与信道有关的联系是，信道是传输通信信号的媒介，它可以是电缆、光纤或者无线传输介质。每个信道都有一定的带宽，表征了信道能够传输的最高频率范围。而信道复用则是在这个有限的频率范围内有效地分配和共享资源。</p><p>信道复用的好处主要体现在以下几个方面：</p><ol><li>提高信道利用效率：通过信道复用，多个通信信号可以在同一个信道上同时传输，充分利用了信道资源，避免了资源的闲置浪费。</li><li>增加信道容量：由于信道复用可以将多个通信信号同时传输，因此可以提高信道的容量，使得更多的用户或设备可以同时进行通信。</li><li>减少成本：信道资源是宝贵且有限的，通过信道复用可以节省新建信道的成本，提高网络的经济效益。</li></ol><p>信道复用的种类有哪些？</p><p>信道复用可以采用不同的复用技术，常见的技术包括频分复用（Frequency Division Multiplexing，FDM）、时分复用（Time Division Multiplexing，TDM）和码分复用（Code Division Multiplexing，CDM）等。这些技术通过将信道分割成不同的子信道或时间片，并为每个用户或设备分配相应的资源，实现多个通信信号在同一个信道上同时传输</p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>一条100m宽马路一次只能通行一辆10m宽的快递车，倘若有10个收货人，第10名肯定得急死也降低了公路的使用率。有什么办法可以改善呢？假如我们用栅栏从中将马路分成10分，一次性不就可以通行10辆车了！</p><p>频分复用（Frequency Division Multiplexing，FDM）是一种将多个信号通过调制不同的载波频率在一个信道中传输的技术。其基本原理是将一段频率范围划分成若干个子频带，每个传输用户占据单独的一个或多个子频带，不同符号从不同的子频带中传输，通过将多个子信号叠加在同一信道中传输，完成多路信号的传输。</p><p>在FDM系统中，每个用户所使用的带宽都是固定不变的，因此不会互相干扰。目前应用广泛的有线电视、广播和移动通信等系统中采用了FDM技术。FDM技术具有传输速率高、带宽利用率高以及接收灵敏度高等优点，但也存在传输容量固定、系统复杂度高、对信噪比要求高以及频率分配受到限制等缺点。</p><h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p>前面谈到频分复用，但考虑这样的极端情况：100个子信道中只有1个信道在传输数据或者100的带宽资源被分成10000份。这两种情况下不仅导致信道利用率下降还会导致每个用户在单位时间内可以传输的数据量也就相应降低了，从而导致单位时间内传输的数据量减少。有没有一种方法解决呢？</p><p>时分复用（Time Division Multiplexing，TDM）是一种信道复用技术，它将单个物理信道分成多个子信道，每个子信道只在特定的时间段内被分配给一个通信设备或用户进行传输。TDM 技术通常应用于数字通信系统中，可以有效地利用带宽资源，提高信道容量和利用效率。</p><p>在 TDM 中，物理信道按照时间分割成若干个时隙，每个时隙都是固定长度的时间片。不同的用户或设备按照轮流使用时隙的方式，即在不同的时间段内占用相同的时隙。这样，所有的用户或设备可以在同一个物理信道上进行同时传输，而不会相互干扰。</p><p>例如，假设有 4 个用户需要进行通信，每个用户需要传输的数据速率都为 10 Mbps，但只有一个 40 Mbps 的物理信道可供使用。如果使用时间分割复用技术，可以将物理信道分成 40 个时隙，每个时隙的时长为 1&#x2F;40 秒。然后将这 40 个时隙分配给不同的用户，让它们依次占用各自的时隙，如下图所示：</p><p>Copy Code</p><p><em>|</em>—- <em>10 Mbps</em> —-<em>|</em>—- <em>10 Mbps</em> —-<em>|</em>—- <em>10 Mbps</em> —-<em>|</em>—- <em>10 Mbps</em> —-<em>|</em></p><p><em>|</em>&lt;—- <em>1&#x2F;40 s* —-&gt;</em>|<em>&lt;—- *1&#x2F;40 s* —-&gt;</em>|<em>&lt;—- *1&#x2F;40 s* —-&gt;</em>|<em>&lt;—- *1&#x2F;40 s* —-&gt;</em>|*</p><p><em>User 1 User 2 User 3 User 4</em></p><p>在这个例子中，每个用户只需要传输 10 Mbps 的数据，因此不同的用户只需要占用相应数量的时隙即可。当所有用户都在轮流使用时隙进行传输时，就可以实现多用户同时传输，而不会互相干扰，从而提高了信道的利用效率和容量。</p><p>需要注意的是，TDM 技术需要精确的时钟同步，在发送端和接收端都需要有严格的时序控制。这对于实现准确同步、协调多个用户的传输速率等方面提出了挑战，但是这些问题可以通过一些专门的技术手段来解决。</p><p>问题：</p><p><img src="https://pic1.zhimg.com/v2-38dee6ce266028cea9ccc95ebe54f872_1440w.jpg" alt="img"></p><h3 id="统计时分复用（进阶版时分复用）"><a href="#统计时分复用（进阶版时分复用）" class="headerlink" title="统计时分复用（进阶版时分复用）"></a>统计时分复用（进阶版时分复用）</h3><p>统计时分复用（Statistical Time Division Multiplexing，STDM）是一种基于时分复用（TDM）的数据传输技术，它在时分复用的基础上引入了动态分配的机制。</p><p>在传统的时分复用中，每个用户被分配一个固定的时间片段进行数据传输，无论这个时间片段内有无实际数据需要传输。这样可能导致带宽资源的浪费。而在统计时分复用中，分配给每个用户的时间片段不再是固定的，而是根据实际数据传输需求进行动态分配。</p><p>具体来说，统计时分复用的过程如下：</p><ol><li>收集用户的数据：系统根据用户发送数据的需求，收集各个用户的数据。</li><li>动态分配时间片段：根据用户的数据量和传输需求，系统动态地分配时间片段给每个用户。数据量较大的用户可以获得更多的时间片段，而数据量较小的用户则分配较少的时间片段。</li><li>数据传输：在各自分配到的时间片段内，用户将自己的数据通过时分复用的方式进行传输。由于时间片段是根据实际需求进行动态调整的，因此可以更好地利用带宽资源。</li></ol><p><img src="https://pica.zhimg.com/v2-394665827202f5d2b43ea2e161e709f6_1440w.jpg" alt="img"></p><h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p>码分复用（Code Division Multiplexing，CDM）是一种用于多用户间同时使用同一频带传输数据的技术。与频分复用不同，码分复用采用了更为复杂的调制方式来实现多路信号的复用。</p><p>码分复用通过将每个用户的数据码序列进行编码，再将它们映射到不同的、周期性变化的码片上。每个码片都由一个伪随机码片序列（Pseudo-Random Noise Sequence，PRN序列）生成，是一段具有随机性质的比特序列。每个用户的编码器所使用的伪随机码片序列都是不同的，因此不同用户的码片之间互不干扰。由于码片之间具有正交性，因此不同用户的数据可以同时在同一频率带宽上传输，而不会相互干扰。</p><p>在接收端，接收器使用相同的伪随机码片序列对接收到的信号进行解码。由于每个码片都具有正交性质，因此只有接收器使用正确的伪随机码片序列进行解码时，才能够提取出该用户发送的数据。其他码片的数据则被解码后视为噪声而被滤除掉。</p><p>码分复用已经被广泛应用于移动通信、卫星通信以及军事通信等领域。它具有以下几个特点：</p><ol><li>码分复用的带宽利用率高，多路信号可以在同一频率带宽上进行传输。</li><li>码分复用具有优秀的抗干扰性能，因为每个用户的数据都被编码成具有随机性质的码片，相互之间不存在相关关系，因此即使是强烈的干扰也很难对其造成影响。</li><li>码分复用可以实现灵活的资源管理，根据用户需求动态地分配码片资源，提高了系统的效率和灵活性。</li></ol><p>以上就是码分复用的工作原理，它通过将多个用户的数据映射到不同的码片上，并通过使用相同的伪随机码片序列对数据进行解码，实现了多用户同时在同一频带宽上传输数据的目的。</p><p>码片序列的正交关系（数学公式）</p><p><img src="https://pic3.zhimg.com/v2-23da0729e5dcc9c2430f4feb956d72b2_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-4f4e68a70043b7ddb057e06a2fc2caff_1440w.jpg" alt="img"></p><p>CDMA工作原理：</p><p><img src="https://picx.zhimg.com/v2-e4c59ad9d8ed6d244d23e6e9cf92d4fd_1440w.jpg" alt="img"></p><h2 id="4-宽带接入技术"><a href="#4-宽带接入技术" class="headerlink" title="4.宽带接入技术"></a>4.宽带接入技术</h2><ol><li>ADSL<br>ADSL（Asymmetric Digital Subscriber Line）是一种基于普通电话线提供高速数据传输的技术，它采用数字信号复用技术，将语音和数据流分离在不同的频段上进行传输。ADSL的特点是上行和下行带宽不对称，支持高速上网和多媒体通信，但受到距离限制，信号衰减会导致传输速率下降。ADSL常用于家庭用户和小型企业的宽带接入。</li><li>HFC网<br>HFC（Hybrid Fiber Coaxial）是一种混合光纤同轴电缆网络结构，结合了光纤和同轴电缆的优点，具有高速信号传输和容量大的特点，适用于高密度住宅区和商业地区的大规模宽带接入。HFC通过将信号从中心办公室发送到周围的同轴电缆节点，再通过同轴电缆向用户终端传输，同时还可以提供电视信号等多种服务。</li><li>FTTx技术</li></ol><p>FTTx是一系列基于光纤的宽带接入技术，包括FTTH（Fiber to the Home）、FTTC（Fiber to the Curb）和FTTB（Fiber to the Building）等。FTTx技术的特点是光纤传输距离远、带宽大、干扰小、速率高，并且未来可升级性好，可以满足用户日益增长的带宽需求。其中，FTTH是将光纤直接引入用户家中的技术，提供最高的传输速率和质量，目前被认为是宽带接入的最佳技术。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx时间管理与定时器</title>
    <link href="/2023/02/18/Nginx%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/2023/02/18/Nginx%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx时间管理与定时器"><a href="#Nginx时间管理与定时器" class="headerlink" title="Nginx时间管理与定时器"></a>Nginx时间管理与定时器</h1><h2 id="我眼中的是时间管理"><a href="#我眼中的是时间管理" class="headerlink" title="我眼中的是时间管理"></a>我眼中的是时间管理</h2><p>从系统调用函数直接获取当前时间</p><h2 id="我眼中的定时器"><a href="#我眼中的定时器" class="headerlink" title="我眼中的定时器"></a>我眼中的定时器</h2><ul><li>有一定数据结构组织起来【链表】</li><li>有回调处理函数</li></ul><h2 id="Nginx实现的时间管理"><a href="#Nginx实现的时间管理" class="headerlink" title="Nginx实现的时间管理"></a>Nginx实现的时间管理</h2><p><img src="https://s2.loli.net/2024/05/28/sSOeYAMayZW5tjn.png" alt="image-20240528103843360"></p><p><strong>Linux下操作时间的相关函数和结构体</strong></p><p><img src="https://s2.loli.net/2024/05/28/yM82u75C1UdKEkh.png" alt="20200923110542514"></p><ol><li><strong>结构体：</strong><ul><li><strong><code>struct tm</code>：</strong> 用于表示日期和时间的各个组成部分，包括秒、分、时、日、月、年等。</li><li><strong><code>struct timeval</code>：</strong> 用于表示时间间隔的结构体，包括秒和微秒。</li></ul></li><li><strong>函数：</strong><ul><li><strong><code>time_t time(time_t *t)</code>：</strong> 获取当前日历时间的秒数，返回自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来经过的秒数。</li><li><strong><code>int gettimeofday(struct timeval *tv, struct timezone *tz)</code>：</strong> 获取当前时间和时区信息，填充到 <code>struct timeval</code> 结构体和 <code>struct timezone</code> 结构体中。</li><li><strong><code>struct tm *localtime(const time_t *timep)</code>：</strong> 将日历时间转换为本地时间，返回指向 <code>struct tm</code> 结构体的指针。</li><li><strong><code>struct tm *gmtime(const time_t *timep)</code>：</strong> 将日历时间转换为格林尼治时间（UTC 时间），返回指向 <code>struct tm</code> 结构体的指针。</li><li><strong><code>time_t mktime(struct tm *tm)</code>：</strong> 将本地时间或格林尼治时间转换为日历时间，返回对应的日历时间秒数。</li><li><strong><code>char *asctime(const struct tm *tm)</code>：</strong> 将 <code>struct tm</code> 结构体表示的时间转换为字符串格式，并返回一个指向静态分配的字符串的指针。</li><li><strong><code>char *ctime(const time_t *timep)</code>：</strong> 将日历时间转换为字符串格式，并返回一个指向静态分配的字符串的指针。</li></ul></li></ol><h3 id="时间结构体"><a href="#时间结构体" class="headerlink" title="时间结构体"></a>时间结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">time_t</span>      sec;     <span class="hljs-comment">// 秒数</span><br>    <span class="hljs-type">ngx_uint_t</span>  msec;    <span class="hljs-comment">// 毫秒数</span><br>    <span class="hljs-type">ngx_int_t</span>   gmtoff;  <span class="hljs-comment">// GMT偏移量</span><br>&#125; <span class="hljs-type">ngx_time_t</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span>             <span class="hljs-title">ngx_tm_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">int</span> tm_sec;<span class="hljs-comment">/* Seconds.[0-60] (1 leap second) */</span><br>  <span class="hljs-type">int</span> tm_min;<span class="hljs-comment">/* Minutes.[0-59] */</span><br>  <span class="hljs-type">int</span> tm_hour;<span class="hljs-comment">/* Hours.[0-23] */</span><br>  <span class="hljs-type">int</span> tm_mday;<span class="hljs-comment">/* Day.[1-31] */</span><br>  <span class="hljs-type">int</span> tm_mon;<span class="hljs-comment">/* Month.[0-11] */</span><br>  <span class="hljs-type">int</span> tm_year;<span class="hljs-comment">/* Year- 1900.  */</span><br>  <span class="hljs-type">int</span> tm_wday;<span class="hljs-comment">/* Day of week.[0-6] */</span><br>  <span class="hljs-type">int</span> tm_yday;<span class="hljs-comment">/* Days in year.[0-365]*/</span><br>  <span class="hljs-type">int</span> tm_isdst;<span class="hljs-comment">/* DST.[-1/0/1]*/</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">ifdef</span>__USE_MISC</span><br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> tm_gmtoff;<span class="hljs-comment">/* Seconds east of UTC.  */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *tm_zone;<span class="hljs-comment">/* Timezone abbreviation.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> __tm_gmtoff;<span class="hljs-comment">/* Seconds east of UTC.  */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *__tm_zone;<span class="hljs-comment">/* Timezone abbreviation.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意差别：</p><ol><li><strong><code>struct tm</code> 结构体：</strong><ul><li><code>struct tm</code> 结构体是标准 C 库 <code>&lt;time.h&gt;</code> 中定义的，在很多 C 语言的标准库中都可以找到。</li><li>它用于表示日期和时间的各个组成部分，如年、月、日、时、分、秒等，并提供了一些其他与时间相关的信息，如周几、一年中的第几天、夏令时标志等。</li><li>它通常用于时间日期的转换和格式化，例如将时间戳转换为人类可读的日期时间格式，或者将日期时间格式解析为时间戳等操作。</li></ul></li><li><strong><code>ngx_tm_t</code> 结构体：</strong><ul><li><code>ngx_tm_t</code> 结构体是在 Nginx 源码中定义的，用于表示 Nginx 内部的时间信息。</li><li>它与标准的 <code>struct tm</code> 结构体类似，但通常只包含了时间的基本信息，如秒数、毫秒数等，并没有包含日期、周几、时区等额外信息。</li><li>它通常用于 Nginx 内部的时间操作，如计算时间差、时间戳的获取、时间的更新等。</li></ul></li></ol><p><strong><code>struct tm</code> 结构体更加通用，适用于标准 C 语言环境下的时间操作，而 <code>ngx_tm_t</code> 结构体则是针对 Nginx 内部的时间处理需求而设计的，更加简洁和高效。</strong></p><h4 id="全局时间缓存"><a href="#全局时间缓存" class="headerlink" title="全局时间缓存"></a>全局时间缓存</h4><p>用于存储当前时间及其不同格式的字符串表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_time_t</span>        cached_time[NGX_TIME_SLOTS];<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_time_t</span>  *ngx_cached_time;<br></code></pre></td></tr></table></figure><h4 id="简单科普一下GMT与ISO-8601"><a href="#简单科普一下GMT与ISO-8601" class="headerlink" title="简单科普一下GMT与ISO 8601"></a>简单科普一下GMT与ISO 8601</h4><h5 id="ISO-8601-时间格式"><a href="#ISO-8601-时间格式" class="headerlink" title="ISO 8601 时间格式"></a>ISO 8601 时间格式</h5><p><strong>ISO 8601</strong> 是国际标准化组织（ISO）发布的日期和时间表示法标准，旨在提供一种清晰、一致的方式来表示日期和时间。其主要特点和格式如下：</p><ol><li><p><strong>日期格式</strong>：</p><ul><li><code>YYYY-MM-DD</code>：四位数的年份，二位数的月份和日期。例如，2024年5月27日表示为 <code>2024-05-27</code>。</li></ul></li><li><p><strong>时间格式</strong>：</p><ul><li><code>hh:mm:ss</code>：二位数的小时、分钟和秒。例如，下午2点30分45秒表示为 <code>14:30:45</code>。</li></ul></li><li><p><strong>日期和时间的组合</strong>：</p><ul><li><code>YYYY-MM-DDThh:mm:ss</code>：日期和时间通过字母“T”连接。例如，2024年5月27日下午2点30分45秒表示为 <code>2024-05-27T14:30:45</code>。</li></ul></li><li><p><strong>时区表示</strong>：</p><ul><li><code>Z</code>：表示时间是以UTC（协调世界时）表示。例如，<code>2024-05-27T14:30:45Z</code>。</li><li><code>±hh:mm</code>：表示相对于UTC的偏移量。例如，东八区的时间可以表示为 <code>2024-05-</code></li></ul><p><img src="https://s2.loli.net/2024/05/28/Zj1BPSaDcnbWfiu.png" alt="下载"></p></li></ol><h5 id="什么是-GMT？"><a href="#什么是-GMT？" class="headerlink" title="什么是 GMT？"></a>什么是 GMT？</h5><p>GMT（Greenwich Mean Time，格林尼治标准时间）是指通过位于英国伦敦的皇家格林尼治天文台测定的时间。GMT 是全球统一的时间基准，用于定义世界各地的时间。它曾是国际标准时间，但现在更多使用的是 UTC（协调世界时），两者在日常使用中通常被认为是等价的。</p><h5 id="相对于-GMT-的偏移量"><a href="#相对于-GMT-的偏移量" class="headerlink" title="相对于 GMT 的偏移量"></a>相对于 GMT 的偏移量</h5><p>相对于 GMT 的偏移量（GMT offset）表示一个地区的本地时间与 GMT 之间的时差。偏移量通常以小时或分钟为单位，可以是正数也可以是负数。例如：</p><ul><li><strong>UTC+8</strong>：表示当地时间比 GMT 快 8 小时。这适用于像中国这样的国家。</li><li><strong>UTC-5</strong>：表示当地时间比 GMT 慢 5 小时。这适用于美国东部标准时间。</li></ul><h5 id="GMT-与-UTC"><a href="#GMT-与-UTC" class="headerlink" title="GMT 与 UTC"></a>GMT 与 UTC</h5><p><strong>GMT（格林尼治标准时间）</strong> 和 <strong>UTC（协调世界时）</strong> 通常被用来表示世界时间的标准，但二者略有不同：</p><ul><li><strong>GMT</strong>：格林尼治标准时间，是指通过位于英国伦敦的格林尼治天文台的时间。这是一种历史标准，通常被认为等同于UTC。</li><li><strong>UTC</strong>：协调世界时，是基于原子钟的时间标准，精度更高。UTC 是现代国际时间标准。</li></ul><h5 id="具体时间实例"><a href="#具体时间实例" class="headerlink" title="具体时间实例"></a>具体时间实例</h5><p>假设当前的 GMT 时间是 2024 年 5 月 27 日 12:00:00（中午 12 点）。</p><ul><li>在北京（UTC+8），当地时间是 2024 年 5 月 27 日 20:00:00（晚上 8 点）。</li><li>在纽约（UTC-5），当地时间是 2024 年 5 月 27 日 07:00:00（早上 7 点）。</li></ul><p><img src="https://s2.loli.net/2024/05/28/RiXWBKvckgdVPUt.jpg" alt="What is gmt time zone? - Yoors"></p><h4 id="全局缓存的时间字符串"><a href="#全局缓存的时间字符串" class="headerlink" title="全局缓存的时间字符串"></a><strong>全局缓存的时间字符串</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_err_log_time;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_http_time;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_http_log_time;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_http_log_iso8601;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_syslog_time;<br></code></pre></td></tr></table></figure><hr><h3 id="初始化时间缓存"><a href="#初始化时间缓存" class="headerlink" title="初始化时间缓存"></a>初始化时间缓存</h3><p> <strong><code>ngx_time_init</code> 的作用是初始化 Nginx 的时间缓存系统，为日志记录和时间格式化等操作提供预定义的时间格式。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_time_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 设置时间字符串的长度</span><br>    ngx_cached_err_log_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;1970/09/28 12:00:00&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置错误日志时间格式的字符串长度。</span><br>    ngx_cached_http_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置HTTP头部时间格式的字符串长度。</span><br>    ngx_cached_http_log_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;28/Sep/1970:12:00:00 +0600&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置HTTP日志时间格式的字符串长度。</span><br>    ngx_cached_http_log_iso8601.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;1970-09-28T12:00:00+06:00&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置ISO 8601格式的时间字符串长度。</span><br>    ngx_cached_syslog_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Sep 28 12:00:00&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置系统日志时间格式的字符串长度。</span><br><br>    ngx_cached_time = &amp;cached_time[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化全局时间缓存指针</span><br><br>    ngx_time_update(); <span class="hljs-comment">// 更新时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="更新时间缓存"><a href="#更新时间缓存" class="headerlink" title="更新时间缓存"></a>更新时间缓存</h4><p><strong><code>ngx_time_update</code> 函数用于更新 Nginx 的时间缓存。这个函数会获取当前的时间，将其转换为多种格式，并缓存起来，以便在日志记录和其他需要时间的地方高效使用。通过缓存时间，可以减少频繁调用系统时间获取函数的开销，提高系统性能。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_time_update</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    u_char          *p0, *p1, *p2, *p3, *p4;<br>    <span class="hljs-type">ngx_tm_t</span>         tm, gmt;<br>    <span class="hljs-type">time_t</span>           sec;<br>    <span class="hljs-type">ngx_uint_t</span>       msec;<br>    <span class="hljs-type">ngx_time_t</span>      *tp;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span>   <span class="hljs-title">tv</span>;</span><br><br>    <span class="hljs-comment">// 尝试加锁，确保线程安全</span><br>    <span class="hljs-keyword">if</span> (!ngx_trylock(&amp;ngx_time_lock)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前时间</span><br>    ngx_gettimeofday(&amp;tv);<br><br>    sec = tv.tv_sec; <span class="hljs-comment">// 秒</span><br>    msec = tv.tv_usec / <span class="hljs-number">1000</span>; <span class="hljs-comment">// 毫秒</span><br><br>    ngx_current_msec = ngx_monotonic_time(sec, msec); <span class="hljs-comment">// 获取单调时间（毫秒）</span><br><br>    tp = &amp;cached_time[slot];<br><br>    <span class="hljs-comment">// 如果秒数没有变化，只更新毫秒值并解锁返回</span><br>    <span class="hljs-keyword">if</span> (tp-&gt;sec == sec) &#123;<br>        tp-&gt;msec = msec;<br>        ngx_unlock(&amp;ngx_time_lock);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新缓存槽位</span><br>    <span class="hljs-keyword">if</span> (slot == NGX_TIME_SLOTS - <span class="hljs-number">1</span>) &#123;<br>        slot = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        slot++;<br>    &#125;<br><br>    tp = &amp;cached_time[slot];<br><br>    tp-&gt;sec = sec; <span class="hljs-comment">// 更新秒</span><br>    tp-&gt;msec = msec; <span class="hljs-comment">// 更新毫秒</span><br><br>    <span class="hljs-comment">// 将时间转换为 GMT 时间</span><br>    ngx_gmtime(sec, &amp;gmt);<br><br>    <span class="hljs-comment">// 更新 HTTP 时间缓存</span><br>    p0 = &amp;cached_http_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p0, <span class="hljs-string">&quot;%s, %02d %s %4d %02d:%02d:%02d GMT&quot;</span>,<br>                       week[gmt.ngx_tm_wday], gmt.ngx_tm_mday,<br>                       months[gmt.ngx_tm_mon - <span class="hljs-number">1</span>], gmt.ngx_tm_year,<br>                       gmt.ngx_tm_hour, gmt.ngx_tm_min, gmt.ngx_tm_sec);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_GETTIMEZONE)</span><br><br>    tp-&gt;gmtoff = ngx_gettimezone(); <span class="hljs-comment">// 获取时区偏移量</span><br>    ngx_gmtime(sec + tp-&gt;gmtoff * <span class="hljs-number">60</span>, &amp;tm); <span class="hljs-comment">// 计算本地时间</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (NGX_HAVE_GMTOFF)</span><br><br>    ngx_localtime(sec, &amp;tm); <span class="hljs-comment">// 获取本地时间</span><br>    cached_gmtoff = (<span class="hljs-type">ngx_int_t</span>) (tm.ngx_tm_gmtoff / <span class="hljs-number">60</span>);<br>    tp-&gt;gmtoff = cached_gmtoff; <span class="hljs-comment">// 更新时区偏移量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    ngx_localtime(sec, &amp;tm); <span class="hljs-comment">// 获取本地时间</span><br>    cached_gmtoff = ngx_timezone(tm.ngx_tm_isdst); <span class="hljs-comment">// 计算时区</span><br>    tp-&gt;gmtoff = cached_gmtoff; <span class="hljs-comment">// 更新时区偏移量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 更新错误日志时间缓存</span><br>    p1 = &amp;cached_err_log_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p1, <span class="hljs-string">&quot;%4d/%02d/%02d %02d:%02d:%02d&quot;</span>,<br>                       tm.ngx_tm_year, tm.ngx_tm_mon,<br>                       tm.ngx_tm_mday, tm.ngx_tm_hour,<br>                       tm.ngx_tm_min, tm.ngx_tm_sec);<br><br>    <span class="hljs-comment">// 更新 HTTP 日志时间缓存</span><br>    p2 = &amp;cached_http_log_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p2, <span class="hljs-string">&quot;%02d/%s/%d:%02d:%02d:%02d %c%02i%02i&quot;</span>,<br>                       tm.ngx_tm_mday, months[tm.ngx_tm_mon - <span class="hljs-number">1</span>],<br>                       tm.ngx_tm_year, tm.ngx_tm_hour,<br>                       tm.ngx_tm_min, tm.ngx_tm_sec,<br>                       tp-&gt;gmtoff &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;-&#x27;</span> : <span class="hljs-string">&#x27;+&#x27;</span>,<br>                       ngx_abs(tp-&gt;gmtoff / <span class="hljs-number">60</span>), ngx_abs(tp-&gt;gmtoff % <span class="hljs-number">60</span>));<br><br>    <span class="hljs-comment">// 更新 ISO8601 格式的时间缓存</span><br>    p3 = &amp;cached_http_log_iso8601[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p3, <span class="hljs-string">&quot;%4d-%02d-%02dT%02d:%02d:%02d%c%02i:%02i&quot;</span>,<br>                       tm.ngx_tm_year, tm.ngx_tm_mon,<br>                       tm.ngx_tm_mday, tm.ngx_tm_hour,<br>                       tm.ngx_tm_min, tm.ngx_tm_sec,<br>                       tp-&gt;gmtoff &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;-&#x27;</span> : <span class="hljs-string">&#x27;+&#x27;</span>,<br>                       ngx_abs(tp-&gt;gmtoff / <span class="hljs-number">60</span>), ngx_abs(tp-&gt;gmtoff % <span class="hljs-number">60</span>));<br><br>    <span class="hljs-comment">// 更新系统日志时间缓存</span><br>    p4 = &amp;cached_syslog_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p4, <span class="hljs-string">&quot;%s %2d %02d:%02d:%02d&quot;</span>,<br>                       months[tm.ngx_tm_mon - <span class="hljs-number">1</span>], tm.ngx_tm_mday,<br>                       tm.ngx_tm_hour, tm.ngx_tm_min, tm.ngx_tm_sec);<br><br>    <span class="hljs-comment">// 内存屏障，确保写操作的顺序性</span><br>    ngx_memory_barrier();<br><br>    <span class="hljs-comment">// 更新全局时间缓存指针</span><br>    ngx_cached_time = tp;<br>    ngx_cached_http_time.data = p0;<br>    ngx_cached_err_log_time.data = p1;<br>    ngx_cached_http_log_time.data = p2;<br>    ngx_cached_http_log_iso8601.data = p3;<br>    ngx_cached_syslog_time.data = p4;<br><br>    <span class="hljs-comment">// 解锁</span><br>    ngx_unlock(&amp;ngx_time_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="格式化转换"><a href="#格式化转换" class="headerlink" title="格式化转换"></a>格式化转换</h5><p><strong><code>ngx_gmtime</code> 函数的作用是将一个 <code>time_t</code> 类型的时间值转换为一个 <code>ngx_tm_t</code> 结构体，该结构体包含人类可读的时间信息（例如年、月、日、小时、分钟和秒）。该函数类似于标准库中的 <code>gmtime</code> 函数，但进行了专门的实现和优化，以满足 Nginx 的特定需求。</strong></p><blockquote><p><code>time_t</code> 是一种在标准 C 库中定义的类型，用于表示日历时间。通常，它表示从 1970 年 1 月 1 日 00:00:00 UTC（称为 Unix 纪元）以来经过的秒数。具体的实现可以是一个整数或一个浮点数，取决于平台。</p></blockquote><blockquote><p>在 Nginx 中，<code>time_t</code> 通常用于存储秒级精度的时间戳。<code>ngx_time_t</code> 是一个自定义的时间结构体，扩展了 <code>time_t</code> 的功能，以包含毫秒和 GMT 偏移量等信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_gmtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> t, <span class="hljs-type">ngx_tm_t</span> *tp)</span> &#123;<br>    <span class="hljs-type">ngx_int_t</span>   yday;<br>    <span class="hljs-type">ngx_uint_t</span>  sec, min, hour, mday, mon, year, wday, days, leap;<br><br>    <span class="hljs-comment">// 该计算仅适用于正的 time_t 值</span><br>    <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) &#123;<br>        t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    days = t / <span class="hljs-number">86400</span>; <span class="hljs-comment">// 计算总天数</span><br>    sec = t % <span class="hljs-number">86400</span>;  <span class="hljs-comment">// 计算一天中的秒数</span><br><br>    <span class="hljs-comment">// 支持的最大日期为9999年12月31日23:59:59</span><br>    <span class="hljs-keyword">if</span> (days &gt; <span class="hljs-number">2932896</span>) &#123;<br>        days = <span class="hljs-number">2932896</span>;<br>        sec = <span class="hljs-number">86399</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1970年1月1日是星期四</span><br>    wday = (<span class="hljs-number">4</span> + days) % <span class="hljs-number">7</span>;<br><br>    hour = sec / <span class="hljs-number">3600</span>; <span class="hljs-comment">// 计算小时</span><br>    sec %= <span class="hljs-number">3600</span>;<br>    min = sec / <span class="hljs-number">60</span>;    <span class="hljs-comment">// 计算分钟</span><br>    sec %= <span class="hljs-number">60</span>;         <span class="hljs-comment">// 计算秒</span><br><br>    <span class="hljs-comment">// 基于高斯公式的算法，详见 src/core/ngx_parse_time.c</span><br>    days = days - (<span class="hljs-number">31</span> + <span class="hljs-number">28</span>) + <span class="hljs-number">719527</span>; <span class="hljs-comment">// 自公元前1年3月1日以来的天数</span><br><br>    <span class="hljs-comment">// 计算年份，公式中调整了2天以处理某些年份的3月1日</span><br>    year = (days + <span class="hljs-number">2</span>) * <span class="hljs-number">400</span> / (<span class="hljs-number">365</span> * <span class="hljs-number">400</span> + <span class="hljs-number">100</span> - <span class="hljs-number">4</span> + <span class="hljs-number">1</span>);<br><br>    yday = days - (<span class="hljs-number">365</span> * year + year / <span class="hljs-number">4</span> - year / <span class="hljs-number">100</span> + year / <span class="hljs-number">400</span>);<br><br>    <span class="hljs-comment">// 处理负的 yday 值（闰年）</span><br>    <span class="hljs-keyword">if</span> (yday &lt; <span class="hljs-number">0</span>) &#123;<br>        leap = (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (year % <span class="hljs-number">100</span> || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>));<br>        yday = <span class="hljs-number">365</span> + leap + yday;<br>        year--;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 yday 映射到月份的经验公式</span><br>    mon = (yday + <span class="hljs-number">31</span>) * <span class="hljs-number">10</span> / <span class="hljs-number">306</span>;<br><br>    <span class="hljs-comment">// 计算月之前的天数的高斯公式</span><br>    mday = yday - (<span class="hljs-number">367</span> * mon / <span class="hljs-number">12</span> - <span class="hljs-number">30</span>) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (yday &gt;= <span class="hljs-number">306</span>) &#123;<br>        year++;<br>        mon -= <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// Win32 SYSTEMTIME 没有 yday</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mon += <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// Win32 SYSTEMTIME 没有 yday</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置 tp 结构体的各个字段</span><br>    tp-&gt;ngx_tm_sec = (<span class="hljs-type">ngx_tm_sec_t</span>) sec;<br>    tp-&gt;ngx_tm_min = (<span class="hljs-type">ngx_tm_min_t</span>) min;<br>    tp-&gt;ngx_tm_hour = (<span class="hljs-type">ngx_tm_hour_t</span>) hour;<br>    tp-&gt;ngx_tm_mday = (<span class="hljs-type">ngx_tm_mday_t</span>) mday;<br>    tp-&gt;ngx_tm_mon = (<span class="hljs-type">ngx_tm_mon_t</span>) mon;<br>    tp-&gt;ngx_tm_year = (<span class="hljs-type">ngx_tm_year_t</span>) year;<br>    tp-&gt;ngx_tm_wday = (<span class="hljs-type">ngx_tm_wday_t</span>) wday;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置预定时间点"><a href="#设置预定时间点" class="headerlink" title="设置预定时间点"></a>设置预定时间点</h3><p>计算下一个特定时间点的时间戳。给定一个时间戳 <code>when</code>，函数根据当前时间计算出下一个 <code>when</code> 所表示的时分秒时间，然后转换为时间戳。如果下一个时间点比当前时间晚，则返回该时间点的时间戳；否则，将日期加一，再次尝试计算下一个时间点的时间戳，直到计算成功或者达到某种错误条件。</p><p>它通常用于需要在特定时间执行某些任务的情况下，例如定时任务、定时器等场景。在这些场景中，我们可能需要计算下一个执行时间点，以便安排下一次的任务执行。</p><ul><li><strong>定时任务调度器：</strong> 在一个定时任务调度器中，可能会有很多任务需要在特定的时间点执行，这时就可以使用这个函数来计算下一个执行时间点。</li><li><strong>定时器：</strong> 在网络编程中，有时候需要设置定时器来执行一些操作，比如超时处理、定时发送心跳等，这时就可以使用这个函数来计算下一个超时时间点。</li><li><strong>计划任务管理器：</strong> 在系统中可能会有一些计划任务需要按照预定的时间执行，这时就可以使用这个函数来计算下一个执行时间点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span><br><span class="hljs-title function_">ngx_next_time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> when)</span><br>&#123;<br>    <span class="hljs-type">time_t</span>     now, next;   <span class="hljs-comment">// 当前时间和下一个时间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span>  <span class="hljs-title">tm</span>;</span>          <span class="hljs-comment">// 结构体 tm 用于存储时间的分解部分</span><br><br>    now = ngx_time();       <span class="hljs-comment">// 获取当前时间</span><br><br>    ngx_libc_localtime(now, &amp;tm);  <span class="hljs-comment">// 将当前时间转换为本地时间，存储在结构体 tm 中</span><br><br>    <span class="hljs-comment">// 计算下一个时间的小时、分钟和秒</span><br>    tm.tm_hour = (<span class="hljs-type">int</span>) (when / <span class="hljs-number">3600</span>);<br>    when %= <span class="hljs-number">3600</span>;<br>    tm.tm_min = (<span class="hljs-type">int</span>) (when / <span class="hljs-number">60</span>);<br>    tm.tm_sec = (<span class="hljs-type">int</span>) (when % <span class="hljs-number">60</span>);<br><br>    <span class="hljs-comment">// 将结构体 tm 转换为 time_t 类型的时间，即计算下一个时间的时间戳</span><br>    next = mktime(&amp;tm);<br><br>    <span class="hljs-comment">// 如果 mktime() 返回 -1，表示转换失败，返回 -1 表示错误</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果下一个时间大于当前时间，则返回下一个时间</span><br>    <span class="hljs-keyword">if</span> (next - now &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果下一个时间小于或等于当前时间，说明已经过了今天的设定时间，需要设定为明天的设定时间</span><br>    tm.tm_mday++;   <span class="hljs-comment">// 将日期加 1</span><br><br>    <span class="hljs-comment">/* mktime() should normalize a date (Jan 32, etc) */</span><br>    <span class="hljs-comment">// 再次尝试计算下一个时间</span><br>    next = mktime(&amp;tm);<br><br>    <span class="hljs-comment">// 如果计算成功，返回下一个时间的时间戳，否则返回 -1 表示错误</span><br>    <span class="hljs-keyword">if</span> (next != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 返回 -1 表示错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转换为-HTTP-时间格式和-Cookie-时间格式"><a href="#转换为-HTTP-时间格式和-Cookie-时间格式" class="headerlink" title="转换为 HTTP 时间格式和 Cookie 时间格式"></a>转换为 HTTP 时间格式和 Cookie 时间格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char *<br><span class="hljs-title function_">ngx_http_time</span><span class="hljs-params">(u_char *buf, <span class="hljs-type">time_t</span> t)</span><br>&#123;<br>    <span class="hljs-type">ngx_tm_t</span>  tm;<br><br>    ngx_gmtime(t, &amp;tm); <span class="hljs-comment">// 将时间戳转换为格林尼治时间</span><br><br>    <span class="hljs-comment">// 将格林尼治时间格式化为 HTTP 时间格式，并写入缓冲区 buf 中</span><br>    <span class="hljs-keyword">return</span> ngx_sprintf(buf, <span class="hljs-string">&quot;%s, %02d %s %4d %02d:%02d:%02d GMT&quot;</span>,<br>                       week[tm.ngx_tm_wday],<br>                       tm.ngx_tm_mday,<br>                       months[tm.ngx_tm_mon - <span class="hljs-number">1</span>],<br>                       tm.ngx_tm_year,<br>                       tm.ngx_tm_hour,<br>                       tm.ngx_tm_min,<br>                       tm.ngx_tm_sec);<br>&#125;<br><br>u_char *<br><span class="hljs-title function_">ngx_http_cookie_time</span><span class="hljs-params">(u_char *buf, <span class="hljs-type">time_t</span> t)</span><br>&#123;<br>    <span class="hljs-type">ngx_tm_t</span>  tm;<br><br>    ngx_gmtime(t, &amp;tm); <span class="hljs-comment">// 将时间戳转换为格林尼治时间</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Netscape 3.x does not understand 4-digit years at all and</span><br><span class="hljs-comment">     * 2-digit years more than &quot;37&quot;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 根据规范格式化为 Cookie 时间格式，并写入缓冲区 buf 中</span><br>    <span class="hljs-keyword">return</span> ngx_sprintf(buf,<br>                       (tm.ngx_tm_year &gt; <span class="hljs-number">2037</span>) ?<br>                                         <span class="hljs-string">&quot;%s, %02d-%s-%d %02d:%02d:%02d GMT&quot;</span>:<br>                                         <span class="hljs-string">&quot;%s, %02d-%s-%02d %02d:%02d:%02d GMT&quot;</span>,<br>                       week[tm.ngx_tm_wday],<br>                       tm.ngx_tm_mday,<br>                       months[tm.ngx_tm_mon - <span class="hljs-number">1</span>],<br>                       (tm.ngx_tm_year &gt; <span class="hljs-number">2037</span>) ? tm.ngx_tm_year:<br>                                                 tm.ngx_tm_year % <span class="hljs-number">100</span>,<br>                       tm.ngx_tm_hour,<br>                       tm.ngx_tm_min,<br>                       tm.ngx_tm_sec);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_time()           ngx_cached_time-&gt;sec</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_timeofday()      (ngx_time_t *) ngx_cached_time</span><br></code></pre></td></tr></table></figure><h2 id="Nginx定时器事件"><a href="#Nginx定时器事件" class="headerlink" title="Nginx定时器事件"></a>Nginx定时器事件</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Nginx 定时器事件是 Nginx 服务器中用于管理和处理事件的一种机制，用于实现异步、非阻塞的事件驱动模型。定时器事件主要用于处理与时间相关的事件，如超时事件、定时任务等。</p><p>在 Nginx 中，定时器事件通常用于以下几个方面：</p><ol><li><strong>超时处理</strong>：Nginx 服务器需要处理各种网络请求，如客户端的连接请求、HTTP 请求等。为了避免请求处理时间过长导致资源浪费或性能下降，Nginx 使用定时器事件来管理请求的超时时间，一旦超时，即可将相应的请求标记为超时状态，然后进行相应的处理。</li><li><strong>定时任务</strong>：Nginx 可以执行一些周期性的定时任务，如定时清理日志、定时刷新缓存等。这些定时任务通常也是通过定时器事件来实现的，通过设置一定的时间间隔，定期执行相应的任务。</li><li><strong>事件调度</strong>：定时器事件还用于管理和调度事件的执行顺序。在异步事件处理模型中，事件的触发和执行通常是异步的，而定时器事件可以确保事件按照预定的顺序进行执行，从而保证系统的稳定性和可靠性。</li></ol><p><img src="https://s2.loli.net/2024/05/28/nq19v5TPZf4LNXh.png" alt="image-20240528113151022"></p><h3 id="定时器数据结构"><a href="#定时器数据结构" class="headerlink" title="定时器数据结构"></a>定时器数据结构</h3><p>保存事件的结构体ngx_event_t 中有三个关于时间管理的成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_event_s</span>&#123;</span><br>    ...<br>    <span class="hljs-comment">/* 标志位，为1表示当前事件已超时 */</span>  <br>    <span class="hljs-type">unsigned</span>         timedout:<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">/* 标志位，为1表示当前事件存在于由红黑树维护的定时器中 */</span>  <br>    <span class="hljs-type">unsigned</span>         timer_set:<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">/* 由红黑树维护的定时器 */</span>  <br>    <span class="hljs-type">ngx_rbtree_node_t</span>   timer; <br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>Nginx 设置两个关于定时器的全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 所有定时器事件组成的红黑树 */</span><br>ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span>  ngx_event_timer_rbtree;<br><span class="hljs-comment">/* 红黑树的哨兵节点 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ngx_rbtree_node_t</span>          ngx_event_timer_sentinel;<br></code></pre></td></tr></table></figure><h3 id="初始化事件定时器"><a href="#初始化事件定时器" class="headerlink" title="初始化事件定时器"></a>初始化事件定时器</h3><p>初始化事件定时器，它使用红黑树作为底层数据结构来管理定时事件。函数通过调用 <code>ngx_rbtree_init</code> 初始化了一个红黑树 <code>ngx_event_timer_rbtree</code>，并指定了哨兵节点 <code>ngx_event_timer_sentinel</code>，以及用于比较的插入函数 <code>ngx_rbtree_insert_timer_value</code>。初始化成功后返回状态码 <code>NGX_OK</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化事件定时器，使用红黑树作为底层数据结构。</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     log: 日志对象指针，用于记录初始化过程中的日志信息。</span><br><span class="hljs-comment"> * 返回值：</span><br><span class="hljs-comment"> *     NGX_OK: 初始化成功。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ngx_int_t</span> <span class="hljs-title function_">ngx_event_timer_init</span><span class="hljs-params">(<span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 使用 ngx_rbtree_init 函数初始化红黑树 ngx_event_timer_rbtree，</span><br>    <span class="hljs-comment">// 第一个参数为红黑树的根节点，第二个参数为红黑树的哨兵节点，</span><br>    <span class="hljs-comment">// 第三个参数为插入时用于比较的函数指针 ngx_rbtree_insert_timer_value。</span><br>    ngx_rbtree_init(&amp;ngx_event_timer_rbtree, &amp;ngx_event_timer_sentinel,<br>                    ngx_rbtree_insert_timer_value);<br><br>    <span class="hljs-keyword">return</span> NGX_OK;  <span class="hljs-comment">// 返回初始化成功的状态码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加定时器事件"><a href="#添加定时器事件" class="headerlink" title="添加定时器事件"></a>添加定时器事件</h3><p>向事件定时器中添加指定事件，并设置事件的定时器时间。首先，计算了事件定时器的时间戳，然后判断事件的定时器是否已经设置，如果已经设置，则检查新旧定时器值之间的差异是否小于 <code>NGX_TIMER_LAZY_DELAY</code> 毫秒，如果是，则不添加新的定时器，直接返回，以减少红黑树操作的次数。如果差异超过了阈值，则先从红黑树中删除旧的定时器，然后设置事件的定时器时间，并将事件的定时器插入到红黑树中。最后，设置事件的定时器已被设置标志位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 向事件定时器中添加指定事件，并设置定时器时间。</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     ev: 待添加的事件指针。</span><br><span class="hljs-comment"> *     timer: 定时器的时间，以毫秒为单位。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span> <span class="hljs-title function_">ngx_event_add_timer</span><span class="hljs-params">(<span class="hljs-type">ngx_event_t</span> *ev, <span class="hljs-type">ngx_msec_t</span> timer)</span><br>&#123;<br>    <span class="hljs-type">ngx_msec_t</span>      key;<br>    <span class="hljs-type">ngx_msec_int_t</span>  diff;<br><br>    <span class="hljs-comment">// 计算定时器的时间戳</span><br>    key = ngx_current_msec + timer;<br><br>    <span class="hljs-comment">// 如果事件的定时器已经设置，则检查新旧定时器值之间的差异是否小于 NGX_TIMER_LAZY_DELAY 毫秒，</span><br>    <span class="hljs-comment">// 如果是，则不添加新的定时器，直接返回，这样可以减少红黑树操作的次数，提高性能。</span><br>    <span class="hljs-keyword">if</span> (ev-&gt;timer_set) &#123;<br><br>        diff = (<span class="hljs-type">ngx_msec_int_t</span>) (key - ev-&gt;timer.key);<br><br>        <span class="hljs-keyword">if</span> (ngx_abs(diff) &lt; NGX_TIMER_LAZY_DELAY) &#123;<br>            <span class="hljs-comment">// 调试日志记录定时器更新情况。</span><br>            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;event timer: %d, old: %M, new: %M&quot;</span>,<br>                           ngx_event_ident(ev-&gt;data), ev-&gt;timer.key, key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 从红黑树中删除旧的定时器。</span><br>        ngx_del_timer(ev);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置事件的定时器时间。</span><br>    ev-&gt;timer.key = key;<br><br>    <span class="hljs-comment">// 调试日志记录定时器添加情况。</span><br>    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                   <span class="hljs-string">&quot;event timer add: %d: %M:%M&quot;</span>,<br>                   ngx_event_ident(ev-&gt;data), timer, ev-&gt;timer.key);<br><br>    <span class="hljs-comment">// 将事件的定时器插入到红黑树中。</span><br>    ngx_rbtree_insert(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);<br><br>    <span class="hljs-comment">// 设置事件的定时器已被设置标志位。</span><br>    ev-&gt;timer_set = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除定时器事件"><a href="#删除定时器事件" class="headerlink" title="删除定时器事件"></a>删除定时器事件</h3><p>从事件定时器中移除指定的事件，并清除事件相关的定时器数据。首先，通过调试日志记录了被删除的事件的标识符和定时器键值。然后，通过调用 <code>ngx_rbtree_delete</code> 函数从红黑树中删除了事件的定时器。最后，如果编译时启用了调试模式（<code>NGX_DEBUG</code> 宏定义），则清空了事件的定时器节点的左、右、父节点，用于调试目的。最后，将事件的 <code>timer_set</code> 标志位设置为 0，表示事件的定时器已被移除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从事件定时器中移除指定的事件，并清除事件相关的定时器数据。</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     ev: 待移除的事件指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span> <span class="hljs-title function_">ngx_event_del_timer</span><span class="hljs-params">(<span class="hljs-type">ngx_event_t</span> *ev)</span><br>&#123;<br>    <span class="hljs-comment">// 记录调试日志，包括事件标识符和定时器键值。</span><br>    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                   <span class="hljs-string">&quot;event timer del: %d: %M&quot;</span>,<br>                   ngx_event_ident(ev-&gt;data), ev-&gt;timer.key);<br><br>    <span class="hljs-comment">// 从红黑树中删除事件的定时器。</span><br>    ngx_rbtree_delete(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_DEBUG)</span><br>    <span class="hljs-comment">// 清空事件的定时器节点的左、右、父节点，用于调试。</span><br>    ev-&gt;timer.left = <span class="hljs-literal">NULL</span>;<br>    ev-&gt;timer.right = <span class="hljs-literal">NULL</span>;<br>    ev-&gt;timer.parent = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 标记事件的定时器已被移除。</span><br>    ev-&gt;timer_set = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找最近定时器时间"><a href="#查找最近定时器时间" class="headerlink" title="查找最近定时器时间"></a>查找最近定时器时间</h3><p>查找事件定时器中最近的定时器时间。如果事件定时器为空，则返回无限大的定时器时间。否则，遍历红黑树找到最小的定时器节点，计算最近的定时器时间，并返回该时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 查找事件定时器中最近的定时器时间。</span><br><span class="hljs-comment"> * 返回值：</span><br><span class="hljs-comment"> *     返回值为事件定时器中最近的定时器时间，以毫秒为单位。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ngx_msec_t</span> <span class="hljs-title function_">ngx_event_find_timer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">ngx_msec_int_t</span>      timer;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *node, *root, *sentinel;<br><br>    <span class="hljs-comment">// 如果事件定时器为空，则返回无限大的定时器时间。</span><br>    <span class="hljs-keyword">if</span> (ngx_event_timer_rbtree.root == &amp;ngx_event_timer_sentinel) &#123;<br>        <span class="hljs-keyword">return</span> NGX_TIMER_INFINITE;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取事件定时器的根节点和哨兵节点。</span><br>    root = ngx_event_timer_rbtree.root;<br>    sentinel = ngx_event_timer_rbtree.sentinel;<br><br>    <span class="hljs-comment">// 查找事件定时器中最小的定时器节点。</span><br>    node = ngx_rbtree_min(root, sentinel);<br><br>    <span class="hljs-comment">// 计算最近的定时器时间。</span><br>    timer = (<span class="hljs-type">ngx_msec_int_t</span>) (node-&gt;key - ngx_current_msec);<br><br>    <span class="hljs-comment">// 返回最近的定时器时间，如果定时器时间小于等于0，则返回0。</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">ngx_msec_t</span>) (timer &gt; <span class="hljs-number">0</span> ? timer : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理已经过期的事件定时器"><a href="#处理已经过期的事件定时器" class="headerlink" title="处理已经过期的事件定时器"></a>处理已经过期的事件定时器</h3><p>处理已经过期的事件定时器。它会遍历事件定时器红黑树，找到所有已经过期的事件定时器，并调用相应的事件处理函数来处理这些已经过期的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 处理已经过期的事件定时器。</span><br><span class="hljs-comment"> * 该函数会遍历事件定时器红黑树，处理所有已经过期的事件定时器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_event_expire_timers</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">ngx_event_t</span>        *ev;        <span class="hljs-comment">// 指向已经过期的事件</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *node, *root, *sentinel;  <span class="hljs-comment">// 用于遍历红黑树的节点指针</span><br><br>    sentinel = ngx_event_timer_rbtree.sentinel;  <span class="hljs-comment">// 获取红黑树的哨兵节点</span><br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br>        root = ngx_event_timer_rbtree.root;  <span class="hljs-comment">// 获取红黑树的根节点</span><br><br>        <span class="hljs-comment">// 如果根节点是哨兵节点，表示事件定时器为空，直接返回</span><br>        <span class="hljs-keyword">if</span> (root == sentinel) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找红黑树中最小的定时器节点</span><br>        node = ngx_rbtree_min(root, sentinel);<br><br>        <span class="hljs-comment">// 如果最小节点的定时器时间大于当前时间，表示没有事件定时器过期，直接返回</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">ngx_msec_int_t</span>) (node-&gt;key - ngx_current_msec) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取对应的事件对象</span><br>        ev = ngx_rbtree_data(node, <span class="hljs-type">ngx_event_t</span>, timer);<br><br>        <span class="hljs-comment">// 打印调试日志，表示该事件定时器已经过期</span><br>        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                       <span class="hljs-string">&quot;event timer del: %d: %M&quot;</span>,<br>                       ngx_event_ident(ev-&gt;data), ev-&gt;timer.key);<br><br>        <span class="hljs-comment">// 从红黑树中删除该事件定时器</span><br>        ngx_rbtree_delete(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_DEBUG)</span><br>        <span class="hljs-comment">// 清空定时器节点的左右子节点和父节点指针（仅在调试模式下有效）</span><br>        ev-&gt;timer.left = <span class="hljs-literal">NULL</span>;<br>        ev-&gt;timer.right = <span class="hljs-literal">NULL</span>;<br>        ev-&gt;timer.parent = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// 将事件的 timer_set 标志位清零，表示该事件的定时器已经被删除</span><br>        ev-&gt;timer_set = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 设置事件的 timedout 标志位为1，表示该事件已经超时</span><br>        ev-&gt;timedout = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 调用事件的 handler 处理函数，处理超时事件</span><br>        ev-&gt;handler(ev);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>利用缓存尽量减少调用系统函数以提高系统性能</li><li>Linux下的时间相关处理与程序在不同时区内运行的准确性</li><li>时间格式的转换</li></ul><p>限于篇幅限制，定时器事件执行与Nginx事件模块将会在下一篇中介绍。</p><hr>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx日志系统</title>
    <link href="/2023/02/10/Nginx%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/02/10/Nginx%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="我眼里的日志系统："><a href="#我眼里的日志系统：" class="headerlink" title="我眼里的日志系统："></a>我眼里的日志系统：</h2><p>发生异常—-&gt;将异常信息写入日志文件——&gt;退出</p><h2 id="Nginx实现的日志系统"><a href="#Nginx实现的日志系统" class="headerlink" title="Nginx实现的日志系统"></a>Nginx实现的日志系统</h2><p><img src="https://s2.loli.net/2024/05/27/L1OfGAd982xwKpQ.png" alt="image-20240527210455690"></p><h3 id="专门的日志数据结构"><a href="#专门的日志数据结构" class="headerlink" title="专门的日志数据结构"></a>专门的日志数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_log_s</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>           log_level;            <span class="hljs-comment">// 日志级别，用于控制日志的详细程度（例如，DEBUG、INFO、ERROR 等）</span><br>    <span class="hljs-type">ngx_open_file_t</span>     *file;                 <span class="hljs-comment">// 指向打开文件的指针，表示日志输出的目标文件</span><br>    <span class="hljs-type">ngx_atomic_uint_t</span>    connection;           <span class="hljs-comment">// 记录当前连接数，使用原子类型以保证多线程环境下的安全性</span><br>    <span class="hljs-type">time_t</span>               disk_full_time;       <span class="hljs-comment">// 上次磁盘满时间，用于记录磁盘满的时间戳</span><br>    ngx_log_handler_pt   handler;              <span class="hljs-comment">// 自定义日志处理函数指针，用于特殊日志处理</span><br>    <span class="hljs-type">void</span>                *data;                 <span class="hljs-comment">// 任意类型的指针，可以存放与日志相关的附加数据</span><br>    ngx_log_writer_pt    writer;               <span class="hljs-comment">// 自定义日志写入函数指针，用于特殊日志写入方式</span><br>    <span class="hljs-type">void</span>                *wdata;                <span class="hljs-comment">// 任意类型的指针，可以存放与日志写入相关的附加数据</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 我们将 &quot;action&quot; 声明为 &quot;char *&quot; 类型，因为动作通常是静态字符串，</span><br><span class="hljs-comment">     * 如果使用 &quot;u_char *&quot; 类型，我们需要经常覆盖其类型。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">char</span>                *action;               <span class="hljs-comment">// 描述当前操作的字符串（例如，&quot;reading client request&quot;）</span><br>    <span class="hljs-type">ngx_log_t</span>           *next;                 <span class="hljs-comment">// 指向下一个日志对象的指针，用于支持链式日志记录</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Nginx的文件描述"><a href="#Nginx的文件描述" class="headerlink" title="Nginx的文件描述"></a>Nginx的文件描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_open_file_s</span> &#123;</span><br>    <span class="hljs-type">ngx_fd_t</span>              fd;       <span class="hljs-comment">// 文件描述符</span><br>    <span class="hljs-type">ngx_str_t</span>             name;     <span class="hljs-comment">// 文件名</span><br><br>    <span class="hljs-type">void</span>                (*flush)(<span class="hljs-type">ngx_open_file_t</span> *file, <span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>);  <span class="hljs-comment">// 刷新文件缓冲区函数指针</span><br>    <span class="hljs-type">void</span>                 *data;     <span class="hljs-comment">// 指向用户自定义数据的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="将错误日志进行分类—-等级数组"><a href="#将错误日志进行分类—-等级数组" class="headerlink" title="将错误日志进行分类—&gt;等级数组"></a>将错误日志进行分类—&gt;等级数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_str_t</span> err_levels[] = &#123;<br>    ngx_null_string,<br>    ngx_string(<span class="hljs-string">&quot;emerg&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;alert&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;crit&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;error&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;warn&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;notice&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;info&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;debug&quot;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="初始化日志文件"><a href="#初始化日志文件" class="headerlink" title="初始化日志文件"></a>初始化日志文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_log_t</span> * <span class="hljs-title function_">ngx_log_init</span><span class="hljs-params">(u_char *prefix, u_char *error_log)</span><br>&#123;<br>    u_char  *p, *name;<br>    <span class="hljs-type">size_t</span>   nlen, plen;<br><br>    <span class="hljs-comment">// 初始化全局的 ngx_log 结构</span><br>    ngx_log.file = &amp;ngx_log_file;<br>    ngx_log.log_level = NGX_LOG_NOTICE;  <span class="hljs-comment">// 将默认日志级别设置为 NOTICE</span><br><br>    <span class="hljs-comment">// 如果未提供错误日志路径，则使用默认错误日志路径</span><br>    <span class="hljs-keyword">if</span> (error_log == <span class="hljs-literal">NULL</span>) &#123;<br>        error_log = (u_char *) NGX_ERROR_LOG_PATH;<br>    &#125;<br><br>    name = error_log;  <span class="hljs-comment">// 将提供的错误日志路径赋给 name</span><br>    nlen = ngx_strlen(name);  <span class="hljs-comment">// 获取错误日志路径的长度</span><br><br>    <span class="hljs-comment">// 如果错误日志路径为空，则使用标准错误输出（stderr）</span><br>    <span class="hljs-keyword">if</span> (nlen == <span class="hljs-number">0</span>) &#123;<br>        ngx_log_file.fd = ngx_stderr;<br>        <span class="hljs-keyword">return</span> &amp;ngx_log;<br>    &#125;<br><br>    p = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果错误日志路径不是绝对路径，则需要拼接前缀</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_WIN32)</span><br>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-keyword">if</span> (prefix) &#123;<br>            plen = ngx_strlen(prefix);  <span class="hljs-comment">// 计算前缀的长度</span><br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NGX_PREFIX</span><br>            prefix = (u_char *) NGX_PREFIX;<br>            plen = ngx_strlen(prefix);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            plen = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (plen) &#123;<br>            name = <span class="hljs-built_in">malloc</span>(plen + nlen + <span class="hljs-number">2</span>);  <span class="hljs-comment">// 分配存储路径的内存空间</span><br>            <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br><br>            p = ngx_cpymem(name, prefix, plen);  <span class="hljs-comment">// 将前缀拷贝到路径中</span><br><br>            <span class="hljs-keyword">if</span> (!ngx_path_separator(*(p - <span class="hljs-number">1</span>))) &#123;  <span class="hljs-comment">// 如果前缀末尾没有路径分隔符，则添加</span><br>                *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>            &#125;<br><br>            ngx_cpystrn(p, error_log, nlen + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 将错误日志路径拷贝到路径末尾</span><br><br>            p = name;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 打开错误日志文件</span><br>    ngx_log_file.fd = ngx_open_file(name, NGX_FILE_APPEND,<br>                                    NGX_FILE_CREATE_OR_OPEN,<br>                                    NGX_FILE_DEFAULT_ACCESS);<br><br>    <span class="hljs-comment">// 如果打开文件失败，则输出错误日志到标准错误输出（stderr）</span><br>    <span class="hljs-keyword">if</span> (ngx_log_file.fd == NGX_INVALID_FILE) &#123;<br>        ngx_log_stderr(ngx_errno,<br>                       <span class="hljs-string">&quot;[alert] could not open error log file: &quot;</span><br>                       ngx_open_file_n <span class="hljs-string">&quot; \&quot;%s\&quot; failed&quot;</span>, name);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_WIN32)</span><br>        ngx_event_log(ngx_errno,<br>                       <span class="hljs-string">&quot;could not open error log file: &quot;</span><br>                       ngx_open_file_n <span class="hljs-string">&quot; \&quot;%s\&quot; failed&quot;</span>, name);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        ngx_log_file.fd = ngx_stderr;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放分配的内存</span><br>    <span class="hljs-keyword">if</span> (p) &#123;<br>        ngx_free(p);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;ngx_log;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置日志文件配置项"><a href="#设置日志文件配置项" class="headerlink" title="设置日志文件配置项"></a>设置日志文件配置项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<br><span class="hljs-title function_">ngx_log_set_log</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">ngx_log_t</span> **head)</span><br>&#123;<br>    <span class="hljs-type">ngx_log_t</span>          *new_log;           <span class="hljs-comment">// 新日志结构体</span><br>    <span class="hljs-type">ngx_str_t</span>          *value, name;      <span class="hljs-comment">// 配置项值和名称</span><br>    <span class="hljs-type">ngx_syslog_peer_t</span>  *peer;            <span class="hljs-comment">// syslog 配置结构体</span><br><br>    <span class="hljs-comment">// 如果当前日志链表已存在且日志级别为0，表示已存在一个未指定级别的日志结构</span><br>    <span class="hljs-keyword">if</span> (*head != <span class="hljs-literal">NULL</span> &amp;&amp; (*head)-&gt;log_level == <span class="hljs-number">0</span>) &#123;<br>        new_log = *head;  <span class="hljs-comment">// 直接使用现有的日志结构</span><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则，创建一个新的日志结构</span><br>        new_log = ngx_pcalloc(cf-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_log_t</span>));<br>        <span class="hljs-keyword">if</span> (new_log == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果当前日志链表为空，则将新日志结构设置为链表的头部</span><br>        <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>) &#123;<br>            *head = new_log;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取配置项参数值</span><br>    value = cf-&gt;args-&gt;elts;<br><br>    <span class="hljs-comment">// 如果配置为输出到标准错误输出</span><br>    <span class="hljs-keyword">if</span> (ngx_strcmp(value[<span class="hljs-number">1</span>].data, <span class="hljs-string">&quot;stderr&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        ngx_str_null(&amp;name);  <span class="hljs-comment">// 清空日志文件名</span><br>        cf-&gt;cycle-&gt;log_use_stderr = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标记使用标准错误输出</span><br><br>        <span class="hljs-comment">// 打开标准错误输出文件</span><br>        new_log-&gt;file = ngx_conf_open_file(cf-&gt;cycle, &amp;name);<br>        <span class="hljs-keyword">if</span> (new_log-&gt;file == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>    <span class="hljs-comment">// 如果配置为输出到内存</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ngx_strncmp(value[<span class="hljs-number">1</span>].data, <span class="hljs-string">&quot;memory:&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_DEBUG)</span><br>        <span class="hljs-type">size_t</span>                 size, needed;  <span class="hljs-comment">// 缓冲区大小及所需大小</span><br>        <span class="hljs-type">ngx_pool_cleanup_t</span>    *cln;          <span class="hljs-comment">// 清理回调结构体</span><br>        <span class="hljs-type">ngx_log_memory_buf_t</span>  *buf;         <span class="hljs-comment">// 内存日志缓冲区</span><br><br>        <span class="hljs-comment">// 去除&quot;memory:&quot;前缀</span><br>        value[<span class="hljs-number">1</span>].len -= <span class="hljs-number">7</span>;<br>        value[<span class="hljs-number">1</span>].data += <span class="hljs-number">7</span>;<br><br>        <span class="hljs-comment">// 计算所需的缓冲区大小</span><br>        needed = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;MEMLOG  :&quot;</span> NGX_LINEFEED)<br>                 + cf-&gt;conf_file-&gt;file.name.len<br>                 + NGX_SIZE_T_LEN<br>                 + NGX_INT_T_LEN<br>                 + NGX_MAX_ERROR_STR;<br><br>        <span class="hljs-comment">// 解析配置的缓冲区大小</span><br>        size = ngx_parse_size(&amp;value[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">// 如果解析失败或缓冲区太小，则返回错误</span><br>        <span class="hljs-keyword">if</span> (size == (<span class="hljs-type">size_t</span>) NGX_ERROR || size &lt; needed) &#123;<br>            ngx_conf_log_error(NGX_LOG_EMERG, cf, <span class="hljs-number">0</span>,<br>                               <span class="hljs-string">&quot;invalid buffer size \&quot;%V\&quot;&quot;</span>, &amp;value[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 分配内存日志缓冲区</span><br>        buf = ngx_pcalloc(cf-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_log_memory_buf_t</span>));<br>        <span class="hljs-keyword">if</span> (buf == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 分配缓冲区内存</span><br>        buf-&gt;start = ngx_pnalloc(cf-&gt;pool, size);<br>        <span class="hljs-keyword">if</span> (buf-&gt;start == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        buf-&gt;end = buf-&gt;start + size;<br><br>        <span class="hljs-comment">// 初始化缓冲区，记录日志文件名及行号</span><br>        buf-&gt;pos = ngx_slprintf(buf-&gt;start, buf-&gt;end, <span class="hljs-string">&quot;MEMLOG %uz %V:%ui%N&quot;</span>,<br>                                size, &amp;cf-&gt;conf_file-&gt;file.name,<br>                                cf-&gt;conf_file-&gt;line);<br><br>        <span class="hljs-comment">// 填充剩余空间为 &#x27; &#x27;</span><br>        ngx_memset(buf-&gt;pos, <span class="hljs-string">&#x27; &#x27;</span>, buf-&gt;end - buf-&gt;pos);<br><br>        <span class="hljs-comment">// 设置清理回调，用于释放内存日志缓冲区</span><br>        cln = ngx_pool_cleanup_add(cf-&gt;pool, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (cln == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        cln-&gt;data = new_log;<br>        cln-&gt;handler = ngx_log_memory_cleanup;<br><br>        <span class="hljs-comment">// 设置日志写入函数和写入数据</span><br>        new_log-&gt;writer = ngx_log_memory_writer;<br>        new_log-&gt;wdata = buf;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        ngx_conf_log_error(NGX_LOG_EMERG, cf, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;nginx was built without debug support&quot;</span>);<br>        <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 如果配置为输出到syslog</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ngx_strncmp(value[<span class="hljs-number">1</span>].data, <span class="hljs-string">&quot;syslog:&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配syslog配置结构体</span><br>        peer = ngx_pcalloc(cf-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_syslog_peer_t</span>));<br>        <span class="hljs-keyword">if</span> (peer == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理syslog配置</span><br>        <span class="hljs-keyword">if</span> (ngx_syslog_process_conf(cf, peer) != NGX_CONF_OK) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置日志写入函数和写入数据</span><br>        new_log-&gt;writer = ngx_syslog_writer;<br>        new_log-&gt;wdata = peer;<br><br>    <span class="hljs-comment">// 其他情况，输出到指定文件</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 打开指定文件</span><br>        new_log-&gt;file = ngx_conf_open_file(cf-&gt;cycle, &amp;value[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (new_log-&gt;file == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置日志级别</span><br>    <span class="hljs-keyword">if</span> (ngx_log_set_levels(cf, new_log) != NGX_CONF_OK) &#123;<br>        <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果日志链表不为空，则将新日志插入到链表中</span><br>    <span class="hljs-keyword">if</span> (*head != new_log) &#123;<br>        ngx_log_insert(*head, new_log);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_CONF_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="格式化错误信息"><a href="#格式化错误信息" class="headerlink" title="格式化错误信息"></a>格式化错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> ngx_cdecl<br><span class="hljs-title function_">ngx_log_abort</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    u_char   *p;<br>    va_list   args;<br>    u_char    errstr[NGX_MAX_CONF_ERRSTR];<br><br>    <span class="hljs-comment">//使用va_start宏开始对可变参数的处理，并调用ngx_vsnprintf函数将格式化字符串fmt和可变参数args写入errstr数组中，生成格式化的错误信息</span><br>    va_start(args, fmt);<br>    p = ngx_vsnprintf(errstr, <span class="hljs-keyword">sizeof</span>(errstr) - <span class="hljs-number">1</span>, fmt, args);<br>    va_end(args);<br>   <span class="hljs-comment">//将生成的错误信息以NGX_LOG_ALERT级别写入到nginx的日志中</span><br>    ngx_log_error(NGX_LOG_ALERT, ngx_cycle-&gt;<span class="hljs-built_in">log</span>, err,<br>                  <span class="hljs-string">&quot;%*s&quot;</span>, p - errstr, errstr);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="错误码err转换为对应的错误描述"><a href="#错误码err转换为对应的错误描述" class="headerlink" title="错误码err转换为对应的错误描述"></a>错误码err转换为对应的错误描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char *<br><span class="hljs-title function_">ngx_log_errno</span><span class="hljs-params">(u_char *buf, u_char *last, <span class="hljs-type">ngx_err_t</span> err)</span><br>&#123;<br>    <span class="hljs-comment">//首先函数进行了边界检查，确保在向缓冲区写入前还有足够的空间。如果缓冲区的剩余空间不足50个字节，就会留出一个空间用于放置错误码，然后在缓冲区的末尾写入三个点号&quot;...&quot;，以表示截断了部分错误信息。</span><br>    <span class="hljs-keyword">if</span> (buf &gt; last - <span class="hljs-number">50</span>) &#123;<br>        <span class="hljs-comment">/* leave a space for an error code */</span><br><br>        buf = last - <span class="hljs-number">50</span>;<br>        *buf++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        *buf++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        *buf++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_WIN32)</span><br>    buf = ngx_slprintf(buf, last, ((<span class="hljs-type">unsigned</span>) err &lt; <span class="hljs-number">0x80000000</span>)<br>                                       ? <span class="hljs-string">&quot; (%d: &quot;</span> : <span class="hljs-string">&quot; (%Xd: &quot;</span>, err);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    buf = ngx_slprintf(buf, last, <span class="hljs-string">&quot; (%d: &quot;</span>, err);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//调用ngx_strerror函数将错误码转换为对应的错误描述，并将描述信息追加到缓冲区中</span><br>    buf = ngx_strerror(err, buf, last - buf);<br><br>    <span class="hljs-keyword">if</span> (buf &lt; last) &#123;<br>        *buf++ = <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常信息首先输入到缓冲区"><a href="#异常信息首先输入到缓冲区" class="headerlink" title="异常信息首先输入到缓冲区"></a>异常信息首先输入到缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char * ngx_cdecl<br><span class="hljs-title function_">ngx_slprintf</span><span class="hljs-params">(u_char *buf, u_char *last, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    u_char   *p;<br>    va_list   args;<br><br>    va_start(args, fmt);<br>    p = ngx_vslprintf(buf, last, fmt, args);<br>    va_end(args);<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打开-新建日志文件并插入日志链表"><a href="#打开-新建日志文件并插入日志链表" class="headerlink" title="打开&#x2F;新建日志文件并插入日志链表"></a>打开&#x2F;新建日志文件并插入日志链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_log_open_default</span><span class="hljs-params">(<span class="hljs-type">ngx_cycle_t</span> *cycle)</span><br>&#123;<br>    <span class="hljs-type">ngx_log_t</span>  *<span class="hljs-built_in">log</span>;<br><br>    <span class="hljs-keyword">if</span> (ngx_log_get_file_log(&amp;cycle-&gt;new_log) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_OK;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cycle-&gt;new_log.log_level != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* there are some error logs, but no files */</span><br><br>        <span class="hljs-built_in">log</span> = ngx_pcalloc(cycle-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_log_t</span>));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span> == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* no error logs at all */</span><br>        <span class="hljs-built_in">log</span> = &amp;cycle-&gt;new_log;<br>    &#125;<br><br>    <span class="hljs-built_in">log</span>-&gt;log_level = NGX_LOG_ERR;<br><br>    <span class="hljs-built_in">log</span>-&gt;file = ngx_conf_open_file(cycle, &amp;cycle-&gt;error_log);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>-&gt;file == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span> != &amp;cycle-&gt;new_log) &#123;<br>        ngx_log_insert(&amp;cycle-&gt;new_log, <span class="hljs-built_in">log</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取日志文件"><a href="#获取日志文件" class="headerlink" title="获取日志文件"></a>获取日志文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_log_t</span> *<br><span class="hljs-title function_">ngx_log_get_file_log</span><span class="hljs-params">(<span class="hljs-type">ngx_log_t</span> *head)</span><br>&#123;<br>    <span class="hljs-type">ngx_log_t</span>  *<span class="hljs-built_in">log</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">log</span> = head; <span class="hljs-built_in">log</span>; <span class="hljs-built_in">log</span> = <span class="hljs-built_in">log</span>-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>-&gt;file != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">log</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="刷入磁盘"><a href="#刷入磁盘" class="headerlink" title="刷入磁盘"></a>刷入磁盘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将文本写入标准错误流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_write_stderr</span><span class="hljs-params">(<span class="hljs-type">char</span> *text)</span><br>&#123;<br>    (<span class="hljs-type">void</span>) ngx_write_fd(ngx_stderr, text, ngx_strlen(text));<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将文本写入标准输出流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_write_stdout</span><span class="hljs-params">(<span class="hljs-type">char</span> *text)</span><br>&#123;<br>    (<span class="hljs-type">void</span>) ngx_write_fd(ngx_stdout, text, ngx_strlen(text));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在指定文件描述符上写入数据</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     - fd：文件描述符</span><br><span class="hljs-comment"> *     - buf：待写入数据的缓冲区指针</span><br><span class="hljs-comment"> *     - n：待写入数据的字节数</span><br><span class="hljs-comment"> * 返回值：</span><br><span class="hljs-comment"> *     成功：返回写入的字节数</span><br><span class="hljs-comment"> *     失败：返回-1，并设置errno为对应的错误码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">ssize_t</span><br><span class="hljs-title function_">ngx_write_fd</span><span class="hljs-params">(<span class="hljs-type">ngx_fd_t</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> write(fd, buf, n);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="输入到控制台的功能"><a href="#输入到控制台的功能" class="headerlink" title="输入到控制台的功能"></a>输入到控制台的功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> ngx_cdecl<br><span class="hljs-title function_">ngx_log_stderr</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    u_char   *p, *last;   <span class="hljs-comment">// 指向错误信息字符串的指针</span><br>    va_list   args;       <span class="hljs-comment">// 可变参数列表</span><br>    u_char    errstr[NGX_MAX_ERROR_STR];  <span class="hljs-comment">// 错误信息缓冲区</span><br><br>    last = errstr + NGX_MAX_ERROR_STR;  <span class="hljs-comment">// 缓冲区的末尾位置</span><br>    p = ngx_cpymem(errstr, <span class="hljs-string">&quot;nginx: &quot;</span>, <span class="hljs-number">7</span>);  <span class="hljs-comment">// 将固定的前缀拷贝到缓冲区</span><br>    va_start(args, fmt);  <span class="hljs-comment">// 初始化可变参数列表</span><br>    p = ngx_vslprintf(p, last, fmt, args);  <span class="hljs-comment">// 将格式化字符串和参数格式化到缓冲区</span><br>    va_end(args);  <span class="hljs-comment">// 结束可变参数列表</span><br><br>    <span class="hljs-comment">// 如果有错误码，将错误码添加到错误信息中</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        p = ngx_log_errno(p, last, err);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果错误信息超出缓冲区末尾，截断字符串</span><br>    <span class="hljs-keyword">if</span> (p &gt; last - NGX_LINEFEED_SIZE) &#123;<br>        p = last - NGX_LINEFEED_SIZE;<br>    &#125;<br><br>    ngx_linefeed(p);  <span class="hljs-comment">// 添加换行符</span><br><br>    <span class="hljs-comment">// 将错误信息输出到标准错误流</span><br>    (<span class="hljs-type">void</span>) ngx_write_console(ngx_stderr, errstr, p - errstr);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Nginx有关错误宏定义"><a href="#Nginx有关错误宏定义" class="headerlink" title="Nginx有关错误宏定义"></a>Nginx有关错误宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EPERM 1<span class="hljs-comment">/* Operation not permitted */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOENT 2<span class="hljs-comment">/* No such file or directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ESRCH 3<span class="hljs-comment">/* No such process */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EINTR 4<span class="hljs-comment">/* Interrupted system call */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EIO 5<span class="hljs-comment">/* I/O error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENXIO 6<span class="hljs-comment">/* No such device or address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>E2BIG 7<span class="hljs-comment">/* Argument list too long */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOEXEC 8<span class="hljs-comment">/* Exec format error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EBADF 9<span class="hljs-comment">/* Bad file number */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ECHILD10<span class="hljs-comment">/* No child processes */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EAGAIN11<span class="hljs-comment">/* Try again */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOMEM12<span class="hljs-comment">/* Out of memory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EACCES13<span class="hljs-comment">/* Permission denied */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EFAULT14<span class="hljs-comment">/* Bad address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOTBLK15<span class="hljs-comment">/* Block device required */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EBUSY16<span class="hljs-comment">/* Device or resource busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EEXIST17<span class="hljs-comment">/* File exists */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EXDEV18<span class="hljs-comment">/* Cross-device link */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENODEV19<span class="hljs-comment">/* No such device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOTDIR20<span class="hljs-comment">/* Not a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EISDIR21<span class="hljs-comment">/* Is a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EINVAL22<span class="hljs-comment">/* Invalid argument */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENFILE23<span class="hljs-comment">/* File table overflow */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EMFILE24<span class="hljs-comment">/* Too many open files */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOTTY25<span class="hljs-comment">/* Not a typewriter */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ETXTBSY26<span class="hljs-comment">/* Text file busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EFBIG27<span class="hljs-comment">/* File too large */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOSPC28<span class="hljs-comment">/* No space left on device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ESPIPE29<span class="hljs-comment">/* Illegal seek */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EROFS30<span class="hljs-comment">/* Read-only file system */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EMLINK31<span class="hljs-comment">/* Too many links */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EPIPE32<span class="hljs-comment">/* Broken pipe */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EDOM33<span class="hljs-comment">/* Math argument out of domain of func */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ERANGE34<span class="hljs-comment">/* Math result not representable */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="Nginx处理错误字符串"><a href="#Nginx处理错误字符串" class="headerlink" title="Nginx处理错误字符串"></a>Nginx处理错误字符串</h2><p>选择不同的方法来获取错误信息并将其复制到指定的缓冲区中。</p><ol><li>第一部分使用了<code>strerrordesc_np</code>函数，该函数在glibc 2.32中引入。它是异步信号安全的，可以直接使用它来获取系统错误信息，而无需复制错误消息。如果系统支持这个函数，就直接调用它获取错误信息。如果不支持，则使用预定义的<code>ngx_unknown_error</code>。</li><li>第二部分处理了不支持<code>strerrordesc_np</code>的情况，主要是为了兼容之前的版本。它首先初始化了一个错误消息列表，存储了系统中可能的错误消息。然后通过<code>strerror</code>函数获取每个错误码对应的错误消息，并将其存储在动态分配的内存中。这样，在需要获取错误信息时，就可以根据错误码直接在列表中查找对应的错误消息了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_str_t</span>   ngx_unknown_error = ngx_string(<span class="hljs-string">&quot;Unknown error&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_STRERRORDESC_NP)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * strerrordesc_np()函数是在glibc 2.32中引入的，是异步信号安全的。</span><br><span class="hljs-comment"> * 这使得可以直接使用它，而不需要复制错误消息。</span><br><span class="hljs-comment"> */</span><br><br>u_char *<br><span class="hljs-title function_">ngx_strerror</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, u_char *errstr, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">size_t</span>       len;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>  *msg;<br><br>    msg = strerrordesc_np(err);<br><br>    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">NULL</span>) &#123;<br>        msg = (<span class="hljs-type">char</span> *) ngx_unknown_error.data;<br>        len = ngx_unknown_error.len;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        len = ngx_strlen(msg);<br>    &#125;<br><br>    size = ngx_min(size, len);<br><br>    <span class="hljs-keyword">return</span> ngx_cpymem(errstr, msg, size);<br>&#125;<br><br><br><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_strerror_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * strerror()消息被复制，原因是：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1) strerror()和strerror_r()函数不是异步信号安全的，</span><br><span class="hljs-comment"> *    因此不能在信号处理程序中使用；</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2) 可以使用直接的sys_errlist[]数组来替代这些函数，</span><br><span class="hljs-comment"> *    但Linux链接器会警告其使用：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * warning: `sys_errlist&#x27; is deprecated; use `strerror&#x27; or `strerror_r&#x27; instead</span><br><span class="hljs-comment"> * warning: `sys_nerr&#x27; is deprecated; use `strerror&#x27; or `strerror_r&#x27; instead</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    这会导致错误的bug报告。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">ngx_str_t</span>  *ngx_sys_errlist;<br><span class="hljs-type">static</span> <span class="hljs-type">ngx_err_t</span>   ngx_first_error;<br><span class="hljs-type">static</span> <span class="hljs-type">ngx_err_t</span>   ngx_last_error;<br><br>u_char *<br><span class="hljs-title function_">ngx_strerror</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, u_char *errstr, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">ngx_str_t</span>  *msg;<br><br>    <span class="hljs-keyword">if</span> (err &gt;= ngx_first_error &amp;&amp; err &lt; ngx_last_error) &#123;<br>        msg = &amp;ngx_sys_errlist[err - ngx_first_error];<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        msg = &amp;ngx_unknown_error;<br>    &#125;<br><br>    size = ngx_min(size, msg-&gt;len);<br><br>    <span class="hljs-keyword">return</span> ngx_cpymem(errstr, msg-&gt;data, size);<br>&#125;<br><br><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_strerror_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span>       *msg;<br>    u_char     *p;<br>    <span class="hljs-type">size_t</span>      len;<br>    <span class="hljs-type">ngx_err_t</span>   err;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_SYS_NERR)</span><br>    ngx_first_error = <span class="hljs-number">0</span>;<br>    ngx_last_error = NGX_SYS_NERR;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (EPERM &gt; 1000 &amp;&amp; EPERM &lt; 0x7fffffff - 1000)</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果错误数未知，并且EPERM错误代码有很大但合理的值，</span><br><span class="hljs-comment">     * 则根据strerror()返回的错误消息从EPERM开始猜测可能的错误代码。</span><br><span class="hljs-comment">     * 特别是，这包括GNU/Hurd，其错误从0x40000001开始。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">for</span> (err = EPERM; err &gt; EPERM - <span class="hljs-number">1000</span>; err--) &#123;<br>        ngx_set_errno(<span class="hljs-number">0</span>);<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (errno == EINVAL<br>            || msg == <span class="hljs-literal">NULL</span><br>            || <span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">&quot;Unknown error&quot;</span>, <span class="hljs-number">13</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ngx_first_error = err;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (err = EPERM; err &lt; EPERM + <span class="hljs-number">1000</span>; err++) &#123;<br>        ngx_set_errno(<span class="hljs-number">0</span>);<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (errno == EINVAL<br>            || msg == <span class="hljs-literal">NULL</span><br>            || <span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">&quot;Unknown error&quot;</span>, <span class="hljs-number">13</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ngx_last_error = err + <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果错误数未知，则根据strerror()返回的错误消息猜测错误数。</span><br><span class="hljs-comment">     */</span><br><br>    ngx_first_error = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (err = <span class="hljs-number">0</span>; err &lt; <span class="hljs-number">1000</span>; err++) &#123;<br>        ngx_set_errno(<span class="hljs-number">0</span>);<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (errno == EINVAL<br>            || msg == <span class="hljs-literal">NULL</span><br>            || <span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">&quot;Unknown error&quot;</span>, <span class="hljs-number">13</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ngx_last_error = err + <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ngx_strerror()在此阶段尚不准备工作，因此使用malloc()，</span><br><span class="hljs-comment">     * 并使用strerror()记录可能的错误。</span><br><span class="hljs-comment">     */</span><br><br>    len = (ngx_last_error - ngx_first_error) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_str_t</span>);<br><br>    ngx_sys_errlist = <span class="hljs-built_in">malloc</span>(len);<br>    <span class="hljs-keyword">if</span> (ngx_sys_errlist == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (err = ngx_first_error; err &lt; ngx_last_error; err++) &#123;<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_sys_errlist[err - ngx_first_error] = ngx_unknown_error;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        len = ngx_strlen(msg);<br><br>        p = <span class="hljs-built_in">malloc</span>(len);<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br><br>        ngx_memcpy(p, msg, len);<br>        ngx_sys_errlist[err - ngx_first_error].len = len;<br>        ngx_sys_errlist[err - ngx_first_error].data = p;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br><br>failed:<br><br>    err = errno;<br>    ngx_log_stderr(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;malloc(%uz) failed (%d: %s)&quot;</span>, len, err, strerror(err));<br><br>    <span class="hljs-keyword">return</span> NGX_ERROR;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>封装专门的日志和文件数据结构</li><li>分类异常信息</li><li>先读入缓冲区后刷入磁盘</li><li>日志链表设计以及日志配置设计</li><li>格式化输入输出</li><li>刷入磁盘</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="/2023/02/10/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2023/02/10/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早年在知乎发的文章，现转载到博客上</p></blockquote><h2 id="1-数据链路层"><a href="#1-数据链路层" class="headerlink" title="1.数据链路层"></a>1.数据链路层</h2><p>就像上一节物理层所总结的那样，物理层通过各种传输介质（例如光纤、铜线等）实现了数据的物理传输。</p><p>而链路层处理的是相邻节点之间的数据传输问题，它利用物理层提供的物理介质提供了面向连接的通信，确保数据帧在相邻节点之间可靠传输。</p><p><em>想象一辆货车在运输货物的过程中，可以将其比作计算机网络中的数据传输过程。在这个类比中：</em></p><p><em>物理层就好比货车所使用的公路系统，它负责实际的物理传输。就像货车需要依靠公路系统才能将货物从一个地方运送到另一个地方一样。</em></p><p><em>链路层可以比作货车司机，负责将货物从一个地点运送到另一个地点，并与其他司机协调交接。</em></p><p><em>网络层就相当于货物的发货单，它规定了货物的最终目的地，并指示货车司机如何到达目的地。</em></p><h2 id="2-链路层所提供的服务？"><a href="#2-链路层所提供的服务？" class="headerlink" title="2.链路层所提供的服务？"></a>2.链路层所提供的服务？</h2><p>尽管任一链路层的基本服务都是将数据报通过单一通信链路从一个结点移动到相邻结 点，但所提供的服务细节能够随着链路层协议的不同而变化 链路层协议能够提供的可能服务包括:</p><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1,封装成帧"></a><strong>1,封装成帧</strong></h3><p>在链路层，数据被封装成帧以便在物理介质上传输。这个过程大致可以分为以下几个步骤：</p><p>1，添加帧起始标志：在开始传输数据之前，发送端会向数据包添加帧起始标志，以告知接收端一个新的帧即将到来。</p><p>2，加入地址信息：在大多数情况下，在以太网中，目标 MAC 地址和源 MAC 地址会被添加到帧的首部，这样接收端就能知道帧的目的地和发送源。</p><p>3，加入长度&#x2F;类型：在以太网中，接下来的字段包含了表示数据包长度或者类型的信息，这有助于接收端正确地解析帧。</p><p>4，加入数据：数据包的实际内容会放在帧中，这可能是来自更高层的数据包，例如 IP 数据包。</p><p>5，加入校验：通常还会添加一些校验位，例如 CRC（循环冗余校验），用于帮助接收端检测并纠正传输过程中可能出现的错误。</p><ol><li>添加帧结束标志：最后，发送端会向帧添加一个结束标志，表明帧的发送已经完成。</li></ol><p><img src="https://pic3.zhimg.com/v2-906564c750f269554f2e7adea716d154_1440w.jpg" alt="img"></p><p><img src="https://pica.zhimg.com/v2-f148c317c2602381f39c6f09ae3a9ad4_1440w.jpg" alt="img"></p><h3 id="2-差错检测"><a href="#2-差错检测" class="headerlink" title="2,差错检测"></a>2,差错检测</h3><p>在链路层，差错检测和纠正通常是通过循环冗余校验（CRC）来实现的。下面是简要描述差错检测和纠正的过程：</p><p>1，发送端计算数据包的 CRC 值：在发送数据包之前，发送端会对数据包中的一些字段进行计算，生成一个 CRC 值。</p><p>2，CRC 值附加到数据包中：得到 CRC 值后，发送端将其附加到数据包的尾部，并发送给接收端。</p><p>3，接收端计算CRC值：接收端接收数据包后，会重新计算接收到的数据包的 CRC 值。</p><p>4，对比CRC值：接收端的计算结果与接收到的CRC值进行比较，如果两者不一致，则表示数据包可能已经损坏。</p><p><img src="https://pic1.zhimg.com/v2-e4fbc7702a9232f92ee6064e8817da5a_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-26a0917f2d483c7e4fc2774f239bd9de_1440w.jpg" alt="img"></p><p>注意传输差错：一类是最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。例如，发送方连续传送三个帧： [#1]-[#2]-[#3]。假定接收端收到的每一个帧都没有比特差错，但却出现下面的几种情况：</p><p>帧丢失:收到[#1]-<a href="%E4%B8%A2%E5%A4%B1%5B#2%5D">#3</a>。</p><p>帧重复:收到[#1]-[#2]-[#2]-<a href="%E6%94%B6%E5%88%B0%E4%B8%A4%E4%B8%AA%5B#2%5D">#3</a>。　　</p><p>帧失序：收到[#1]-[#3]-<a href="%E5%90%8E%E5%8F%91%E9%80%81%E7%9A%84%E5%B8%A7%E5%8F%8D%E8%80%8C%E5%85%88%E5%88%B0%E8%BE%BE%E4%BA%86%E6%8E%A5%E6%94%B6%E7%AB%AF%EF%BC%8C%E8%BF%99%E4%B8%8E%E4%B8%80%E8%88%AC%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E4%BC%A0%E8%BE%93%E6%A6%82%E5%BF%B5%E4%B8%8D%E4%B8%80%E6%A0%B7">#2</a>。　　</p><p>以上三种情况都属于“出现传输差错”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂，对这些问题我们现在不展开讨论。</p><p>我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。　</p><p>　我们知道，过去 OSI 的观点是：必须让数据链路层向上提供可靠传输。因此在 CRC检错的基础上，增加了帧编号、确认和重传机制。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。因此，现在互联网就采取了区别对待的方法：　　</p><p>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议(例如，运输层的 TCP 协议)来完成。　　</p><p>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。实践证明，这样做可以提高通信效率，数据链路层协议都不是可靠传输的协议</p><h3 id="3-透明传输"><a href="#3-透明传输" class="headerlink" title="3,透明传输"></a>3,透明传输</h3><p>链路层透明传输是指在数据帧传输过程中，传输系统能够无歧义地处理各种数据，不会对数据内容进行解释或修改。这样的传输方式可以确保发送端和接收端之间的数据传输是可靠、准确的。下面是链路层透明传输的基本过程：</p><p>不进行数据解释或修改：在透明传输中，传输系统不会对传输的数据进行任何形式的解释或修改。无论数据的内容是什么，传输系统都会严格按照原始数据进行传输，确保数据的完整性和准确性。</p><p>数据格式不变：传输系统会严格遵循链路层协议规定的数据格式，不会因为数据内容的不同而进行调整。这意味着无论是文本、图像、音频还是其他类型的数据，在传输过程中都能得到正确的处理和传输。</p><p>透明传输技术：在实际应用中，透明传输通常会借助一些特定的技术来实现，比如使用特殊的编码方式来处理数据，以确保数据在传输过程中不会丢失或损坏。另外，还会采用一些差错检测和纠正的机制，以确保数据的可靠传输。</p><p>总的来说，链路层透明传输通过严格遵循原始数据格式、不进行解释或修改以及利用特定技术实现可靠传输等方式来确保传输过程中数据的准确性和完整性。</p><p>但请考虑这样一种情况：</p><p><img src="https://pica.zhimg.com/v2-9fb8e0fa232df49f2809c505f8e90f28_1440w.jpg" alt="img"></p><p>解决方法：</p><p>字节填充技术的基本原理是在需要填充的地方插入特定的填充字节，以确保传输的数据能够正确地被接收端解析，同时不影响实际数据内容的准确性。常见的字节填充技术包括</p><p>字符填充：</p><p>*<strong>在字符填充技术中，会在数据中出现特定的字符时，使用转义字符将其转义为另一个字符，从而确保数据传输的透明性。这样一来，接收端就可以根据转义字符来正确解析数据内容。*</strong></p><p><img src="https://pic4.zhimg.com/v2-5a93d63ba6718f3292ce911d9303e487_1440w.jpg" alt="img"></p><h2 id="3-网络链路分为哪几种类型？"><a href="#3-网络链路分为哪几种类型？" class="headerlink" title="3.网络链路分为哪几种类型？"></a>3.网络链路分为哪几种类型？</h2><p>3.1什么是点对点链路？</p><p>点对点链路是指在计算机网络中两个节点之间直接建立的通信链路。这种链路连接通常是一条物理线路或虚拟电路，用于直接连接两个设备，如两台计算机、路由器或交换机等。点对点链路不需要经过其他转发设备，数据可以直接在两个节点之间进行传输，因此具有较低的延迟和更高的带宽利用率。</p><h4 id="3-1-1PPP协议"><a href="#3-1-1PPP协议" class="headerlink" title="3.1.1PPP协议"></a>3.1.1PPP协议</h4><p>定义：</p><p>PPP（Point-to-Point Protocol，点对点协议）是一种数据链路层通信协议，用于在两个节点之间进行数据传输。它通常用于在数字通信线路上进行数据传输，如在拨号连接、DSL（数字用户线路）和ISDN（综合业务数字网）等网络环境中。PPP协议设计的初衷是为了提供简单、可靠的数据传输机制，并支持多种网络层协议的封装</p><p>特点（优点）：</p><p>建立连接：PPP允许两个节点之间建立连接以进行数据传输。它使用LCP链路控制协议）来协商并建立连接的参数，如数据压缩和认证方式等。</p><p>数据帧格式：PPP使用数据帧来封装传输的数据。数据帧包括标志字段、地址字段、控制字段、协议字段、数据字段和校验字段等部分，以便在通信中区分各个部分和进行差错检测。</p><p>多协议支持：PPP协议本身不限定传输的数据类型，而是通过NCP（网络控制协议）来支持多种网络层协议的封装，如IP、IPX和苹果Talk等，使得PPP可以在不同的网络环境中使用。</p><p>认证和加密：PPP支持多种认证方式，如PAP（Password Authentication Protocol，口令认证协议）和CHAP（挑战握手认证协议），以确保通信双方的身份验证和安全性。</p><p>错误检测和恢复：PPP具有良好的差错检测和恢复机制，通过校验字段和重传等方式，确保数据传输的可靠性。<strong>每一帧都有循环冗余检验；</strong></p><ol><li>通信双方可以进行 I P地址的动态协商(使用 I P网络控制协议)；</li><li>与C S L I P类似，对T C P和I P报文首部进行压缩；</li><li>链路控制协议可以 对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加 3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li></ol><p>PPP协议的组成：</p><ol><li>在串行链路上封装 I P数据报的方法。 P P P既支持数据为 8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。</li><li>建立、配置及测试数据链路的链路控制协议（ L C P：Link Control Protocol）。它允许通<br>信双方进行协商，以确定不同的选项。</li><li>针对不同网络层协议的网络控制协议（ N C P：Network Control Protocol）体系。当前<br>R F C定义的网络层有I P、O S I网络层、D E C n e t以及A p p l e Ta l k。例如，IP NCP允许双方商定是<br>否对报文首部进行压缩，类似于 C S L I P（缩写词N C P也可用在T C P的前面）。<br><strong>PPP协议的帧格式：</strong></li></ol><p><img src="https://pica.zhimg.com/v2-ec2a47c393e41a1e459b7d15ee988b40_1440w.jpg" alt="img"></p><p>字节填充：<br>正如一开始讨论的透明传输那样：</p><p><img src="https://pic1.zhimg.com/v2-d63c9bc4575e81885f08b84bf2ffa89c_1440w.jpg" alt="img"></p><p>零比特填充：</p><p><img src="https://pic3.zhimg.com/v2-da067faa956e57c3c4a7a86011b9b150_1440w.jpg" alt="img"></p><p><strong>PPP协议工作状态：</strong></p><p><img src="https://picx.zhimg.com/v2-f6916cb7f4cae3240c52c0d271cbed51_1440w.jpg" alt="img"></p><h4 id="3-2什么是广播链路？"><a href="#3-2什么是广播链路？" class="headerlink" title="3.2什么是广播链路？"></a><strong>3.2什么是广播链路？</strong></h4><p>广播链路能够让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上 这里使用术语”广播”是因为当任何一个结点传输一个帧时，信道广播该帧，每个其他结点都收到一个副本。以太网和无线局域网是广播链路层技术的例子。<br>当有多个发送和接受节点同时发送和接受时，便出现了一个问题:如何协调多个发送和接收结点对一个共享广播信道的访问，这就是多路访问问题</p><h5 id="3-2-1，载波侦听多路访问-CSMA-CD"><a href="#3-2-1，载波侦听多路访问-CSMA-CD" class="headerlink" title="3.2.1，载波侦听多路访问 (CSMA&#x2F;CD)"></a><strong>3.2.1，载波侦听多路访问 (CSMA&#x2F;CD)</strong></h5><p>想象一下：一个偌大的教室里，所有学生都在交流，如何确保所有学生能听到老师的声音（相同，单一的广播媒体）<br>这个问题的中心是：<strong>确定谁以及在什么时候获得说话权力(也就是向信道传输)</strong> 作为人类，为了共享这种广播信道，我们已经演化得到了个精心设计的协议集了:<br>“给每个人 个讲话的机会”<br>“该你讲话时你才说话”<br>“不要一个人独占整个谈话”<br>“如果有问题请举手”<br>“当有人讲话时不要打断”<br>“当其他人讲话时不要睡觉<br>计算机网络有类似的协议，也就是所谓的<strong>多路访问协议</strong><br><strong>定义：</strong><br>CSMA&#x2F;CD协议，（带碰撞检测的载波监听多路访问）是一种用于以太网局域网的多路访问协议。在以太网中，多个节点通过共享同一物理介质进行数据通信，CSMA&#x2F;CD协议旨在解决节点之间的数据碰撞问题。<br><strong>基本工作流程：</strong><br>载波监听：节点在发送数据之前先监听信道，检测是否有其他节点正在发送数据。如果信道上没有检测到其他节点的信号，节点将继续发送数据；否则，它将等待直到信道空闲。<br>碰撞检测：如果两个节点几乎同时发送数据导致碰撞，它们会通过检测到信道上的信号变化来意识到碰撞的发生。一旦节点检测到碰撞，它们会立即停止发送，并发送一个”jam”信号以通知其他节点有碰撞发生。<br>退避算法：在发生碰撞后，节点会使用退避算法来确定下一次重试发送数据的时间。该算法会随机选择一个时间间隔，在此间隔内等待然后再次尝试发送数据，以减少碰撞的概率。</p><p><img src="https://pic1.zhimg.com/v2-0628e617196cf679f50622d4bea8f376_1440w.jpg" alt="img"></p><p><strong>预期目标：</strong><br>减少碰撞影响：通过及时检测到碰撞并采取相应的措施，如停止发送数据并发送”jam”信号，CSMA&#x2F;CD协议可以尽快地清除碰撞，从而减少碰撞对网络带宽的影响，提高数据传输的成功率。<br>提高公平性：CSMA&#x2F;CD协议基于竞争机制，所有节点都有平等的机会发送数据。这样可以确保网络资源在各个节点之间公平地共享，避免某些节点长时间占用网络资源而导致其他节点无法发送数据。<br>最大化网络吞吐量：通过合理的退避算法和碰撞检测机制，CSMA&#x2F;CD协议试图最大化网络的吞吐量，即单位时间内网络所能传输的数据量，以提高网络性能。<br>降低网络延迟：CSMA&#x2F;CD协议旨在通过减少碰撞、合理分配网络资源等方式降低网络的传输延迟，从而提高数据传输的效率。<br><strong>传播时延对载波监听的影响</strong></p><p><img src="https://pic4.zhimg.com/v2-33b5bf32b1b14b10701ca2b9d8222acd_1440w.jpg" alt="img"></p><h2 id="4-交换局域网"><a href="#4-交换局域网" class="headerlink" title="4.交换局域网"></a>4.<strong>交换局域网</strong></h2><h3 id="4-1-网络层已经有IP地址了，为什么还要有MAC地址？"><a href="#4-1-网络层已经有IP地址了，为什么还要有MAC地址？" class="headerlink" title="4.1,网络层已经有IP地址了，为什么还要有MAC地址？"></a>4.1,网络层已经有IP地址了，为什么还要有MAC地址？</h3><p>局域网是为任意网络层协议而设计的，而不只是用于 IP 和因特网 如果适配器被指派IP</p><p>地址而不是”中性的” MAC 地址的话，则适配器将不能够方便地支持其他网络层协议(例如， IPX 或者 DECnel)</p><blockquote><p>如果适配器使用网络层地址而不是 MAC 地址的话，网络层地址必须存储在适配器的 RAM 中，并且在每次适配器移动(或加电)时要重新配置。另一种选择是在适配器中不使用任何地址，让每个适配器将它收到的每帧数据(通常是lP数据报)沿协议裁向上传递 然后网络层则能够核对网络地址层是否匹配</p></blockquote><p>这种选择带来的一个问题是，主机将被局域网上发送的每个帧中断，包括被目的地址</p><p>在相同广播局域网上的其他给点的帧中断</p><p>总之，为了使网络体系结构中各层次成为极为独立的构建棋块，不同的层次需要有它们自己的寻址方案</p><p><img src="https://pic1.zhimg.com/v2-77dda232e3970145a652b1c3e35bb2b4_1440w.jpg" alt="img"></p><p><img src="https://picx.zhimg.com/v2-b3ea253947f420e1f82d916f72df0ef9_1440w.jpg" alt="img"></p><h3 id="4-2-什么是链路层交换机？"><a href="#4-2-什么是链路层交换机？" class="headerlink" title="4.2,什么是链路层交换机？"></a>4.2,什么是链路层交换机？</h3><p>链路层交换机是一种在OSI模型中工作于数据链路层的网络设备，用于在局域网中转发数据帧。它主要用于连接不同计算机、网络设备或其他交换机，以实现数据的转发和交换。</p><p><strong>主要功能包括：</strong></p><p>数据帧转发：链路层交换机能够接收到来自一个端口的数据帧，并根据目标MAC地址将其转发至合适的端口，从而实现数据的点对点传输。</p><p>MAC地址学习：当数据帧进入交换机时，交换机会学习源MAC地址和对应的输入端口，建立MAC地址表。这样，当交换机需要转发数据帧时，可以根据目标MAC地址查找相应的输出端口进行转发。</p><p><img src="https://picx.zhimg.com/v2-76b2bd4db1d2b8fa714f25f551923033_1440w.jpg" alt="img"></p><p>数据帧过滤：交换机能够根据目标MAC地址来过滤数据帧，只将特定目标地址的数据帧发送至对应的端口，从而提高网络的安全性和效率。</p><p>碰撞域隔离：与传统的集线器（hub）不同，交换机能够隔离不同端口上的碰撞域，使得数据帧只在必要的端口上传输，减少了网络中的碰撞，提高了网络的性能。</p><p>VLAN支持：许多链路层交换机还支持虚拟局域网（VLAN）的功能，可以将不同物理位置的计算机组合成逻辑上的同一个网络，从而提高网络的灵活性和安全性。</p><p><img src="https://pic4.zhimg.com/v2-3f65e6f67ccba753dd8415a90613300f_1440w.jpg" alt="img"></p><h3 id="4-3-什么是虚拟局域网？"><a href="#4-3-什么是虚拟局域网？" class="headerlink" title="4.3,什么是虚拟局域网？"></a>4.3,什么是虚拟局域网？</h3><p><strong>定义</strong>：</p><p>虚拟局域网是一种将局域网中的设备按照逻辑上的组织方式划分成多个虚拟网络的技术。通过VLAN技术，可以实现不同物理位置的设备被划分到同一个逻辑网络中，或者将同一物理位置上的设备划分到不同的逻辑网络中，从而提高网络的管理灵活性、安全性和性能。</p><p><img src="https://pic1.zhimg.com/v2-996ff466b1eda675069e39b6ed1b4d3e_1440w.jpg" alt="img"></p><p><strong>VLAN技术的主要特点包括：</strong></p><p>逻辑隔离：VLAN技术可以将同一物理局域网中的设备按照逻辑上的不同需求进行隔离，使得它们在同一物理网段上可以进行独立的广播域划分和数据流量控制。</p><p>安全性：VLAN技术可以根据不同的安全需求将设备划分到不同的VLAN中，从而实现对不同用户、部门或应用的隔离，有效地提高网络的安全性。</p><p>灵活性：通过VLAN技术，网络管理员可以根据需要随时重新划分和重新配置虚拟网络，而无需改变物理网络结构，提高了网络的管理灵活性。</p><p>性能优化：VLAN技术还可以通过减少广播域的大小，限制广播帧的传播范围，从而减少网络中的广播风暴，提高了网络的性能。</p><p><img src="https://pica.zhimg.com/v2-5f9e219cfcfe5dc88ba25352cdd11a16_1440w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AES算法原理与逆向练习</title>
    <link href="/2023/02/05/AES%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%86%E5%90%91%E7%BB%83%E4%B9%A0/"/>
    <url>/2023/02/05/AES%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%86%E5%90%91%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://wangxiaobai08.github.io/2023/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学体系框架 - The Peak Tower</a>简单介绍了AES的基本流程，这篇主要来了解一下AES的数学计算原理和openssl对其的实现逆向</p><h1 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h1><p><strong>Galois Field（伽罗华域&#x2F;伽罗瓦域）</strong>是代数学中的一个重要概念，广泛应用于密码学、编码理论、误差修正和许多其他数学及工程领域。它的命名源于法国数学家 <strong>Évariste Galois</strong>，他在19世纪提出了代数方程的解法和域的相关理论。尽管 <strong>伽罗华域</strong> 和 <strong>伽罗瓦域</strong> 两个翻译在国内存在一定的差异，但它们指的都是同一个概念，即有限域（Finite Field）。</p><h3 id="1-有限域的定义"><a href="#1-有限域的定义" class="headerlink" title="1. 有限域的定义"></a><strong>1. 有限域的定义</strong></h3><p>有限域是一个包含有限个元素的域（Field）。数学中，域是满足加法和乘法两种运算，并且这两种运算满足一些基本的代数性质的代数结构。有限域是指其中包含的元素个数是有限的，这些元素可以进行加法、乘法以及加法和乘法的逆运算。</p><p>一个有限域的符号通常表示为 <strong>Fq</strong>，其中 <strong>q</strong> 表示域中元素的个数。有限域的元素个数 <strong>q</strong> 必须是一个素数 <strong>p</strong> 的某个幂，即 <strong>q&#x3D;p^n <strong>，其中 <strong>p</strong> 是素数，</strong>n</strong> 是正整数。</p><ul><li>当 <strong>q &#x3D; p</strong> 时，有限域被称为 <strong>素数域</strong> Fp</li><li>当 <strong>q &#x3D; p^n</strong> 且 <strong>n &gt; 1</strong> 时，有限域被称为 <strong>扩展域</strong> F{p^n}，这个域包含 p^n 个元素。</li></ul><h3 id="2-Galois-Field（伽罗华域-伽罗瓦域）"><a href="#2-Galois-Field（伽罗华域-伽罗瓦域）" class="headerlink" title="2. Galois Field（伽罗华域&#x2F;伽罗瓦域）"></a><strong>2. Galois Field（伽罗华域&#x2F;伽罗瓦域）</strong></h3><p><strong>Galois Field</strong>，表示为 **GF(q)**，是一种特别的有限域，其中 <strong>q</strong> 为元素个数。Galois Field 是代数中描述代数结构的核心概念之一，特别适用于不可约多项式的构造和处理。</p><p><strong>GF(2^M)</strong> 是常见的表示形式，表示一个包含 <strong>2^M</strong> 个元素的有限域。对于 **GF(2^M)**，它的元素可以用 <strong>M</strong> 位二进制数来表示，每个元素可以通过对 <strong>M</strong> 次方的多项式的系数进行运算来表示。在 <strong>GF(2^M)</strong> 中的加法和乘法运算都是在二进制下进行的。</p><h3 id="3-本原多项式"><a href="#3-本原多项式" class="headerlink" title="3. 本原多项式"></a><strong>3. 本原多项式</strong></h3><p>在有限域中，运算的基础是一个本原多项式（Primitive Polynomial）。本原多项式是定义域的构造基准。通过这个本原多项式，我们可以实现多项式除法和域的加法、乘法等运算。</p><h4 id="不可约多项式"><a href="#不可约多项式" class="headerlink" title="不可约多项式"></a><strong>不可约多项式</strong></h4><p>本原多项式通常是不可约多项式，这意味着它不能分解成两个较低次的多项式的乘积。有限域的构造依赖于不可约多项式，尤其是在扩展域（如 **GF(2^M)**）中。</p><h4 id="例子：GF-2-8"><a href="#例子：GF-2-8" class="headerlink" title="例子：GF(2^8)"></a><strong>例子：GF(2^8)</strong></h4><p>对于 **GF(2^8)**，域中有 <strong>2^8 &#x3D; 256</strong> 个元素。为了构造这个有限域，我们需要一个不可约的多项式（本原多项式），该多项式是一个次数为 8 的多项式。常见的本原多项式包括：</p><ul><li><strong>P(x) &#x3D; x^8 + x^4 + x^3 + x^2 + 1</strong></li><li><strong>AES中的本原多项式</strong>：<strong>P(x) &#x3D; x^8 + x^4 + x^3 + x^1 + 1</strong></li></ul><p>这两个多项式是不可约的，用于定义 <strong>GF(2^8)</strong> 域中的加法和乘法运算。通过模这个不可约多项式对多项式进行运算，可以得到有限域中的元素，并且实现加法、乘法和逆元运算。</p><h3 id="4-GF-2-M-的构造"><a href="#4-GF-2-M-的构造" class="headerlink" title="4. GF(2^M) 的构造"></a><strong>4. GF(2^M) 的构造</strong></h3><p>对于 <strong>GF(2^M)<strong>，元素的表示通常采用 <strong>二进制位</strong>。例如，</strong>GF(2^8)</strong> 中的元素是 8 位二进制数，表示为 {0,1,2,…,255}或 {0,1,α,α2,…,α255}，其中 <strong>α</strong> 是一个生成元。</p><p>每个元素可以表示为一个 <strong>M</strong> 次多项式的系数：</p><ul><li>例如，<strong>x^7 + x^3 + 1</strong> 在 <strong>GF(2^8)</strong> 中表示为 10100001210100001_2（二进制）。</li><li>运算时，这些多项式会模一个不可约多项式进行运算，从而保证运算的封闭性。</li></ul><p>在密码学中，有限域特别是 <strong>GF(2^8)</strong> 被广泛应用于加密算法中。例如，<strong>AES（高级加密标准）</strong> 就是在 <strong>GF(2^8)</strong> 中进行的运算。AES使用 <strong>GF(2^8)</strong> 中的加法和乘法来执行代数运算，确保加密过程的安全性。</p><p>在 AES 中，本原多项式 <strong>P(x) &#x3D; x^8 + x^4 + x^3 + x^1 + 1</strong> 定义了在 <strong>GF(2^8)</strong> 中的乘法运算，确保加密算法的复杂性和安全性。</p><h1 id="有限域的加法与乘法运算"><a href="#有限域的加法与乘法运算" class="headerlink" title="有限域的加法与乘法运算"></a>有限域的加法与乘法运算</h1><p>有限域中的运算方式需要先把数值转化成多项式的形式，然后再进行相关运算。其中加法操作可以直接进行运算。</p><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>计算机异或运算</p><p>加法例子：4+3</p><p>展开多项式为: x^2 + (x^1 + x^0) &#x3D;&gt; 2^2 + 2^1 + 1 &#x3D;&gt; 4 + 2 + 1 &#x3D;&gt; 4 ^ 2 ^ 1 &#x3D; 7</p><p>直接计算：4^3 &#x3D; 7</p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>通过乘法结合律展开多项式，如果x的最高指数大于7，那么需要对本原多项式取余数（初二多项式除法运算），否则就是展开后的多项式做加法操作。</p><p>取余操作有一个算法，参考《密码编码学与网络安全学原理》一书中提到的公式：</p><p>已知GF(2^8)最长的多项式f(x)&#x3D;b7<em>x^7+b6</em>x^6+b5<em>x^5+b4</em>x^4+b3<em>x^3+b2</em>x^2+b1<em>x^1+b0</em>x^0</p><p>x<em>f(x)&#x3D; b7</em>x^8+b6<em>x^7+b5</em>x^6+b4<em>x^5+b3</em>x^4+b2<em>x^3+b1</em>x^2+b0*x^1</p><p>x*f(x)的情况如下：</p><p>当b7&#x3D;0时，最高指数为7不需要取余，直接做异或加法运算。</p><p>当b7&#x3D;1时，最高指数为8，大于7，则需要取m(x)的余数，推导如下：</p><p>f(x) &#x3D; ( b7<em>x^8+b6</em>x^7+b5<em>x^6+b4</em>x^5+b3<em>x^4+b2</em>x^3+b1<em>x^2+b0</em>x^1 )mod m(x);</p><p>这里有另外一个等式：x^8 mod m(x) &#x3D; [m(x) – x^8] &#x3D; (x^4 + x^3 + x + 1)</p><p>所以根据上面的等式可以化简f(x) &#x3D; b6<em>x^7+b5</em>x^6+b4<em>x^5+b3</em>x^4+b2<em>x^3+b1</em>x^2+b0*x^1 + x^4 + x^3 + x +1</p><p>而x^4 + x^3 + x + 1 就是十六进程的0x1B(因为2^4+2^3+2+1&#x3D;27),因此本原多项式取余的操作就等价于 异或本原多项式。公式如下：</p><p><img src="https://s2.loli.net/2024/12/30/xAdDujKoqkeUsH5.png" alt="image-20241230143827313"></p><p>高阶的x可以重复使用这个公式，在程序实现部分会详细介绍下。</p><p>乘法例子：7*4</p><p>展开多项式为:(x^2+x^1+x^0)*(x^2) &#x3D;&gt; x^4 + x^2 + x^2 &#x3D;&gt; 2^4 + 2^2 + 2^2 &#x3D; 16 ^ 4 ^ 4 &#x3D; 16</p><p>乘法例子：130*3</p><p>展开多项式为:(x^7+x^1)*(x^1+x^0) &#x3D;&gt; x^8 + x^7 + x^1 + x^1 &#x3D;&gt; x^8 + x^7 +( x^8+x^4+x^3+x^1+x^0 ) ( 不可约多项式 ) &#x3D;&gt; x^7 + x^4+x^3+x^1+x^0 &#x3D;&gt; 2^7 + 2^4 + 2^3 + 2^1 + 1 &#x3D; 128 ^ 16 ^ 8 ^ 2 ^ 1 &#x3D; 155</p><h1 id="不同加密模式和要求"><a href="#不同加密模式和要求" class="headerlink" title="不同加密模式和要求"></a>不同加密模式和要求</h1><p>AES 加密算法有多种加密模式，包括 <strong>ECB</strong>（电子密码本）、<strong>CBC</strong>（链式块加密）、<strong>CFB</strong>（加密反馈模式）、<strong>OFB</strong>（输出反馈模式）等。这些模式在如何加密和处理数据上有所不同，主要的差异体现在如何处理数据块、是否支持并行加密、加密的安全性等方面。下面是这些模式的详细对比。</p><h3 id="AES-加密模式对比"><a href="#AES-加密模式对比" class="headerlink" title="AES 加密模式对比"></a>AES 加密模式对比</h3><table><thead><tr><th><strong>加密模式</strong></th><th><strong>描述</strong></th><th><strong>加密过程</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>ECB (Electronic Codebook)</strong></td><td>每个数据块独立加密，最简单的模式。</td><td>明文被分为固定大小的块（例如 128 位），每个块独立加密，使用相同的密钥。</td><td>简单、高效，适合小数据量加密。</td><td>相同的明文块加密结果相同，容易泄露模式信息，易受攻击。</td><td>适用于简单加密任务，特别是独立的数据块加密，适合短文本加密。</td></tr><tr><td><strong>CBC (Cipher Block Chaining)</strong></td><td>每个数据块的加密结果依赖前一个块的密文（加密链接）。</td><td>每个数据块与前一个加密块的密文异或，第一块使用随机的初始化向量（IV）。</td><td>可以防止 ECB 中的模式泄漏问题，安全性较高。</td><td>解密操作串行化，性能较差；需要随机生成 IV，且 IV 必须唯一。</td><td>适用于大规模数据加密，如文件加密、磁盘加密。</td></tr><tr><td><strong>CFB (Cipher Feedback)</strong></td><td>通过反馈机制对明文进行加密，支持“流式”加密。</td><td>明文被按位加密。每个块的密文会反馈给下一个加密块的输入。</td><td>可以处理流数据，可以进行“流加密”。</td><td>加密过程需要串行操作，无法并行化处理。</td><td>适用于加密流数据，如网络传输、实时通信等。</td></tr><tr><td><strong>OFB (Output Feedback)</strong></td><td>明文加密时，每个加密块的反馈源来自加密后的输出，而不是密文。</td><td>明文被加密时，反馈来自先前加密的输出，生成密钥流后与明文异或。</td><td>与 CFB 模式相比，OFB 不会产生反馈延迟，适合连续加密流数据。</td><td>对于错误传播较为敏感，一旦某个数据块损坏，后续数据会受到影响。</td><td>用于需要流加密且对错误传播敏感性低的场景，如音视频流加密等。</td></tr><tr><td><strong>CTR (Counter)</strong></td><td>基于计数器的模式，支持并行化加密。</td><td>生成一个计数器流，并与密钥进行异或，生成密钥流后与明文异或。</td><td>高效并行化处理，适用于加密大量数据，且密文长度可以任意。</td><td>需要确保计数器唯一，否则安全性丧失。</td><td>适用于大数据流加密，如磁盘加密、VPN、SSL&#x2F;TLS 等。</td></tr><tr><td><strong>GCM (Galois&#x2F;Counter Mode)</strong></td><td>结合了 CTR 的加密特性和认证功能。</td><td>加密和生成认证标签，保证数据的完整性和机密性。加密与认证同时进行。</td><td>提供加密和认证，能保证数据完整性，支持并行化处理。</td><td>IV 必须唯一，计算较复杂，标签生成可能会带来性能开销。</td><td>适用于高安全性要求的加密和认证场景，如 TLS、IPSec、VPN 等。</td></tr></tbody></table><h3 id="1-AES-的基本要求"><a href="#1-AES-的基本要求" class="headerlink" title="1. AES 的基本要求"></a>1. <strong>AES 的基本要求</strong></h3><h4 id="明文位数"><a href="#明文位数" class="headerlink" title="明文位数"></a><strong>明文位数</strong></h4><ul><li><strong>AES</strong> 是基于 <strong>128 位</strong>（16 字节）数据块的加密算法，因此 AES 的明文长度必须是 128 位（16 字节）的整数倍。</li><li>如果明文长度不是 128 位的整数倍，在加密前通常需要 <strong>填充</strong>（Padding）操作，以确保每个明文块大小为 128 位。常见的填充方法包括 PKCS7 或 ISO 10126。</li></ul><h4 id="密钥位数"><a href="#密钥位数" class="headerlink" title="密钥位数"></a><strong>密钥位数</strong></h4><p>AES 支持三种密钥长度：</p><ul><li><strong>128 位密钥</strong>：用于 AES-128。</li><li><strong>192 位密钥</strong>：用于 AES-192。</li><li><strong>256 位密钥</strong>：用于 AES-256。</li></ul><p>密钥长度决定了加密过程的 <strong>轮数</strong>：</p><ul><li><strong>AES-128</strong>：共进行 10 轮加密。</li><li><strong>AES-192</strong>：共进行 12 轮加密。</li><li><strong>AES-256</strong>：共进行 14 轮加密。</li></ul><h1 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h1><p>这里选取了aes_core.c进行分析：</p><p>理论上下面这段代码更符合上面文章中的流程，但这段代码的作用是确保在没有汇编加速的情况下，如果启用了常量时间加密，就会选择常量时间的实现方式。但不是更通用的 AES 具体实现</p><p><img src="https://s2.loli.net/2024/12/30/oRA82iwvzWnFsxy.png" alt="image-20241230145535182"></p><p>故接下来着重看<code>!defined(AES_ASM)</code>），即使用更通用的 AES 实现：</p><p>具体来看：</p><h2 id="预计算查找表"><a href="#预计算查找表" class="headerlink" title="预计算查找表"></a>预计算查找表</h2><p><img src="https://s2.loli.net/2024/12/30/ouF6t71QdCBqecV.png" alt="image-20241230150349547"></p><p>我们知道AES具体可分为：</p><p><img src="https://s2.loli.net/2024/12/30/iWTzHgNyu5IkMOC.png" alt="image-20241230150600478"></p><p>其中字节代换是通过一个替换表（S盒）对每个字节进行替换(解密同理，唯一就是采用的是逆S盒)，而列混合实际上是为4<em>4的矩阵与另一个给定4</em>4矩阵:<img src="https://s2.loli.net/2024/12/30/5CbucgOGFxWQAHj.png" alt="image-20241230150924232" style="zoom:25%;" /></p><p>异或相乘(注意：矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算)</p><p>而这里的预计算查找表实际上就是：根据 <code>S[x]</code>（代换表）和固定的常数（如 <code>02</code>, <code>03</code>, <code>01</code>）通过 <strong>有限域</strong> 运算（GF(2^8)）生成的。</p><p><strong><code>Te</code> 和 <code>Td</code> 表的生成</strong>：它们通过对每个字节应用特定的矩阵乘法（基于有限域运算）来得到。每个字节的替代值由固定的常数和 <code>S[x]</code> 值与有限域乘法结合生成。</p><p>接下来：</p><p><img src="https://s2.loli.net/2024/12/30/Sli3vnWP2G1mTMt.png" alt="image-20241230151232405"></p><h2 id="AES-set-encrypt-key"><a href="#AES-set-encrypt-key" class="headerlink" title="AES_set_encrypt_key"></a>AES_set_encrypt_key</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">AES_set_encrypt_key</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *userKey, <span class="hljs-type">const</span> <span class="hljs-type">int</span> bits,AES_KEY *key)</span><br>&#123;<br>    u32 *rk;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    u32 temp;<br><br>    <span class="hljs-keyword">if</span> (!userKey || !key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (bits != <span class="hljs-number">128</span> &amp;&amp; bits != <span class="hljs-number">192</span> &amp;&amp; bits != <span class="hljs-number">256</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><br>    rk = key-&gt;rd_key;<br><br>    <span class="hljs-keyword">if</span> (bits == <span class="hljs-number">128</span>)<br>        key-&gt;rounds = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bits == <span class="hljs-number">192</span>)<br>        key-&gt;rounds = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">else</span><br>        key-&gt;rounds = <span class="hljs-number">14</span>;<br><br>    rk[<span class="hljs-number">0</span>] = GETU32(userKey     );<br>    rk[<span class="hljs-number">1</span>] = GETU32(userKey +  <span class="hljs-number">4</span>);<br>    rk[<span class="hljs-number">2</span>] = GETU32(userKey +  <span class="hljs-number">8</span>);<br>    rk[<span class="hljs-number">3</span>] = GETU32(userKey + <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">if</span> (bits == <span class="hljs-number">128</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            temp  = rk[<span class="hljs-number">3</span>];<br>            rk[<span class="hljs-number">4</span>] = rk[<span class="hljs-number">0</span>] ^<br>                (Te2[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0xff000000</span>) ^<br>                (Te3[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>                (Te0[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>                (Te1[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0x000000ff</span>) ^<br>                rcon[i];<br>            rk[<span class="hljs-number">5</span>] = rk[<span class="hljs-number">1</span>] ^ rk[<span class="hljs-number">4</span>];<br>            rk[<span class="hljs-number">6</span>] = rk[<span class="hljs-number">2</span>] ^ rk[<span class="hljs-number">5</span>];<br>            rk[<span class="hljs-number">7</span>] = rk[<span class="hljs-number">3</span>] ^ rk[<span class="hljs-number">6</span>];<br>            <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            rk += <span class="hljs-number">4</span>;<br>        &#125;<br>    &#125;<br>    rk[<span class="hljs-number">4</span>] = GETU32(userKey + <span class="hljs-number">16</span>);<br>    rk[<span class="hljs-number">5</span>] = GETU32(userKey + <span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">if</span> (bits == <span class="hljs-number">192</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            temp = rk[ <span class="hljs-number">5</span>];<br>            rk[ <span class="hljs-number">6</span>] = rk[ <span class="hljs-number">0</span>] ^<br>                (Te2[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0xff000000</span>) ^<br>                (Te3[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>                (Te0[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>                (Te1[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0x000000ff</span>) ^<br>                rcon[i];<br>            rk[ <span class="hljs-number">7</span>] = rk[ <span class="hljs-number">1</span>] ^ rk[ <span class="hljs-number">6</span>];<br>            rk[ <span class="hljs-number">8</span>] = rk[ <span class="hljs-number">2</span>] ^ rk[ <span class="hljs-number">7</span>];<br>            rk[ <span class="hljs-number">9</span>] = rk[ <span class="hljs-number">3</span>] ^ rk[ <span class="hljs-number">8</span>];<br>            <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">8</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            rk[<span class="hljs-number">10</span>] = rk[ <span class="hljs-number">4</span>] ^ rk[ <span class="hljs-number">9</span>];<br>            rk[<span class="hljs-number">11</span>] = rk[ <span class="hljs-number">5</span>] ^ rk[<span class="hljs-number">10</span>];<br>            rk += <span class="hljs-number">6</span>;<br>        &#125;<br>    &#125;<br>    rk[<span class="hljs-number">6</span>] = GETU32(userKey + <span class="hljs-number">24</span>);<br>    rk[<span class="hljs-number">7</span>] = GETU32(userKey + <span class="hljs-number">28</span>);<br>    <span class="hljs-keyword">if</span> (bits == <span class="hljs-number">256</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            temp = rk[ <span class="hljs-number">7</span>];<br>            rk[ <span class="hljs-number">8</span>] = rk[ <span class="hljs-number">0</span>] ^<br>                (Te2[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0xff000000</span>) ^<br>                (Te3[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>                (Te0[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>                (Te1[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0x000000ff</span>) ^<br>                rcon[i];<br>            rk[ <span class="hljs-number">9</span>] = rk[ <span class="hljs-number">1</span>] ^ rk[ <span class="hljs-number">8</span>];<br>            rk[<span class="hljs-number">10</span>] = rk[ <span class="hljs-number">2</span>] ^ rk[ <span class="hljs-number">9</span>];<br>            rk[<span class="hljs-number">11</span>] = rk[ <span class="hljs-number">3</span>] ^ rk[<span class="hljs-number">10</span>];<br>            <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">7</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            temp = rk[<span class="hljs-number">11</span>];<br>            rk[<span class="hljs-number">12</span>] = rk[ <span class="hljs-number">4</span>] ^<br>                (Te2[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0xff000000</span>) ^<br>                (Te3[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>                (Te0[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>                (Te1[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x000000ff</span>);<br>            rk[<span class="hljs-number">13</span>] = rk[ <span class="hljs-number">5</span>] ^ rk[<span class="hljs-number">12</span>];<br>            rk[<span class="hljs-number">14</span>] = rk[ <span class="hljs-number">6</span>] ^ rk[<span class="hljs-number">13</span>];<br>            rk[<span class="hljs-number">15</span>] = rk[ <span class="hljs-number">7</span>] ^ rk[<span class="hljs-number">14</span>];<br><br>            rk += <span class="hljs-number">8</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1. 函数声明"></a>1. <strong>函数声明</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">AES_set_encrypt_key</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *userKey, <span class="hljs-type">const</span> <span class="hljs-type">int</span> bits, AES_KEY *key)</span><br></code></pre></td></tr></table></figure><ul><li>**<code>userKey</code>**：输入的原始密钥，类型是 <code>unsigned char *</code>，通常是 128 位、192 位或 256 位。</li><li>**<code>bits</code>**：指定密钥的位数，值可以是 128、192 或 256。</li><li>**<code>key</code>**：指向 <code>AES_KEY</code> 结构体的指针，结构体中将存储扩展后的轮密钥。</li></ul><h3 id="2-基础验证"><a href="#2-基础验证" class="headerlink" title="2. 基础验证"></a>2. <strong>基础验证</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!userKey || !key)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (bits != <span class="hljs-number">128</span> &amp;&amp; bits != <span class="hljs-number">192</span> &amp;&amp; bits != <span class="hljs-number">256</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br></code></pre></td></tr></table></figure><ul><li>首先检查 <code>userKey</code> 和 <code>key</code> 是否为 <code>NULL</code>，如果是，返回错误。</li><li>然后检查 <code>bits</code> 是否为 128、192 或 256 中的一个，如果不是，返回错误。</li></ul><h3 id="3-设置轮数"><a href="#3-设置轮数" class="headerlink" title="3. 设置轮数"></a>3. <strong>设置轮数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (bits == <span class="hljs-number">128</span>)<br>    key-&gt;rounds = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bits == <span class="hljs-number">192</span>)<br>    key-&gt;rounds = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">else</span><br>    key-&gt;rounds = <span class="hljs-number">14</span>;<br></code></pre></td></tr></table></figure><ul><li>AES 使用不同的轮数：<ul><li>128 位密钥需要 10 轮。</li><li>192 位密钥需要 12 轮。</li><li>256 位密钥需要 14 轮。</li></ul></li></ul><h3 id="4-初始化轮密钥"><a href="#4-初始化轮密钥" class="headerlink" title="4. 初始化轮密钥"></a>4. <strong>初始化轮密钥</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">rk = key-&gt;rd_key;<br></code></pre></td></tr></table></figure><ul><li><code>rk</code> 是 <code>AES_KEY</code> 结构体中的 <code>rd_key</code> 字段，指向存储轮密钥的数组。</li></ul><h3 id="5-将用户密钥复制到轮密钥数组"><a href="#5-将用户密钥复制到轮密钥数组" class="headerlink" title="5. 将用户密钥复制到轮密钥数组"></a>5. <strong>将用户密钥复制到轮密钥数组</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">rk[<span class="hljs-number">0</span>] = GETU32(userKey);<br>rk[<span class="hljs-number">1</span>] = GETU32(userKey + <span class="hljs-number">4</span>);<br>rk[<span class="hljs-number">2</span>] = GETU32(userKey + <span class="hljs-number">8</span>);<br>rk[<span class="hljs-number">3</span>] = GETU32(userKey + <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><ul><li><code>GETU32()</code> 是一个宏，用于从输入字节流（<code>userKey</code>）中提取 32 位数据并存储到 <code>rk</code> 数组中。</li><li>假设 <code>userKey</code> 是一个 16 字节（128 位）数组，<code>rk[0]</code> 到 <code>rk[3]</code> 存储这 16 字节的前 4 个 32 位块。</li></ul><h3 id="6-AES-128-位密钥扩展"><a href="#6-AES-128-位密钥扩展" class="headerlink" title="6. AES 128 位密钥扩展"></a>6. <strong>AES 128 位密钥扩展</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (bits == <span class="hljs-number">128</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        temp  = rk[<span class="hljs-number">3</span>];<br>        rk[<span class="hljs-number">4</span>] = rk[<span class="hljs-number">0</span>] ^<br>            (Te2[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0xff000000</span>) ^<br>            (Te3[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>            (Te0[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>            (Te1[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0x000000ff</span>) ^<br>            rcon[i];<br>        rk[<span class="hljs-number">5</span>] = rk[<span class="hljs-number">1</span>] ^ rk[<span class="hljs-number">4</span>];<br>        rk[<span class="hljs-number">6</span>] = rk[<span class="hljs-number">2</span>] ^ rk[<span class="hljs-number">5</span>];<br>        rk[<span class="hljs-number">7</span>] = rk[<span class="hljs-number">3</span>] ^ rk[<span class="hljs-number">6</span>];<br>        <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        rk += <span class="hljs-number">4</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>rk[4]</code> 到 <code>rk[7]</code> 是通过一系列的操作扩展出来的轮密钥</strong>。<ul><li>使用 <code>Te2</code>, <code>Te3</code>, <code>Te0</code>, <code>Te1</code> 查找表进行字节替换和列混合（即非线性变换）。</li><li><strong><code>rcon[i]</code></strong> 是轮常量，它是一个固定的数列，在 AES 中用于增加加密的复杂性。</li><li>每一轮的轮密钥是基于前一轮的结果和轮常量（<code>rcon[i]</code>）计算出来的。</li><li>轮密钥扩展的核心是将前一轮的密钥与查找表的结果进行异或操作，得到当前轮的轮密钥。</li></ul></li><li>该过程在 <code>i == 10</code> 时终止，因为 AES-128 有 10 轮。</li></ul><h3 id="7-AES-192-位密钥扩展"><a href="#7-AES-192-位密钥扩展" class="headerlink" title="7. AES 192 位密钥扩展"></a>7. <strong>AES 192 位密钥扩展</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">rk[<span class="hljs-number">4</span>] = GETU32(userKey + <span class="hljs-number">16</span>);<br>rk[<span class="hljs-number">5</span>] = GETU32(userKey + <span class="hljs-number">20</span>);<br><span class="hljs-keyword">if</span> (bits == <span class="hljs-number">192</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        temp = rk[<span class="hljs-number">5</span>];<br>        rk[<span class="hljs-number">6</span>] = rk[<span class="hljs-number">0</span>] ^<br>            (Te2[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0xff000000</span>) ^<br>            (Te3[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>            (Te0[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>            (Te1[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0x000000ff</span>) ^<br>            rcon[i];<br>        rk[<span class="hljs-number">7</span>] = rk[<span class="hljs-number">1</span>] ^ rk[<span class="hljs-number">6</span>];<br>        rk[<span class="hljs-number">8</span>] = rk[<span class="hljs-number">2</span>] ^ rk[<span class="hljs-number">7</span>];<br>        rk[<span class="hljs-number">9</span>] = rk[<span class="hljs-number">3</span>] ^ rk[<span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">8</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        rk[<span class="hljs-number">10</span>] = rk[<span class="hljs-number">4</span>] ^ rk[<span class="hljs-number">9</span>];<br>        rk[<span class="hljs-number">11</span>] = rk[<span class="hljs-number">5</span>] ^ rk[<span class="hljs-number">10</span>];<br>        rk += <span class="hljs-number">6</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于 <strong>192 位密钥</strong>，同样使用类似的方法进行密钥扩展，但是轮密钥的数量和 <code>rcon[i]</code> 的使用略有不同。</li><li>192 位密钥需要 12 轮，每一轮生成 6 个轮密钥（<code>rk += 6</code>）。</li></ul><h3 id="8-AES-256-位密钥扩展"><a href="#8-AES-256-位密钥扩展" class="headerlink" title="8. AES 256 位密钥扩展"></a>8. <strong>AES 256 位密钥扩展</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">rk[<span class="hljs-number">6</span>] = GETU32(userKey + <span class="hljs-number">24</span>);<br>rk[<span class="hljs-number">7</span>] = GETU32(userKey + <span class="hljs-number">28</span>);<br><span class="hljs-keyword">if</span> (bits == <span class="hljs-number">256</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        temp = rk[<span class="hljs-number">7</span>];<br>        rk[<span class="hljs-number">8</span>] = rk[<span class="hljs-number">0</span>] ^<br>            (Te2[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0xff000000</span>) ^<br>            (Te3[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>            (Te0[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>            (Te1[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0x000000ff</span>) ^<br>            rcon[i];<br>        rk[<span class="hljs-number">9</span>] = rk[<span class="hljs-number">1</span>] ^ rk[<span class="hljs-number">8</span>];<br>        rk[<span class="hljs-number">10</span>] = rk[<span class="hljs-number">2</span>] ^ rk[<span class="hljs-number">9</span>];<br>        rk[<span class="hljs-number">11</span>] = rk[<span class="hljs-number">3</span>] ^ rk[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">if</span> (++i == <span class="hljs-number">7</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        temp = rk[<span class="hljs-number">11</span>];<br>        rk[<span class="hljs-number">12</span>] = rk[<span class="hljs-number">4</span>] ^<br>            (Te2[(temp &gt;&gt; <span class="hljs-number">24</span>)       ] &amp; <span class="hljs-number">0xff000000</span>) ^<br>            (Te3[(temp &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x00ff0000</span>) ^<br>            (Te0[(temp &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x0000ff00</span>) ^<br>            (Te1[(temp      ) &amp; <span class="hljs-number">0xff</span>] &amp; <span class="hljs-number">0x000000ff</span>);<br>        rk[<span class="hljs-number">13</span>] = rk[<span class="hljs-number">5</span>] ^ rk[<span class="hljs-number">12</span>];<br>        rk[<span class="hljs-number">14</span>] = rk[<span class="hljs-number">6</span>] ^ rk[<span class="hljs-number">13</span>];<br>        rk[<span class="hljs-number">15</span>] = rk[<span class="hljs-number">7</span>] ^ rk[<span class="hljs-number">14</span>];<br><br>        rk += <span class="hljs-number">8</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>256 位密钥</strong>扩展需要更多的轮密钥，并且生成过程和 192 位密钥相似，但每次生成更多的轮密钥（<code>rk += 8</code>），以满足 14 轮的要求。</li></ul><h2 id="AES-encrypt"><a href="#AES-encrypt" class="headerlink" title="AES_encrypt"></a>AES_encrypt</h2><h3 id="初识变换"><a href="#初识变换" class="headerlink" title="初识变换"></a>初识变换</h3><p><img src="https://s2.loli.net/2024/12/30/6ixw5lOKHRc7FPX.png" alt="image-20241230151509443"></p><p>通过左循环移位和右循环移位的结合，代码实现了对 32 位整数的字节顺序交换。原本从内存中读取的字节顺序（<code>B0 B1 B2 B3</code>）被调整为新顺序（<code>B3 B2 B1 B0</code>），即进行了字节交换操作。</p><p><img src="https://s2.loli.net/2024/12/30/eOBpq4yQ2N9TaPn.png" alt="image-20241230151938466"></p><p>而这一部分就是初识变换，将子密钥与明文按字节异或操作</p><p>接下来一个大大的9轮循环：</p><p><img src="https://s2.loli.net/2024/12/30/TxFLRPGrtM4vd1m.png" alt="image-20241230152143720"></p><p>这里的字节代换和列混合都是经第一步的预计算查找表查表得到，快速完成这两个操作，而不需要每轮都执行复杂的运算。</p><h3 id="SubBytes（字节替代）"><a href="#SubBytes（字节替代）" class="headerlink" title="SubBytes（字节替代）"></a>SubBytes（字节替代）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">t0 = Te0[(s0 &gt;&gt; <span class="hljs-number">24</span>)       ] ^ Te1[(s1 &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] ^<br>     Te2[(s2 &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] ^ Te3[(s3      ) &amp; <span class="hljs-number">0xff</span>] ^ rk[<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>这里的 <code>Te0</code>~&#96;Te3&#96; 是查找表，包含了预先优化后的值。这些表将 <strong>S-Box 替换</strong> 和 <strong>MixColumns 操作</strong> 合并在一起，减少了独立的 SubBytes 操作。</p><ul><li><code>s0 &gt;&gt; 24</code> 取 <code>s0</code> 的最高 8 位。</li><li><code>(s1 &gt;&gt; 16) &amp; 0xff</code> 取 <code>s1</code> 的次高 8 位。</li><li><code>(s2 &gt;&gt; 8) &amp; 0xff</code> 取 <code>s2</code> 的次低 8 位。</li><li><code>s3 &amp; 0xff</code> 取 <code>s3</code> 的最低 8 位。</li></ul><p>这相当于将当前状态的每个字节查表替换。</p><h3 id="ShiftRows（行移位）"><a href="#ShiftRows（行移位）" class="headerlink" title="ShiftRows（行移位）"></a>ShiftRows（行移位）</h3><p><strong>作用：</strong><br>对状态矩阵的每一行进行偏移，第 1 行右移 0 位，第 2 行右移 1 位，依次类推。目的是增加列之间的混淆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">t0 = Te0[(s0 &gt;&gt; <span class="hljs-number">24</span>)       ] ^ Te1[(s1 &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] ^<br>     Te2[(s2 &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] ^ Te3[(s3      ) &amp; <span class="hljs-number">0xff</span>] ^ rk[<span class="hljs-number">4</span>];<br>t1 = Te0[(s1 &gt;&gt; <span class="hljs-number">24</span>)       ] ^ Te1[(s2 &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] ^<br>     Te2[(s3 &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] ^ Te3[(s0      ) &amp; <span class="hljs-number">0xff</span>] ^ rk[<span class="hljs-number">5</span>];<br>t2 = Te0[(s2 &gt;&gt; <span class="hljs-number">24</span>)       ] ^ Te1[(s3 &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] ^<br>     Te2[(s0 &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] ^ Te3[(s1      ) &amp; <span class="hljs-number">0xff</span>] ^ rk[<span class="hljs-number">6</span>];<br>t3 = Te0[(s3 &gt;&gt; <span class="hljs-number">24</span>)       ] ^ Te1[(s0 &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>] ^<br>     Te2[(s1 &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>] ^ Te3[(s2      ) &amp; <span class="hljs-number">0xff</span>] ^ rk[<span class="hljs-number">7</span>];<br><br></code></pre></td></tr></table></figure><p>从代码中可以看出，状态字的排列顺序已自然实现了行偏移：</p><ul><li><code>t0</code> 的字节依次使用了 <code>s0, s1, s2, s3</code>，其中每个状态对应于状态矩阵的一列。</li><li><code>t1</code> 将 <code>s1</code>、<code>s2</code>、<code>s3</code> 和 <code>s0</code> 重新排列，完成了一次行移位。</li></ul><p>这种实现方式无需显式调用 <code>ShiftRows</code>，通过位移和查表间接完成了操作。</p><h3 id="MixColumns（列混合）"><a href="#MixColumns（列混合）" class="headerlink" title="MixColumns（列混合）"></a>MixColumns（列混合）</h3><p><strong>作用：</strong><br>对状态矩阵的每一列进行多项式运算，增加字节之间的线性混淆。</p><p><code>Te0</code>~&#96;Te3&#96; 查表中已经将 <strong>S-Box 替换</strong> 和 <strong>列混合</strong> 合并优化。</p><p>以 <code>Te0</code> 为例，其每一项对应如下公式：</p><p>Te0[x]&#x3D;(2⋅S[x],3⋅S[x],1⋅S[x],1⋅S[x])</p><p>在预计算标志已经完成，而这里</p><p><strong>查表操作</strong>：</p><ul><li><code>Te0[(s0 &gt;&gt; 24)]</code>：查找 <code>Te0</code> 表中索引为 <code>(s0 &gt;&gt; 24)</code> 的字节。</li><li><code>Te1[(s1 &gt;&gt; 16) &amp; 0xff]</code>：查找 <code>Te1</code> 表中索引为 <code>(s1 &gt;&gt; 16) &amp; 0xff</code> 的字节。</li><li><code>Te2[(s2 &gt;&gt; 8) &amp; 0xff]</code>：查找 <code>Te2</code> 表中索引为 <code>(s2 &gt;&gt; 8) &amp; 0xff</code> 的字节。</li><li><code>Te3[(s3)]</code>：查找 <code>Te3</code> 表中索引为 <code>s3</code> 的字节。</li></ul><p><strong>按位异或（XOR）</strong>：</p><ul><li><code>^</code> 是按位异或操作符。在这里，它将从四个查找表中得到的字节进行按位异或合并。通过异或操作，将这些字节组合成一个新的加密状态。</li></ul><h3 id="AddRoundKey（轮密钥加）"><a href="#AddRoundKey（轮密钥加）" class="headerlink" title="AddRoundKey（轮密钥加）"></a>AddRoundKey（轮密钥加）</h3><p>轮密钥加的操作是通过对状态矩阵的每一列与轮密钥进行异或（XOR）来实现的。每一轮加密都会使用不同的轮密钥。</p><p><strong>体现方式</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">t0</span> = ... ^ rk[<span class="hljs-number">4</span>]<span class="hljs-comment">;</span><br><span class="hljs-attr">t1</span> = ... ^ rk[<span class="hljs-number">5</span>]<span class="hljs-comment">;</span><br><span class="hljs-attr">t2</span> = ... ^ rk[<span class="hljs-number">6</span>]<span class="hljs-comment">;</span><br><span class="hljs-attr">t3</span> = ... ^ rk[<span class="hljs-number">7</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ul><li>在每一轮的操作中，<code>rk[4]</code>, <code>rk[5]</code>, <code>rk[6]</code>, <code>rk[7]</code> 是轮密钥中的一部分，<code>rk[i]</code> 是密钥扩展过程中生成的密钥。每轮加密时都需要用当前轮的密钥和数据进行 <strong>异或操作</strong>，这就是轮密钥加的体现。</li><li><code>rk[4]</code> 到 <code>rk[7]</code> 分别与 <code>t0</code>, <code>t1</code>, <code>t2</code>, <code>t3</code> 进行异或，从而实现了 <strong>AddRoundKey</strong>。</li></ul><h3 id="最后一轮"><a href="#最后一轮" class="headerlink" title="最后一轮"></a>最后一轮</h3><p><img src="https://s2.loli.net/2024/12/30/4fjGXL3D2yrESza.png" alt="image-20241230155307659"></p><p>最终轮的操作与普通轮类似，但<strong>省略了列混合（MixColumns）</strong>。最终轮包含以下三个步骤：</p><ol><li><strong>字节代换（SubBytes）</strong>。</li><li><strong>行移位（ShiftRows）</strong>。</li><li><strong>轮密钥加（AddRoundKey）</strong>。</li></ol><p>这是一个非常好的问题，确实涉及到 AES 加密最后一轮的实现细节和优化策略。我来详细解答一下这个问题。</p><h4 id="1-S-Box-和-Te0-Te1-Te2-Te3-的背景"><a href="#1-S-Box-和-Te0-Te1-Te2-Te3-的背景" class="headerlink" title="1. S-Box 和 Te0, Te1, Te2, Te3 的背景"></a>1. <strong>S-Box 和 <code>Te0</code>, <code>Te1</code>, <code>Te2</code>, <code>Te3</code> 的背景</strong></h4><p>首先，我们需要区分两者：</p><ul><li><strong>传统的 S-Box</strong>：是 AES 加密中进行 <strong>字节替换</strong>（<code>SubBytes</code>）的基本操作。S-Box 是一个 16×16 的矩阵，处理的是每个字节的替换，不涉及列混合。</li><li><strong><code>Te0</code>, <code>Te1</code>, <code>Te2</code>, <code>Te3</code> 查找表</strong>：这些查找表是 <strong>优化版的 S-Box</strong>，同时融合了 <strong>字节替换</strong>（SubBytes）和 <strong>列混合</strong>（MixColumns）操作的预计算形式。它们通过提前将字节替换和列混合操作计算到查找表中，提高了加密过程的效率。</li></ul><h4 id="2-为什么-Te0-Te1-Te2-Te3-不等同于列混合？"><a href="#2-为什么-Te0-Te1-Te2-Te3-不等同于列混合？" class="headerlink" title="2. 为什么 Te0, Te1, Te2, Te3 不等同于列混合？"></a>2. <strong>为什么 <code>Te0</code>, <code>Te1</code>, <code>Te2</code>, <code>Te3</code> 不等同于列混合？</strong></h4><p>虽然 <code>Te0</code>, <code>Te1</code>, <code>Te2</code>, <code>Te3</code> 包含了列混合的优化，它们并不等同于实际的 <strong>列混合操作</strong>。原因在于：</p><ul><li><strong>列混合</strong> 是在每轮的 <strong>中间轮次</strong>（即除了最后一轮）执行的，目的是增强加密的扩散性，使得每列的数据互相混合，提高加密的复杂度。</li><li>在 <strong>最后一轮</strong>，AES 明确规定不执行列混合操作。原因是最后一轮的目的是确保输出的密文是密切结合轮密钥的，同时也要保持对称加密的特性。因此，最后一轮只包括 <strong>字节替换（SubBytes）</strong>、<strong>行移位（ShiftRows）</strong> 和 <strong>轮密钥加（AddRoundKey）</strong>。</li></ul><h4 id="3-Te0-Te1-Te2-Te3-的优化方式"><a href="#3-Te0-Te1-Te2-Te3-的优化方式" class="headerlink" title="3. Te0, Te1, Te2, Te3 的优化方式"></a>3. <strong><code>Te0</code>, <code>Te1</code>, <code>Te2</code>, <code>Te3</code> 的优化方式</strong></h4><ul><li><strong><code>Te0</code>, <code>Te1</code>, <code>Te2</code>, <code>Te3</code></strong> 查找表虽然融合了列混合的元素，但它们并不意味着在 <strong>最后一轮</strong> 会执行列混合。它们的作用是通过提前计算字节替换和列混合的效果，将它们结合成查找表，从而节省计算时间。<strong>这些查找表的计算过程是在前几轮中完成的，不会影响到最后一轮的设计</strong>。</li></ul><h4 id="4-最后一轮为什么不进行列混合？"><a href="#4-最后一轮为什么不进行列混合？" class="headerlink" title="4. 最后一轮为什么不进行列混合？"></a>4. <strong>最后一轮为什么不进行列混合？</strong></h4><p>最后一轮的设计是为了确保加密过程的对称性和符合 AES 的设计规范。在最后一轮：</p><ul><li><strong>字节替换</strong> 仍然通过查找表（如 <code>Te0</code> 等）进行，但由于没有列混合的要求，查找表中的列混合部分被自动忽略。实际上，**<code>Te0</code>, <code>Te1</code>, <code>Te2</code>, <code>Te3</code>** 仅用于 <strong>字节替换</strong>，而不执行列混合操作。</li><li>在实际实现中，查找表的每一项本质上是已经预计算好的，包含了在 <strong>前几轮中</strong>发生的列混合操作，但 <strong>不再影响最后一轮</strong>。因此，即使查找表融合了列混合，最后一轮中的计算仍然只是字节替换和轮密钥加操作。</li></ul><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="AES-set-encrypt-key-1"><a href="#AES-set-encrypt-key-1" class="headerlink" title="AES_set_encrypt_key"></a>AES_set_encrypt_key</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!userKey || !key)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (bits != <span class="hljs-number">128</span> &amp;&amp; bits != <span class="hljs-number">192</span> &amp;&amp; bits != <span class="hljs-number">256</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><br>rk = key-&gt;rd_key;<br><br><span class="hljs-keyword">if</span> (bits == <span class="hljs-number">128</span>)<br>    key-&gt;rounds = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bits == <span class="hljs-number">192</span>)<br>    key-&gt;rounds = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">else</span><br>    key-&gt;rounds = <span class="hljs-number">14</span>;<br></code></pre></td></tr></table></figure><p>汇编代码：</p><p><img src="https://s2.loli.net/2024/12/30/eKYytOXI9RAWbZU.png" alt="image-20241230164315412"></p><p>可以看到其经过汇编优化后整体意思不变，但执行逻辑顺序发生了变化，似乎更加顺序执行了</p><p>其中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">rk[<span class="hljs-number">0</span>] = GETU32(userKey     );<br>rk[<span class="hljs-number">1</span>] = GETU32(userKey +  <span class="hljs-number">4</span>);<br>rk[<span class="hljs-number">2</span>] = GETU32(userKey +  <span class="hljs-number">8</span>);<br>rk[<span class="hljs-number">3</span>] = GETU32(userKey + <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/30/dyBzM9mn4Hetlbs.png" alt="image-20241230165222776"></p><p>注意留意LDR和STR指令的存取</p><blockquote><p>STR W9, [X2, #16] 将内存中的地址存到数组上</p><p>LDR             W1, [X15,X8] 将数组上的值存到变量中</p></blockquote><p>REV是反转字节序的指令，记住开头的</p><blockquote><p>CMP             W1, #128</p></blockquote><p><img src="https://s2.loli.net/2024/12/30/sO6ZP3iDl8QCL5G.png" alt="image-20241230165545062"></p><p>判断是否为128，不是则进行跳转</p><p><img src="https://s2.loli.net/2024/12/30/g7GyJPqQSDHlxBd.png" alt="image-20241230165635695"></p><p>再次判断是否为192，不是再次进行跳转</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rk</span>[<span class="hljs-number">4</span>] = GETU32(userKey + <span class="hljs-number">16</span>);<br><span class="hljs-attribute">rk</span>[<span class="hljs-number">5</span>] = GETU32(userKey + <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/30/sMCEOSlVqdtbmhJ.png" alt="image-20241230170756447"></p><p>这里</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arm"><span class="hljs-symbol">text:</span><span class="hljs-number">000000000023</span>A1E8                 <span class="hljs-keyword">LDRB</span>            <span class="hljs-built_in">W9</span>, [<span class="hljs-built_in">X8</span>,<span class="hljs-number">#20</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000023</span>A1EC                 <span class="hljs-keyword">LDRB</span>            <span class="hljs-built_in">W3</span>, [<span class="hljs-built_in">X8</span>,<span class="hljs-number">#21</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000023</span>A1F0                 <span class="hljs-keyword">LDRB</span>            <span class="hljs-built_in">W10</span>, [<span class="hljs-built_in">X8</span>,<span class="hljs-number">#22</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000000023</span>A1F4                 <span class="hljs-keyword">LDRB</span>            <span class="hljs-built_in">W17</span>, [<span class="hljs-built_in">X8</span>,<span class="hljs-number">#23</span>]<br></code></pre></td></tr></table></figure><p>先一个字节一个字节的从数组x8中存到w9,w3,w10,w17扩展到32位。</p><p>将 <code>W9</code> 中的值左移 24 位，并将结果存储到 <code>W11</code> 寄存器中。这样，<code>W9</code> 中的字节会被移动到 <code>W11</code> 的高字节部分。</p><p>执行按位或操作 <code>W17</code> 和 <code>W10</code>，其中 <code>W10</code> 会先左移 8 位。结果存储到 <code>W16</code> 寄存器中。这通常用于将多个字节组合成一个更大的值。</p><p>将 <code>W3</code> 左移 16 位后，执行按位或操作，将结果存储到 <code>W11</code> 中。这个操作结合了从 <code>W9</code> 和 <code>W3</code> 中来的数据。</p><p>将 <code>W16</code> 和 <code>W11</code> 执行按位或操作，并将结果存储回 <code>W16</code>。这一步将前面的多个字节数据合并成一个32位的值。</p><p>将 <code>W16</code> 寄存器中的 <strong>32位</strong> 数据存储到内存地址 <code>X2 + 20</code> 处。</p><p>接着跳转到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">rk[<span class="hljs-number">6</span>] = GETU32(userKey + <span class="hljs-number">24</span>);<br>rk[<span class="hljs-number">7</span>] = GETU32(userKey + <span class="hljs-number">28</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/30/ZNQjK4JseO5qURy.png" alt="image-20241230171433492"></p><p>下面接着分析256流程</p><p><img src="https://s2.loli.net/2024/12/30/Ckc4mnVAMqX5bRa.png" alt="image-20241230184035211"></p><p><code>ADRL</code>指令的作用是加载一个标签的地址（即内存地址），而不是加载标签所指向的数据。而这里是将标签<code>Tex</code>的地址加载到寄存器<code>Xx</code>中</p><p><img src="https://s2.loli.net/2024/12/30/pKDcIJfzV5P7oHa.png" alt="image-20241230211321525"></p><p>这段反编译后的代码长这样：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">Te0</span>[<span class="hljs-name">4</span> * (<span class="hljs-name">unsigned</span> __int8)v58 + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>但源代码是：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">Te0</span>[(<span class="hljs-name">temp</span>      ) &amp; <span class="hljs-number">0</span>xff] &amp; <span class="hljs-number">0</span>x0000ff00)<br></code></pre></td></tr></table></figure><p>**<code>(temp) &amp; 0xff</code>**：<br>这部分操作将 <code>temp</code> 变量的最低 8 位提取出来。例如，如果 <code>temp</code> 是一个 32 位整数，<code>(temp) &amp; 0xff</code> 会得到 <code>temp</code> 的最低字节（也就是 <code>temp</code> 的第 0 到 7 位），并传递给 <code>Te0</code> 查找表。</p><p>**<code>Te0[(temp) &amp; 0xff]</code>**：<br>这部分操作将 <code>temp</code> 的最低 8 位作为索引传递给 <code>Te0</code> 查找表。假设 <code>Te0</code> 是一个具有 256 个条目的查找表（<code>Te0[0]</code> 到 <code>Te0[255]</code>），那么 <code>Te0[(temp) &amp; 0xff]</code> 就是查找 <code>Te0</code> 表中对应的值。</p><p>**<code>&amp; 0x0000ff00</code>**：<br>这部分操作对查找表返回的结果进行掩码，目的是将只关心 <code>Te0</code> 查找结果的中间字节（第 8 到 15 位）保留下来。</p><ul><li>比如，如果 <code>Te0[(temp) &amp; 0xff]</code> 的结果是一个 32 位数 <code>0x12345678</code>，则 <code>(Te0[(temp) &amp; 0xff] &amp; 0x0000ff00)</code> 将把这个值限制为 <code>0x00005600</code>，即保留中间的 8 位。</li></ul><p>再看：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">Te3</span>[(<span class="hljs-name">temp</span> &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0</span>xff] &amp; <span class="hljs-number">0</span>x00ff0000)<br></code></pre></td></tr></table></figure><p>这里&gt;&gt;  8 再配合&amp;0xff 实现了提取temp 32位中任意一个字节的作用</p><p>注意这里的算数右移和逻辑右移的区别—&gt;符号位</p><p>再看反编译代码的原理：</p><p>**<code>(unsigned __int8)v58</code>**：</p><ul><li>这部分提取出 <code>v58</code> 变量的最低字节（即 <code>v58</code> 的低 8 位），假设 <code>v58 = 0x12345678</code>，那么 <code>(unsigned __int8)v58</code> 的结果就是 <code>0x78</code>。</li></ul><p>**<code>4 \* (unsigned __int8)v58 + 1</code>**：</p><ul><li>上面这个表达式计算出了查找表 <code>Te0</code> 的索引位置。因为每个条目是 4 字节，我们将字节值乘以 4（即 <code>4 * (unsigned __int8)v58</code>），然后加 1 来访问该条目中的第二个字节。</li><li>假设 <code>(unsigned __int8)v58 = 0x78</code>，那么 <code>4 * 0x78 = 0x1F0</code>，所以 <code>4 * 0x78 + 1 = 0x1F1</code>，表示我们访问 <code>Te0[0x1F1]</code>，即查找表 <code>Te0</code> 中第 <code>0x1F1</code> 条目的第二个字节。</li></ul><p>**<code>Te0[4 \* (unsigned __int8)v58 + 1]</code>**：</p><ul><li>查找表 <code>Te0</code> 返回的是一个 32 位的值，假设 <code>Te0[0x1F1] = 0x12345678</code>。</li><li>通过索引，我们提取出的是这个条目中的第二个字节，即 <code>0x34</code>（如果 <code>Te0[0x1F1]</code> 是 <code>0x12345678</code>）。</li></ul><p>**<code>&lt;&lt; 8</code>**：</p><ul><li>这部分操作是将提取出来的字节左移 8 位。假设查找表 <code>Te0[0x1F1]</code> 的值是 <code>0x12345678</code>，那么 <code>Te0[0x1F1]</code> 的第二个字节是 <code>0x34</code>，通过左移 8 位（<code>0x34 &lt;&lt; 8</code>），我们得到的是 <code>0x3400</code>。</li></ul><p>可以看出：</p><p>这两者在字节提取和操作上有相似性：它们都旨在从一个 32 位数中提取出特定的字节并为后续的计算做好准备。</p><p>​其中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rk</span>[ <span class="hljs-number">9</span>] = rk[ <span class="hljs-number">1</span>] ^ rk[ <span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure><p>这里的STP存两个寄存器值，这段代码一共四个x2刚好8个，x0又是前面x2数组+32的位置</p><p>ARM 架构中的内存地址是按字节寻址的，即每个地址单元是 1 字节。遇到的常量通常是以<strong>字节为单位</strong></p><p><img src="https://s2.loli.net/2024/12/30/h7aXTbA8DmNnPjt.png" alt="image-20241230214231590"></p><blockquote><p>找弱点，特征(规律)</p></blockquote><h2 id="AES-encrypt-1"><a href="#AES-encrypt-1" class="headerlink" title="AES_encrypt"></a>AES_encrypt</h2><p>再看：</p><p><img src="https://s2.loli.net/2024/12/31/ufHeVrxXkd5AOqI.png" alt="image-20241231100714269"></p><p>其中1：表示将一众寄存器存储在栈上，用于保存当前函数调用所需的寄存器状态到栈中，确保它们在函数执行过程中不会被修改。</p><p>2：在汇编中，<code>LDP</code> 指令是 <strong>加载一对寄存器</strong>，每对寄存器加载两个 32 位数据。比如：LDP W8, W9, [X0]这条指令从内存地址 <code>X0</code> 加载两个 32 位值到 <code>W8</code> 和 <code>W9</code> 寄存器。如果 <code>X0</code> 指向 <code>in</code>，那么这条指令就加载了 <code>in[0..3]</code> 到 <code>W8</code> 和 <code>in[4..7]</code> 到 <code>W9</code>。</p><p>3：对各自取得的字节进行异或操作。</p><p>对应于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">s0 = GETU32(in     ) ^ rk[<span class="hljs-number">0</span>];<br>s1 = GETU32(in +  <span class="hljs-number">4</span>) ^ rk[<span class="hljs-number">1</span>];<br>s2 = GETU32(in +  <span class="hljs-number">8</span>) ^ rk[<span class="hljs-number">2</span>];<br>s3 = GETU32(in + <span class="hljs-number">12</span>) ^ rk[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>其中每一个rk占4字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> <span class="hljs-type">u32</span> *rk;<br></code></pre></td></tr></table></figure><p>对于9轮循环，我们只截取关键部分进行查看：</p><p><img src="https://s2.loli.net/2024/12/31/ovKLJGfCwHdU5Nc.png" alt="image-20241231102720499"></p><p>在汇编中：</p><blockquote><p>UBFX            W4, W15, #8, #8</p></blockquote><p>实现了(s2 &gt;&gt;  8) &amp; 0xff提取字节的操作</p><blockquote><p>LDR             W4, [X11,W4,UXTW#2]</p></blockquote><p>实现了查表的操作：Te2[(s2 &gt;&gt;  8) &amp; 0xff]</p><blockquote><p>EOR             W0, W0, W3</p></blockquote><p>实现迭代异或的中间保存值</p><blockquote><p> LSR             W19, W15, #24</p></blockquote><p>逻辑右移操作</p><p>这个过程：</p><p><img src="https://s2.loli.net/2024/12/31/pzSPL2n9Bf6ui48.png" alt="image-20241231113916900"></p><p>两组合并：</p><p><img src="https://s2.loli.net/2024/12/31/hJ5xgArd2W6kEPR.png" alt="image-20241231114556615"></p><p>反编译代码:</p><p><img src="https://s2.loli.net/2024/12/31/gbSTr9ncWOXNBml.png" alt="image-20241231114618462"></p><blockquote><p>汇编与高级语言有巨大差异，汇编会对一个变量的变化求根问底</p></blockquote><p>最后一轮</p><p><img src="https://s2.loli.net/2024/12/31/jv2CGrHU1RXBadF.png" alt="image-20241231114700152"></p><p>反编译同前面的密钥扩展相似，不多介绍</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
      <category>对称密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2023/01/30/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2023/01/30/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早年在知乎发的文章，现转载到博客上</p></blockquote><h2 id="网络层的作用？"><a href="#网络层的作用？" class="headerlink" title="网络层的作用？"></a>网络层的作用？</h2><p>网络层的作用从表面上看极为简单，即将分组从一台发送主机移动到一台接收主机</p><p>为此，需要两种重要的网络层功能:</p><p><strong>转发：</strong>当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适</p><p>当的输出链路 例如，来自主机 Hl 到路由器 Rl 的一个分组，必须向在 H2 路径</p><p>上的下一台路由器转发。</p><p><strong>路由选择</strong> 当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路</p><p>由或路径，计算这些路径的算法被称为路由选择算法</p><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><p><img src="https://pic1.zhimg.com/v2-8f832cedebafa39ac1198a6b62ca85b2_1440w.jpg" alt="img"></p><p>IP是TCP&#x2F; IP协议族中最为核心的协议。其提供不可靠、无连接的数据报传送服务。</p><p><strong>不可靠</strong>的意思是它不能保证 I P数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送 ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如T C P）。</p><p><strong>无连接</strong>的意思是 IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B可能在A到达之前先到达。</p><h3 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h3><p><img src="https://pic4.zhimg.com/v2-b3fdfa34bf1e361f458e1cdecf5bfee3_1440w.jpg" alt="img"></p><ol><li>首部长度指的是首部占 32 bit字的数目，包括任何选项。由于它是一个 4比特字段，因此首部最长为60个字节。</li><li>服务类型字段包括一个3 bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位但必须置0。4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。</li><li>总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道 I P数据报中数据内容的起始位置和长度。由于该字段长 1 6比特，所以 I P数据报最长可达 6 5 5 3 5字节，当数据报被分片时，该字段的值也随着变化。</li><li>标识字段唯一地标识主机发送的每一份数据报。</li><li>首部检验和字段是根据I P首部计算的检验和码。它不对首部后面的数据进行计算IC MP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</li></ol><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h3 id="IP地址表示-分类"><a href="#IP地址表示-分类" class="headerlink" title="IP地址表示+分类"></a>IP地址表示+分类</h3><p><img src="https://pic2.zhimg.com/v2-ee98958735d93da93e5761ee7342614f_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-a640ac196dc7213ec9df92ce71685173_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-bcd8da781302b3623e9649cfbf5b2ce6_1440w.jpg" alt="img"></p><h3 id="IP子网划分"><a href="#IP子网划分" class="headerlink" title="IP子网划分"></a>IP子网划分</h3><p>子网划分这项技术用来把一个单一的IP网络地址划分成多个更小的子网(subnet)。 这种技术可使一个较大的分类IP地址能够被进一步划分为几个子网。通常是把IP地址中主机标识部分划出一定的位数用作本网的各个子网，剩余的主机标识作为相应子网的主机标识部分。</p><p>（地址掩码是一个32位的二进制数，用于指示一个IP地址中哪些位用于网络标识，哪些位用于主机标识。地址掩码与IP地址一起使用，确定IP地址的网络部分和主机部分。）</p><p><img src="https://pic2.zhimg.com/v2-e44d00a81ccb160b9052737929c13b85_1440w.jpg" alt="img"></p><h3 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h3><p>在传统的地址分配方法中，如果一个组织只需要500个IP地址，但是它被分配了一个B类地址，这意味着该组织将获得超过65000个IP地址的地址块，其中绝大多数都无法使用。这会导致大量的IP地址浪费。为了解决IPv4地址空间不足的问题而提出CIDR。</p><p><strong>通过将IP地址划分为更小的子网来解决这个问题</strong>。CIDR中，一个IP地址由网络前缀和主机标识符两部分组成，其中网络前缀用于标识主机所在的网络，主机标识符用于标识该主机在该网络中的位置。CIDR中，网络前缀的长度可以是任意的，这使得网络管理员可以更灵活地分配IP地址，从而减少了IP地址的浪费。</p><p><img src="https://pic4.zhimg.com/v2-d3c6c4f7c280be324b8e4fbe0f830bc1_1440w.jpg" alt="img"></p><h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p><strong>数据链路如以太网或令牌环网都有自己的寻址机制</strong>（常常为 48 bit地址），这是使用数据链路的任何网络层都必须遵从的。一个网络如以太网可以同时被不同的网络层使用。例如，一组使用T P&#x2F;IP协议的主机和另一组使用某种P C网络软件的主机可以共享相同的电缆。当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据 48 bit的以太网地址来确定目的接口的。设备驱动程序从不检查 I P数据报中的目的I P地址。地址解析为这两种不同的地址形式提供映射：32 bit的IP地址和数据链路层使用的任何类型的地址。ARP为IP地址到对应的硬件地址之间提供动态映射。</p><h3 id="ARP的分组格式"><a href="#ARP的分组格式" class="headerlink" title="ARP的分组格式"></a>ARP的分组格式</h3><p><img src="https://pic2.zhimg.com/v2-c910e8824efb3f6ab08b1a751d3c7159_1440w.jpg" alt="img"></p><h3 id="ARP工作原理"><a href="#ARP工作原理" class="headerlink" title="ARP工作原理"></a>ARP工作原理</h3><p><strong>ARP请求：</strong></p><p>当主机A知道目标主机的IP地址，但不知道其对应的MAC地址时，它会在局域网内广播一个ARP请求包，请求其他主机告知该IP地址对应的MAC地址。</p><p><strong>ARP应答：</strong></p><p>目标主机收到ARP请求后，如果发现自己的IP地址与请求中的IP地址相符，就会向源主机发送一个ARP应答包，其中包含自己的MAC地址。</p><p><strong>ARP缓存：</strong></p><p>每个主机在接收到ARP应答后，会将对应的IP地址和MAC地址进行缓存，以便将来直接进行通信而不需要再次发送ARP请求。</p><p><strong>ARP欺骗：</strong></p><p>由于ARP协议的工作原理，存在一定的安全漏洞，即ARP欺骗，攻击者可以发送虚假的ARP响应，欺骗其他主机将其数据发送到攻击者的主机上。</p><h3 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h3><p><img src="https://pic4.zhimg.com/v2-94f51d069fb6851230d6aa58653a7ed7_1440w.jpg" alt="img"></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="路由器演变历史"><a href="#路由器演变历史" class="headerlink" title="路由器演变历史"></a>路由器演变历史</h3><p><strong>早期网络：</strong></p><p>在互联网发展的初期，网络通信主要基于主机到主机的连接方式。每个主机都需要了解整个网络的拓扑结构，并且需要知道如何直接与其他主机进行通信。</p><p><strong>分组交换网络：</strong></p><p>随着网络规模的增长，主机到主机的连接方式变得不可行且低效。为了提高网络性能，分组交换网络应运而生。这种网络将数据分割成小的数据包（分组），每个数据包独立传输，并通过网络中的节点进行转发。</p><p><strong>网络节点：</strong></p><p>为了实现分组交换，网络中的节点（也称为数据包交换机）开始出现。这些节点负责接收数据包，并根据目标地址来决定将数据包转发到哪个接口。</p><p><strong>路由表：</strong></p><p>随着网络规模的进一步增长，网络中的节点需要更复杂的路由决策。为此，引入了路由表的概念。路由表包含了网络中不同目标地址所对应的下一跳信息，用于指导数据包的转发。</p><p><strong>路由器的出现：</strong></p><p>随着网络规模的不断扩大，为了更高效地管理网络流量和实现灵活的路由决策，专用的路由器设备开始出现。路由器是一种硬件设备，具有处理数据包转发和路由协议等功能。</p><p><strong>路由协议：</strong></p><p>路由器通过使用各种路由协议（如RIP、OSPF、BGP等）来学习和交换路由信息。这些协议使得路由器能够动态地更新路由表，并根据网络状况进行最优的路由选择。</p><p><strong>随着互联网的快速发展，路由器的功能和性能也得到了不断的提升。现代路由器不仅用于连接不同的局域网和广域网，还具备防火墙、VPN、负载均衡等功能，成为网络中重要的基础设施之一。</strong></p><p><img src="https://pica.zhimg.com/v2-896bde3f226a3b26e686c98d12b258ee_1440w.jpg" alt="img"></p><h3 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h3><p><strong>接收数据包：</strong></p><p>路由器通过其接口（例如以太网、无线）接收到来自源主机的数据包。</p><p><strong>解析目标地址：</strong></p><p>路由器检查数据包的目标IP地址，并在其路由表中查找匹配项。路由表中的条目通常包括目标网络的IP地址范围和下一跳的信息。</p><p><strong>查找最佳路径：</strong></p><p>路由器根据路由表中的信息确定最佳的转发路径。这可能涉及到多个路由器之间的转发。</p><p><strong>转发数据包：</strong></p><p>路由器将数据包发送到下一跳或目标网络。它会通过适当的接口将数据包传输到相应的网络。</p><p><strong>更新路由表：</strong></p><p>路由器可以使用动态路由协议（如RIP、OSPF、BGP等）学习和更新路由表。这些协议允许路由器与其他路由器交换路由信息，以便实时地调整路由选择。</p><p><strong>网络地址转换（NAT）（可选）：</strong></p><p>在某些情况下，路由器可能还执行网络地址转换（NAT）的功能。NAT将私有IP地址转换为公共IP地址，以便在互联网上进行通信。</p><p><strong>安全功能（可选）：</strong></p><p>现代路由器通常还具备防火墙、入侵检测和虚拟专用网络（VPN）等安全功能，以保护网络免受恶意攻击和非法访问。</p><p><img src="https://pica.zhimg.com/v2-12cc1c15e971ab9859917a3997b4eb50_1440w.jpg" alt="img"></p><h3 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h3><p>虚拟专用网络（VPN）是一种通过公共网络（如互联网）建立安全的连接的技术。</p><p>VPN 的主要目的是提供一个加密和匿名的网络连接，使用户可以在不安全的公共网络上进行安全的通信。它通过在用户设备和目标服务器之间创建一个加密的隧道来保护数据的传输。这使得用户可以在公共网络上发送和接收数据，同时保持数据的机密性和完整性。</p><p><strong>使用 VPN 可以带来以下好处：</strong></p><p>数据加密：VPN 使用加密技术对数据进行加密，从而保护用户的隐私和敏感信息，防止被窃听或篡改。</p><p>匿名性：VPN 可以隐藏用户的真实 IP 地址，并代表用户向目标服务器发送请求，增强了用户的匿名性和隐私保护。</p><p><strong>绕过地理限制：</strong>通过连接到不同地区的 VPN 服务器，用户可以绕过地理限制，访问被限制在特定地区的内容和服务。</p><p>公共Wi-Fi 安全：当使用公共 Wi-Fi 网络时，VPN 可以提供额外的安全性，防止黑客和恶意用户窃取用户的个人信息。</p><h3 id="VPN工作原理"><a href="#VPN工作原理" class="headerlink" title="VPN工作原理"></a>VPN工作原理</h3><ol><li><strong>建立连接：</strong>用户打开 VPN 客户端，并选择连接到 VPN 服务器。客户端和服务器之间建立一个安全的连接。</li><li><strong>数据加密：</strong>在建立连接后，VPN 客户端和服务器之间的通信会使用加密算法对数据进行加密。这样，即使有人截获了数据包，也无法解读其内容。</li><li><strong>数据封装：</strong>当用户发送数据时，VPN 客户端会将数据包装在一个新的数据包中，添加了VPN的头部信息。这个过程称为“封装”（encapsulation）。</li><li><strong>隧道传输：</strong>经过封装后的数据被发送到 VPN 服务器，通过公共网络进行传输。由于数据已被加密和封装，所以即使在传输过程中被窃听，也无法获取其原始内容。</li><li><strong>数据解封装：</strong>一旦数据抵达 VPN 服务器，服务器会解开封装，还原原始数据。</li><li>目标访问：解封装后的数据会被发送到目标服务器，目标服务器会向其响应。</li><li>响应封装：目标服务器的响应数据会被封装，加上VPN的头部信息。</li><li><strong>返回给客户端：</strong>封装后的响应数据通过加密隧道返回到 VPN 客户端，然后在客户端进行解封装和解密。</li></ol><h3 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h3><p>网络地址转换（NAT）是一种将私有 IP 地址转换为公共 IP 地址的技术。NAT 技术主要用于在局域网和互联网之间进行通信时，使得局域网中的多个主机可以使用同一个公共 IP 地址访问互联网。</p><p>NAT 的基本原理是将内部网络的私有 IP 地址映射到公共 IP 地址，这样就可以在不改变内部网络结构的情况下实现网络连接。例如，当内部网络的主机向外部网络发送请求时，路由器会将其源 IP 地址修改为公共 IP 地址，以便从外部网络响应请求。</p><p><img src="https://pic1.zhimg.com/v2-25839a5f59c066e6fdccb158604ab810_1440w.jpg" alt="img"></p><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>路由表（Routing Table）是路由器或计算机操作系统中存储的一种数据结构，它用于决定数据包从源地址到目的地址的传输路径。路由表中包含了各种网络目的地及与之相关联的下一跳信息，以帮助设备进行数据包的转发和路由选择。路由表中的每一项都包含下面这些信息：</p><p>• 目的I P地址。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定（如下所述）。主机地址有一个非0的主机号（见图1 - 5），以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。</p><p>• 下一站（或下一跳）路由器（ next-hop router）的I P地址，或者有直接连接的网络 I P地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。</p><p>• 标志。其中一个标志指明目的 I P地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口（我们将在 9 . 2节中详细介绍这些标志）。</p><p>• 为数据报的传输指定一个网络接口。</p><p><img src="https://picx.zhimg.com/v2-282d2b29bb8e2b9cbf6adc4e2af92393_1440w.jpg" alt="img"></p><h2 id="IP选路"><a href="#IP选路" class="headerlink" title="IP选路"></a>IP选路</h2><h3 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h3><p>IP路由选择是逐跳地进行的。IP并不知道到达任何目的的完整路径（当然，除了那些与主机直接相连的目的）。所有的IP路由选择只为数据报传输提供下一站路由器的 I P地址。它假定下一站路由器比发送数据报的主机更接近目的，而且下一站路由器与该主机是直接相连的。</p><p>IP路由选择主要完成以下这些功能：</p><ol><li>搜索路由表，寻找能与目的 I P地址完全匹配的表目（网络号和主机号都要匹配）。如果<br>找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标<br>志字段的值）。</li><li>搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑可能的子网掩码。关于这一点我们在下一节中进行讨论。</li><li>搜索路由表，寻找标为“默认”的表目。如果找到，则把报文发送给该表目</li></ol><p>指定的下一站路由器。</p><p>如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。（网络控制报文协议ICMP）<strong>一个例子：</strong></p><p>主机 b s d i有一个I P数据报要发送给主机 s u n。双方都在同一个以太网上。</p><p><img src="https://picx.zhimg.com/v2-89da487f5b5204ae0ce34157b046c47f_1440w.jpg" alt="img"></p><p>主机 b s d i有一个I P数据报要发送给主机 s u n。双方不在同一个以太网上。</p><p><img src="https://pica.zhimg.com/v2-1a6e4c5a65aa3aec676c3c83e1eb9914_1440w.jpg" alt="img"></p><p>对于这个例子需要指出一些关键点：</p><ol><li>该例子中的所有主机和路由器都使用了默认路由。事实上，大多数主机和一些路由器<br>可以用默认路由来处理任何目的，除非它在本地局域网上。</li><li>数据报中的目的I P地址始终不发生任何变化，只有使用源路由选项时，目的I P地址才有可能被修改，但这种情况很少出现）。所有的路由选择决策都是基于这个目的I P地址。</li><li>每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址。在例子中，两个以太网封装了含有下一站以太网地址的链路层首部，但是S L I P链路没有这样做。以太网地址一般通过ARP获得。</li></ol><h3 id="IP动态选路协议"><a href="#IP动态选路协议" class="headerlink" title="IP动态选路协议"></a>IP动态选路协议</h3><p>在网络很小，且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用静态路由选择是可行的。但如果上述三种情况不能全部满足，通常使用<strong>动态选路</strong>。</p><p>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器之间必须采用选路协议进行通信，。路由器上有一个进程称为路由守护程序，它运行选路协议,并与其相邻的一些路由器进行通信。路由守护程序根据它从相邻路由器接收到的信息，更新内核中的路由表。动态选路并不改变选路机制内核搜索路由表，查找主机路由、网络路由以及默认路由的方式并没有改变。仅仅是放置到路由表中的信息改变了—当路由随时间变化时，路由是由路</p><p>由守护程序动态地增加或删除。Interne是以一组自治系统的方式组织的，每个自治系统通常由单个实体管理。常常将一个公司或大学校园定义为一个自治系统。 N S F N E T的In t e r n e t骨干网形成一个自治系统，这是因为骨干网中的所有路由器都在单个的管理控制之下。<strong>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为内部网关协议IGP或域内选路协议.</strong></p><p><strong>外部网关协议EGP或域内选路协议的分隔选路协议用于不同自治系统之间的路由器。</strong></p><h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3><p>RIP是一种基于距离向量的内部网关协议（IGP），用于在小型网络中动态交换路由信息。RIP是一种简单、易于实现的路由协议，常用于较小规模的网络环境。</p><h3 id="RIP报文格式"><a href="#RIP报文格式" class="headerlink" title="RIP报文格式"></a>RIP报文格式</h3><p><img src="https://picx.zhimg.com/v2-6c376ed9df6cd0338b30cf78ae391d57_1440w.jpg" alt="img"></p><h3 id="RIP协议的一些特点："><a href="#RIP协议的一些特点：" class="headerlink" title="RIP协议的一些特点："></a>RIP协议的一些特点：</h3><p><strong>距离向量：</strong>RIP使用距离向量算法来计算到达目的网络的最佳路径。每个路由器根据收到的邻居路由器的距离信息，更新自己的路由表。</p><p><strong>距离度量：</strong>RIP使用跳数作为距离度量，即将到达目的网络所经过的路由器数量作为衡量路径优劣的标准。默认情况下，RIP将跳数限制在15跳以内，超过这个跳数则认为到达目的地不可达。</p><p><strong>广播更新：</strong>RIP使用广播方式周期性地向网络中的其他路由器发送路由更新信息，以交换路由信息。这样，所有路由器都能了解到整个网络的拓扑结构，并相应地更新自己的路由表。</p><p><strong>慢收敛：</strong>由于RIP的更新机制是周期性的，而且RIP对网络变化的检测和适应较慢，因此RIP的收敛速度相对较慢。这意味着在网络发生变化时，RIP可能需要一段时间才能适应新的路由变化。</p><h3 id="RIP工作原理："><a href="#RIP工作原理：" class="headerlink" title="RIP工作原理："></a>RIP工作原理：</h3><p>• 初始化：在启动一个路由守护程序时，它先判断启动了哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点的。如果网络支持广播的话，这种请求是以广播形式发送的。目的 U D P端口号是5 2 0（这是其他路由器的路由守护程序端口号）。这种请求报文的命令字段为 1，但地址系列字段设置为 0，而度量字段设置为 1 6。这是一种要求另一端完整路由表的特殊请求报文。</p><p>• 接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为 1 6（度量为1 6是一种称为“无穷大”的特殊值，它意味着没有到达目的的路由）。然后发回响应。</p><p>• 接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。</p><p>• 定期选路更新。每过3 0秒，所有或部分路由器会将其完整路由表发送给相邻路由器。发送路由表可以是广播形式的（如在以太网上），或是发送给点对点链路的其他终点的命令</p><p>• 触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。每条路由都有与之相关的定时器。如果运行 R I P的系统发现一条路由在 3分钟内未更新，</p><p>就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在 6个3 0秒更新时间里没收到通告该路由的路由器的更新了。再过 6 0秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</p><p><img src="https://picx.zhimg.com/v2-8d3b7cf2cd86ddb01bef5d752611500b_1440w.jpg" alt="img"></p><h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3><p>O S P F是除R I P外的另一个内部网关协议。它克服了 R I P的所有限制。</p><p>与采用距离向量的 R I P协议不同的是， O S P F是一个链路状态协议。距离向量的意思是，</p><p>R I P发送的报文包含一个距离向量（跳数）。每个路由器都根据它所接收到邻站的这些距离向量来更新自己的路由表。</p><p>在一个链路状态协议中，路由器并不与其邻站交换距离信息。它采用的是每个路由器主</p><p>动地测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在</p><p>自治系统中传播出去。每个路由器接收这些链路状态信息，并建立起完整的路由表。</p><p>由于各路由器之间频繁的交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库(link-state database)，这个数据库的实质是全网的拓扑结构图，这个拓扑结构在全网就是一致的。因此，每一个路由器知道全网共有多少个路由器，以及那些路由器是相连的，其代价是多少等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表(例如迪杰斯特拉的最短路径算法)。我们注意到，RIP协议的每一个路由器虽然知道所有网络的距离以及下一跳以及下一跳路由器，但却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳怎么走)。</p><p><img src="https://pic4.zhimg.com/v2-36d7c45ca42aa6c6ddb89a539794312b_1440w.jpg" alt="img"></p><p>从实际角度来看，二者的不同点是链路状态协议总是比距离向量协议收敛更快。收敛的意思是在路由发生变化后，例如在路由器关闭或链路出故障后，可以稳定下来。</p><p><strong>OSPF的三个要点和RIP都不一样：</strong></p><ol><li>向本自治系统中的所有路由器发送信息。这里使用的方法是洪范法(flooding)，</li></ol><p><img src="https://pic4.zhimg.com/v2-8af5f59d24aac8052f63f15e77abc0f7_1440w.jpg" alt="img"></p><p>这就是路由器通过所有输出端口向相邻的路由器发送信息。而每一个相邻的路由器又再将此信息发往其所有的相邻路由器。这样，最终整个所有的路由器都得到了这个信息的一个副本。更具体的做法后面继续讨论，我们应该注意，RIP协议是仅仅向自己相邻的几个路由器发送信息。</p><p>2，发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息，所谓的链路状态就是说明本路由状态都和哪些路由相邻，对于RIP协议，发送的信息是：“到所有网络的距离和下一跳路由器”。</p><p>3，只有当链路状态发生变化时候，路由器才能向所有路由器采用洪范法发送此信息。而不像RIP那样，不管网络拓扑结构是否发生变化，路由器之间都要定期更换路路由表信息。</p><h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>OSPF、ISIS路由协议在网络中已经广泛使用，但是随着网络规模的扩大，路由条目也随增加，IGP协议已经无法管理大规模网络了。因此出现了AS的概念。（AS是指在同一组织管理下，使用统一选路策略设备的集合。）</p><p>简单来说：就是你可以把一个网络中的不同的设备划分到不同的组（AS）中，或者都划分在一个组中，那么一个组中的这些设备具备相同的路由协议。</p><p><img src="https://pic1.zhimg.com/v2-e01220b4542d0955cc8dfe299575e2ba_1440w.jpg" alt="img"></p><p>比如你可以将企业总部网络划分在一个AS中，企业的分部网络划分在一个AS中。不同的AS可以运行不同的路由协议。</p><p>那么不同AS的网络需要通信时，采用什么路由协议进行通信呢？答案就是本章的BGP路由协议。那么为什么不能够通过IGP（ISIS、BGP）进行通信呢？</p><p>这个举个简单的例子，企业网络或者数据中心网络对接运营商的Internet时。如果使用IGP路由协议（OSPF、ISIS）对接时，那么这个时候企业网络和运营商的网络是运行在一张网络中，这个是不安全的，你可以认为运营商为什么信任你的企业网络？</p><p>还有一点就是整个网络规模扩大，路由数量增多，路由收敛慢。</p><p>那么有没有一种路由协议可以实现不同网络间的路由交互呢？答案就是BGP。BGP有个好处就是不产生路由，只传递路由，并且具备丰富的路由策略。</p><p><img src="https://pica.zhimg.com/v2-081d688950d282171eb0fea7c2fd1050_1440w.jpg" alt="img"></p><h3 id="BGP传递路由优势"><a href="#BGP传递路由优势" class="headerlink" title="BGP传递路由优势"></a>BGP传递路由优势</h3><p>BGP是基于TCP的路由协议，只要能够建立TCP就能够建立BGP；</p><p>BGP只传递路由信息，不计算路由，不会暴露AS内部的网络拓扑；</p><p>BGP的路由更新是触发更新，不是周期性更新；</p><h3 id="什么是BGP路由协议"><a href="#什么是BGP路由协议" class="headerlink" title="什么是BGP路由协议"></a>什么是BGP路由协议</h3><p>BGP是一种基于距离矢量的路由协议，用于实现不同AS之间的路由可达。</p><p>BGP协议的基本特点：</p><p>（1）BGP是一种外部网关协议，其着眼点不在于发现和计算路由，而在于控制路由的传播和选择最佳路由；</p><p>（2）BGP使用TCP作为其传输层协议（端口号179）,提高了协议的可靠性；</p><p>（3）BGP是一种距离矢量路由协议，在设计上就避免了环路的发生；</p><p>（4）BGP提供了丰富的路由策略，能够实现路由的灵活过滤和选择；</p><p>（5）BGP采用触发式增量更新，而不是周期性的更新；</p><h3 id="BGP报文头格式"><a href="#BGP报文头格式" class="headerlink" title="BGP报文头格式"></a>BGP报文头格式</h3><p>不同于常见的IGP协议，BGP使用TCP作为传输层协议，端口号179。BGP存在5种不同类型的报文，不同类型的报文具有相同的头部。</p><p><img src="https://pic4.zhimg.com/v2-c7e39eff0fdf0e6458cb632f9a3ad1b7_1440w.jpg" alt="img"></p><p><strong>BGP选路规则与负载分担</strong></p><p>当到达同一目的地存在多条路由时，BGP采取如下策略进行路由选择：</p><p>如果此路由的下一跳不可达，忽略此路由</p><p>优选协议首选值（PrefVal）最高的路由 （华为设备特有属性）</p><p>优选本地优先级（Local_Pref）最高的路由</p><p>优选本地生成的路由</p><p>优选AS路径（AS_Path）最短的路由</p><p>比较Origin属性，依次优选Origin类型为IGP、EGP、Incomplete的路由</p><p>优选MED值最低的路由</p><p>优选从EBGP邻居学来的路由</p><p>优选到BGP下一跳IGP Metric较小的路由</p><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>I C M P经常被认为是 I P层的一个组成部分。它传递差错报文以及其他需要注意的信息。</p><p>I C M P报文通常被I P层或更高层协议（ T C P或U D P）使用。一些 I C M P报文把差错报文返回给用户进程。</p><h3 id="ICMP背景与作用"><a href="#ICMP背景与作用" class="headerlink" title="ICMP背景与作用"></a>ICMP背景与作用</h3><p>ICMP协议是一个网络层协议。 一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。因此我们需要ICMP协议来完成这样的功能。</p><p><strong>ICMP消息可以用于以下几个方面：</strong></p><p><strong>错误报告</strong>：当在路由过程中遇到问题或数据包丢失时，路由器或主机会向发送者发送ICMP错误消息，以便通知发送者发生了错误。例如，ICMP目的不可达消息可以告知发送者目标主机不可达。</p><p><strong>查询和回应</strong>：ICMP还支持查询和回应功能，用于获取关于网络设备的状态信息。例如，ICMP回应消息用于确认数据包是否成功到达目标主机，ICMP Echo请求和回应消息则用于进行网络连通性测试（常见的Ping操作）。</p><p><strong>重定向</strong>：当路由器接收到数据包并发现更好的路径时，可以使用ICMP重定向消息通知发送者使用新的路径来发送数据。</p><p><strong>时间戳</strong>：ICMP还支持时间戳请求和回应消息，用于测量网络延迟和授时。</p><p>ICMP消息通常被底层网络设备（如路由器）生成和处理，以帮助维护网络的正常运行和故障排除。在网络故障排查和网络监测中，ICMP起到了重要的作用，可以提供关键的信息来诊断和解决网络问题。</p><p>ICMP协议的功能主要有：</p><p>确认IP包是否成功到达目标地址</p><p>通知在发送过程中IP包被丢弃的原因</p><p><img src="https://pic2.zhimg.com/v2-2e2a022b814d598c41ed8576684a20fd_1440w.jpg" alt="img"></p><p><strong>ICMP报文</strong></p><p><img src="https://pic1.zhimg.com/v2-9ccfbdc7625b117d42970c2156a89fb2_1440w.jpg" alt="img"></p><p>类型：占1字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文</p><p>代码：占1字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型</p><p>校验和：占2字节，这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错</p><p>内容：占8字节。</p><h3 id="ICMP报文的类型"><a href="#ICMP报文的类型" class="headerlink" title="ICMP报文的类型"></a>ICMP报文的类型</h3><p>常见的ICMP报文可以分为两大类，即差错报文和查询报文。</p><p>当发送一份I C M P差错报文时，报文始终包含 I P的首部和产生I C M P差错报文的I P数据报的前8个字节。这样，接收 I C M P差错报文的模块就会把它与某个特定的协议（根据 I P数据报首部中的协议字段来判断）和用户进程（根据包含在 I P数据报前8字节中的T C P或U D P报文首部中的T C P或U D P端口号来判断）联系起来。</p><p><img src="https://pica.zhimg.com/v2-668cb57e318656d7c90cefcef8f8e726_1440w.jpg" alt="img"></p><p>下面各种情况都不会导致产生 I C M P差错报文：</p><ol><li>ICMP差错报文（但是，I C M P查询报文可能会产生I C M P差错报文）。</li><li>目的地址是广播地址（见图 3 - 9）或多播地址（D类地址，见图1 - 5）的I P数据报。</li><li>作为链路层广播的数据报。</li><li>不是I P分片的第一片（将在11 . 5节介绍分片）。</li><li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地</li></ol><p>址或多播地址。</p><p>这些规则是为了防止过去允许 I C M P差错报文对广播分组响应所带来的广播风暴。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6是用于网络通信的下一代IP协议。它是IPv4的继任者，旨在解决IPv4所面临的地址空间枯竭和其他一些限制性问题。</p><h3 id="基本首部"><a href="#基本首部" class="headerlink" title="基本首部"></a>基本首部</h3><p><img src="https://pic2.zhimg.com/v2-887eb41091f3ca32b729c846fca87727_1440w.jpg" alt="img"></p><h3 id="改进和特性"><a href="#改进和特性" class="headerlink" title="改进和特性"></a>改进和特性</h3><p><strong>更大的地址空间：</strong>IPv6采用128位的地址空间，相比IPv4的32位地址空间大得多，提供了约340亿亿亿亿（3.4×10^38）个可用的IP地址。这样大的地址空间可以满足未来互联网设备的需求，并解决了IPv4中出现的地址耗尽问题。</p><p><strong>简化的地址表示</strong>：IPv6地址使用8组四位十六进制数表示，以冒号分隔，例如2001:0db8:85a3:0000:0000:8a2e:0370:7334。为了进一步简化表示，连续的0可以省略并用“::”表示一次，例如2001:0db8:85a3::8a2e:0370:7334。这种简化的表示形式使IPv6地址更易读和管理。</p><p><strong>改进的扩展性和灵活性</strong>：IPv6引入了扩展头（Extension Headers）的概念，可以在IPv6数据包中添加各种扩展选项，如认证和加密扩展。这种灵活性使得IPv6在支持新的网络功能和服务方面更具有优势。</p><p><strong>改进的安全性：</strong>IPv6在协议层面提供了更强的安全性支持，包括IPsec（IP Security）的原生支持。IPsec可以提供数据的加密、身份验证和完整性保护，为网络通信提供更高的安全性。</p><p>改进的多播支持：IPv6对多播（Multicast）进行了改进，引入了一种新的多播地址类型，称为组播地址，用于在IPv6网络中进行有效的多播通信。</p><p><strong>简化的网络配置：</strong>IPv6通过自动配置的方式，使得网络设备可以自动获取全局唯一的IPv6地址，而无需手动配置或使用DHCP（Dynamic Host Configuration Protocol）。这种简化的网络配置过程降低了网络管理的复杂性。</p><h2 id="网络组管理协议IGMP"><a href="#网络组管理协议IGMP" class="headerlink" title="网络组管理协议IGMP"></a>网络组管理协议IGMP</h2><p>IGMP是一种用于在IP网络中进行组播管理的协议。</p><p>组播是一种将数据包从一个源发送到多个目的地的通信方式，可以有效地实现多播流量的分发。IGMP协议用于主机和路由器之间的交互，以便主机能够加入、离开和查询组播组，并确保只有对组播感兴趣的主机接收到相关数据。</p><h3 id="IGMP报文"><a href="#IGMP报文" class="headerlink" title="IGMP报文"></a>IGMP报文</h3><p><img src="https://pic1.zhimg.com/v2-f9d96b14ed3e22f32b9363314f66f774_1440w.jpg" alt="img"></p><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h3><p>多播的基础就是一个进程的概念（使用的术语进程是指操作系统执行的一个程序），该进</p><p>程在一个主机的给定接口上加入了一个多播组。在一个给定接口上的多播组中的成员是动态的—它随时因进程加入和离开多播组而变化。</p><p>这里所指的进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加</p><p>入的多播组。这些是一个支持多播主机中任何 A P I所必需的部分。使用限定词“接口”是因为多播组中的成员是与接口相关联的。一个进程可以在多个接口上加入同一多播组。</p><p><strong>多播路由器使用I G M P报文来记录与该路由器相连网络中组成员的变化情况。使用规则如</strong></p><p><strong>下：</strong></p><ol><li>当第一个进程加入一个组时，主机就发送一个 I G M P报告。如果一个主机的多个进程加入同一组，只发送一个I G M P报告。这个报告被发送到进程加入组所在的同一接口上。</li><li>进程离开一个组时，主机不发送 I G M P报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的 I G M P查询中就不再发送报告报文。</li><li>多播路由器定时发送I G M P查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个 I G M P查询。因为路由器希望主机对它加入的每个多播组均<br>发回一个报告，因此I G M P查询报文中的组地址被设置为 0。</li><li>主机通过发送I G M P报告来响应一个I G M P查询，对每个至少还包含一个进程的组均要发回I G M P报告。</li></ol><p><strong>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还</strong></p><p><strong>包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使</strong></p><p><strong>用相应的多播链路层地址）还拥有属于那个组主机的接口上。</strong></p><p><img src="https://pic3.zhimg.com/v2-da1fb8f9b33337f01f143cb488eddd32_1440w.jpg" alt="img"></p><p>多播是一种将报文发往多个接收者的通信方式。在许多应用中，它比广播更好，因为多播降低了不参与通信的主机的负担。简单的主机成员报告协议 ( I G M P )是多播的基本模块。在一个局域网中或跨越邻近局域网的多播需要使用这里介绍的技术。广播通常局限在单个局域网中，对目前许多使用广播的应用来说，可采用多播来替代广播。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外存管理【补充】</title>
    <link href="/2023/01/25/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91/"/>
    <url>/2023/01/25/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="I-O系统的功能-模型和接口"><a href="#I-O系统的功能-模型和接口" class="headerlink" title="I&#x2F;O系统的功能,模型和接口"></a>I&#x2F;O系统的功能,模型和接口</h1><h2 id="I-O系统的层次结构和模型"><a href="#I-O系统的层次结构和模型" class="headerlink" title="I&#x2F;O系统的层次结构和模型"></a>I&#x2F;O系统的层次结构和模型</h2><h3 id="I-O软件的层次结构"><a href="#I-O软件的层次结构" class="headerlink" title="I&#x2F;O软件的层次结构"></a>I&#x2F;O软件的层次结构</h3><table><thead><tr><th><strong>层次</strong></th><th><strong>功能描述</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td><strong>用户层 I&#x2F;O 软件</strong></td><td>与用户交互，提供I&#x2F;O请求生成、格式化、排队等功能</td><td><code>read()</code>、<code>write()</code> 系统调用，Spooling 系统</td></tr><tr><td><strong>设备独立性软件</strong></td><td>提供设备抽象，统一设备命令，资源分配与缓冲区管理</td><td>操作系统中与设备独立的驱动接口</td></tr><tr><td><strong>设备驱动程序</strong></td><td>直接控制硬件设备，执行操作命令，数据传输</td><td>磁盘驱动程序，打印机驱动程序</td></tr><tr><td><strong>中断处理程序 (ISR)</strong></td><td>处理硬件中断，保存和恢复现场，执行中断响应</td><td>设备I&#x2F;O完成中断，硬件故障中断处</td></tr></tbody></table><p><img src="https://s2.loli.net/2025/01/03/YdmZncQXk1Ny9ib.png" alt="image-20250103210526054"></p><h3 id="IO系统各模块之间的层次视图"><a href="#IO系统各模块之间的层次视图" class="headerlink" title="IO系统各模块之间的层次视图"></a><strong>IO系统各模块之间的层次视图</strong></h3><p><img src="https://s2.loli.net/2025/01/03/OIZmf6QMzTNaSyG.png" alt="image-20250103210726591"></p><h4 id="I-O系统的上下接口"><a href="#I-O系统的上下接口" class="headerlink" title="I&#x2F;O系统的上下接口"></a>I&#x2F;O系统的上下接口</h4><h5 id="1-上层接口（上接口）"><a href="#1-上层接口（上接口）" class="headerlink" title="1. 上层接口（上接口）"></a>1. <strong>上层接口（上接口）</strong></h5><ul><li><p><strong>与用户或应用程序的接口</strong>，即用户应用程序或操作系统与I&#x2F;O系统的交互接口。上层接口负责接受用户的I&#x2F;O请求，格式化数据、提供操作等，并将这些请求传递到下层。具体而言，用户层会通过操作系统的系统调用向I&#x2F;O控制层发送请求。</p></li><li><p>典型接口</p><ul><li><strong>系统调用</strong>：如<code>read()</code>、<code>write()</code>、<code>open()</code>、<code>close()</code>等，这些都是用户程序与操作系统间的交互接口，通过这些接口，程序可以发起文件操作、设备操作等。</li><li><strong>文件系统接口</strong>：为用户程序提供抽象的文件操作接口，如打开、读写文件，关闭文件等，文件系统会把这些请求转化为低级的I&#x2F;O请求。</li><li><strong>I&#x2F;O库函数</strong>：例如C标准库中的<code>fopen()</code>, <code>fread()</code>等，提供更高层次的抽象，简化用户的I&#x2F;O操作。</li></ul></li></ul><h5 id="2-下层接口（下接口）"><a href="#2-下层接口（下接口）" class="headerlink" title="2. 下层接口（下接口）"></a>2. <strong>下层接口（下接口）</strong></h5><ul><li><p><strong>与硬件或设备驱动的接口</strong>，即I&#x2F;O系统与硬件设备之间的接口。下层接口是操作系统与设备之间的通信桥梁，它接收来自上层的请求并转发至具体的硬件或设备驱动。</p></li><li><p>典型接口</p><ul><li><strong>设备驱动程序接口</strong>：设备驱动程序通常会提供接口，接收来自I&#x2F;O控制管理层的命令并将其转化为具体的硬件操作。例如，磁盘驱动程序提供的接口可以包括读、写、寻址等功能。</li><li><strong>硬件接口</strong>：这是操作系统与硬件设备之间的低级接口，通过总线和硬件协议与设备进行交互。例如，硬件中断、DMA（直接内存存取）等机制是底层设备与系统进行通信的关键部分。</li><li><strong>中断服务程序（ISR）</strong>：通过中断机制，硬件设备可以向操作系统发出中断信号，中断服务程序负责处理中断并响应硬件设备。</li></ul></li></ul><h4 id="I-O系统的分层"><a href="#I-O系统的分层" class="headerlink" title="I&#x2F;O系统的分层"></a>I&#x2F;O系统的分层</h4><h5 id="1-中断处理程序（Interrupt-Service-Routine-ISR）"><a href="#1-中断处理程序（Interrupt-Service-Routine-ISR）" class="headerlink" title="1. 中断处理程序（Interrupt Service Routine, ISR）"></a>1. <strong>中断处理程序（Interrupt Service Routine, ISR）</strong></h5><ul><li><strong>功能</strong>：中断处理程序位于I&#x2F;O系统的最底层，负责响应硬件设备发出的中断信号。当设备完成I&#x2F;O操作或发生错误时，硬件通过中断信号通知操作系统。ISR会及时响应并进行相应处理。</li><li>职责：<ul><li><strong>保存进程状态</strong>：当中断发生时，操作系统需要保存当前执行进程的现场，以便在中断处理后恢复执行。</li><li><strong>处理中断</strong>：ISR会根据中断源的类型执行相应的操作，例如读取设备状态、清除中断标志、向设备发送确认信号等。</li><li><strong>恢复现场</strong>：完成中断服务后，ISR需要恢复被中断程序的执行状态，确保程序从中断发生前的状态继续执行。</li></ul></li><li><strong>作用</strong>：ISR是操作系统与硬件之间的桥梁，负责处理中断事件并启动相应的设备或进程。中断机制能够保证操作系统对外部设备的实时响应。</li></ul><p><strong>举例</strong>：</p><ul><li>硬盘完成一次读写操作后，通过中断通知操作系统，ISR将处理该中断，可能进行数据拷贝或更新缓存，然后恢复应用程序的执行。</li></ul><hr><h5 id="2-设备驱动程序（Device-Driver）"><a href="#2-设备驱动程序（Device-Driver）" class="headerlink" title="2. 设备驱动程序（Device Driver）"></a>2. <strong>设备驱动程序（Device Driver）</strong></h5><ul><li><strong>功能</strong>：设备驱动程序直接与硬件设备交互，实现具体的I&#x2F;O操作。它位于操作系统的较低层次，负责接收I&#x2F;O控制管理层（或者上层）的命令，执行设备的控制指令，并管理设备的数据传输。</li><li>职责：<ul><li><strong>硬件操作</strong>：驱动程序实现对硬件的直接控制，如磁盘的读写、网络设备的数据发送等。</li><li><strong>设备初始化与配置</strong>：在设备启用前，驱动程序需要进行初始化配置，设置设备的参数、操作模式等。</li><li><strong>数据传输</strong>：设备驱动程序通过中断或直接内存存取（DMA）将数据从内存传输到设备，或将数据从设备传回内存。</li><li><strong>错误处理</strong>：驱动程序也负责监控设备的工作状态，处理可能出现的硬件错误或通信问题。</li></ul></li><li><strong>作用</strong>：设备驱动程序将操作系统的高层命令转换为硬件可理解的命令，确保硬件设备按照预期执行操作。每个硬件设备通常有一个或多个对应的设备驱动程序。</li></ul><p><strong>举例</strong>：</p><ul><li>磁盘驱动程序根据I&#x2F;O请求，向硬盘发出指令（例如读、写命令），并根据硬盘的响应执行相应的操作（例如更新缓冲区或向应用程序返回数据）。</li></ul><hr><h5 id="3-设备独立性软件（Device-Independence-Software）"><a href="#3-设备独立性软件（Device-Independence-Software）" class="headerlink" title="3. 设备独立性软件（Device Independence Software）"></a>3. <strong>设备独立性软件（Device Independence Software）</strong></h5><ul><li><strong>功能</strong>：设备独立性软件位于I&#x2F;O系统的中层，提供一个统一的接口，使得操作系统和用户程序能够不关心具体的硬件实现，统一地对外提供设备访问接口。</li><li>职责：<ul><li><strong>屏蔽硬件差异</strong>：设备独立性软件的核心任务是屏蔽不同设备之间的差异。操作系统通过这一层抽象接口，统一设备的操作方式。例如，磁盘、打印机和键盘的具体硬件实现不同，但操作系统通过设备独立性层提供统一的I&#x2F;O接口给上层应用。</li><li><strong>设备资源管理</strong>：管理设备的资源（如设备的分配、释放和共享），确保多个进程对同一设备的访问不会发生冲突。</li><li><strong>缓冲区管理</strong>：对输入输出的数据进行缓冲，以提高I&#x2F;O操作的效率。</li><li><strong>任务调度</strong>：设备独立性软件也可能负责设备请求的排队和调度，确保设备能够高效地为多个进程提供服务。</li></ul></li><li><strong>作用</strong>：设备独立性软件将设备硬件的复杂性封装起来，为操作系统和应用程序提供统一的、设备无关的接口，从而使得程序能够不关心设备的具体实现。</li></ul><p><strong>举例</strong>：</p><ul><li>操作系统通过设备独立性软件为文件系统提供统一的接口，应用程序可以通过<code>read()</code>和<code>write()</code>进行文件I&#x2F;O操作，而不需要知道是通过磁盘、网络还是其他设备来进行的实际数据传输。</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>       应用程序层（<span class="hljs-variable">User</span> <span class="hljs-variable">Layer</span>）       <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 与用户交互，发起<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>请求<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>   设备独立性软件层（<span class="hljs-variable">Device</span> <span class="hljs-variable">Independence</span> <span class="hljs-variable">Software</span>）   <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 屏蔽硬件差异，提供统一接口<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>         <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>控制管理层（<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> <span class="hljs-built_in">Control</span> <span class="hljs-variable">Layer</span>）         <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 管理设备资源，调度<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>请求<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>           设备驱动程序层（<span class="hljs-variable">Device</span> <span class="hljs-variable">Driver</span> <span class="hljs-variable">Layer</span>）    <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 控制硬件设备，进行<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>           中断处理程序（<span class="hljs-built_in">Interrupt</span> <span class="hljs-variable">Service</span> <span class="hljs-variable">Routine</span>）<span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 处理中断，进行硬件控制<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>               硬件层（<span class="hljs-variable">Hardware</span> <span class="hljs-variable">Layer</span>）              <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 执行实际<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作<br><span class="hljs-operator">+-------------------------------------+</span><br><br></code></pre></td></tr></table></figure><h2 id="I-O系统接口"><a href="#I-O系统接口" class="headerlink" title="I&#x2F;O系统接口"></a>I&#x2F;O系统接口</h2><p>I&#x2F;O系统中的接口是操作系统与硬件设备、应用程序之间进行交互的桥梁。不同类型的设备有不同的接口，这些接口可以分为<strong>块设备接口</strong>、<strong>流设备接口</strong>和<strong>网络通信接口</strong>。每种接口适应不同类型的I&#x2F;O设备，提供相应的操作方法和协议。</p><h3 id="1-块设备接口（Block-Device-Interface）"><a href="#1-块设备接口（Block-Device-Interface）" class="headerlink" title="1. 块设备接口（Block Device Interface）"></a>1. <strong>块设备接口（Block Device Interface）</strong></h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>块设备（Block Devices）是指那些支持按块（Block）进行数据访问的设备，数据在这些设备上是按固定大小的块进行组织的。常见的块设备包括硬盘、固态硬盘（SSD）、光盘等。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>数据存取单位</strong>：块设备的存取单位是“块”，通常是512字节或4KB的倍数。</li><li><strong>随机访问</strong>：块设备支持随机访问，允许直接读取或写入任何块。</li><li><strong>持久性</strong>：块设备上的数据通常是持久化存储，即数据在设备断电后仍然存在。</li></ul><h4 id="接口操作："><a href="#接口操作：" class="headerlink" title="接口操作："></a>接口操作：</h4><p>块设备的接口通常包括以下几种操作：</p><ul><li><strong>读&#x2F;写操作</strong>：对指定的块进行读写操作。</li><li><strong>寻址操作</strong>：通过设备的逻辑块地址（LBA）来定位和访问数据块。</li><li><strong>设备控制操作</strong>：例如初始化、格式化、修复坏块等。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><ul><li>**<code>read()</code>**：从块设备的指定块中读取数据。</li><li>**<code>write()</code>**：向块设备的指定块写入数据。</li><li>**<code>ioctl()</code>**：用于控制设备的各种命令，如格式化、调整块大小等。</li></ul><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul><li><strong>硬盘、固态硬盘（SSD）</strong>：这些存储设备都采用块存储模型，操作系统通过块设备接口进行读写操作。</li></ul><h3 id="2-流设备接口（Character-Device-Interface）"><a href="#2-流设备接口（Character-Device-Interface）" class="headerlink" title="2. 流设备接口（Character Device Interface）"></a>2. <strong>流设备接口（Character Device Interface）</strong></h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>流设备（Character Devices）是指那些支持按字节流进行数据访问的设备。流设备通常是串行的，数据流通常是连续的，不以块为单位进行存储。常见的流设备包括串口设备、键盘、鼠标、打印机等。</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>数据存取单位</strong>：流设备的数据存取单位是字节（byte），数据是顺序读取的，通常是逐个字节地传输。</li><li><strong>顺序访问</strong>：流设备不支持随机访问，数据必须按照顺序进行处理。</li><li><strong>实时性</strong>：流设备的数据传输通常具有实时性要求，操作系统需要及时处理这些数据。</li></ul><h4 id="接口操作：-1"><a href="#接口操作：-1" class="headerlink" title="接口操作："></a>接口操作：</h4><p>流设备的接口通常包括以下几种操作：</p><ul><li><strong>读&#x2F;写操作</strong>：从流设备中读取字节或向流设备写入字节。</li><li><strong>设备控制操作</strong>：流设备可能还包括对设备的控制命令，例如获取设备状态、控制设备开启或关闭等。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><ul><li>**<code>read()</code>**：从流设备中读取一个字节的数据。</li><li>**<code>write()</code>**：向流设备写入一个字节的数据。</li><li>**<code>ioctl()</code>**：控制设备操作，例如设置串口的波特率、打开或关闭设备等。</li></ul><h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h4><ul><li><strong>串口设备、键盘、鼠标</strong>：这些设备通常处理按字节顺序的数据，操作系统通过流设备接口进行数据交换。</li></ul><h3 id="3-网络通信接口（Network-Communication-Interface）"><a href="#3-网络通信接口（Network-Communication-Interface）" class="headerlink" title="3. 网络通信接口（Network Communication Interface）"></a>3. <strong>网络通信接口（Network Communication Interface）</strong></h3><h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h4><p>网络通信接口用于处理网络设备（如网卡）和操作系统之间的数据传输。它是通过网络协议栈来实现的，支持通过不同的通信协议进行数据交换。常见的网络接口有以太网、Wi-Fi、蓝牙等。</p><h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>基于协议栈</strong>：网络通信接口依赖于协议栈（如TCP&#x2F;IP协议栈）来进行数据的分发、路由和传输。</li><li><strong>支持异步通信</strong>：网络通信通常是异步的，数据可能在不同时间到达，且可能需要重试、流量控制和确认等操作。</li><li><strong>可扩展性</strong>：网络通信接口需要支持不同的协议和网络配置，如IPv4、IPv6、TCP、UDP等。</li></ul><h4 id="接口操作：-2"><a href="#接口操作：-2" class="headerlink" title="接口操作："></a>接口操作：</h4><p>网络通信接口通常支持以下操作：</p><ul><li><strong>发送&#x2F;接收数据</strong>：通过协议栈发送和接收数据包。</li><li><strong>连接管理</strong>：建立、管理和关闭网络连接。</li><li><strong>设备控制</strong>：网络接口的配置、状态查询等。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><ul><li>**<code>socket()</code>**：创建一个套接字，进行网络连接的初始化。</li><li>**<code>send()</code>&#x2F;<code>recv()</code>**：向网络连接发送或接收数据。</li><li>**<code>ioctl()</code>**：设置网络设备的参数，查询设备状态等。</li></ul><h4 id="使用场景：-2"><a href="#使用场景：-2" class="headerlink" title="使用场景："></a>使用场景：</h4><ul><li><strong>以太网卡、Wi-Fi适配器</strong>：操作系统通过网络通信接口和网络设备进行数据传输，处理与其他计算机或设备的通信。</li></ul><hr><h3 id="各接口的比较"><a href="#各接口的比较" class="headerlink" title="各接口的比较"></a>各接口的比较</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>块设备接口（Block Device）</strong></th><th><strong>流设备接口（Character Device）</strong></th><th><strong>网络通信接口（Network Interface）</strong></th></tr></thead><tbody><tr><td><strong>数据存取单位</strong></td><td>块（通常为512字节或4KB）</td><td>字节（按字节流传输数据）</td><td>数据包（按照网络协议进行分组和传输）</td></tr><tr><td><strong>访问类型</strong></td><td>随机访问</td><td>顺序访问</td><td>异步、流式访问（可能是双向或单向）</td></tr><tr><td><strong>使用场景</strong></td><td>硬盘、SSD、光盘等存储设备</td><td>键盘、鼠标、打印机、串口设备等</td><td>网卡、Wi-Fi、蓝牙、互联网连接等</td></tr><tr><td><strong>常用操作</strong></td><td><code>read()</code>, <code>write()</code>, <code>ioctl()</code></td><td><code>read()</code>, <code>write()</code>, <code>ioctl()</code></td><td><code>socket()</code>, <code>send()</code>, <code>recv()</code>, <code>ioctl()</code></td></tr><tr><td><strong>协议&#x2F;规范</strong></td><td>物理设备上的数据块操作</td><td>流式数据传输，没有固定的协议</td><td>基于网络协议栈（如TCP&#x2F;IP、UDP）</td></tr></tbody></table><hr><h1 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h1><p><img src="https://s2.loli.net/2025/01/04/DP8JrEHTdAXaUS3.png" alt="image-20250104090411981"></p><p>在<a href="https://wangxiaobai08.github.io/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/">CPU虚拟化与进程 - The Peak Tower</a>我们提到中断是操作系统夺回CPU控制的唯一途径，当中断发生时，就意味着操作系统介入，进行管理工作。正因如此多道程序才能进行并发运行，合理的移交CPU控制权</p><p>我们知道用户态的程序进行系统调用时会触发库函数(并不是每一个库函数都会进行中断)里的中断，进而陷入内核态。</p><blockquote><p>那么当内核态操作系统完成调用时，如何将控制器移交给用户程序呢？</p></blockquote><p><img src="https://s2.loli.net/2025/01/04/LP5wZUQ1TOoVm3J.png" alt="image-20250104084448013"></p><p>流程大体如下：</p><ol><li><strong>用户程序</strong>通过系统调用请求操作系统服务。</li><li><strong>CPU</strong>切换到<strong>内核模式</strong>，操作系统执行相应任务。</li><li><strong>操作系统</strong>执行完成任务，保存内核态的上下文。</li><li>操作系统将<strong>控制权返回到用户态</strong>，并恢复用户程序的上下文。</li><li><strong>返回结果</strong>给用户程序（通常是通过寄存器或内存返回）。</li><li><strong>用户程序</strong>继续执行，使用返回的结果。</li></ol><p>这里简单介绍一下什么是特权指令和非特权指令：</p><table><thead><tr><th><strong>特性</strong></th><th><strong>特权指令</strong></th><th><strong>非特权指令</strong></th></tr></thead><tbody><tr><td><strong>执行模式</strong></td><td>仅能在<strong>内核模式</strong>下执行</td><td>可以在<strong>用户模式</strong>下执行</td></tr><tr><td><strong>访问权限</strong></td><td>具有对硬件和系统资源的访问权限</td><td>仅能访问用户程序自身的数据和代码</td></tr><tr><td><strong>功能</strong></td><td>操作系统核心功能，如内存管理、中断控制、I&#x2F;O操作等</td><td>一般为普通程序逻辑运算，如算术运算、数据传输等</td></tr><tr><td><strong>示例</strong></td><td>- 修改控制寄存器- 禁用&#x2F;启用中断- I&#x2F;O控制</td><td>- 加法、减法运算- 数据传送（<code>mov</code>）- 跳转（<code>jmp</code>）</td></tr><tr><td><strong>安全性</strong></td><td>执行不当可能破坏系统稳定性，具有潜在风险</td><td>不涉及系统资源，执行不会对系统造成直接风险</td></tr><tr><td><strong>操作系统介入</strong></td><td>需要操作系统或内核来执行，中断或异常处理</td><td>不需要操作系统介入，可以由普通程序执行</td></tr><tr><td><strong>使用场景</strong></td><td>操作系统内部功能、硬件设备的直接控制、进程管理等</td><td>普通应用程序的计算、数据处理、逻辑控制等</td></tr></tbody></table><blockquote><p>当执行中断陷入内核态时，操作系统怎么知道哪一个中断触发了它，后续如何处理中断？</p></blockquote><h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a><strong>中断向量表</strong></h2><p>当中断（无论是硬件中断还是软件中断）发生时，操作系统需要确定哪个中断源触发了中断，并执行相应的处理程序。中断向量表是一个数据结构，用于存储所有中断的入口地址（即对应中断服务程序的地址）。</p><ul><li><strong>中断向量表</strong>包含了所有中断的入口地址，处理不同的中断请求（IRQ）。每个中断都有一个对应的向量（即一个唯一的编号），该向量指向相应的<strong>中断服务程序</strong>（ISR）。</li><li>在中断发生时，CPU会根据中断源的编号查找中断向量表，从而跳转到对应的中断服务程序。</li></ul><p>举例：</p><ul><li><strong>硬件中断</strong>：例如，键盘按键中断、磁盘I&#x2F;O中断等，都有不同的中断向量。</li><li><strong>软件中断（如系统调用）</strong>：在x86架构中，系统调用会通过<code>int 0x80</code>指令触发中断，并跳转到内核模式的系统调用处理程序。</li></ul><p><img src="https://s2.loli.net/2025/01/04/o4OnLIrsWqEiKfz.png" alt="de06c8c75719a3f2df6e795b673a3a29"></p><blockquote><p>接下来我们需要继续完善中断执行流程</p></blockquote><p><strong>触发中断</strong>：</p><ul><li>当硬件中断或系统调用发生时，CPU停止当前的指令执行，将当前的状态（程序计数器、寄存器等）保存在堆栈中。</li></ul><ol><li><p><strong>查找中断向量</strong>：</p><ul><li>CPU根据中断号（或系统调用号）在中断向量表中查找相应的中断服务程序（ISR）地址。</li><li>对于系统调用，通常会有一个系统调用号，操作系统会根据该号在系统调用表中查找对应的处理函数。</li></ul></li><li><p><strong>执行中断服务程序（ISR）</strong>：</p><ul><li>操作系统执行相应的中断处理或系统调用的处理程序。</li></ul></li><li><p><strong>保存&#x2F;恢复进程上下文</strong>：</p><ul><li>在执行中断服务程序之前，操作系统保存当前进程的上下文信息（如寄存器值、程序计数器等）。</li><li>在中断处理程序结束后，恢复之前保存的上下文，确保用户程序能够继续执行。</li></ul></li><li><p><strong>返回用户态</strong>：</p><ul><li>操作系统通过<strong>返回中断</strong>指令（如<code>iret</code>或<code>sysret</code>）将控制权交还给用户程序。</li><li>用户程序继续执行，从发生系统调用或中断的位置开始。</li></ul><blockquote><p>注意：</p><p>操作系统管理每个进程的状态信息，并存储在<strong>进程控制块（PCB）</strong>中。PCB包括了进程的上下文（寄存器状态、程序计数器等），当发生中断时，操作系统会保存当前进程的PCB，并根据中断的类型决定下一步的操作。</p><ul><li>对于<strong>系统调用</strong>，操作系统通过查找当前进程的系统调用号（通常存储在寄存器中）来决定该执行哪个系统调用处理程序。</li><li>对于<strong>硬件中断</strong>，操作系统通过中断向量表查找对应的中断服务程序，执行完相应操作后，恢复进程执行。</li></ul></blockquote></li></ol><h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><table><thead><tr><th><strong>分类标准</strong></th><th><strong>中断类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>按触发源分类</strong></td><td><strong>硬件中断</strong></td><td>由外部硬件设备或内部设备触发，通常用于响应外部事件，如I&#x2F;O操作、定时器等。</td></tr><tr><td></td><td><strong>软件中断</strong></td><td>由程序通过特定指令（如<code>syscall</code>或<code>int</code>）触发，通常用于系统调用或异常处理。</td></tr><tr><td><strong>按发生时机分类</strong></td><td><strong>同步中断</strong></td><td>中断与当前执行指令密切相关，通常由程序执行中的错误或特定操作触发。</td></tr><tr><td></td><td><strong>异步中断</strong></td><td>中断与当前执行的指令无关，通常由外部硬件或外部事件触发，如设备完成数据传输。</td></tr><tr><td><strong>按响应机制分类</strong></td><td><strong>屏蔽中断</strong></td><td>可以被操作系统或CPU屏蔽的中断，通常用于允许某些关键操作不中断。</td></tr><tr><td></td><td><strong>非屏蔽中断</strong></td><td>无法被操作系统或CPU屏蔽的中断，通常用于紧急事件，如硬件故障、紧急安全事件等。</td></tr><tr><td><strong>按优先级分类</strong></td><td><strong>可调优先级中断</strong></td><td>中断有不同的优先级，操作系统根据优先级处理高优先级的中断，低优先级的中断可以被打断。</td></tr><tr><td></td><td><strong>固定优先级中断</strong></td><td>中断有固定的优先级，通常由硬件设置，优先级不变。</td></tr><tr><td><strong>常见中断类型</strong></td><td><strong>外部中断</strong></td><td>由外部设备或事件触发的中断，如I&#x2F;O设备、定时器中断等。</td></tr><tr><td></td><td><strong>内部中断</strong></td><td>程序执行中出现的错误或异常事件，如除零错误、非法内存访问等。</td></tr><tr><td></td><td><strong>系统调用中断</strong></td><td>用户程序请求操作系统服务时触发的中断，通过<code>syscall</code>等指令发起。</td></tr><tr><td></td><td><strong>硬件故障中断</strong></td><td>硬件故障或错误引发的中断，如内存故障、总线错误等。</td></tr><tr><td></td><td><strong>定时器中断</strong></td><td>定时器触发的中断，通常用于操作系统调度、时间片轮转等。</td></tr></tbody></table><p><img src="https://s2.loli.net/2025/01/04/qvDzoaSCGwgyZcF.png" alt="image-20250104090449719"></p><h1 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h1><h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>设备控制器是一个硬件组件，它充当了计算机中央处理单元（CPU）与外部设备（如硬盘、打印机、显示器、网络卡等）之间的中介。设备控制器负责管理设备的操作和状态控制，提供设备与CPU之间的通信通道。它的作用是将设备的物理操作转换为计算机可以理解和处理的数字信号，并通过设备驱动程序与操作系统进行交互。</p><p>简言之，设备控制器就是计算机与外部硬件设备之间的“桥梁”，它通过控制设备的输入输出（I&#x2F;O）操作，协调设备的工作。</p><p>确切地说，<strong>设备控制器</strong>的存在正是为了屏蔽不同硬件设备之间的差异，使得操作系统和应用程序可以以统一的方式与不同的硬件进行交互。每种设备（如硬盘、显示器、打印机等）通常会有一个对应的设备控制器组件，该组件负责处理与设备相关的底层操作，简化了操作系统对硬件的管理。下面进一步详细解释这一点。</p><table><thead><tr><th><strong>作用</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>屏蔽硬件差异</strong></td><td>提供统一接口，将不同硬件设备之间的通信协议、数据格式和信号方式等差异抽象化，使操作系统和应用程序无需关心硬件细节。</td><td>操作系统通过相同接口（如文件系统接口）进行硬盘的读写，无论是IDE、SATA硬盘还是SSD，底层控制器处理硬件差异。</td></tr><tr><td><strong>提供统一的操作接口</strong></td><td>操作系统通过设备控制器发出命令，控制设备进行相应的操作。设备控制器将操作系统的高层请求转化为适合硬件的操作。</td><td>操作系统使用通用I&#x2F;O接口进行数据交换（如读&#x2F;写命令），硬盘控制器将高层请求转化为硬盘的具体操作（如数据读取&#x2F;写入）。</td></tr><tr><td><strong>优化硬件资源管理</strong></td><td>管理设备资源，协调多个设备之间的竞争，防止资源冲突，进行资源的合理分配（如内存缓冲、DMA通道等）。</td><td>显卡控制器管理显示缓冲区，硬盘控制器管理数据块分配，确保设备资源不冲突并实现高效数据传输。</td></tr><tr><td><strong>处理设备中断</strong></td><td>接收并处理硬件设备发出的中断请求，当设备完成任务或发生错误时，生成中断信号通知操作系统进行后续处理。</td><td>网络卡控制器接收到数据包后发出中断，操作系统或驱动程序接收并处理这些数据。硬盘控制器在完成数据传输后也会生成中断。</td></tr></tbody></table><p>其中组成部分在<a href="https://wangxiaobai08.github.io/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/">外存管理 - The Peak Tower</a>有过介绍不多赘述，</p><blockquote><p>那 CPU 是如何与设备的控制寄存器和数据缓冲区进行通信的？</p></blockquote><ul><li><em><strong>端口 I&#x2F;O</strong></em>，每个控制寄存器被分配一个 I&#x2F;O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 <code>in/out</code> 类似的指令。</li><li><em><strong>内存映射 I&#x2F;O</strong></em>，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区</li></ul><p>I&#x2F;O <strong>控制方式</strong></p><p>在前面我知道，每种设备都有一个设备控制器，控制器相当于一个小 CPU，它可以自己处理一些事情，但有个问题是，当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，它读完的时候，要怎么通知 CPU 呢？</p><p>在<a href="https://wangxiaobai08.github.io/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/">外存管理 - The Peak Tower</a>同样介绍过，这里简单总结一下</p><table><thead><tr><th><strong>控制方式</strong></th><th><strong>描述</strong></th><th><strong>优缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>轮询（Polling）</strong></td><td>CPU 定期检查设备控制器的状态寄存器，等待设备完成操作并返回结果。</td><td><strong>优点</strong>：实现简单，设备状态查询直观；<strong>缺点</strong>：占用大量 CPU 时间，CPU 需要一直轮询设备，效率低，浪费资源。</td><td>适用于设备操作时间较短且 I&#x2F;O 请求较少的场景。</td></tr><tr><td><strong>中断（Interrupt）</strong></td><td>当设备完成操作时，通过中断机制通知 CPU 停止当前任务并处理中断请求，设备完成 I&#x2F;O 操作后触发中断信号。</td><td><strong>优点</strong>：减少 CPU 空闲时的浪费，CPU 只在有需要时被打断；<strong>缺点</strong>：频繁的中断会导致 CPU 频繁中断当前任务，消耗时间。</td><td>适用于较为复杂、需要响应的设备（如网络卡、打印机等），但不适合频繁 I&#x2F;O 操作的设备。</td></tr><tr><td><strong>DMA（Direct Memory Access）</strong></td><td>设备控制器通过 DMA 控制器将数据直接从设备传输到内存，CPU 只需要在开始和结束时干预，完成数据传输后通过中断通知 CPU。</td><td><strong>优点</strong>：不占用 CPU 处理时间，提升 I&#x2F;O 性能；<strong>缺点</strong>：硬件实现复杂，需要支持 DMA 的设备和 DMA 控制器。</td><td>适用于大规模、高频率的数据传输，如磁盘、网络等，能够减少 CPU 干预，提升整体系统性能。</td></tr></tbody></table><p><img src="https://s2.loli.net/2025/01/04/92R8slSg7VjLwF1.png" alt="image-20250104092551860"></p><hr><h2 id="引入设备驱动程序"><a href="#引入设备驱动程序" class="headerlink" title="引入设备驱动程序"></a>引入设备驱动程序</h2><p>虽然设备控制器屏蔽了设备的众多细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了设备驱动程序。</p><p>设备驱动程序作为操作系统的一部分，它位于操作系统与硬件之间，负责将操作系统的高层请求转换为适合具体硬件的低层命令，并处理硬件设备的控制器寄存器、缓冲区等不同的使用模式。</p><blockquote><p>设备控制器不属于操作系统范畴，它是属于硬件，而设备驱动程序属于操作系统的一部分，操作系统的内核代码可以像本地调用代码一样使用设备驱动程序接口，而设备驱动程序是面向设备控制器的代码，它发出操控设备控制器的指令后，才可以操作设备控制器。</p></blockquote><h2 id="设备驱动程序的功能"><a href="#设备驱动程序的功能" class="headerlink" title="设备驱动程序的功能"></a><strong>设备驱动程序的功能</strong></h2><table><thead><tr><th><strong>功能</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>接收命令并转换要求</strong></td><td>设备驱动程序接收来自设备独立性软件的命令和参数，并将命令中的抽象要求转化为具体的硬件指令。例如，磁盘驱动程序将逻辑的磁盘块号转换为物理的盘面、磁道号和扇区号。</td><td>将用户请求中的文件读取操作，转换为具体硬盘的物理寻址操作，如将文件的逻辑块号转化为实际的磁盘块号、盘面号、扇区号。</td></tr><tr><td><strong>检查I&#x2F;O请求的合法性</strong></td><td>设备驱动程序需要检查用户发出的 I&#x2F;O 请求的合法性，确保请求参数正确，同时获取设备当前状态，设置设备的工作模式。</td><td>检查 I&#x2F;O 请求中给定的文件路径是否有效，设备是否空闲，设备是否支持请求的操作（如磁盘是否有足够空间，是否支持特定的读写模式）。</td></tr><tr><td><strong>发出I&#x2F;O命令</strong></td><td>当设备空闲时，驱动程序发出 I&#x2F;O 命令并启动设备完成操作；若设备忙碌，则将请求挂起，等待设备空闲后再执行。</td><td>当用户发出文件读取命令时，如果硬盘空闲，驱动程序立即发出磁盘读取命令；如果硬盘忙碌，驱动程序将该请求加入队列，等待硬盘空闲后再执行。</td></tr><tr><td><strong>响应中断请求</strong></td><td>设备控制器或通道发出的中断信号会通知驱动程序处理设备状态变化或任务完成，驱动程序根据中断类型调用相应的中断处理程序。</td><td>硬盘在完成数据读写后，发送中断信号，驱动程序响应中断，读取硬盘控制器的状态，获取数据，并通知操作系统处理。</td></tr><tr><td><strong>构成通道程序（对于有通道的系统）</strong></td><td>对于支持通道的计算机系统，设备驱动程序根据用户的 I&#x2F;O 请求构成通道程序，指示计算机如何操作设备。</td><td>对于支持 DMA 通道的系统，驱动程序会根据 I&#x2F;O 请求自动生成通道程序，并通过 DMA 控制器将数据从硬盘传输到内存，而无需 CPU 参与。</td></tr></tbody></table><h2 id="设备处理方式"><a href="#设备处理方式" class="headerlink" title="设备处理方式"></a>设备处理方式</h2><p>在不同的操作系统中所采用的设备处理方式并不完全相同。</p><p>根据在设备处理时是否设置进程，以及设置什么样的进程而把设备处理方式分成以下三类：</p><ul><li><p>为每一类设备设置一个进程，专门用于执行这类设备的I&#x2F;O操作。 比如，为所有的交互式终端设置一个交互式终端进程；为同一类型的打印机设置一个打印进程。</p></li><li><p>在整个系统中设置一个I&#x2F;O进程，专门用于执行系统中所有各类设备的I&#x2F;O操作。也可以设置一个输入进程和一个输出进程，分别处理系统中所有各类设备的输入和输出操作。</p></li><li><p>不设置专门的设备处理进程，而只为各类设备设置相应的设备处理程序（模块），供用户进程或系统进程调用。</p></li></ul><h2 id="设备驱动程序的特点"><a href="#设备驱动程序的特点" class="headerlink" title="设备驱动程序的特点"></a>设备驱动程序的特点</h2><table><thead><tr><th><strong>特点</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>与 I&#x2F;O 进程和设备控制器之间的通信转换</strong></td><td>驱动程序将进程的 I&#x2F;O 请求转换为适合设备控制器的指令，并将设备的状态和 I&#x2F;O 操作完成情况反馈给进程。</td></tr><tr><td><strong>与硬件特性紧密相关</strong></td><td>每种设备或同一类型的设备（由于厂商不同）需要不同的驱动程序，设备驱动程序与硬件设备的特性紧密相关。</td></tr><tr><td><strong>与 I&#x2F;O 控制方式相关</strong></td><td>驱动程序与设备使用的 I&#x2F;O 控制方式相关，如 <strong>中断驱动</strong> 和 <strong>DMA 驱动</strong>，两者的编写方式和处理机制不同。</td></tr><tr><td><strong>部分驱动程序需要汇编语言编写</strong></td><td>由于设备驱动程序需要直接操作硬件，一些底层驱动程序使用汇编语言编写，部分驱动程序已被固化在 <strong>ROM</strong> 中，减少内存消耗。</td></tr><tr><td><strong>支持可重入性</strong></td><td>驱动程序需支持可重入性，即在驱动程序执行过程中可以被再次调用，例如网络驱动程序在处理一个数据包时，可以同时处理另一个数据包的到达。</td></tr><tr><td><strong>不允许直接调用系统调用</strong></td><td>驱动程序不能直接进行普通的系统调用，但可以通过调用内核过程（如内存管理）来进行某些操作，以满足与内核的交互需求。</td></tr></tbody></table><h2 id="设备驱动程序处理过程"><a href="#设备驱动程序处理过程" class="headerlink" title="设备驱动程序处理过程"></a>设备驱动程序处理过程</h2><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1）将抽象要求转换为具体要求</strong></td><td>驱动程序将用户和上层软件提出的抽象命令转换为设备控制器能够理解的具体命令。驱动程序负责处理命令、参数和数据，并将它们正确地传递到控制器的寄存器。</td></tr><tr><td><strong>2）检查 I&#x2F;O 请求的合法性</strong></td><td>驱动程序检查用户发出的 I&#x2F;O 请求是否合法，确保请求不超出设备能力范围，避免对设备造成不正常的操作。</td></tr><tr><td><strong>3）读出和检查设备的状态</strong></td><td>驱动程序读取设备的状态信息，判断设备是否处于空闲状态，是否可以接受新的 I&#x2F;O 请求。通常检查设备是否处于 “忙” 状态，避免与其他操作冲突。</td></tr><tr><td><strong>4）传送必要的参数</strong></td><td>对于一些设备（如磁盘等块设备），驱动程序需要将相关参数（如数据传送的字节数、数据存储地址等）传送到设备控制器的相关寄存器中。</td></tr><tr><td><strong>5）工作方式的设置</strong></td><td>设置设备的工作模式，例如确定是同步 I&#x2F;O 还是异步 I&#x2F;O，配置设备的缓冲区、DMA 模式等，以确保设备在合适的工作模式下执行操作。</td></tr><tr><td><strong>6）启动 I&#x2F;O 设备</strong></td><td>向设备控制器发送启动命令，启动 I&#x2F;O 操作。驱动程序之后会将自己阻塞，直到设备完成 I&#x2F;O 操作并通过中断通知驱动程序完成任务。</td></tr></tbody></table><h1 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h1><p><strong>与设备无关的 I&#x2F;O 软件</strong>是指操作系统中一类不依赖于具体硬件设备的 I&#x2F;O 管理软件模块。它的主要任务是提供一种抽象层，屏蔽不同硬件设备之间的差异，使得上层应用程序和操作系统能够以统一的方式进行 I&#x2F;O 操作，而无需关心具体设备的硬件细节。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>设备抽象</strong></td><td>与设备无关的 I&#x2F;O 软件提供对设备的抽象，使操作系统和应用程序不直接与硬件设备交互，通过统一的接口（如文件系统接口）访问不同类型的设备（如硬盘、打印机、网络设备等）。</td></tr><tr><td><strong>设备管理</strong></td><td>负责设备的分配、调度和回收。例如，文件系统管理磁盘上的文件，但不直接与硬盘交互，而是通过 I&#x2F;O 软件层实现这一管理功能。</td></tr><tr><td><strong>I&#x2F;O 调度</strong></td><td>根据设备请求进行调度，确保多个 I&#x2F;O 请求按顺序处理。与设备无关的软件负责制定 I&#x2F;O 调度策略，且不关心设备的具体实现。</td></tr><tr><td><strong>统一接口</strong></td><td>提供统一的 API（如读写文件），使得应用程序和操作系统可以通过标准接口进行 I&#x2F;O 操作，这些接口与具体设备实现无关，确保不同硬件设备的兼容性。</td></tr><tr><td><strong>设备驱动模块与 I&#x2F;O 中介</strong></td><td>操作系统通过设备驱动程序与硬件交互，但这些驱动程序由与设备无关的 I&#x2F;O 软件管理，减少应用层对硬件的依赖，使驱动程序专注于硬件操作。</td></tr></tbody></table><h3 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h3><ol><li><strong>文件系统</strong>：<ul><li>文件系统为用户提供了一个统一的接口，使得用户可以通过文件操作命令（如 <code>open</code>、<code>read</code>、<code>write</code>）访问不同类型的存储设备（如硬盘、SSD、网络存储等）。用户无需关心文件存储在何处，如何在磁盘上进行具体的读写操作，这些由与设备无关的 I&#x2F;O 软件处理。</li></ul></li><li><strong>设备驱动程序接口</strong>：<ul><li>操作系统通过设备驱动程序与具体硬件进行交互，但与设备无关的 I&#x2F;O 软件提供了一个统一的接口给操作系统，操作系统通过这个接口来调用不同的设备驱动程序，而无需关心每种硬件的具体细节。</li></ul></li><li><strong>标准输入输出流（stdin, stdout, stderr）</strong>：<ul><li>在许多操作系统中，标准输入输出流是由与设备无关的 I&#x2F;O 软件管理的。用户可以通过 <code>printf</code> 输出信息，或通过 <code>scanf</code> 获取输入，而这些操作背后可能会涉及键盘、终端、文件等多种设备，但用户无需了解这些细节。</li></ul></li></ol><h2 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h2><p>设备独立性（是指操作系统及其应用程序不需要了解底层硬件设备的具体实现细节，而能够通过统一的接口与不同的设备进行交互。通过设备独立性，操作系统提供一个抽象层，屏蔽了硬件的差异，使得应用程序在处理设备时能够实现设备无关操作。</p><p>设备独立性的核心思想是：上层软件（如操作系统和应用程序）通过设备无关的 I&#x2F;O 软件层来与硬件设备交互，而不需要直接控制每个具体硬件的细节。这使得用户可以在不同硬件环境下运行相同的软件，且无需对设备进行修改。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol><li><strong>提高可移植性</strong><br> 设备独立性使得应用程序和操作系统不依赖于特定的硬件设备。当硬件发生变化时，只需要修改底层的设备驱动程序或硬件抽象层，而不需要更改应用程序或操作系统的其他部分。因此，应用程序可以在不同硬件平台上无缝运行。</li><li><strong>简化应用程序开发</strong><br> 通过提供统一的接口，开发者不需要了解每个硬件设备的具体细节，如不同硬盘、打印机、显示器等设备的控制方式。开发者只需通过标准的系统调用和接口来进行设备的访问，简化了开发过程。</li><li><strong>增强系统的扩展性</strong><br> 设备独立性使得系统能够更容易地添加新设备。操作系统只需提供新设备的驱动程序，并将其纳入现有的 I&#x2F;O 软件架构中，无需修改应用程序或核心的其他部分。新的硬件设备可以以最小的代价集成进系统。</li><li><strong>减少硬件依赖性</strong><br> 在多种硬件平台上，操作系统和应用程序能以相同的方式运行，减少了对特定硬件的依赖。这使得系统能够更好地适应硬件的更新换代，延长软件的生命周期。</li><li><strong>提高兼容性</strong><br> 设备独立性通过提供统一的接口和抽象，使得不同厂商、不同型号的硬件设备能够与操作系统兼容。用户无需为每个设备配置单独的软件，操作系统能够处理不同硬件设备间的差异，提高了兼容性。</li><li><strong>简化系统维护和更新</strong><br> 由于硬件与操作系统的关系通过设备驱动程序隔离，系统的维护和更新变得更加容易。如果需要更换或更新硬件，只需更新或替换相关的设备驱动程序，而不需要修改应用程序或操作系统的其他部分。</li></ol><h3 id="设备独立性的实现方式"><a href="#设备独立性的实现方式" class="headerlink" title="设备独立性的实现方式"></a>设备独立性的实现方式</h3><ol><li><strong>统一的 I&#x2F;O 接口</strong><br> 操作系统提供统一的 I&#x2F;O 接口，供应用程序进行文件、设备等操作。例如，文件系统通过标准的读写接口来操作硬盘，而不需要关注硬盘的具体型号和工作原理。</li><li><strong>设备抽象层</strong><br> 操作系统通过设备驱动程序提供对硬件设备的抽象。设备驱动程序将硬件设备的操作抽象为统一的接口，使得上层的软件无需关心设备的具体实现。</li><li><strong>虚拟设备</strong><br> 操作系统可能使用虚拟设备的方式来实现设备独立性。例如，操作系统会为每种硬件设备创建一个虚拟设备接口，所有硬件设备都通过该虚拟接口与操作系统和应用程序交互。</li></ol><h2 id="I-O-重定向与设备独立性"><a href="#I-O-重定向与设备独立性" class="headerlink" title="I&#x2F;O 重定向与设备独立性"></a>I&#x2F;O 重定向与设备独立性</h2><p><strong>I&#x2F;O 重定向</strong> 是操作系统中一个重要的功能，它允许用户改变标准输入、标准输出和标准错误的默认设备。例如，可以将命令行中的输出重定向到文件，或者将一个程序的输入重定向到另一个程序的输出。通过重定向，用户可以灵活地指定 I&#x2F;O 操作的目标和源，而不必修改程序的代码。</p><p>I&#x2F;O 重定向与设备独立性有紧密关系。由于设备独立性提供了统一的 I&#x2F;O 接口，操作系统和应用程序可以通过标准的文件和设备接口进行交互，I&#x2F;O 重定向正是利用这种抽象能力，允许 I&#x2F;O 操作不受底层硬件或设备的限制。</p><h3 id="I-O-重定向的概念"><a href="#I-O-重定向的概念" class="headerlink" title="I&#x2F;O 重定向的概念"></a>I&#x2F;O 重定向的概念</h3><p>I&#x2F;O 重定向指的是改变进程的标准输入、标准输出和标准错误流的默认设备。比如，命令行中常见的输入输出重定向操作：</p><ul><li><p>标准输出重定向将程序的输出写入文件而不是显示在屏幕上。</p><ul><li>示例：<code>echo &quot;Hello, World!&quot; &gt; output.txt</code></li></ul></li><li><p>标准输入重定向将文件的内容作为输入传递给程序。</p><ul><li>示例：<code>sort &lt; input.txt</code></li></ul></li><li><p>管道将一个程序的输出传递到另一个程序的输入。</p><ul><li>示例：<code>cat file.txt | grep &quot;keyword&quot;</code></li></ul></li></ul><h3 id="I-O-重定向如何利用设备独立性"><a href="#I-O-重定向如何利用设备独立性" class="headerlink" title="I&#x2F;O 重定向如何利用设备独立性"></a>I&#x2F;O 重定向如何利用设备独立性</h3><ol><li><strong>统一的接口</strong>： 设备独立性通过提供统一的文件系统接口，使得 I&#x2F;O 重定向操作可以透明地在不同设备间进行。例如，用户可以通过简单的命令将数据从磁盘重定向到屏幕，或者将标准输出重定向到一个文件。操作系统提供统一的接口来处理这些操作，而不需要考虑设备类型或硬件的具体实现。</li><li><strong>增强的灵活性</strong>： 设备独立性允许操作系统支持多种不同的设备，而 I&#x2F;O 重定向可以使得用户在不改变应用程序代码的情况下，灵活地选择输入输出的目标。这种灵活性是由设备无关的 I&#x2F;O 软件实现的，它通过统一接口屏蔽了硬件差异，使得用户可以根据需要重定向 I&#x2F;O 到不同的设备或文件中。</li><li><strong>简化的应用程序设计</strong>： 设备独立性简化了应用程序的设计，使得应用程序可以忽略硬件设备的细节。应用程序只需要处理标准的输入输出流，而不需要关心数据从哪个设备来或去往哪个设备。因此，I&#x2F;O 重定向在应用程序中变得更加简洁，程序设计不需要为不同的设备编写专门的代码。</li><li><strong>增强的系统可移植性</strong>： 由于设备独立性，程序可以在不同的硬件平台上无缝运行。而 I&#x2F;O 重定向的功能也与设备无关，因此它增强了系统的可移植性。用户可以在不同操作系统或硬件环境中使用相同的 I&#x2F;O 重定向命令，不会受到底层硬件差异的影响。</li></ol><p>具体参考：<a href="https://www.cnblogs.com/05-ivyli-19/p/17378319.html">第五章 输入输出系统 5.5 与设备无关的I&#x2F;O软件 - LEE_Minhyung - 博客园</a></p><p><a href="https://blog.csdn.net/qq_38499859/article/details/81172220">操作系统19———IO系统之与设备无关的I&#x2F;O软件&amp;用户层的I&#x2F;O软件_与设备无关性的基本含义是什么? 为什么要设置该层?-CSDN博客</a></p><h1 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I&#x2F;O软件"></a>用户层的I&#x2F;O软件</h1><p>用户层的 I&#x2F;O 软件是操作系统中的一部分，它位于内核层的 I&#x2F;O 子系统与用户程序之间，主要负责向应用程序提供与硬件设备交互的接口。用户层 I&#x2F;O 软件通常提供更高层次的抽象，简化了用户对设备的访问方式，同时也增加了设备访问的灵活性和可移植性。</p><table><thead><tr><th><strong>功能</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>I&#x2F;O 系统调用接口</strong></td><td>提供用户与操作系统之间进行设备交互的接口，包含文件读写、设备控制等常用功能。</td></tr><tr><td><strong>标准 I&#x2F;O 库</strong></td><td>提供易于使用的高层次 API，封装了底层的系统调用，简化了 I&#x2F;O 操作。</td></tr><tr><td><strong>文件系统</strong></td><td>为用户提供统一的文件和目录管理接口，将硬件存储抽象为文件，并支持文件操作、目录操作等。</td></tr><tr><td><strong>设备驱动接口</strong></td><td>提供设备驱动程序的标准接口，用户程序通过这些接口访问硬件设备，而无需关注底层硬件的实现细节。</td></tr><tr><td><strong>设备无关的 I&#x2F;O 软件</strong></td><td>提供设备抽象，屏蔽硬件差异，简化设备的管理和操作，使应用程序与硬件设备无关。</td></tr><tr><td><strong>异步 I&#x2F;O</strong></td><td>允许用户程序在发起 I&#x2F;O 操作时继续执行其他任务，提高了程序的响应性和性能。</td></tr><tr><td><strong>缓存与缓冲区管理</strong></td><td>提供高效的数据缓存和缓冲管理，减少 I&#x2F;O 操作的次数，提高数据访问效率。</td></tr></tbody></table><p>具体参考：<a href="https://blog.csdn.net/tang7mj/article/details/136191815">6.6 用户层的I&#x2F;O软件_用户层软件-CSDN博客</a></p><p><a href="https://www.cnblogs.com/liyaaixuexi/p/17352046.html">考研408操作系统-SPOOLing技术（假脱机技术） - liya今天学什么 - 博客园</a></p><h1 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h1><p>具体参考：</p><p><a href="https://zhuanlan.zhihu.com/p/533321012">操作系统–缓冲管理 - 知乎</a></p><p><a href="https://blog.csdn.net/qq_61888137/article/details/134085322">操作系统缓冲区管理（单缓冲，双缓冲，循环缓冲，缓冲池）_单缓冲区和双缓冲区的问题-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44096670/article/details/121632471">操作系统缓冲区管理（单缓冲、双缓冲、循环缓冲以及缓冲池）_单缓冲区-CSDN博客</a></p><h1 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h1><p>具体参考：<a href="https://www.cnblogs.com/05-ivyli-19/p/17399022.html">第五章 输入输出系统 5.8 磁盘存储器的性能和调度 - LEE_Minhyung - 博客园</a></p><p><a href="https://blog.csdn.net/qq_40212930/article/details/105393493">图解五种磁盘调度算法, FCFS, SSTF, SCAN, C-SCAN, LOOK_scan算法-CSDN博客</a></p><blockquote><p>需要留意这里的磁盘调度算法</p></blockquote><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/qq_26553393/article/details/122239406">1.1.5 中断的概念和作用、内部中断、外部中断、中断机制的基本原理_处理器中断-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_73077810/article/details/136356343">如何理解操作系统中的设备控制与设备驱动程序？_设备驱动程序和设备控制器-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理【补充2】</title>
    <link href="/2023/01/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%90%E8%A1%A5%E5%85%852%E3%80%91/"/>
    <url>/2023/01/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%90%E8%A1%A5%E5%85%852%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p><img src="https://s2.loli.net/2025/01/03/kIJ6PYv9cteCuES.png" alt="image-20250103204223634"></p><p>更详细具体参考：<a href="https://blog.csdn.net/rc4gyyc/article/details/144007150">计算机操作系统——第六章 虚拟存储器-CSDN博客</a></p><blockquote><p>注意：在虚拟存储器中，允许将一个作业分多次调入内存。如果采用连续分配方式，则由于要求必须将作业装入一个连续的内存区域中，因此就必须事先为作业一次性申请一个足以容纳整个作业的内存空间，以便能将该作业分先后多次装入内存。这不仅会使相当一部分内存空间都处于暂时或“永久”空闲状态，造成内存资源的严重浪费，而且无法也无意义再从逻辑上扩大内存容量。因此，虚拟存储器的实现，都毫无例外地建立在<strong>离散分配方式</strong>的基础上。目前，所有的虚拟存储器都是采用下述方式之一实现的。</p></blockquote><h1 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h1><p>请求分页存储管理（<strong>Paged Demand Paging</strong>）是一种虚拟内存管理方式，结合了分页和按需调度技术。这种方式使得程序只在需要时才从磁盘加载相应的页面到内存中，而不是在程序开始运行时就一次性加载所有内容，从而节省了内存资源。</p><p>通常，请求分页存储管理由操作系统实现，通过以下几个步骤：</p><ol><li>进程启动时，操作系统为每个程序分配虚拟地址空间，但不立即将所有页面加载到内存。</li><li>当程序访问某个页面时，如果该页面尚未加载到内存，就发生页面缺失。</li><li>操作系统捕获页面缺失异常，加载相应页面到内存中，然后恢复程序执行。</li><li>操作系统根据某些策略（如最近最少使用（LRU）算法）来替换不常用的页面，保持内存的有效利用。</li></ol><h2 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h2><h3 id="请求页表机制"><a href="#请求页表机制" class="headerlink" title="请求页表机制"></a>请求页表机制</h3><p>请求分页系统中，主要数据结构是<strong>请求页表</strong>，其基本作用仍是<strong>将逻辑地址映射为物理地址</strong>。为满足页面换进换出的需要，请求分页系统中的页表进行了更改：</p><p><img src="https://s2.loli.net/2025/01/03/d2R3OwM7F5sfAHh.png" alt="image-20250103195314642"></p><ul><li><strong>状态位 P</strong> ：指示该页是否已调入内存</li><li><strong>访问字段 A</strong> ：置换时考量的参数，用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问</li><li><strong>修改位 M</strong> ：关系到置换时调出的具体操作，用于记录该页在调入内存后是否被修改过</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址</li></ul><h3 id="什么是缺页中断？"><a href="#什么是缺页中断？" class="headerlink" title="什么是缺页中断？"></a>什么是缺页中断？</h3><p><strong>缺页中断（Page Fault）</strong> 是在虚拟内存管理中，当程序访问的虚拟地址不在物理内存中的时候，操作系统触发的一种中断。它是分页存储管理的一部分，通常与请求分页存储管理一起使用。</p><h4 id="缺页中断的过程："><a href="#缺页中断的过程：" class="headerlink" title="缺页中断的过程："></a>缺页中断的过程：</h4><ol><li><strong>程序访问虚拟地址</strong>： 当程序执行时，CPU会根据虚拟地址访问数据或代码。</li><li><strong>检查页面是否在内存中</strong>： 操作系统会检查虚拟地址对应的页面是否已经加载到内存。如果该页面在内存中，程序继续正常执行；如果页面不在内存中，就发生缺页中断。</li><li><strong>触发缺页中断</strong>： 一旦发生缺页中断，硬件会暂停当前程序的执行，并通知操作系统。</li><li><strong>操作系统处理中断</strong>： 操作系统会进行以下操作：<ul><li><strong>查找页面</strong>：首先，操作系统查找缺失的页面是否存在于磁盘上的交换区（或页面文件）中。</li><li><strong>调度磁盘I&#x2F;O</strong>：如果页面在磁盘上，操作系统会将该页面从磁盘读取到内存中，通常会根据页面置换算法（如LRU、FIFO）选择一个页面进行替换。</li><li><strong>更新页表</strong>：操作系统将页表中该虚拟地址对应的页表项更新为新的物理内存地址。</li><li><strong>恢复程序执行</strong>：一旦页面被加载到内存并且页表更新完毕，操作系统会重新启动程序的执行。</li></ul></li><li><strong>恢复执行</strong>： 当缺页处理完毕后，程序会继续执行，刚才中断的指令会重新执行。由于页面已经加载到内存，所以程序可以继续访问这个页面。</li></ol><h4 id="缺页中断的分类："><a href="#缺页中断的分类：" class="headerlink" title="缺页中断的分类："></a>缺页中断的分类：</h4><ol><li><strong>硬缺页中断（Hard Page Fault）</strong>：<ul><li>发生在程序访问的页面完全不在内存中，需要从磁盘读取该页面。</li><li>是最常见的缺页中断类型，通常会涉及磁盘I&#x2F;O，导致较高的延迟。</li></ul></li><li><strong>软缺页中断（Soft Page Fault）</strong>：<ul><li>发生在程序访问的页面已经在内存中，但是在页面表中未正确标记或由于某些其他原因无法直接访问（比如被标记为只读或已换出）。</li><li>这种情况下，操作系统可以将页面放回内存或恢复其他访问权限，通常不涉及磁盘I&#x2F;O，处理开销较低。</li></ul></li></ol><p><img src="https://s2.loli.net/2025/01/03/K6zndcIhGYip4PQ.png" alt="image-20250103201239000"></p><h4 id="缺页中断的优缺点："><a href="#缺页中断的优缺点：" class="headerlink" title="缺页中断的优缺点："></a>缺页中断的优缺点：</h4><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>内存高效利用</strong>：程序不需要加载所有页面，只有被访问的页面才会被加载，从而有效利用有限的内存资源。</td><td><strong>性能开销</strong>：每当发生缺页中断时，操作系统需要中断程序并进行磁盘I&#x2F;O操作，这可能导致较大的延迟，尤其是在磁盘速度慢的情况下，影响程序的运行效率。</td></tr><tr><td><strong>支持大程序</strong>：即使程序的大小超出物理内存，仍然可以运行，通过按需调入页面实现。</td><td><strong>频繁缺页</strong>：如果程序在短时间内访问大量未加载的页面，可能会导致大量缺页中断，降低程序的执行效率。</td></tr></tbody></table><h4 id="缺页中断与一般中断的异同点？"><a href="#缺页中断与一般中断的异同点？" class="headerlink" title="缺页中断与一般中断的异同点？"></a>缺页中断与一般中断的异同点？</h4><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><table><thead><tr><th><strong>特性</strong></th><th><strong>缺页中断</strong></th><th><strong>一般中断</strong></th></tr></thead><tbody><tr><td><strong>中断机制</strong></td><td>都是由硬件或软件触发的中断机制</td><td>都是由硬件或软件触发的中断机制</td></tr><tr><td><strong>中断处理</strong></td><td>都需要操作系统通过中断处理程序来处理</td><td>都需要操作系统通过中断处理程序来处理</td></tr><tr><td><strong>打断程序执行</strong></td><td>都会打断当前程序的执行，转到操作系统处理</td><td>都会打断当前程序的执行，转到操作系统处理</td></tr><tr><td><strong>上下文切换</strong></td><td>都会引起进程的上下文切换</td><td>都会引起进程的上下文切换</td></tr></tbody></table><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><table><thead><tr><th><strong>特性</strong></th><th><strong>缺页中断</strong></th><th><strong>一般中断</strong></th></tr></thead><tbody><tr><td><strong>触发条件</strong></td><td>发生在程序访问的虚拟页面不在内存中时。</td><td>可以由各种外部或内部事件触发，例如I&#x2F;O设备的请求、定时器中断、外部硬件中断等。</td></tr><tr><td><strong>目的</strong></td><td>目的是将缺失的页面从磁盘或交换区调入内存，保证程序的正常运行。</td><td>目的是响应外部或内部事件，执行相应的处理操作，如硬件设备驱动、定时器管理等。</td></tr><tr><td><strong>中断源</strong></td><td>内存管理单元（MMU）通过页表检测到缺页时触发。</td><td>可能是硬件（如I&#x2F;O设备、中断请求线）或软件触发（如系统调用）。</td></tr><tr><td><strong>处理中断时间</strong></td><td>处理中断时间较长，通常涉及磁盘I&#x2F;O操作，可能导致显著的延迟。</td><td>处理中断时间较短，通常是响应硬件或定时器中断，涉及的操作相对简单。</td></tr><tr><td><strong>对程序的影响</strong></td><td>程序可能会因为频繁的缺页中断而显著变慢，特别是磁盘访问较慢时。</td><td>一般中断影响较小，除非是硬件错误或严重的系统问题。</td></tr><tr><td><strong>上下文切换</strong></td><td>由于缺页中断，操作系统需要保存和恢复程序的上下文，可能导致高开销。</td><td>一般中断处理时，操作系统同样需要保存和恢复上下文，但开销通常较低。</td></tr><tr><td><strong>资源使用</strong></td><td>需要更多的内存和磁盘I&#x2F;O资源，用于页面的加载和交换。</td><td>主要消耗CPU资源，用于处理硬件或软件事件。</td></tr><tr><td><strong>处理方式</strong></td><td>通常由操作系统的内存管理模块处理，涉及页面置换算法和磁盘I&#x2F;O。</td><td>由中断处理程序（例如设备驱动程序、定时器处理程序等）处理，操作内容较为多样。</td></tr></tbody></table><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>请求分页系统中的地址变化机构是在分页系统地址变化的机构上增加了两个功能：产生与处理缺页中断的功能<strong>（请求调入）</strong>、从内存中换出一页的功能<strong>（置换）</strong></p><p><img src="https://s2.loli.net/2025/01/03/pI3hkB9uZ6GqVoH.png" alt="31-2"></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>在为进程分配内存时，作业不采用一次装入的方法，而采用部分装入的方法，这就涉及到以下三个问题：</p><h3 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h3><p>为保证进程能正常运行，所需要的物理块数的确定是十分关键的</p><p>随着为每个进程分配的物理块的减少，将使进程在执行中的缺页率上升，从而降低进程的执行速度</p><p>为使进程有效地工作，应为其分配一定数量的物理块，而<strong>最小物理块数</strong>是指<strong>能保证进程正常运行所需的物理块的最小数量</strong></p><p>当系统为进程分配的物理块数少于此值时，进程将无法运行，而这个最小物理块数的确定，与计算机的硬件结构有关，<strong>取决于指令的格式、功能、寻址方式</strong></p><h3 id="物理块的分配策略"><a href="#物理块的分配策略" class="headerlink" title="物理块的分配策略"></a>物理块的分配策略</h3><p>在请求分页系统中，可采用两种<strong>内存分配策略</strong>：</p><ol><li><strong>固定分配</strong>，是指为每个进程分配一组固定数目的物理块，在进程运行期间不再改变</li><li><strong>可变分配</strong>，是指为每个进程分配一定数目的物理块，在进程运行期间，根据情况做适当的增加或减少</li></ol><p>在进行置换时，也可采用两种<strong>内存置换策略</strong>：</p><ol><li><strong>全局置换</strong>，是指进程在运行中若出现缺页，则将 OS 所管理的空闲物理块队列中，取出一块分配给该进程，将欲装入的页装入</li><li><strong>局部置换</strong>，是指进程在运行中若出现缺页，只能从分配给该进程的 n 个页面中选出一页换出，以保证分配给该进程的内存空间不变，且不影响其他进程执行</li></ol><p>将上述的策略进行组合，可组合出以下三种适用的策略：</p><ul><li><strong>固定分配局部置换策略</strong>：困难在于难以把握为每个进程分配适量的物理块数</li><li><strong>可变分配全局置换策略</strong>：当空闲空间不足时，可与其他任何进程页面置换，会使其他进程缺页率提高，影响运行，但易于实现</li><li><strong>可变分配局部置换策略</strong>：系统会根据缺页率适当地增减进程的物理块数。若频繁缺页中断，会为进程分配若干物理快；若缺页率特别低，会减少分配给该进程的物理块</li></ul><h3 id="物理块的分配算法"><a href="#物理块的分配算法" class="headerlink" title="物理块的分配算法"></a>物理块的分配算法</h3><p>采用固定分配策略时，分配物理块可采用以下几种算法：</p><ol><li><strong>平均分配算法</strong>：将所有可供分配的物理块平均分配给各进程，这种方法未考虑各进程本身的大小，可能会出现很高的缺页率</li><li><strong>考虑优先权的分配算法</strong>：将所有可用物理块分两部分， 一部分按比例分配给各进程，另一部分根据各进程优先权，适当地为其增加份额，分配给各进程</li><li><strong>按比例分配算法</strong>：根据进程的大小按比例分配物理块</li></ol><p>设进程中有 n 个进程，每个进程的页面数为 Si，则系统中各进程页面数的总和为：</p><img src="https://s2.loli.net/2025/01/03/6mBxwoaLs23SZuf.png" alt="image-20250103200950500" style="zoom:50%;" /><p>假定系统中可用的物理块总数为 m，则每个进程所能分到的物理块数为：</p><img src="https://s2.loli.net/2025/01/03/RrCFO8chpobdeak.png" alt="image-20250103200959804" style="zoom:50%;" /><p>需要注意的是，此处 bi 应该取正，其必须大于最小物理块数</p><h2 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h2><h3 id="页面调入时机"><a href="#页面调入时机" class="headerlink" title="页面调入时机"></a>页面调入时机</h3><p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种策略：</p><ol><li><strong>预调页策略</strong>：以预测为基础，将预计不久后便会被访问的若干页面，预先调入内存</li><li><strong>请求调页策略</strong>：运行中需要的页面不再内存时，就立即提出请求，由 OS 将其调入内存</li></ol><p>预调页策略的优点在于可一次调入若干页，效率较好，但其预测不一定准确，预先调入的页面可能不会被执行；请求调页策略的优点在于被调入的页一定会被访问，且容易实现，但每次仅调入一页，需花费较大的系统开销，增加了磁盘 I&#x2F;O 的启动频率</p><h3 id="页面调入地点"><a href="#页面调入地点" class="headerlink" title="页面调入地点"></a>页面调入地点</h3><p>请求分页系统中的外存分为两部分，一部分是采用离散分配方式用于存放文件的<strong>文件区</strong>，另一部分是采用连续分配方式存放对换页面的<strong>对换区</strong></p><p>对换区的数据存取速度比文件区要高，因此每当发生缺页时，系统应从何处将缺页调入内存，分成三种情况：</p><ol><li><strong>系统拥有足够的对换区空间</strong>：进程运行前将所有页面由文件区拷贝到对换区，运行需要的全部页面从对换区调入内存，提高调页速度</li><li><strong>系统缺少足够的对换区空间</strong>：不会被修改的部分，在文件区操作；可能被修改的部分，在对换区操作</li><li><strong>UNIX 方式</strong>：与进程有关的文件都存放在文件区，因此未运行过的页面，都从文件区调入；而曾运行过又被换出的页面存放在对换区，因此随着进程的运行，已运行过的页面再次被调用时，直接从对换区调入。由于 UNIX 系统允许页面共享，因此某进程所请求的页面可能已被其他进程调入内存，此时就无需从对换区调入</li></ol><h3 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h3><p>在开始运行时，预调入一部分页面，在运行过程中，需要的页面不在内存时，向 CPU 发出一缺页中断，中断处理程序开始工作：</p><ul><li>保留 CPU 环境</li><li>分析中断原因，转入缺页中断处理程序</li><li>判断是否置换、页表信息更新</li><li>恢复现场，重新操作页面</li></ul><h2 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h2><p><strong>缺页率（Page Fault Rate）</strong> 是指在程序运行过程中，由于访问的页面不在内存中，需要从磁盘或其他存储介质加载页面时发生缺页中断的频率。换句话说，缺页率衡量的是程序在访问内存时，发生缺页中断的概率。</p><h3 id="计算缺页率"><a href="#计算缺页率" class="headerlink" title="计算缺页率"></a>计算缺页率</h3><p>缺页率可以通过以下公式计算：</p><p><img src="https://s2.loli.net/2025/01/03/d2vrq4ZC95Qpf6R.png" alt="image-20250103201656250"></p><p>其中：</p><ul><li><strong>缺页中断的次数</strong>：指程序在运行过程中由于访问的页面不在内存中，导致操作系统需要从磁盘加载页面的次数。</li><li><strong>总的内存访问次数</strong>：指程序进行的所有内存访问次数，包括读取和写入。</li></ul><h3 id="影响缺页率的因素"><a href="#影响缺页率的因素" class="headerlink" title="影响缺页率的因素"></a>影响缺页率的因素</h3><p>缺页率的高低受以下几个因素的影响：</p><ol><li><strong>程序访问模式</strong>：如果程序的访问模式是局部性的（即访问的数据集中在一个较小的区域），则可能会导致较低的缺页率；反之，如果程序访问的数据是分散的，缺页率可能较高。</li><li><strong>内存容量</strong>：如果程序的内存需求大于物理内存，且操作系统需要频繁地从磁盘调入页面，缺页率会增高。如果内存足够大，程序可能大部分时间不发生缺页，缺页率较低。</li><li><strong>页面置换算法</strong>：操作系统采用的页面置换算法（如LRU、FIFO、OPT等）也会影响缺页率。不同的算法对页面的管理策略不同，可能导致不同的缺页率。</li><li><strong>工作集大小</strong>：工作集是程序在某一时刻活跃的页面集合。若工作集较小，内存能够容纳更多的活跃页面，缺页率较低；若工作集较大，则可能发生频繁的缺页。</li><li><strong>程序的多任务负载</strong>：如果系统正在运行多个程序，且这些程序的总内存需求超过了物理内存，那么系统可能会频繁发生缺页中断，导致较高的缺页率。</li></ol><h3 id="缺页率的影响"><a href="#缺页率的影响" class="headerlink" title="缺页率的影响"></a>缺页率的影响</h3><ul><li><strong>高缺页率</strong>：当缺页率较高时，意味着程序频繁从磁盘调入页面，这会导致大量的磁盘I&#x2F;O操作，进而增加程序的执行延迟，影响系统的性能。这通常会引起<strong>交换抖动（Thrashing）</strong>，即系统在进行页面交换时浪费了大量时间和资源。</li><li><strong>低缺页率</strong>：低缺页率通常意味着程序能够有效地利用内存，大多数页面都已加载到内存中，程序的执行效率较高。</li></ul><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><h2 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h2><p><strong>概述</strong>： 最佳置换算法（OPT）是理论上最优的页面置换算法。它通过选择将来最长时间内不再使用的页面进行替换，确保最小化缺页中断的数量。</p><p><strong>工作原理</strong>：</p><ul><li>当发生缺页中断且内存已满时，操作系统通过查看未来一段时间内的页面访问序列，选择最远的一个页面进行置换。</li><li>这种算法的最大优点是最少的缺页率，因为它总是选择最不常用的页面进行替换。</li></ul><h2 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h2><p><strong>概述</strong>： 先进先出（FIFO）置换算法是最简单的页面置换算法。它根据页面进入内存的顺序进行页面替换。换句话说，最早进入内存的页面将最先被替换。</p><p><strong>工作原理</strong>：</p><ul><li>操作系统维护一个页面队列，队列中存放当前在内存中的页面。当发生缺页中断时，操作系统会选择队列中最早进入内存的页面进行替换。</li><li>FIFO算法遵循队列的“先进先出”原则，即第一个进入队列的页面将首先被替换出去。</li></ul><h2 id="最近最久未使用算法"><a href="#最近最久未使用算法" class="headerlink" title="最近最久未使用算法"></a>最近最久未使用算法</h2><p><strong>概述</strong>： 最近最久未使用（LRU）算法是一个常见的置换算法，它根据页面最近的使用情况来决定页面的替换。LRU算法认为，最久未使用的页面是最不可能在近期再次使用的页面，因此选择它进行替换。</p><p><strong>工作原理</strong>：</p><ul><li>操作系统维护一个记录页面访问时间的数据结构（通常是一个链表或栈），每次页面被访问时，操作系统都会更新该页面的访问时间。</li><li>当发生缺页中断时，操作系统选择访问时间最久的页面进行替换。</li></ul><h3 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h3><p><strong>概述</strong>： Clock算法是LRU算法的一种近似实现，它通过循环指针和标记位来高效地选择页面进行替换。Clock算法的基本思想是将页面按时钟方式组织，指针指向当前页面，当发生缺页时，指针会检查页面的访问位，选择最久未访问的页面进行替换。</p><p><strong>工作原理</strong>：</p><ul><li>所有的页面都在一个环形队列中，每个页面都有一个”访问位”（referenced bit）。</li><li>当页面被访问时，操作系统将页面的访问位设置为1。如果页面未被访问，访问位保持为0。</li><li>指针扫描环形队列并检查每个页面的访问位。如果访问位为1，则将其清零并移动指针；如果访问位为0，表示该页面长时间未被访问，操作系统就将其替换出去。</li><li>这种方法模拟了一个时钟的行为，因此被称为“Clock”算法。</li></ul><h2 id="最少使用置换算法"><a href="#最少使用置换算法" class="headerlink" title="最少使用置换算法"></a>最少使用置换算法</h2><p><strong>概述</strong>： 最少使用（LFU）置换算法基于页面的访问频率来决定页面的替换。LFU算法认为，访问频率最少的页面最不可能在未来被访问，因此应该将其替换出去。</p><p><strong>工作原理</strong>：</p><ul><li>操作系统维护一个计数器，每个页面都有一个计数器记录该页面被访问的次数。</li><li>当发生缺页中断时，操作系统选择访问频率最少的页面进行替换。</li><li>计数器会随着页面的每次访问增加，操作系统根据页面的访问频率来决定哪个页面最少被访问，选择它进行替换。</li></ul><p>总结对比：</p><table><thead><tr><th><strong>算法</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>最佳置换算法 (OPT)</strong></td><td>选择将来最远的页面进行替换</td><td>最优，最小化缺页率</td><td>无法实现，需要预知未来访问</td></tr><tr><td><strong>先进先出 (FIFO)</strong></td><td>根据页面进入内存的顺序替换页面</td><td>实现简单，易于理解</td><td>忽略页面的访问频率，可能导致高缺页率</td></tr><tr><td><strong>最近最久未使用 (LRU)</strong></td><td>根据页面最近访问情况进行替换</td><td>比FIFO更合理，较低缺页率</td><td>实现复杂，需要额外的数据结构</td></tr><tr><td><strong>Clock</strong></td><td>LRU的近似实现，通过环形队列和访问位来模拟LRU</td><td>高效实现LRU，适用于硬件资源有限的系统</td><td>无法做到最佳性能，处理局部性差时表现不佳</td></tr><tr><td><strong>最少使用 (LFU)</strong></td><td>选择访问频率最少的页面进行替换</td><td>可有效替换长时间未被使用的页面</td><td>计数器管理开销大，访问频率突变时可能出现问题</td></tr></tbody></table><h1 id="虚拟内存中的抖动与工作集"><a href="#虚拟内存中的抖动与工作集" class="headerlink" title="虚拟内存中的抖动与工作集"></a>虚拟内存中的抖动与工作集</h1><p>虚拟内存是一种内存管理技术，它允许操作系统使用硬盘作为扩展内存，使得程序可以使用超出物理内存限制的内存空间。在虚拟内存的管理过程中，涉及到许多复杂的内存调度和页面交换策略，其中“抖动”和“工作集”是两个非常关键的概念。</p><h2 id="1-抖动"><a href="#1-抖动" class="headerlink" title="1. 抖动"></a>1. <strong>抖动</strong></h2><p><strong>抖动</strong>是指操作系统在管理虚拟内存时，频繁地发生页面交换（即页面从内存移到磁盘或从磁盘移回内存）的现象。这种情况通常会导致系统的性能急剧下降，因为系统花费了大量的时间来交换页面，而没有足够的时间执行实际的进程计算。</p><p>抖动的发生通常是在内存不足的情况下，进程需要的数据频繁被交换出内存并重新加载，从而产生一种“死循环”，即操作系统不断地将页面调度到内存中，导致极低的 CPU 使用率和非常差的系统性能。</p><blockquote><p>本质是：同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每一个进程在运行时，频繁出现缺页，必须请求系统将所缺的页调入内存</p></blockquote><h3 id="抖动的原因："><a href="#抖动的原因：" class="headerlink" title="抖动的原因："></a><strong>抖动的原因：</strong></h3><ul><li><strong>内存不足</strong>：如果物理内存不足以容纳正在运行的进程和其使用的所有页面，操作系统就需要不断交换页面。</li><li><strong>进程的内存需求超过了物理内存的容量</strong>：当系统中运行的进程总共需要的内存超过了可用的物理内存时，系统不得不频繁交换页面。</li><li><strong>不合理的页面替换算法</strong>：例如，操作系统使用的页面置换算法不合理，导致系统总是选择将活跃页面交换出去，造成频繁的页面交换。</li></ul><h3 id="抖动的症状："><a href="#抖动的症状：" class="headerlink" title="抖动的症状："></a><strong>抖动的症状：</strong></h3><ul><li>系统响应时间显著变慢。</li><li>CPU 使用率很低，很多时间被浪费在页面的交换上。</li><li>频繁的磁盘访问，导致磁盘 I&#x2F;O 操作繁忙。</li></ul><h3 id="防止抖动的方法："><a href="#防止抖动的方法：" class="headerlink" title="防止抖动的方法："></a><strong>防止抖动的方法：</strong></h3><ul><li><strong>增加物理内存</strong>：最直接的方法是增加系统的物理内存，减少页面交换的需求。</li><li><strong>使用工作集模型</strong>：通过工作集模型来管理内存，确保每个进程所需的页面能够保持在内存中，减少不必要的页面交换。</li><li><strong>进程优先级管理</strong>：对于某些进程，可以设置较低的优先级，避免它们占用过多的内存资源。</li><li><strong>优化页面置换算法</strong>：例如，使用更先进的页面置换算法（如LRU、CLOCK等）来减少不必要的页面交换。</li></ul><h2 id="2-工作集"><a href="#2-工作集" class="headerlink" title="2. 工作集"></a>2. <strong>工作集</strong></h2><p><strong>工作集</strong>是指进程在一段时间内实际使用的内存页面的集合。工作集模型通过分析进程在一定时间窗口内访问的内存页面，帮助操作系统更有效地管理内存。工作集的大小和组成是动态变化的，因为随着进程的执行，所需的页面集合可能会发生变化。</p><p>工作集的核心思想是：每个进程在运行时，只有部分内存页面是频繁访问的，其他部分则可能长时间不使用。因此，操作系统应尽量保证进程的工作集中的页面常驻内存，减少不必要的页面交换。</p><h3 id="工作集的特点："><a href="#工作集的特点：" class="headerlink" title="工作集的特点："></a><strong>工作集的特点：</strong></h3><ul><li><strong>动态性</strong>：工作集随着时间的推移而变化，进程对内存的访问模式也是动态的。</li><li><strong>局部性</strong>：工作集体现了程序的局部性原理，即程序在一段时间内倾向于重复访问同一部分数据和代码。</li><li><strong>时间窗口</strong>：工作集的计算通常会根据一个时间窗口来评估，通常是最近一段时间内进程访问过的页面。</li></ul><h3 id="工作集的计算："><a href="#工作集的计算：" class="headerlink" title="工作集的计算："></a><strong>工作集的计算：</strong></h3><p>工作集的计算通常依赖于<strong>时间窗口</strong>。假设一个进程在运行时访问了一系列页面，操作系统可以根据一个固定的时间窗口来定义工作集。工作集中的页面是进程在这个时间窗口内访问过的页面。</p><p>举例来说，如果窗口大小为10秒，那么进程在过去10秒内访问过的所有页面构成了该进程的工作集。如果页面在过去10秒内没有被访问过，则认为它不属于工作集的一部分。</p><h3 id="工作集模型的优点："><a href="#工作集模型的优点：" class="headerlink" title="工作集模型的优点："></a><strong>工作集模型的优点：</strong></h3><ul><li><strong>减少抖动</strong>：通过确保工作集中的页面始终保持在内存中，操作系统可以减少页面交换，从而避免抖动现象。</li><li><strong>提高内存利用率</strong>：通过合理管理进程的工作集，操作系统可以保证进程所需的页面始终驻留在内存中，从而提高内存利用率。</li><li><strong>优化页面置换策略</strong>：工作集可以作为页面置换策略的依据，操作系统可以优先保留工作集中的页面，将不在工作集中的页面置换出去。</li></ul><h3 id="工作集模型的实现方法："><a href="#工作集模型的实现方法：" class="headerlink" title="工作集模型的实现方法："></a><strong>工作集模型的实现方法：</strong></h3><ol><li><strong>工作集管理</strong>：操作系统需要定期监控进程的页面访问情况，并维护工作集的大小。每个进程的工作集应包含它在过去一段时间内频繁访问的页面。</li><li><strong>页面置换</strong>：操作系统可以根据工作集的大小动态调整每个进程的内存分配。例如，进程的工作集很大时，操作系统可能会分配更多的内存，以确保工作集中的页面始终驻留在内存中。</li><li><strong>时间窗口调整</strong>：时间窗口的大小可以根据实际需求进行调整。如果窗口太小，工作集的估计可能会过于片面；如果窗口太大，工作集的动态性可能会降低。</li></ol><h2 id="工作集与抖动的关系："><a href="#工作集与抖动的关系：" class="headerlink" title="工作集与抖动的关系："></a><strong>工作集与抖动的关系：</strong></h2><p>工作集模型可以有效地防止抖动现象。通过确保每个进程的工作集中的页面尽可能常驻内存，操作系统可以减少页面交换的频率，从而避免因频繁交换页面而引发的抖动。</p><h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a><strong>例子说明</strong></h2><p>假设有一个进程运行在一个物理内存大小为4GB的系统中，进程需要的内存总量为3GB。在这种情况下，操作系统可能无法一次性为进程分配足够的内存。因此，操作系统可以通过计算进程的工作集，确保进程的活跃页面保持在内存中。当工作集的大小变化时，操作系统动态地调整内存分配，保证页面不会频繁被交换，防止系统发生抖动。</p><h1 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h1><p>同请求分页部分相似，可参考<a href="https://blog.csdn.net/Zevalin/article/details/137146134">操作系统理论 第五章（虚拟存储器）—第五节（请求分段存储管理方式）-CSDN博客</a></p><blockquote><p>注意这里的越界中断</p></blockquote><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/weixin_43914604/article/details/105978678">3.2.2 OS之请求分页管理方式（请求页表、缺页中断机构、地址变换机构）_缺页的地址变换机构-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_62679382/article/details/140018096">【操作系统】内存管理——请求分页管理方式（个人笔记）_请求分页式存储管理-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外存管理</title>
    <link href="/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在提供计算机持久化的知识框架体系，对于一些细节内容并没有过多介绍。</p></blockquote><h1 id="内存的不足"><a href="#内存的不足" class="headerlink" title="内存的不足"></a>内存的不足</h1><h2 id="内存管理管理方式："><a href="#内存管理管理方式：" class="headerlink" title="内存管理管理方式："></a>内存管理管理方式：</h2><p>在上一篇文章中：<a href="https://wangxiaobai08.github.io/2024/12/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理 - The Peak Tower</a>，提到了内存管理：<strong>所有的应用程序都需要<code>存储</code>和<code>检索</code>信息。进程运行时，它能够在自己的存储空间内存储一定量的信息。</strong></p><h2 id="带来的问题："><a href="#带来的问题：" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>然而，存储容量受<code>虚拟地址空间</code>大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了。</p><p>第二个问题是，当进程终止时信息会丢失。对于一些应用程序（例如数据库），信息会长久保留。在这些进程终止时，相关的信息应该保留下来，是不能丢失的。甚至这些应用程序崩溃后，信息也应该保留下来。</p><p>第三个问题是，通常需要很多进程在同一时刻访问这些信息。解决这种问题的方式是把这些信息单独保留在各自的进程中。</p><h1 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h1><h2 id="管理方式："><a href="#管理方式：" class="headerlink" title="管理方式："></a>管理方式：</h2><p>通过对内存不足的分析，对于长久存储的信息我们有三个基本需求：</p><ul><li><strong>必须要有可能存储的大量的信息</strong></li><li><strong>信息必须能够在进程终止时保留</strong></li><li><strong>必须能够使多个进程同时访问有关信息</strong></li></ul><p>因此可以引入<strong>持久化存储</strong>，例如硬盘、固态硬盘（SSD）等非易失性存储设备。</p><h2 id="带来的问题：-1"><a href="#带来的问题：-1" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>对于新引入的设备，计算机如何将I&#x2F;O集成进系统中？其中的一般机制是什么？如何让它们变得高效？</p><h1 id="IO接口与设备"><a href="#IO接口与设备" class="headerlink" title="IO接口与设备"></a>IO接口与设备</h1><p>在开始下面的内容前，有必要先简单了解什么是IO接口与设备？</p><p><strong>IO（Input&#x2F;Output）设备</strong>是将数据输入计算机或接收计算机输出的设备。</p><p>鼠标、键盘都属于IO设备，它们所连接到的电脑的接口叫做IO接口（或称为IO控制器）。</p><p>IO接口为了能够充当设备与计算机的桥梁，它需要多个寄存器：</p><ul><li><strong>数据寄存器</strong>：保存设备的输出或计算机的输出。</li><li><strong>控制寄存器</strong>：计算机需要控制设备做出操作，要做的操作存在这里。</li><li><strong>状态寄存器</strong>：设备完成操作后，需要告诉计算机当前的状态。</li></ul><p>这些寄存器对于计算机而言都是<strong>IO端口</strong>——数据端口、状态端口、控制端口。一个IO接口可以对应多个设备，每个设备可以有自己的一组数据、控制、状态寄存器，这样计算机就可以通过控制不同组的寄存器，来控制不同的设备。</p><p><img src="https://s2.loli.net/2024/12/21/VK4UMSjxOYlFhpt.png" alt="IO接口"></p><p>计算机通过一条系统总线（包含数据、地址、控制信号线）与IO接口连接，CPU、主存、IO接口都连在上面。cpu可以通过总线直接控制IO接口，也可以让主存与IO接口间传递数据。</p><p><img src="https://s2.loli.net/2024/12/21/K9PfI4X1GlNTADR.png" alt="系统总线"></p><p>CPU有两种方式获得数据：</p><ul><li><strong>程序查询方式</strong>：CPU会不断询问键盘的状态寄存器输入是否完成，如果检测到了完成，就会把数据寄存器里的数据拿到主存。</li><li><strong>程序中断方式</strong>：CPU不用询问，IO接口根据状态寄存器来选择是否需要向CPU发送一个中断信号，CPU收到信号会过来收取数据。</li></ul><p>程序查询方式会导致cpu只能一直等着键盘输入，不能做其他事；程序中断方式可以允许CPU先做其他事，等输入完成后过来取到主存。</p><blockquote><p><strong>中断</strong>是计算机中比较重要的内容，在这里与主体内容关联不大，不多赘述，可自自行百度</p></blockquote><p>注意有一种特殊的IO接口——<strong>DMA接口</strong>，它可以用DMA总线与主存直接相连，只要CPU告诉DMA接口要把数据存在主存中的哪个地址，DMA接口就会根据地址把数据放进主存。</p><img src="https://s2.loli.net/2024/12/21/8VoPR9gelTqMHcu.png" alt="v2-9b1553f891f5172e314eafd35fca0677_1440w" style="zoom:50%;" /><p>对于DMA接口而言，CPU还需要告诉它主存地址，如果有多个DMA接口，CPU依旧会很忙碌。为了进一步解放CPU，<strong>通道</strong>可以接替CPU做一些基础操作。</p><img src="https://s2.loli.net/2024/12/21/PVHza71unBCiIJ8.png" alt="v2-5054d9430842c23df9b840bddb745f23_1440w" style="zoom:50%;" /><p>它就像一个低级CPU，有自己的指令系统——<a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=1&q=%E9%80%9A%E9%81%93%E6%8C%87%E4%BB%A4&zhida_source=entity">通道指令</a>，能够执行一些有限的操作。当它接受到CPU发出的<strong>IO指令</strong>后，可以按照要求启动IO设备，或者执行通道指令——就像是CPU的小弟。</p><p>IO指令从逻辑上分为三个字段：</p><ul><li>操作码：可以被用作和其他指令的区分，让CPU知道这是一条IO指令。</li><li>命令码：代表了设备要做的具体操作。</li><li>设备码：可以指定对某个设备进行操作，用作区分设备。</li></ul><p>不同设备的IO指令各不相同，同样是设置鼠标侧键、灯光或是灵敏度，不同的品牌都有不同的IO指令。这也是为什么在插上鼠标键盘显卡之类的部件时，如果你想更好的使用它就需要安装驱动的原因。</p><p>键盘的每一次敲击都在向计算机发出中断信号，一般情况下计算机会暂停手上的工作，先处理键盘的输入数据，之后再回到自己之前的工作。</p><h1 id="I-O集成"><a href="#I-O集成" class="headerlink" title="I&#x2F;O集成"></a>I&#x2F;O集成</h1><p>先来观察计算机体系架构：</p><img src="https://s2.loli.net/2024/12/21/eoLBjYpE2VUkHKA.png" alt="计算机架构" style="zoom:25%;" /><p>CPU通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能I&#x2F;O设备通过常规的I&#x2F;O总线（I&#x2F;O bus）连接到系统，在许多现代系统中会是PCI或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如SCSI、SATA或者USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。</p><p>接着续上<em>持久化存储</em>中<strong>计算机如何将I&#x2F;O集成进系统中？</strong>的问题，继续探讨：</p><p>这里要解决的第一个问题便是：</p><h2 id="如何与设备通信"><a href="#如何与设备通信" class="headerlink" title="如何与设备通信?"></a>如何与设备通信?</h2><p><strong>I&#x2F;O指令方式</strong>：通过指令（如 <code>in</code> 和 <code>out</code>）与设备通信，指定寄存器和设备端口，通常为特权指令，仅操作系统可使用，确保安全性。</p><p><strong>内存映射I&#x2F;O</strong>：设备寄存器映射为内存地址，操作系统通过读写这些地址与设备交互，硬件将访问操作转交给设备，而非物理内存。</p><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><p>每个设备都有非常具体的接口，如何将它们纳入操作系统，而我们希望操作系统尽可能通用?比如：</p><table><thead><tr><th>设备类型</th><th>接口类型</th><th>特殊要求</th></tr></thead><tbody><tr><td>硬盘</td><td>块设备，协议如 SATA、NVMe</td><td>批量传输数据，支持异步操作，命令格式多样</td></tr><tr><td>显示器</td><td>输出设备，通过显卡接口或协议驱动</td><td>实时更新数据，要求特定的视频信号、刷新率等支持</td></tr></tbody></table><p><strong>本质</strong>：不同设备有不同的寄存器布局、通信协议和操作流程，这些具体接口定义了设备的使用方式，需要操作系统进行抽象和标准化以实现通用性。</p><p>这个问题抽象，在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序（device driver），所有设备交互的细节都封装在其中。</p><p><strong>设备驱动程序</strong>（Device Driver）是操作系统的一部分，负责在操作系统与硬件设备之间建立连接，使操作系统能够控制和管理设备，而无需直接处理设备的底层硬件细节。<br><strong>核心功能</strong>：</p><ul><li><strong>抽象化设备接口</strong>：隐藏硬件的具体实现细节，对操作系统提供统一的访问接口。</li><li><strong>管理硬件资源</strong>：与设备通信，完成初始化、数据传输、资源分配等操作。</li><li><strong>兼容性与扩展性</strong>：通过加载不同的驱动程序，操作系统能够支持多种硬件设备，而无需修改自身核心。</li></ul><p>比如：</p><p>假设有一台打印机，用户希望通过电脑将文档打印出来。不同厂商、型号的打印机可能有完全不同的通信协议和功能设置。那么，操作系统如何支持这些打印机呢？这就是设备驱动程序的作用。</p><p><strong>具体过程</strong>：</p><p><strong>设备驱动的作用</strong>：<br>打印机驱动程序是一个中间层，负责将操作系统的打印请求（如 “打印这份 PDF 文档”）翻译成打印机能理解的具体命令。</p><p><strong>实现过程</strong>：</p><p>用户在电脑上点击“打印”，操作系统将打印内容通过<strong>统一的打印接口</strong>（如 Windows 的打印子系统）发送给打印机驱动程序。</p><p>驱动程序会根据打印机的具体型号和协议，生成打印机可以理解的命令，如：</p><ul><li>将文字和图片数据转换为打印机支持的格式（如 PCL、PostScript 等）。</li><li>设置具体的打印参数（分辨率、纸张类型等）。</li></ul><p>驱动程序与打印机通信，发送这些指令并控制打印过程。</p><p><strong>操作系统的通用性</strong>：</p><ul><li>操作系统本身只需要支持一个通用的打印接口。</li><li>针对不同型号的打印机，只需加载相应的驱动程序。</li></ul><img src="https://s2.loli.net/2024/12/21/C8mHAvK1BF2kaTz.png" alt="驱动程序" style="zoom:50%;" /><p>注意：<strong>设备驱动程序必须实现操作系统定义的接口</strong>，以便操作系统能够通过统一的方式与设备交互，而不关心具体设备的实现细节。常见的比如：<strong>读写操作接口</strong>：<br>驱动程序需要实现设备读写的标准接口。例如：</p><ul><li>在 Linux 中，字符设备驱动实现 <code>read()</code> 和 <code>write()</code> 方法。</li><li>在 Windows 中，驱动程序需实现 I&#x2F;O 请求包（IRP）的处理函数，响应 <code>IRP_MJ_READ</code> 和 <code>IRP_MJ_WRITE</code>。</li></ul><p><strong>这里特别关注的是存储设备，比如磁盘驱动器原理和一系列调度算法</strong>，这里不多介绍，自行百度</p><h1 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h1><p>在解决了与设备通信与驱动后，在诸如存储设备（如硬盘、SSD、USB 等），我们不得不面临如何像管理内存那样<strong>组织、存储、管理和检索数据</strong>。就拿磁盘为例：</p><img src="https://s2.loli.net/2024/12/21/zKfeyVMhHrZuRUD.png" alt="磁盘" style="zoom:50%;" /><p>如何对磁盘上的文件进行组织管理？—<strong>文件系统</strong>应运而生：它为存储设备（上的数据提供了一种结构化的方式，使用户和程序能够以文件和目录的形式高效地访问和管理数据。类比内存可以把每个文件都看作一个独立的地址空间</p><table><thead><tr><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>将物理存储抽象为逻辑结构</strong></td><td>- <strong>物理存储的复杂性</strong>：硬盘以扇区（如 512 字节）为单位存储数据，直接操作扇区会很不便。 - <strong>文件系统的抽象</strong>：通过“文件”和“目录”来组织和管理数据，屏蔽底层物理细节。</td></tr><tr><td><strong>数据组织和查找</strong></td><td>- <strong>无文件系统的情况</strong>：数据可能存储在任意位置，难以高效查找。 - <strong>文件系统的作用</strong>：通过目录结构（如树形结构）和路径组织文件，便于管理和检索数据。</td></tr><tr><td><strong>数据持久性</strong></td><td>- 文件系统确保数据在存储设备断电或系统重启后仍然可用，实现数据长期保存。</td></tr><tr><td><strong>支持多用户和并发访问</strong></td><td>- 通过权限管理，确保用户只能访问自己授权的数据。 - 处理多个进程同时访问同一文件的冲突，保证数据一致性。</td></tr><tr><td><strong>提高存储效率</strong></td><td>- 通过优化存储分配（如簇、块）和读取方式（如顺序读写、索引）提升性能。 - 提供删除、压缩等功能回收或节省存储空间。</td></tr></tbody></table><blockquote><p>接下来的问题便是：如何构建一个简单的文件系统？磁盘上需要什么结构？它们需要记录什么？它们如何访问？</p></blockquote><h2 id="构建文件系统"><a href="#构建文件系统" class="headerlink" title="构建文件系统"></a>构建文件系统</h2><blockquote><p>第一个方面是文件系统的数据结构（data structure）。换言之，文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？</p><p>文件系统的第二个方面是访问方法（access method）。如何将进程发出的调用，如open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？</p></blockquote><h3 id="文件系统的数据结构"><a href="#文件系统的数据结构" class="headerlink" title="文件系统的数据结构"></a>文件系统的数据结构</h3><p>重点参考：<a href="https://www.cnblogs.com/wkfvawl/p/11847413.html#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">操作系统——文件系统概述、文件逻辑地址、目录、物理地址 - 王陸 - 博客园</a></p><blockquote><p>用户角度的文件的逻辑结构：</p><table><thead><tr><th><strong>文件逻辑结构</strong></th><th><strong>特点</strong></th><th><strong>应用场景</strong></th><th><strong>访问方式</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>顺序结构</strong></td><td>数据按顺序存储，必须逐个读取</td><td>日志文件、文本文件</td><td>顺序访问</td><td>文本文件，如 <code>.txt</code> 文件</td></tr><tr><td><strong>层次结构</strong></td><td>数据以树状结构组织，具有父子关系</td><td>文件系统的目录结构</td><td>随机访问树中的节点</td><td>文件夹和文件的层级结构</td></tr><tr><td><strong>索引结构</strong></td><td>文件内容与索引表结合存储，支持快速定位数据</td><td>数据库索引、文本搜索</td><td>随机访问，通过索引定位</td><td>数据库的索引文件</td></tr><tr><td><strong>记录结构</strong></td><td>文件由记录组成，每个记录包含多个字段</td><td>数据库文件、表格文件</td><td>随机访问，每次操作记录</td><td>CSV 文件、数据库表</td></tr><tr><td><strong>关系结构</strong></td><td>数据以表格形式存储，支持关系查询</td><td>关系型数据库</td><td>SQL 查询语言随机访问</td><td>MySQL 数据库表</td></tr><tr><td><strong>文本文件</strong></td><td>由字符组成，通常按行或字符组织</td><td>配置文件、源代码、日志文件</td><td>按行或字符操作</td><td><code>.txt</code>、<code>.log</code> 文件</td></tr><tr><td><strong>二进制文件</strong></td><td>由二进制数据组成，不能直接读取为文本</td><td>图像、音频、可执行文件</td><td>通过特定软件操作</td><td><code>.jpg</code>、<code>.mp3</code>、<code>.exe</code> 文件</td></tr><tr><td><strong>目录文件</strong></td><td>存储文件名、大小、存储位置等元数据</td><td>文件系统中的目录管理</td><td>随机访问文件元数据</td><td>操作系统的文件目录结构</td></tr></tbody></table></blockquote><p>这里以VSFS文件系统为例：</p><p>1.将磁盘分成块（block）。简单的文件系统只使用一种块大小，这里正是这样做的。我们选择常用的4KB。因此，对构建文件系统的磁盘分区的看法很简单：一系列块，每块大小为4KB。在大小为N个4KB块的分区中，这些块的地址为从0到N−1。假设我们有一个非常小的磁盘，只有64块：</p><img src="https://s2.loli.net/2024/12/21/ljZu613kvKyEf8p.png" alt="1" style="zoom:50%;" /><blockquote><p><strong>文件的逻辑结构(用户角度)：</strong></p><p>具体参考：<a href="https://www.cnblogs.com/wkfvawl/p/11847413.html#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">操作系统——文件系统概述、文件逻辑地址、目录、物理地址 - 王陸 - 博客园</a></p><p><strong>外存的组织方式(物理结构)：</strong></p><p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种</p><ul><li>连续空间存放方式</li><li>非连续空间存放方式</li></ul><p>具体可参考：</p><p><a href="https://blog.csdn.net/qq_34827674/article/details/107992414">一口气搞懂「文件系统」，就靠这 25 张图了-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhouhengzhe/article/details/123320438">操作系统——文件系统_操作系统文件系统-CSDN博客</a></p></blockquote><p>2.文件系统必须记录每个文件的信息。该信息是元数据（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息的事情。为了存储这些信息，文件系统通常有一个名为inode的结构</p><img src="https://s2.loli.net/2024/12/21/zF2t6Nip9x7BdOJ.png" alt="2" style="zoom:50%;" /><blockquote><p>文件的存储，注意：多级索引，为了支持更大的文件，文件系统设计者必须在inode中引入不同的结构。一个常见的思路是有一个称为间接指针（indirect pointer）的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将inode的间接指针设置为指向它。</p></blockquote><p>3.还需要某种方法来记录inode或数据块是空闲还是已分配。因此，这种分配结构（allocation structure）是所有文件系统中必需的部分。</p><p><img src="https://s2.loli.net/2024/12/21/vSmqKkoWOUurcBz.png" alt="image-20241221143107283"></p><blockquote><p>文件存储空间的管理</p><p>具体参考，<a href="https://blog.csdn.net/zhouhengzhe/article/details/123320438">操作系统——文件系统_操作系统文件系统-CSDN博客</a></p></blockquote><p>4.还有一块。我们将它保留给超级块（superblock），在下图中用S表示。超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）。</p><p><img src="https://s2.loli.net/2024/12/21/HnSauTVIk4Le3bM.png" alt="image-20241221143143501"></p><p>因此，在挂载文件系统时，操作系统将首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。当卷中的文件被访问时，系统就会知道在哪里查找所需的磁盘上的结构。</p><p>4.目录项，也就是 <em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</p><p>目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。对于每个字符串，可能还有一个长度（假定采用可变大小的名称）。</p><p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p><blockquote><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p></blockquote><img src="https://s2.loli.net/2024/12/21/CKL46SdPnqyW1xJ.png" alt="4" style="zoom:50%;" /><p>这里继续给出多种不同文件系统的差异：</p><table><thead><tr><th><strong>文件系统</strong></th><th><strong>数据存储方式</strong></th><th><strong>元数据管理方式</strong></th><th><strong>碎片管理机制</strong></th><th><strong>访问效率</strong></th><th><strong>数据保护与可靠性</strong></th><th><strong>特性支持</strong></th></tr></thead><tbody><tr><td><strong>FAT32</strong></td><td>使用链表（FAT 表）记录每个文件的块链表，结构简单，扩展性差</td><td>元数据存储在目录项中，简单，文件属性有限</td><td>没有特别的碎片管理，容易碎片化</td><td>随机访问效率差，大文件查找速度慢</td><td>无日志，不支持数据保护，崩溃时易丢失数据</td><td>支持小文件存储，适合嵌入式系统、U盘等小型存储设备</td></tr><tr><td><strong>NTFS</strong></td><td>使用 B+树结构索引文件数据位置，支持稀疏文件，优化存储空间</td><td>使用 MFT（主文件表）存储文件及其属性，支持复杂属性（如 ACL 权限）</td><td>通过延迟分配减少碎片，但仍需定期碎片整理</td><td>随机读写性能较高，适合桌面和企业级应用</td><td>支持元数据日志，能恢复文件系统结构，防止崩溃数据丢失</td><td>支持文件压缩、加密（EFS）、权限控制等，适合 Windows 系统</td></tr><tr><td><strong>ext4</strong></td><td>使用多级索引表（类似树结构）管理数据块，支持高效的文件存储</td><td>使用 inode 表存储文件和属性，支持文件权限、软硬链接等</td><td>通过延迟分配和预分配减少碎片化，效率较高</td><td>支持顺序和随机读写，适合小文件和大文件的访问</td><td>提供日志功能，确保系统崩溃后不丢失文件元数据</td><td>支持硬链接、软链接、日志功能，适用于 Linux 系统</td></tr><tr><td><strong>XFS</strong></td><td>延迟分配技术，优化数据块分配以减少碎片化</td><td>使用索引节点管理元数据，支持并发访问和高性能读写</td><td>延迟分配技术避免碎片化，适合大文件存储</td><td>对大文件和并发访问优化，适合高负载、高性能需求的环境</td><td>支持元数据日志，确保高可靠性，防止数据丢失</td><td>适合处理大文件和高负载，广泛用于高性能服务器环境</td></tr><tr><td><strong>APFS</strong></td><td>基于 CoW（Copy-on-Write）技术，避免直接覆盖数据，优化 SSD 性能</td><td>支持元数据快照，适合 SSD 存储的快速读写</td><td>通过 CoW 技术避免碎片化，适合 SSD</td><td>快速随机读写，优化 SSD 性能</td><td>基于快照和加密功能，能恢复系统状态，防止数据丢失</td><td>支持 SSD 优化、快照、文件加密、文件克隆等，适合 macOS 环境</td></tr><tr><td><strong>ZFS</strong></td><td>使用块指针树结构管理数据块，支持多级镜像和校验</td><td>使用分层的数据结构存储元数据，支持元数据校验</td><td>CoW 技术避免碎片化，支持数据去重和压缩</td><td>高效的数据读取和写入，适合大数据量顺序访问和高并发环境</td><td>提供端到端数据校验，支持自修复功能，适合大规模存储和企业级应用</td><td>支持数据去重、快照、镜像、动态块分配等功能，适合云存储、企业备份等</td></tr></tbody></table><ul><li><strong>数据存储方式</strong>：描述文件系统如何组织和存储数据。文件系统使用不同的数据结构（如链表、B+树、块指针树等）来管理数据。</li><li><strong>元数据管理方式</strong>：解释文件系统如何管理文件的元数据（如文件名、权限、时间戳、文件大小等）。</li><li><strong>碎片管理机制</strong>：描述文件系统如何处理碎片化问题。碎片化会降低文件访问效率，一些文件系统通过延迟分配、预分配或 CoW 技术来减少碎片化。</li><li><strong>访问效率</strong>：比较文件系统在数据访问中的效率，尤其是随机访问和大文件的读写性能。</li><li><strong>数据保护与可靠性</strong>：描述文件系统如何保护数据不受损失，防止系统崩溃或断电导致的数据丢失。大多数现代文件系统支持日志记录和数据校验来提高可靠性。</li><li><strong>特性支持</strong>：列出了每种文件系统所支持的特性，如文件加密、压缩、权限管理、快照、去重等。</li></ul><h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><p>可以看到文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。</p><p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p><img src="https://s2.loli.net/2024/12/21/dqhFmucZUt9GaP3.png" alt="VFS" style="zoom:50%;" /><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p><strong>文件系统的挂载（Mounting）</strong> 是将存储设备或分区上的文件系统连接到操作系统的文件层次结构中的一个过程。挂载的目的是使得存储设备上的数据可以被操作系统访问和管理。（指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。）</p><p>Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 inux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。</p><blockquote><p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p></blockquote><p>如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p><blockquote><p>并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p></blockquote><h5 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h5><p>在现代操作系统中，文件系统以树状结构组织数据，这棵树的根节点称为“根目录”（<code>/</code>）。挂载就是将一个存储设备或分区的文件系统（如硬盘、SSD、U盘等）与操作系统的现有文件系统结构中的某个目录连接起来，使得该设备上的文件和目录可以像本地文件一样被访问。</p><h5 id="挂载过程："><a href="#挂载过程：" class="headerlink" title="挂载过程："></a><strong>挂载过程：</strong></h5><ol><li><strong>设备准备</strong>：首先，操作系统会识别并准备好存储设备（如硬盘、SSD、USB设备等）。</li><li><strong>挂载命令</strong>：系统管理员或用户使用挂载命令（在 Linux 中是 <code>mount</code>）指定要挂载的设备和目标目录。</li><li><strong>文件系统关联</strong>：文件系统将设备上的文件系统结构与操作系统文件树中的指定目录进行连接。这使得设备上的文件能够通过目标目录路径访问。</li></ol><blockquote><p>更具体的过程可以参考：<a href="https://blog.csdn.net/weixin_47763623/article/details/143710029">深入理解Linux文件系统的挂载过程_文件挂载-CSDN博客</a></p></blockquote><h5 id="挂载点的意义："><a href="#挂载点的意义：" class="headerlink" title="挂载点的意义："></a><strong>挂载点的意义：</strong></h5><p>挂载点是文件系统挂载的具体目录。在挂载完成后，存储设备的文件系统会表现得像是文件树的一部分，可以通过挂载点来访问设备上的数据。挂载点可以是任何空目录，而不仅仅是 <code>/mnt</code> 或 <code>/media</code>。</p><h3 id="文件系统的访问方法"><a href="#文件系统的访问方法" class="headerlink" title="文件系统的访问方法"></a>文件系统的访问方法</h3><h4 id="从磁盘读取文件"><a href="#从磁盘读取文件" class="headerlink" title="从磁盘读取文件"></a>从磁盘读取文件</h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 用户&#x2F;应用程序发起读取请求</strong></td><td>用户或应用程序通过系统调用（如 <code>open()</code> 和 <code>read()</code>）发起文件读取请求。</td></tr><tr><td><strong>2. 操作系统进行文件查找</strong></td><td>操作系统解析文件路径，查找文件的元数据（如 inode 或 MFT），确定文件的存储位置。</td></tr><tr><td><strong>3. 获取物理块地址</strong></td><td>操作系统根据文件的元数据找到文件数据的物理块位置。</td></tr><tr><td><strong>4. 调用块设备驱动程序</strong></td><td>操作系统将文件的数据块地址传递给磁盘设备驱动程序，驱动程序负责访问磁盘并读取数据块。</td></tr><tr><td><strong>5. 磁盘控制器读取数据</strong></td><td>磁盘控制器根据操作系统的请求，定位并读取物理磁盘上相应的扇区或块，传输数据到内存。</td></tr><tr><td><strong>6. 数据传输到内存</strong></td><td>磁盘控制器将读取的数据传输到内存缓存中，操作系统将数据保存到内存中，准备将其传递给应用程序。</td></tr><tr><td><strong>7. 文件数据返回给应用程序</strong></td><td>操作系统将数据从内存传输到用户空间，应用程序可以对文件数据进行处理。</td></tr><tr><td><strong>8. 缓存和优化</strong></td><td>操作系统和磁盘控制器可能会使用缓存机制（如页面缓存、硬盘缓存）来优化数据访问速度，减少磁盘访问次数。</td></tr></tbody></table><h4 id="写入磁盘"><a href="#写入磁盘" class="headerlink" title="写入磁盘"></a><strong>写入磁盘</strong></h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 用户&#x2F;应用程序发起写入请求</strong></td><td>用户或应用程序通过系统调用（如 <code>open()</code> 和 <code>write()</code>）发起写入请求，指定要写入的数据内容和目标文件。操作系统获取数据并准备写入磁盘。</td></tr><tr><td><strong>2. 操作系统检查文件描述符</strong></td><td>操作系统检查应用程序提供的文件描述符，确保文件已经被打开并且可以写入。如果文件是可写的，系统会继续处理；如果是只读文件，则会报错。</td></tr><tr><td><strong>3. 获取文件的物理存储位置</strong></td><td>操作系统查找文件的元数据（如 inode），确定文件的存储位置（磁盘上的数据块）。如果文件是新创建的，操作系统可能需要为文件分配新的磁盘块。</td></tr><tr><td><strong>4. 调用块设备驱动程序</strong></td><td>操作系统通过文件系统向块设备驱动程序发出写入请求，传递数据块的地址以及要写入的数据。设备驱动程序准备与磁盘或 SSD 进行交互，确保数据能正确写入。</td></tr><tr><td><strong>5. 数据写入磁盘控制器</strong></td><td>磁盘控制器收到写入请求后，将数据写入到磁盘的特定物理扇区或块中。如果是硬盘，磁头会移动到正确的位置；如果是 SSD，数据直接写入对应的闪存单元。</td></tr><tr><td><strong>6. 数据确认</strong></td><td>写入操作完成后，磁盘控制器向操作系统确认数据已经成功写入。数据也可能被缓存到内存中，以便未来的读取请求。</td></tr><tr><td><strong>7. 更新文件元数据</strong></td><td>操作系统更新文件的元数据（如 inode），以反映文件的最新状态（例如，更新文件大小、修改时间等）。如果数据被追加到文件末尾，操作系统也会更新文件的尾部地址。</td></tr><tr><td><strong>8. 应用程序收到写入结果</strong></td><td>操作系统返回写入操作的结果（如成功或失败），并可能将写入的数据缓存到内存中，以便在后续操作中提高性能。应用程序可以进行进一步处理或关闭文件。</td></tr><tr><td><strong>9. 缓存和优化</strong></td><td>操作系统可能会将写入的数据保留在内存中的缓存中，减少后续的磁盘写入次数，并在合适的时候将数据刷新到磁盘。磁盘控制器也可能使用其内部缓存进行写入操作优化。</td></tr></tbody></table><blockquote><ol><li>文件必须已经打开并且具有写权限。</li><li>操作系统通过文件描述符来标识文件，并管理文件的元数据和数据存储。</li><li>写入过程可能涉及数据缓存，以提高磁盘写入效率。</li></ol></blockquote><h3 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h3><p>和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</p><p>在目录文件的块中，最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p><p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。</p><p><img src="https://s2.loli.net/2024/12/21/2nDUmwNpIYa4yHP.png" alt="目录"></p><p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I&#x2F;O 操作，开销较大。所以，为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p><blockquote><p>这里对文件目录更深入了解可以参考：<a href="https://www.cnblogs.com/cxuanBlog/p/12565601.html">简直不要太硬了！一文带你彻底理解文件系统 - 程序员cxuan - 博客园</a></p><p><a href="https://www.cnblogs.com/wkfvawl/p/11847413.html#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">操作系统——文件系统概述、文件逻辑地址、目录、物理地址 - 王陸 - 博客园</a></p></blockquote><h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://s2.loli.net/2024/12/21/3JgNmYFdju81Xfo.png" alt="硬链接"></p><p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p><p><img src="https://s2.loli.net/2024/12/21/tNaVmgeKGuC5xdQ.png" alt="软链接"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符（<strong>File Descriptor</strong>，简称 <strong>FD</strong>）是操作系统层面上用于标识打开的文件的一个整数标识符。在操作系统中，文件描述符存在于用户空间和内核空间之间，通常是在 <strong>操作系统的内核层</strong> 中使用的。</p><h5 id="与文件描述符相关的层次和流程："><a href="#与文件描述符相关的层次和流程：" class="headerlink" title="与文件描述符相关的层次和流程："></a><strong>与文件描述符相关的层次和流程：</strong></h5><ol><li>用户空间<ul><li>在用户空间，应用程序通过标准库（如 <code>libc</code>）发起文件操作。库会通过系统调用（如 <code>open()</code>）请求操作系统打开文件。</li><li>应用程序通过文件描述符来与内核交互，使用它来进行文件读写（例如，使用 <code>read()</code>、<code>write()</code> 等函数）。</li></ul></li><li>内核空间<ul><li>操作系统内核使用文件描述符来标识进程打开的文件，并维护与文件相关的状态信息。这些信息通常存储在 <strong>文件表</strong> 中。</li><li>当进程发起文件操作时，内核根据文件描述符查找文件表中的条目，找到文件的元数据并执行实际的文件I&#x2F;O操作。</li><li>每个进程都有一个与之关联的<strong>文件描述符表</strong>，它存储了该进程打开的所有文件的文件描述符以及与这些文件相关的内核信息。</li></ul></li></ol><h1 id="文件共享和文件保护"><a href="#文件共享和文件保护" class="headerlink" title="文件共享和文件保护"></a>文件共享和文件保护</h1><p>具体参考：<a href="https://blog.csdn.net/Qmilumilu/article/details/114558347">【操作系统】4.4文件管理（文件共享、文件保护、文件系统层次结构）_文件共享盘管理制度csdn-CSDN博客</a></p><p><a href="https://blog.csdn.net/swadian2008/article/details/131695918">操作系统16：文件共享和文件保护_文件共享 操作系统-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45962068/article/details/120948304">文件管理之文件共享与文件保护_共享文件管理-CSDN博客</a></p><h1 id="磁盘存储器的管理-文件的物理结构"><a href="#磁盘存储器的管理-文件的物理结构" class="headerlink" title="磁盘存储器的管理(文件的物理结构)"></a>磁盘存储器的管理(文件的物理结构)</h1><p>具体参考：<a href="https://www.cnblogs.com/linfangnan/p/15139136.html">操作系统：磁盘的组织和空间管理 - 乌漆WhiteMoon - 博客园</a></p><p><a href="https://geekdaxue.co/read/7hao@juangou/vqt1u6qonc0gt8gz">计算机操作系统 - 第八章：磁盘存储器的管理 - 《计算机专业课笔记》 - 极客文档</a></p><p><a href="https://blog.csdn.net/m0_50833438/article/details/115151317">【操作系统】第八章-磁盘存储器的管理_增量式索引组织方式-CSDN博客</a></p><blockquote><p>外存的组织方式，文件存储空间的管理</p></blockquote><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://zhuanlan.zhihu.com/p/404423676">计算机组成原理笔记-IO接口与设备 - 知乎</a></p><p><a href="https://www.cnblogs.com/cxuanBlog/p/12565601.html">简直不要太硬了！一文带你彻底理解文件系统 - 程序员cxuan - 博客园</a></p><p><a href="https://www.cnblogs.com/cangqinglang/p/12170828.html">什么是挂载，Linux挂载如何实现详解 - 苍青浪 - 博客园</a></p><p><a href="https://www.cnblogs.com/wkfvawl/p/11847413.html">操作系统——文件系统概述、文件逻辑地址、目录、物理地址 - 王陸 - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/535265977">操作系统–文件和文件系统 - 知乎</a></p><p><a href="https://blog.csdn.net/m0_67656158/article/details/144544055">【操作系统】一篇带你彻底搞定文件系统-CSDN博客</a></p><p><a href="https://www.cnblogs.com/wkfvawl/p/11847413.html#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">操作系统——文件系统概述、文件逻辑地址、目录、物理地址 - 王陸 - 博客园</a></p><p><a href="https://www.cnblogs.com/JinyuLi/p/17611239.html">复习笔记|第五章 文件系统《操作系统原理教程》 - LateSpring - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发与线程</title>
    <link href="/2023/01/18/%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/01/18/%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文仅是最近写并发程序时感到对其知识框架不成体系，故总结如下。一些更细节的我已经知道的内容并没有过多解读。</p></blockquote><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>在<a href="https://wangxiaobai08.github.io/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/">CPU虚拟化与进程 - The Peak Tower</a>和<a href="https://wangxiaobai08.github.io/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理 - The Peak Tower</a>两篇文章中我们已经看到了操作系统提供的基本抽象的发展；也看到了如何将一个物理CPU变成多个虚拟CPU（virtual CPU），从而支持多个程序同时运行的假象；还看到了如何为每个进程创建巨大的、私有的虚拟内存（virtual memory）的假象，这种地址空间（address space）的抽象让每个程序好像拥有自己的内存，而实际上操作系统秘密地让多个地址空间复用物理内存（或者磁盘）。这些都是并发执行的基础</p><p><strong>并发</strong>（Concurrency）指的是多个任务或进程在同一时间段内交替执行的能力。并发并不要求这些任务或进程同时执行，而是它们的执行在时间上重叠。并发的核心在于任务的管理和调度，即使只有一个CPU核心，也能通过快速切换任务来模拟多个任务同时进行。</p><blockquote><p>注意：</p><p><strong>并行</strong>（Parallelism）是指任务<strong>真正同时执行</strong>，通常是在多核或多处理器的系统中实现的。</p><p><strong>并发</strong>则指任务之间<strong>交替执行</strong>，不一定是同时进行的，但它们会在时间上交错执行。</p></blockquote><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在单个进程中，线程是提供的新抽象，每个线程有自己的程序计数器和寄存器。多线程程序具有多个执行点，每个线程独立运行，但共享进程的地址空间，从而能够访问相同的数据。线程的状态与进程状态类似，每个线程有自己的栈，但它们共享进程的地址空间，因此地址空间在上下文切换时不变。</p><ul><li><strong>进程 vs 线程</strong>：进程有独立的地址空间，线程共享进程的地址空间。</li><li><strong>上下文切换</strong>：线程之间的上下文切换类似于进程间切换，但不需要切换页表，因为它们共享地址空间。</li></ul><blockquote><p>线程之间的上下文切换类似于进程间的上下文切换。对于进程，我们将状态保存到进程控制块（Process Control Block，PCB）。现在，我们需要一个或多个线程控制块（Thread Control Block，TCB），保存每个线程的状态。</p></blockquote><ul><li><strong>栈</strong>：每个线程有自己的栈，而不是像单线程进程那样只有一个栈。栈存储了线程的局部变量、参数和返回值。</li></ul><p><img src="https://s2.loli.net/2024/12/23/F3lWdt4NzwovkPM.png" alt="单线程和多线程的地址空间"></p><blockquote><p>可以看到两个栈跨越了进程的地址空间。因此，所有位于栈上的变量、参数、返回值和其他放在栈上的东西，将被放置在有时称为线程本地（thread-local）存储的地方，即相关线程的栈。</p></blockquote><p>总结：线程是进程内的独立执行单元，通过共享地址空间实现轻量级的并发执行，每个线程有自己的栈和执行状态。</p><blockquote><p>正因如此有了那句金典：进程是资源分配的最小单位，线程是进程中的执行最小单元。</p></blockquote><p>以下是进程和线程的对比：</p><table><thead><tr><th>特性</th><th><strong>进程</strong></th><th><strong>线程</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>操作系统分配资源的基本单位，拥有独立的地址空间。</td><td>进程内部的执行单位，共享进程的资源和地址空间。</td></tr><tr><td><strong>资源分配</strong></td><td>每个进程拥有独立的资源，如内存、文件描述符等。</td><td>线程共享进程的资源，每个线程有自己的栈和寄存器。</td></tr><tr><td><strong>执行控制</strong></td><td>进程有独立的程序计数器和执行上下文。</td><td>每个线程有自己的程序计数器和栈，但共享进程内存。</td></tr><tr><td><strong>上下文切换</strong></td><td>上下文切换开销较大，需要保存和恢复完整的进程状态。</td><td>上下文切换开销小，只需保存和恢复线程的状态。</td></tr><tr><td><strong>创建与销毁</strong></td><td>进程创建和销毁开销较大，需要分配独立的资源。</td><td>线程创建和销毁开销较小，资源分配较轻量。</td></tr><tr><td><strong>通信方式</strong></td><td>进程间通信（IPC）复杂，通常通过管道、消息队列等。</td><td>线程间通信简单，直接访问共享内存。</td></tr><tr><td><strong>并发与并行</strong></td><td>可并发或并行执行，取决于CPU核数。</td><td>可并发执行（单核）或并行执行（多核）。</td></tr><tr><td><strong>内存隔离</strong></td><td>进程间内存相互独立，无法直接访问其他进程的内存。</td><td>线程共享进程的地址空间，直接访问共享数据。</td></tr><tr><td><strong>调度单位</strong></td><td>操作系统调度的基本单位。</td><td>进程内部的执行单元，由操作系统调度。</td></tr></tbody></table><hr><h2 id="线程间的执行顺序不确定"><a href="#线程间的执行顺序不确定" class="headerlink" title="线程间的执行顺序不确定"></a>线程间的执行顺序不确定</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">2</span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-number">3</span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mythread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br><span class="hljs-number">6</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, (<span class="hljs-type">char</span> *) arg);<br><span class="hljs-number">7</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">8</span>    &#125;<br><span class="hljs-number">9</span><br><span class="hljs-number">10</span>   <span class="hljs-type">int</span><br><span class="hljs-number">11</span>   <span class="hljs-built_in">main</span>(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[]) &#123;<br><span class="hljs-number">12</span>       <span class="hljs-type">pthread_t</span> p1, p2;<br><span class="hljs-number">13</span>       <span class="hljs-type">int</span> rc;<br><span class="hljs-number">14</span>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main: begin\n&quot;</span>);<br><span class="hljs-number">15</span>       rc = <span class="hljs-built_in">pthread_create</span>(&amp;p1, <span class="hljs-literal">NULL</span>, mythread, <span class="hljs-string">&quot;A&quot;</span>); <span class="hljs-built_in">assert</span>(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">16</span>       rc = <span class="hljs-built_in">pthread_create</span>(&amp;p2, <span class="hljs-literal">NULL</span>, mythread, <span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-built_in">assert</span>(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">17</span>       <span class="hljs-comment">// join waits for the threads to finish</span><br><span class="hljs-number">18</span>       rc = <span class="hljs-built_in">pthread_join</span>(p1, <span class="hljs-literal">NULL</span>); <span class="hljs-built_in">assert</span>(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">19</span>       rc = <span class="hljs-built_in">pthread_join</span>(p2, <span class="hljs-literal">NULL</span>); <span class="hljs-built_in">assert</span>(rc == <span class="hljs-number">0</span>);<br><span class="hljs-number">20</span>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main: end\n&quot;</span>);<br><span class="hljs-number">21</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">22</span>   &#125;<br></code></pre></td></tr></table></figure><p>可能的结果1：</p><img src="https://s2.loli.net/2024/12/23/BVOUPQqXxFdGeYI.png" alt="结果1" style="zoom:50%;" /><p>可能的结果2：</p><p><img src="https://s2.loli.net/2024/12/23/WNj2J1ZpoDUz8Va.png" alt="image-20241223120116496"></p><p>可能的结果3：</p><p><img src="https://s2.loli.net/2024/12/23/apDMsu3cQmYLtn7.png" alt="结果3"></p><p>可以看到<strong>给定一系列指令，有很多可能的顺序，这取决于操作系统会在多个线程之间切换执行（上下文切换），这些切换的时机和顺序是不可控的，因此线程的最终运行结果可能会因调度顺序的不同而产生差异。线程调度是由操作系统的调度器（Scheduler）控制的，调度器决定了哪些线程在何时运行。由于调度的策略和时机往往不可预测，多个线程的执行顺序也无法预知，因此会导致线程执行的结果不确定。</strong></p><h2 id="竞争条件-共享资源"><a href="#竞争条件-共享资源" class="headerlink" title="竞争条件(共享资源)"></a>竞争条件(共享资源)</h2><blockquote><p>竞争条件是指多个线程在并发执行时，试图访问共享资源（如变量、内存等）并且至少有一个线程试图修改该资源。如果多个线程在没有适当同步的情况下同时访问同一资源，就会导致不可预测的结果。例如，两个线程同时对一个全局变量进行加法运算，可能会出现一个线程的操作被另一个线程覆盖，导致最终结果不正确。</p></blockquote><p>在上一节中的<strong>线程间的执行顺序不确定</strong>中可以看到线程执行的结果不确定，而对于多线程的操作共享资源是灾难性的。这种不可控的调度使得程序肯不按所预期进行运行。比如：</p><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">2</span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-number">3</span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mythreads.h&quot;</span></span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span>    <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-number">6</span><br><span class="hljs-number">7</span>    <span class="hljs-comment">//</span><br><span class="hljs-number">8</span>    <span class="hljs-comment">// mythread()</span><br><span class="hljs-number">9</span>    <span class="hljs-comment">//</span><br><span class="hljs-number">10</span>   <span class="hljs-comment">// Simply adds 1 to counter repeatedly, in a loop</span><br><span class="hljs-number">11</span>   <span class="hljs-comment">// No, this is not how you would add 10,000,000 to</span><br><span class="hljs-number">12</span>   <span class="hljs-comment">// a counter, but it shows the problem nicely.</span><br><span class="hljs-number">13</span>   <span class="hljs-comment">//</span><br><span class="hljs-number">14</span>   <span class="hljs-type">void</span> *<br><span class="hljs-number">15</span>   <span class="hljs-built_in">mythread</span>(<span class="hljs-type">void</span> *arg)<br><span class="hljs-number">16</span>   &#123;<br><span class="hljs-number">17</span>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: begin\n&quot;</span>, (<span class="hljs-type">char</span> *) arg);<br><span class="hljs-number">18</span>       <span class="hljs-type">int</span> i;<br><span class="hljs-number">19</span>       <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e7</span>; i++) &#123;<br><span class="hljs-number">20</span>           counter = counter + <span class="hljs-number">1</span>;<br><span class="hljs-number">21</span>       &#125;<br><span class="hljs-number">22</span>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: done\n&quot;</span>, (<span class="hljs-type">char</span> *) arg);<br><span class="hljs-number">23</span>       <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">24</span>   &#125;<br><span class="hljs-number">25</span><br><span class="hljs-number">26</span>   <span class="hljs-comment">//</span><br><span class="hljs-number">27</span>   <span class="hljs-comment">// main()</span><br><span class="hljs-number">28</span>   <span class="hljs-comment">//</span><br><span class="hljs-number">29</span>   <span class="hljs-comment">// Just launches two threads (pthread_create)</span><br><span class="hljs-number">30</span>   <span class="hljs-comment">// and then waits for them (pthread_join)</span><br><span class="hljs-number">31</span>   <span class="hljs-comment">//</span><br><span class="hljs-number">32</span>   <span class="hljs-type">int</span><br><span class="hljs-number">33</span>   <span class="hljs-built_in">main</span>(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])<br><span class="hljs-number">34</span>   &#123;<br><span class="hljs-number">35</span>       <span class="hljs-type">pthread_t</span> p1, p2;<br><span class="hljs-number">36</span>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main: begin (counter = %d)\n&quot;</span>, counter);<br><span class="hljs-number">37</span>       <span class="hljs-built_in">Pthread_create</span>(&amp;p1, <span class="hljs-literal">NULL</span>, mythread, <span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-number">38</span>       <span class="hljs-built_in">Pthread_create</span>(&amp;p2, <span class="hljs-literal">NULL</span>, mythread, <span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-number">39</span><br><span class="hljs-number">40</span>       <span class="hljs-comment">// join waits for the threads to finish</span><br><span class="hljs-number">41</span>       <span class="hljs-built_in">Pthread_join</span>(p1, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">42</span>       <span class="hljs-built_in">Pthread_join</span>(p2, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">43</span>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main: done with both (counter = %d)\n&quot;</span>, counter);<br><span class="hljs-number">44</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">45</span>   &#125;<br></code></pre></td></tr></table></figure><p>可以看看每个工作线程正在尝试做什么：向共享变量计数器添加一个数字，并在循环中执行1000万（107）次。因此，预期的最终结果是：20000000。但每次运行的结果却不同。其更底层原因比如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">mov   <span class="hljs-number">0x8049a1c</span>, %eax<br>add   $0x1, %eax<br>mov   %eax, <span class="hljs-number">0x8049a1c</span><br></code></pre></td></tr></table></figure><p>这个例子假定，变量counter位于地址0x8049a1c。在这3条指令中，先用x86的mov指令，从内存地址处取出值，放入eax。然后，给eax寄存器的值加1（0x1）。最后，eax的值被存回内存中相同的地址。设想我们的两个线程之一（线程1）进入这个代码区域，并且因此将要增加一个计数器。它将counter的值（假设它这时是50）加载到它的寄存器eax中。因此，线程1的eax &#x3D; 50。然后它向寄存器加1，因此eax &#x3D; 51。现在，一件不幸的事情发生了：时钟中断发生。因此，操作系统将当前正在运行的线程（它的程序计数器、寄存器，包括eax等）的状态保存到线程的TCB。现在更糟的事发生了：线程2被选中运行，并进入同一段代码。它也执行了第一条指令，获取计数器的值并将其放入其eax中 [请记住：运行时每个线程都有自己的专用寄存器。上下文切换代码将寄存器虚拟化（virtualized），保存并恢复它们的值]。此时counter的值仍为50，因此线程2的eax &#x3D; 50。假设线程2执行接下来的两条指令，将eax递增1（因此eax &#x3D; 51），然后将eax的内容保存到counter（地址0x8049a1c）中。因此，全局变量counter现在的值是51。最后，又发生一次上下文切换，线程1恢复运行。还记得它已经执行过mov和add指令，现在准备执行最后一条mov指令。回忆一下，eax&#x3D;51。因此，最后的mov指令执行，将值保存到内存，counter再次被设置为51。简单来说，发生的情况是：增加counter的代码被执行两次，初始值为50，但是结果为51。这个程序的“正确”版本应该导致变量counter等于52。</p><p><img src="https://s2.loli.net/2024/12/23/YvG1niM2BWzHjd4.png" alt="image-20241223121845217"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://s2.loli.net/2024/12/23/Jsru6kzE9QHLFi2.png" alt="死锁"></p><p>无论是<strong>进程</strong>和<strong>线程</strong>都可能会遇到<strong>死锁</strong>状态。死锁是指两个或多个进程&#x2F;线程因相互等待资源而导致永远无法继续执行的情况。</p><h3 id="进程死锁："><a href="#进程死锁：" class="headerlink" title="进程死锁："></a>进程死锁：</h3><p>进程死锁发生在多个进程之间，它们持有一部分资源，并等待其他进程释放他们所需的资源，从而形成一种循环等待状态。常见的死锁发生场景包括：</p><ol><li><strong>互斥条件</strong>：资源不能被多个进程共享，每个资源一次只能被一个进程占用。</li><li><strong>占有并等待</strong>：进程持有至少一个资源，并等待获取其他资源。</li><li><strong>不可抢占</strong>：资源一旦分配给某个进程，不能强制从它那里抢占，只能由进程自己释放。</li><li><strong>循环等待</strong>：存在一种进程链，链中的每个进程都在等待下一个进程占用的资源。</li></ol><p>例如，两个进程分别持有资源A和资源B，进程1等待资源B，进程2等待资源A，这样就形成了死锁。</p><h3 id="线程死锁："><a href="#线程死锁：" class="headerlink" title="线程死锁："></a>线程死锁：</h3><p>线程死锁通常发生在同一进程内的多个线程之间。线程之间也可能因为互相等待锁资源而导致死锁。例如，两个线程分别持有锁A和锁B，线程1等待锁B，线程2等待锁A，最终两者都无法继续执行，形成死锁。</p><p>线程死锁的条件和进程死锁类似，也包含：</p><ul><li>互斥：每个锁一次只能被一个线程持有。</li><li>占有并等待：线程持有一个锁，并等待另一个锁。</li><li>不可抢占：锁不能被其他线程强行抢占。</li><li>循环等待：存在一种循环的等待关系。</li></ul><h1 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h1><p>在上述两章的介绍，要解决的的怎么确保并发程序结果正确并不会发生死锁状态？</p><p>先了解一些名词：</p><table><thead><tr><th><strong>概念</strong></th><th><strong>定义</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>临界区</strong></td><td>临界区是指多个线程或进程在执行时，共享资源的那一部分代码区域。</td><td>在多线程或多进程环境中，临界区是访问共享资源（如全局变量、文件等）的代码区域。为了避免竞态条件，必须确保一次只有一个线程或进程能够进入临界区。</td></tr><tr><td><strong>竞态条件</strong></td><td>竞态条件指多个线程&#x2F;进程在并发执行时，试图同时访问共享资源，且至少有一个线程&#x2F;进程会修改该资源，导致程序的行为不可预期。</td><td>竞态条件的发生是因为缺乏同步机制，多个线程&#x2F;进程同时访问并修改共享数据，导致最终的结果不一致或错误。</td></tr><tr><td><strong>不确定性</strong></td><td>不确定性是指由于竞态条件或没有正确同步导致的程序执行结果无法预测。</td><td>不确定性表现为程序执行的结果依赖于线程调度的顺序或其他并发执行的不可控因素，因此同一输入的程序可能会有不同的输出。</td></tr><tr><td><strong>互斥执行</strong></td><td>互斥执行是指对共享资源的访问必须是互斥的，确保同一时刻只有一个线程或进程能够访问该资源。</td><td>互斥执行通常通过锁（如互斥锁、信号量等）来保证，以防止多个线程同时访问临界区或共享资源，避免竞态条件和数据不一致。</td></tr></tbody></table><h2 id="常见的同步机制"><a href="#常见的同步机制" class="headerlink" title="常见的同步机制"></a>常见的同步机制</h2><p>常见的并发同步机制主要用于解决多个线程或进程并发访问共享资源时引发的问题</p><table><thead><tr><th><strong>同步机制</strong></th><th><strong>定义</strong></th><th><strong>应用场景</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>互斥锁 (Mutex)</strong></td><td>用于保证同一时刻只有一个线程能够访问临界区，其他线程必须等待该线程释放锁后才能继续执行。</td><td>- 用于保护共享资源。 - 确保数据一致性。</td><td><strong>优点</strong>：简单易用，确保互斥访问。 <strong>缺点</strong>：可能导致死锁、性能瓶颈。</td></tr><tr><td><strong>读写锁 (Read-Write Lock)</strong></td><td>允许多个线程并发读取共享资源，但只有一个线程可以写入共享资源。在没有写入操作时，多个线程可以同时读取。</td><td>- 适用于读操作远多于写操作的场景。 - 用于减少读取时的阻塞。</td><td><strong>优点</strong>：提高并发性，适合读多写少的场景。 <strong>缺点</strong>：写操作需要独占锁，可能导致写入延迟。</td></tr><tr><td><strong>信号量 (Semaphore)</strong></td><td>用于控制对共享资源的访问数量，允许多个线程在同一时刻访问共享资源，但限制并发访问的最大数量。</td><td>- 限制资源访问数量，如数据库连接池、线程池等。</td><td><strong>优点</strong>：控制资源的并发访问。 <strong>缺点</strong>：需要额外的信号量计数管理，容易导致资源浪费或死锁。</td></tr><tr><td><strong>条件变量 (Condition Variable)</strong></td><td>用于线程间的通信，允许一个线程在特定条件满足时唤醒一个或多个线程。常与互斥锁配合使用。</td><td>- 线程之间的协调。 - 用于解决生产者-消费者问题。</td><td><strong>优点</strong>：灵活，适用于复杂的线程间同步。 <strong>缺点</strong>：必须与锁配合使用，编程较为复杂。</td></tr><tr><td><strong>自旋锁 (Spinlock)</strong></td><td>线程在获取锁失败时，不会被挂起，而是会不断地循环检查锁的状态，直到获取锁为止。</td><td>- 适用于锁持有时间非常短的场景。 - 防止线程上下文切换带来的开销。</td><td><strong>优点</strong>：避免了线程上下文切换的开销。 <strong>缺点</strong>：如果锁竞争激烈，可能导致CPU资源浪费。</td></tr><tr><td><strong>屏障 (Barrier)</strong></td><td>使得多个线程在某一位置等待，直到所有线程都到达这个位置才继续执行。</td><td>- 适用于并行计算中的同步点，如多个线程完成各自任务后再汇总结果。</td><td><strong>优点</strong>：适合并行计算的同步需求。 <strong>缺点</strong>：阻塞所有线程，可能导致性能下降。</td></tr><tr><td><strong>事件 (Event)</strong></td><td>用于线程间的信号传递，一个线程可以等待事件的发生，另一个线程可以触发该事件。</td><td>- 用于线程之间的协调，特别是线程间的通知机制。</td><td><strong>优点</strong>：灵活，适用于多线程通知机制。 <strong>缺点</strong>：在某些情况下可能导致线程被不必要地阻塞。</td></tr></tbody></table><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p>操作系统导论 - 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔 </p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2023/01/15/%E9%80%92%E5%BD%92/"/>
    <url>/2023/01/15/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<img src="https://s2.loli.net/2024/12/24/NiBvQkE1nFwILxV.png" alt="1" style="zoom:50%;" /><p>关于递归的思想<a href="https://blog.csdn.net/weixin_44572229/article/details/119909728">递归详解——让你真正明白递归的含义-CSDN博客</a>这篇文章讲的比较透彻，遇到问题，首先思考：</p><p><strong>问题本身是否可以通过层层拆解到最小粒度来得解。</strong></p><p>如何化大为小？能否找到当前的问题和子问题的关系关联？</p><p>然后程序的主要思想归纳起来就是：</p><ol><li><strong>明确你这个函数想要干什么</strong></li></ol><blockquote><p>高度抽象+返回类型和参数(即我们暂时不管这个函数是怎么实现的，先下定义即可)，在递归中就视为顺序执行，逻辑通顺即可</p><p>就像学霸一样，看似什么都没做，其实人家早就做好了</p></blockquote><ol><li><strong>寻找递归结束条件</strong></li></ol><blockquote><p>视情况分析,最小子问题—-&gt;是指递和归的转折点，应当和归过程视为一起</p></blockquote><ol><li><strong>找出函数的等价关系式</strong>【比如：f(n) &#x3D; n * f(n-1)。】</li></ol><blockquote><p>归的的节点—&gt;视为回调函数</p></blockquote><p>递归与迭代的区别？</p><img src="https://s2.loli.net/2024/12/24/3rJyi25mnIRlwX8.png" alt="2" style="zoom:50%;" /><p>接下来，直接上案例：</p><h1 id="21-合并两个有序链表-力扣（LeetCode）"><a href="#21-合并两个有序链表-力扣（LeetCode）" class="headerlink" title="21. 合并两个有序链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=problem-list-v2&envId=recursion">21. 合并两个有序链表 - 力扣（LeetCode）</a></h1><p>题目描述：将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><blockquote><p>思考：新的 <strong>升序</strong> 链表是不断由小的<strong>升序</strong> 链表合并而来</p><p>1.链表的关键在于寻找下一个节点，故这个函数的目的就是寻找当前节点的下一个节点</p><p>2.结束条件就是节点的值为null</p><p>3.函数关系：</p><p>3.1 a(n)&#x3D;min(a(n-1)+b(n))</p><p>3.2 b(n)&#x3D;min(b(n-1)+a(n))</p></blockquote><p><img src="https://s2.loli.net/2024/12/28/pFhnmHJbKc9ESwu.png" alt="image-20241228210323189"></p><h1 id="231-2-的幂-力扣（LeetCode）"><a href="#231-2-的幂-力扣（LeetCode）" class="headerlink" title="231. 2 的幂 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/power-of-two/description/?envType=problem-list-v2&envId=recursion">231. 2 的幂 - 力扣（LeetCode）</a></h1><p>题目描述：给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>x</code> 使得 <code>n == 2x</code> ，则认为 <code>n</code> 是 2 的幂次方。</p><blockquote><p>思考：当前n&#x3D;&#x3D; 2x是由n&#x2F;2是否是 2 的幂次方的结果得来的</p><p>1.判断n能否除以2</p><p>2.在归的过程就可以判断是否并返回</p><p>3.f(n)&#x3D;&#x3D;f(n)&#x2F;2 ?</p></blockquote><p><img src="https://s2.loli.net/2024/12/28/1YUvheKMHtlzToP.png" alt="image-20241228211711381"></p><p>当然这题有更好的解法：位运行。但因为本章主要总结递归算法，故不多介绍，切勿拿了锤子，看啥都是钉子的思想。</p><h1 id="390-消除游戏-力扣（LeetCode）"><a href="#390-消除游戏-力扣（LeetCode）" class="headerlink" title="390. 消除游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/elimination-game/description/?envType=problem-list-v2&envId=recursion">390. 消除游戏 - 力扣（LeetCode）</a></h1><p>题目描述：列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p><ul><li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li><li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li><li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li></ul><p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p><blockquote><p>提示：当前的问题和子问题中序列下标的映射关系。(就是找规律)</p><p>思考：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]<br>arr = [2, 4, 6, 8]<br>arr = [2, 6]<br>arr = [6]<br></code></pre></td></tr></table></figure><p>从解释中就可以看到：大列表的结果是由处理后的小列表决定的。我们要做的就是找到：1.怎么处理的？——&gt;整体处理过程</p><p>2.处理后的小列表与大列表的关系(规律)？—–&gt;大小问题关系的编写</p><p>1.函数目的：找到列表中的最后一个元素</p><p>2.返回条件：n&#x3D;&#x3D;1—-&gt;最小子问题</p><p>3.关系：</p><p>先找规律：</p><p>1：左到右 操作的情况 :<br>操作前 : 1,2,3,4,5… (序列 0)<br>操作后 : 2,4,6,… (序列 1)<br>可以发现操作后的序列可以看成是 : 2 * (1,2,3… (序列 2) )</p><p>2.右到左 操作的情况：<br>因为当序列长度为 奇数 和 偶数的情况 , 会对开头的 1 是否删除有影响 , 那么我们分类讨论 ：</p><p>2.1当 n 为奇数时 (以 n 等于 7 为例进行说明) :<br>原序列 : 1 2 3 4 5 6 7 (序列 0)<br>操作后 : 2 4 6 (序列 1)<br>那么接下去的一步 , 对 (序列 1) 的操作同样可以转为 对 (序列 2) 的操作 , 选出的数字 * 2 即可 ((序列 2) &#x3D; {1，2，3})<br>2.2当 n 为偶数时 (以 n 等于 8 为例进行说明) :<br>原序列 : 1 2 3 4 5 6 7 8 (序列 0)<br>操作后 : 1 3 5 7 (序列 1)<br>那么接下去的一步 , 对 (序列 1) 的操作同样可以转为 对 (序列 2) 的操作 , 选出的数字 * 2 - 1 即可 ((序列 2) &#x3D; {1，2，3，4})</p><p>从左到右：f(n)&#x3D;2*f(n&#x2F;2)</p><p>从右到左:  </p><p>奇数：f(n)&#x3D;2*f(n&#x2F;2)</p><p>偶数：f(n)&#x3D;2*f(n&#x2F;2)-1</p></blockquote><p>编写代码过程中发现，整体处理过程第一个是从左到右，往后是从右到左，递归流程不好设置，可以把递归代码抽离出来(辅助函数)，初始在主函数里</p><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241228215814433.png" alt="image-20241228215814433"></p><h1 id="50-Pow-x-n-力扣（LeetCode）"><a href="#50-Pow-x-n-力扣（LeetCode）" class="headerlink" title="50. Pow(x, n) - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/powx-n/description/?envType=problem-list-v2&envId=recursion">50. Pow(x, n) - 力扣（LeetCode）</a></h1><p>题目描述：实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p><blockquote><p>思考： pow(<em>x</em>, <em>n</em>)&#x3D;pow(x,n-1)*x,明显的递归关系</p><p>注意：考虑n的正负和奇偶变化—&gt;进行统一</p><p>幂的正负： pow(2,-1)&#x3D;1.0&#x2F;pow(2,1)</p><p>奇数偶数：找规律，最好通过增删将奇数转化成类似偶数形式</p><p>1.分化辅助函数进行快速幂递归，主函数负责初始状态判断和初始化</p><p><em>x</em>→<em>x</em>2→<em>x</em>4→<em>x</em>8→<em>x</em>16→<em>x</em>32→<em>x</em>64</p><p>2.N&#x3D;&#x3D;0时返回，任意数的 0 次方均为 1</p><ol start="3"><li></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">y = <span class="hljs-built_in">quickMul</span>(x, N / <span class="hljs-number">2</span>);<br><span class="hljs-built_in">quickMul</span>(x, N )= (N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x);<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://s2.loli.net/2024/12/29/un7HibrTF4oN58a.png" alt="image-20241229195904885"></p><p>注意不同条件的转化统一</p><h1 id="234-回文链表-力扣（LeetCode）"><a href="#234-回文链表-力扣（LeetCode）" class="headerlink" title="234. 回文链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=problem-list-v2&envId=recursion">234. 回文链表 - 力扣（LeetCode）</a></h1><p>题目描述：给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表</p><p>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>这题一开始用快慢指针做的，但浏览了官方递归的解法，虽然递归不是最好的选择，但巧妙的体现了递归的思想。直接上官方代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ListNode* frontPointer;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recursivelyCheck</span><span class="hljs-params">(ListNode* currentNode)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (currentNode != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            frontPointer = frontPointer-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        frontPointer = head;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursivelyCheck</span>(head);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归为我们提供了一种优雅的方式来方向遍历节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">print_values_in_reverse</span>(<span class="hljs-params">ListNode head</span>)<br>    <span class="hljs-keyword">if</span> head is <span class="hljs-variable constant_">NOT</span> <span class="hljs-literal">null</span><br>        <span class="hljs-title function_">print_values_in_reverse</span>(head.<span class="hljs-property">next</span>)<br>        print head.<span class="hljs-property">val</span><br></code></pre></td></tr></table></figure><p>如果使用递归反向迭代节点，同时使用递归函数外的变量向前迭代，就可以判断链表是否为回文。更详细的解释就是：</p><p><code>recursivelyCheck</code> 函数是一个递归函数，用于检查链表是否是回文。</p><ol><li><strong>递归调用 <code>recursivelyCheck(currentNode-&gt;next)</code>：</strong><ul><li>递归调用的目标是逐个节点地从链表的尾部往头部比较，直到找到链表的终点（即 <code>currentNode == nullptr</code>）。这个递归调用实际上会遍历链表的所有节点，先遍历到链表的尾部，然后再从尾部开始返回，逐个节点地进行比较。</li></ul></li><li><strong><code>if (!recursivelyCheck(currentNode-&gt;next)) &#123; return false; &#125;</code> 的含义：</strong><ul><li>当递归到达链表的终点时，递归函数会返回 <code>true</code>，然后递归逐层返回到每个节点，并进行节点值的比较。</li><li>如果在某一层递归中，发现下一个节点的值不等于当前节点的值（通过 <code>currentNode-&gt;val != frontPointer-&gt;val</code> 进行比较），那么就意味着链表不是回文的。此时递归会返回 <code>false</code>，并且通过这一层的 <code>if (!recursivelyCheck(currentNode-&gt;next)) &#123; return false; &#125;</code> 语句将错误传递给上一层递归，最终返回 <code>false</code>。</li></ul></li><li><strong>为什么要使用递归的方式：</strong><ul><li>递归的方式确保了链表的尾部和头部能够逐一进行比较，因为每次递归会先“进入”到链表的尾部（即通过 <code>currentNode-&gt;next</code> 向前递归），然后再逐步返回到头部，在回程的过程中进行比较。通过这种方式可以巧妙地实现对链表的回文检查。</li></ul></li><li><strong><code>frontPointer</code> 的作用：</strong><ul><li><code>frontPointer</code> 是一个指向链表头部的指针，它在每次递归返回时向后移动（通过 <code>frontPointer = frontPointer-&gt;next</code>），这样就能够比较当前递归节点（<code>currentNode-&gt;val</code>）和链表头部节点的值。通过这种方式，链表的头部和尾部节点会一一进行比较。</li></ul></li></ol><p>可以看到利用了递归，先推(遍历)再归的过程中巧妙进行对比。</p><h1 id="143-重排链表-力扣（LeetCode）"><a href="#143-重排链表-力扣（LeetCode）" class="headerlink" title="143. 重排链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reorder-list/description/?envType=problem-list-v2&envId=recursion">143. 重排链表 - 力扣（LeetCode）</a></h1><p>题目描述：给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span><br></code></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">2</span> → …<br></code></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><blockquote><p>思考：只要是这种链表重新组合排列，基本都可以以大化小</p><p>1.函数返回当前节点的下一个节点</p><p>2.最小子问题，下一个节点为空</p><ol start="3"><li></li></ol><p>f(n)&#x3D;f(n-1)&#x2F;&#x2F;x 这是针对数组的做法，链表没有下标可用</p><p>类型想法的就是—&gt;遍历（就是效率太慢）</p></blockquote><p><img src="https://s2.loli.net/2024/12/29/yPDe4aBKdQNkOTw.png" alt="image-20241229210004550"></p><h1 id="22-括号生成-力扣（LeetCode）"><a href="#22-括号生成-力扣（LeetCode）" class="headerlink" title="22. 括号生成 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/generate-parentheses/solutions/192912/gua-hao-sheng-cheng-by-leetcode-solution/?envType=problem-list-v2&envId=backtracking">22. 括号生成 - 力扣（LeetCode）</a></h1><p>题目描述：数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span> </span>&#123;<br>        <span class="hljs-type">int</span> balance = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ++balance;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --balance;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> balance == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generate_all</span><span class="hljs-params">(string&amp; current, <span class="hljs-type">int</span> n, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == current.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(current)) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(current);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        current += <span class="hljs-string">&#x27;(&#x27;</span>;<br>        <span class="hljs-built_in">generate_all</span>(current, n, result);<br>        current.<span class="hljs-built_in">pop_back</span>();<br>        current += <span class="hljs-string">&#x27;)&#x27;</span>;<br>        <span class="hljs-built_in">generate_all</span>(current, n, result);<br>        current.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        string current;<br>        <span class="hljs-built_in">generate_all</span>(current, n * <span class="hljs-number">2</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>奇怪的是在generate_all中似乎顺序的递归了两次？这该如何理解这段核心代码：</p><p>首先尝试向 <code>current</code> 添加一个左括号 <code>&#39;(&#39;</code>：</p><ul><li>更新 <code>current</code> 为 <code>current + &#39;(&#39;</code>。</li><li>递归调用 <code>generate_all</code>，进入下一层递归。</li><li>递归返回后，通过 <code>pop_back</code> 撤销刚才的修改，回溯到上一状态。</li></ul><p>然后尝试向 <code>current</code> 添加一个右括号 <code>&#39;)&#39;</code>：</p><ul><li>同样，更新 <code>current</code> 为 <code>current + &#39;)&#39;</code>，进入递归。</li><li>递归返回后，再次通过 <code>pop_back</code> 撤销修改。</li></ul><p><strong>递归树分析</strong></p><p>递归生成的是一棵二叉树，每个节点表示当前 <code>current</code> 的状态，每次递归分别尝试添加 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code>：</p><ul><li><strong>根节点</strong>：<code>current = &quot;&quot;</code>（初始状态）。</li><li><strong>第一层</strong>：尝试加 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code>，即 <code>current = &quot;(&quot;</code> 或 <code>current = &quot;)&quot;</code>。</li><li><strong>第二层</strong>：继续尝试，每个分支再加 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code>。</li><li><strong>终止节点</strong>：当 <code>current.size() == n</code> 时，检查是否有效。</li></ul><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>通过 <code>pop_back()</code>，每次递归返回时，撤销最近一次的修改，恢复到上一状态，以便尝试另一分支。这种机制确保可以遍历所有可能的组合。</p><p><strong>整体递归流程</strong></p><p>举例：<code>n = 4</code>（长度为 4 的括号组合）</p><ol><li><p>初始：<code>current = &quot;&quot;</code></p></li><li><p>加 ‘(‘：current &#x3D; “(“</p><p>继续递归，最终构造所有以 <code>&#39;(&#39;</code> 开头的组合。</p></li><li><p>回溯后加 ‘)’：current &#x3D; “)”</p><p>构造所有以 <code>&#39;)&#39;</code> 开头的组合。</p></li><li><p>每次到达长度 <code>n</code> 后检查有效性并返回结果。</p></li></ol><p>可用看到这样有出现了一个核心的算法思想：<strong>回溯</strong></p><p>回溯，向上推导。一个问题推导出多种可能，则选中其中一种可能继续推导。如果一条路到达尽头，则回到起点，选择另外的路径继续推导，直到所有可能被推导完毕。（另外的路径：含有与之前推导过的路径 不同的可能的路径）</p><p>如果知道深度优先搜索，回溯就好像每结束深搜中的一条路线，都会返回一个这条路线上的元素所组成的序列，当所有序列被 一 一 列出，回溯结束。</p><p>算法上回溯常被用递归来实现，我把它理解成“子状态不唯一的递归”（或者是“多分支的递归”）</p><p><img src="https://s2.loli.net/2024/12/29/6FaVk2rDcURt3Cn.png" alt="image-20241229212252975"></p><p>回溯有剪枝的功能：每次剪掉 (输出) 符合条件的树枝，当回溯结束时（若问题有序：当遇到不符合条件的树枝时停下，一种搜索过程的优化）我们就获得了所有符合条件的树枝 (答案)。<br>( 剪掉的部分是末端顶点到离它最近的一个有分叉的点)</p><p>这题的剪枝代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; ans, string&amp; cur, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (open &lt; n) &#123;<br>            cur.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">backtrack</span>(ans, cur, open + <span class="hljs-number">1</span>, close, n);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>            cur.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">backtrack</span>(ans, cur, open, close + <span class="hljs-number">1</span>, n);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        string current;<br>        <span class="hljs-built_in">backtrack</span>(result, current, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>可以看到：只在序列仍然保持有效时才添加 ‘(’ 或 ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，</p><p>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理【补充】</title>
    <link href="/2023/01/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91/"/>
    <url>/2023/01/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91/</url>
    
    <content type="html"><![CDATA[<hr><p>在<a href="https://wangxiaobai08.github.io/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">内存管理 - The Peak Tower</a>中主要讨论了离散分配式的管理方式，本篇是对内存管理的历史补充即：<strong>连续分配管理方式</strong></p><h1 id="什么是连续分配管理方式？"><a href="#什么是连续分配管理方式？" class="headerlink" title="什么是连续分配管理方式？"></a>什么是连续分配管理方式？</h1><p>连续分配存储管理方式（又称为连续分配内存管理）是一种内存管理策略，在这种方式下，操作系统将内存划分为一块或多块连续的区域，每个区域分配给一个作业或进程。每个进程在内存中占据一块连续的内存区域，操作系统通过管理这些区域来实现内存的分配和回收。</p><p>这种方式下，内存分配时，程序必须占用一段连续的内存空间，不允许在程序的内存空间中有空隙（即连续分配）。进程的起始地址和大小在内存中是已知的，通常通过基地址和长度来表示。</p><h1 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h1><p><strong>特点</strong>：</p><ul><li>内存被划分为系统区和用户区两部分。</li><li>系统区位于内存的低地址部分，存放操作系统相关的数据。</li><li>用户区则用于存放用户进程的相关数据。</li><li>用户区内存只分配给一个程序，内存中的用户空间完全由该程序独占。</li></ul><h2 id="优缺点分析："><a href="#优缺点分析：" class="headerlink" title="优缺点分析："></a><strong>优缺点分析</strong>：</h2><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>实现简单，结构非常直观。</td><td>只能用于单用户、单任务的操作系统。</td></tr><tr><td>无外部碎片。</td><td>存在内部碎片，可能造成存储器的浪费。</td></tr><tr><td>可以使用覆盖技术扩充内存。</td><td>存储器利用率低。</td></tr></tbody></table><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p><strong>优点</strong>：</p><ul><li><strong>实现简单</strong>：没有复杂的分配算法，整个内存空间的管理方式非常简单，只需要在系统区和用户区之间进行分配即可。</li><li><strong>无外部碎片</strong>：由于只有一个程序运行，程序能够在内存中完全占据一块连续的空间，因此不存在外部碎片的问题。</li><li><strong>可以采用覆盖技术扩充内存</strong>：当程序的实际内存需求超出物理内存时，可以使用覆盖技术，将不活跃的部分存储到外存中，释放内存空间，扩展程序的运行空间。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>单用户、单任务</strong>：这种方式无法支持多任务并发，适合早期的操作系统（如单任务的批处理系统），不适用于现代操作系统中对多用户、多任务的需求。</li><li><strong>内部碎片</strong>：由于内存只能分配给单一程序，如果程序实际占用的内存小于分配给它的内存区域，那么未使用的部分就会成为内部碎片。</li><li><strong>存储器利用率低</strong>：如果程序需要的内存小于系统分配的空间，剩余空间就浪费，导致内存使用效率低下。</li></ul><h1 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h1><p><strong>特点</strong>：</p><ul><li>内存被划分为若干个大小固定的分区，每个分区只能装入一个作业。</li><li>当有空闲分区时，可以将外存中的作业加载到空闲分区中运行。</li></ul><p><strong>分区方法</strong>：</p><ul><li><strong>分区大小相等</strong>：将内存划分为相同大小的多个分区，适用于处理多个大小相等的作业。</li><li><strong>分区大小不等</strong>：将内存划分为多个不同大小的分区，增加了灵活性，可以根据作业的需求进行选择。</li></ul><h2 id="优缺点分析：-1"><a href="#优缺点分析：-1" class="headerlink" title="优缺点分析："></a><strong>优缺点分析</strong>：</h2><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>实现简单，管理方便。</td><td>当程序需要的内存大于分区时，无法运行。</td></tr><tr><td>无外部碎片。</td><td>内部碎片较严重，分配空间中有浪费。</td></tr><tr><td>分区大小不等时，提供了灵活性。</td><td>覆盖技术需要大量使用时，性能会下降。</td></tr></tbody></table><h3 id="详细解释：-1"><a href="#详细解释：-1" class="headerlink" title="详细解释："></a>详细解释：</h3><p><strong>优点</strong>：</p><ul><li><strong>实现简单</strong>：固定分区分配方式实现起来较为简单，管理也较为方便。分区的数量和大小固定，内存分配管理基本上是静态的。</li><li><strong>无外部碎片</strong>：每个作业都被分配到一个固定大小的分区内，这样的分配方式避免了外部碎片的问题。</li><li><strong>分区大小不等时灵活性高</strong>：如果划分不同大小的分区，可以更加灵活地满足不同大小作业的需求，提高了内存利用效率。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>程序大于分区时无法运行</strong>：如果一个程序的内存需求大于分区的大小，即使内存有空闲也无法运行，限制了程序的灵活性。</li><li><strong>内部碎片严重</strong>：由于分区的大小是固定的，无法完全适配所有程序的内存需求，可能会造成程序占用的内存区域有大量未使用的部分，从而产生内部碎片。</li><li><strong>性能下降</strong>：如果程序大小不合适，需要通过覆盖技术来实现多任务或多程序管理，这样会影响性能，特别是频繁的覆盖操作会增加磁盘I&#x2F;O和内存管理的复杂度。</li></ul><h1 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h1><p>动态分区分配，又称为可变分区分配，是一种内存分配策略，其中内存中的每个分区根据进程的实际需求动态创建和调整。这意味着系统在分配内存时不会预先固定划分出每个分区的大小，而是根据进程的大小，在加载进程时动态地分配相应大小的内存区域。随着进程的加载和卸载，系统中的分区大小和数量会发生变化。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点</strong>：</h2><ol><li><strong>动态分配</strong>：内存中的分区大小不是固定的，而是根据进程的需求来动态分配。当进程需要内存时，操作系统会查找合适的空闲区域，并分配给进程，分配的内存大小恰好满足进程的需求。</li><li><strong>分区的可变性</strong>：随着进程的装入、运行和退出，内存的分区数量和大小会发生变化。每个进程占用的内存区域是连续的，但进程间的内存区域可以有不同的大小。</li><li><strong>内存利用率高</strong>：由于内存的分配是基于实际需求的，通常能够避免固定分区方法中出现的大量内部碎片，因此内存的利用率较高。</li></ol><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a><strong>数据结构</strong>：</h2><p><strong>空闲分区表</strong>：</p><ul><li>空闲分区表用于记录内存中当前所有空闲分区的起始地址和大小。当操作系统需要分配内存时，会查找空闲分区表，找到符合要求的空闲区域。</li><li>每当分配内存时，空闲分区表会更新，记录分配后剩余的空闲区域；当进程退出时，空闲分区表也会更新，重新添加回释放的内存区域。</li></ul><p><strong>空闲分区链</strong>：</p><ul><li>空闲分区链是另一种常见的数据结构，将所有空闲的内存区域通过链表连接起来。每个节点记录一个空闲区域的起始地址和大小。</li><li>操作系统根据空闲分区链中的信息来查找合适的空闲内存区域进行分配。这种链表结构可以更加灵活地管理内存，并减少空闲区域的碎片。</li></ul><p><img src="https://s2.loli.net/2025/01/03/sL7HSReaKdnUDmv.png" alt="33bd0e7c26324266a8f4a0f3ff981216"></p><h2 id="优缺点分析：-2"><a href="#优缺点分析：-2" class="headerlink" title="优缺点分析："></a><strong>优缺点分析</strong>：</h2><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>内存利用率高</strong>：动态分配内存，避免了固定分区大小带来的浪费。</td><td><strong>外部碎片</strong>：随着进程的加载和卸载，可能导致内存中出现多个小的空闲区域，无法满足较大进程的需求。</td></tr><tr><td><strong>灵活性强</strong>：可以根据不同进程的内存需求分配适当大小的内存。</td><td><strong>管理复杂</strong>：需要维护空闲分区表或链表，增加了内存管理的复杂性。</td></tr><tr><td><strong>减少内部碎片</strong>：由于分配的内存空间与进程需求匹配，避免了内部碎片。</td><td><strong>系统开销较大</strong>：频繁的内存分配和回收操作可能增加系统的开销。</td></tr></tbody></table><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><h3 id="基于顺序搜索的动态分区算法"><a href="#基于顺序搜索的动态分区算法" class="headerlink" title="基于顺序搜索的动态分区算法"></a>基于顺序搜索的动态分区算法</h3><h4 id="首次适应算法-FF"><a href="#首次适应算法-FF" class="headerlink" title="首次适应算法(FF)"></a>首次适应算法(FF)</h4><p><strong>首次适应算法</strong>从空闲内存列表的头开始，逐个检查空闲区，直到找到一个足够大的空闲区域。</p><p>一旦找到足够大的区域，分配给进程并停止查找，不再继续搜索剩余的空闲区域。</p><h4 id="循环首次适应算法-NF"><a href="#循环首次适应算法-NF" class="headerlink" title="循环首次适应算法(NF)"></a>循环首次适应算法(NF)</h4><p><strong>循环首次适应算法</strong>是首次适应算法的改进版，首先从空闲列表的头开始查找，但每次分配内存后，下次查找的位置会从上次分配的位置开始，而不是从头开始。</p><p>它使用一个指针标记上次分配的内存区域的末尾，下次查找时从这个位置继续。</p><h4 id="最佳适应算法-BF"><a href="#最佳适应算法-BF" class="headerlink" title="最佳适应算法(BF)"></a>最佳适应算法(BF)</h4><p><strong>最佳适应算法</strong>在查找空闲区时，不是选择第一个适合的区域，而是选择剩余空间最小、但仍能容纳进程的空闲区。这样可以最小化分配后剩余的空闲空间。</p><p>查找时会遍历整个空闲区域列表，找到适合的最小空闲区域进行分配。</p><h4 id="最坏适应算法-WF"><a href="#最坏适应算法-WF" class="headerlink" title="最坏适应算法(WF)"></a>最坏适应算法(WF)</h4><p><strong>最坏适应算法</strong>与最佳适应算法相反，它选择剩余空间最大的空闲区域进行分配。目的是确保分配后，剩余的空闲区域最大，避免生成过小的碎片。</p><p>查找时会遍历整个空闲区域列表，找到空闲空间最大的区域进行分配。</p><h4 id="总结对比："><a href="#总结对比：" class="headerlink" title="总结对比："></a><strong>总结对比</strong>：</h4><table><thead><tr><th>算法</th><th>查找效率</th><th>外部碎片</th><th>内部碎片</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>首次适应（FF）</strong></td><td>快速（找到第一个合适的区域）</td><td>较多</td><td>较少</td><td>快速分配，但容易产生碎片</td></tr><tr><td><strong>循环首次适应（NF）</strong></td><td>快速（避免重复遍历）</td><td>较多</td><td>较少</td><td>在多次分配时性能较好</td></tr><tr><td><strong>最佳适应（BF）</strong></td><td>慢（遍历整个空闲列表）</td><td>较少</td><td>较少</td><td>避免大块空闲空间的产生，但产生更多小碎片</td></tr><tr><td><strong>最坏适应（WF）</strong></td><td>慢（遍历整个空闲列表）</td><td>较多</td><td>较少</td><td>避免小碎片的产生，但可能产生大块空闲区域</td></tr></tbody></table><h5 id="选择最佳算法的依据："><a href="#选择最佳算法的依据：" class="headerlink" title="选择最佳算法的依据："></a><strong>选择最佳算法的依据</strong>：</h5><ul><li><strong>FF 和 NF</strong>：适用于内存中进程变化频繁的场景，分配速度快，适合对速度要求较高的系统。但它们可能产生较多外部碎片。</li><li><strong>BF 和 WF</strong>：适用于要求内存利用率较高的场景，能有效减少外部碎片。然而，这些算法在查找过程中会增加系统开销，性能较差。</li></ul><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><h4 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h4><p>快速适应算法是对经典的首次适应算法（First Fit）的优化版本，它通过引入<strong>多个空闲区块列表</strong>来加速内存分配。传统的首次适应算法需要遍历整个空闲区列表来查找合适的空闲区域，而快速适应算法在此基础上为不同大小的空闲区域设置多个链表（桶），每个链表存储特定大小范围的空闲块。这样，当一个进程请求内存时，系统可以根据请求的大小，直接访问对应的链表，从而快速找到合适的空闲块。</p><ul><li><strong>空闲区列表组织</strong>：系统维护多个链表，每个链表存储一个大小范围的空闲区域。例如，<code>链表1</code>存储1KB到2KB的空闲块，<code>链表2</code>存储2KB到4KB的空闲块，依此类推。</li><li><strong>分配方式</strong>：当一个进程请求内存时，算法根据请求大小直接查找相应大小范围的链表，找到第一个合适的块后进行分配。如果该块空间过大，剩余部分将重新加入到对应链表中</li></ul><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><h5 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a><strong>工作原理</strong>：</h5><p>伙伴系统是一种高效的内存分配算法，通过<strong>分裂和合并内存块</strong>来减少外部碎片。在伙伴系统中，内存被划分为一系列大小为2的幂次的块，每个块的大小是前一个块的两倍。内存分配时，算法始终从大块内存中分配，直到满足进程的需求。通过这种方式，系统可以将内存块切割成任意大小，同时确保内存的合并和拆分高效进行。</p><ul><li><strong>内存划分</strong>：内存从最初的整块内存开始，逐步按大小为2的幂次分割。例如，分配内存时，系统首先检查是否有符合要求的内存块，如果没有，则从更大的块开始分割，直到找到适合的大小。</li><li><strong>伙伴关系</strong>：当一个内存块被分割后，它会产生两个大小相同的块，称为“伙伴”。每当一个进程释放内存时，系统会检查其伙伴块是否也为空闲。如果是，它们会合并成一个更大的块，从而减少碎片。</li></ul><h5 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a><strong>工作流程</strong>：</h5><ol><li><strong>分配内存</strong>：进程请求内存时，算法选择最小且大于或等于请求大小的内存块。如果没有足够大的空闲块，系统将从较大的内存块中分割出合适的大小。</li><li><strong>释放内存</strong>：当进程释放内存时，系统检查是否存在与释放块相邻的空闲伙伴。如果存在，两个块会合并成一个更大的块，直到无法合并为止。</li></ol><blockquote><p>还要的哈希算法，自行百度</p></blockquote><table><thead><tr><th>算法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>快速适应算法（Quick Fit）</strong></td><td>加速内存分配，快速定位合适内存块</td><td>管理多个链表增加开销，可能导致碎片</td><td>内存碎片较多，进程请求大小差异大的场景</td></tr><tr><td><strong>伙伴系统（Buddy System）</strong></td><td>高效的内存分配和合并，无外部碎片</td><td>可能产生内部碎片，实现复杂</td><td>内存需求变化较大，需要高效内存管理的系统</td></tr></tbody></table><h2 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h2><h3 id="内存紧凑"><a href="#内存紧凑" class="headerlink" title="内存紧凑"></a>内存紧凑</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理</strong>：</h4><p>内存紧凑是一种用于减少外部碎片的技术，它的基本思想是在进程的内存释放后，将内存中已使用和空闲的区域重新排列，使得空闲内存区块集中在一起，避免空闲区域分散在不同位置。通过紧凑内存，可以创建一块连续的空闲区域，从而为其他进程分配更大的内存块，提升内存利用率。</p><h4 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a><strong>工作原理</strong>：</h4><ol><li><strong>内存整理</strong>：当多个进程结束时，内存中的空闲区域可能分散在不同的地方，导致外部碎片的产生。为了优化内存使用，操作系统会启动内存紧凑过程，将这些空闲区块移动到内存的一个区域。</li><li><strong>移动进程</strong>：紧凑过程中，操作系统需要将当前占用内存的进程按照它们的顺序移动，填充内存中空闲的区域。</li><li><strong>更新地址映射</strong>：由于进程的位置改变了，操作系统需要更新所有指向原内存地址的引用（包括指针、页表、段表等）。</li></ol><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a><strong>例子</strong>：</h4><p>假设一个内存区域有10KB，其中3KB被进程A占用，2KB被进程B占用，剩余5KB为空闲内存。在执行内存紧凑后，操作系统将进程A和进程B移动到内存的低地址部分，并将剩余的5KB空闲区域集中到高地址部分，避免了分散的空闲内存区块。</p><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a><strong>优缺点</strong>：</h4><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>减少外部碎片</strong>：通过紧凑内存，避免了碎片的产生。</td><td><strong>性能开销</strong>：移动进程和更新地址映射会导致一定的性能损失。</td></tr><tr><td><strong>提高内存利用率</strong>：空闲内存区域得到集中，便于分配。</td><td><strong>操作复杂</strong>：需要操作系统实现复杂的内存管理算法。</td></tr></tbody></table><h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3><p><img src="https://s2.loli.net/2025/01/03/Qmyu4g5hX8tKv1d.png" alt="image-20250103174432120"></p><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a><strong>原理</strong>：</h4><p>动态重定位是一种允许程序在执行期间可以被移动到不同内存位置的技术。与静态分配相比，动态重定位使得程序可以根据内存需求动态地调整其内存位置，而无需停止程序运行。</p><p> 在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址（逻辑地址），将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即需在系统中增设一个重定位寄存器，用来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p><p>地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为<strong>动态重定位。</strong></p><p>当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时，不需对程序做任何修改，只需用该程序在内存的新起始地址，去置换原来的起始地址即可。</p><p>操作系统通过地址重映射技术来实现动态重定位。程序访问的所有虚拟地址都需要通过内存管理单元（MMU）转换成物理地址。操作系统会通过<strong>段表</strong>或<strong>页表</strong>来记录虚拟地址与物理地址之间的映射关系。</p><h4 id="工作原理：-2"><a href="#工作原理：-2" class="headerlink" title="工作原理："></a><strong>工作原理</strong>：</h4><ol><li><strong>内存分配</strong>：当程序需要分配内存时，操作系统根据需要的内存大小选择一个空闲区域并分配给进程。分配的内存区域不需要是连续的。</li><li><strong>重定位地址</strong>：进程运行时，操作系统可以随时改变进程的内存位置。系统会修改进程中的指针或地址映射，使得程序继续按照新的内存布局访问数据。</li><li><strong>更新映射</strong>：操作系统更新虚拟地址与物理地址之间的映射关系，使得程序能够正确访问内存。</li></ol><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a><strong>例子</strong>：</h4><p>假设一个进程的虚拟内存空间有4KB，其中3KB已被分配，1KB为空闲。在某一时刻，该进程需要动态扩展为5KB。操作系统将该进程从原先的4KB内存区域移到一个更大的区域（例如6KB）。系统更新进程的地址映射，确保程序对内存的访问不受影响。</p><h4 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a><strong>优缺点</strong>：</h4><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>灵活性强</strong>：允许进程动态扩展或缩小内存。</td><td><strong>性能开销</strong>：动态重定位需要频繁更新地址映射，可能带来性能损失。</td></tr><tr><td><strong>避免内存碎片</strong>：通过重定位，进程的内存区域可以灵活管理，减少碎片。</td><td><strong>操作复杂</strong>：需要操作系统支持复杂的内存管理机制。</td></tr></tbody></table><h3 id="动态重定位分区分配算法"><a href="#动态重定位分区分配算法" class="headerlink" title="动态重定位分区分配算法"></a>动态重定位分区分配算法</h3><p><img src="https://s2.loli.net/2025/01/03/mHYIw6SrqZs8z1o.png" alt="image-20250103174641767"></p><p>动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了<strong>紧凑</strong>功能。</p><p>动态重定位分区分配算法结合了动态分区分配和动态重定位的概念，在此过程中，操作系统不仅动态地为进程分配内存，而且允许进程在运行时根据需求迁移到不同的内存区域。这种方法可以有效地减少外部碎片，提高内存利用率。</p><h4 id="关键特性："><a href="#关键特性：" class="headerlink" title="关键特性："></a><strong>关键特性</strong>：</h4><ol><li><strong>动态分配</strong>：操作系统在进程需要内存时，根据请求的内存大小动态分配内存，而不预设固定的分区。</li><li><strong>内存重定位</strong>：当进程需要更多内存时，操作系统可以将进程移动到更大的内存区域，同时更新地址映射表。</li><li><strong>内存回收</strong>：进程结束时，操作系统会回收其占用的内存区域，将这些区域加入空闲内存池。</li></ol><h4 id="工作原理：-3"><a href="#工作原理：-3" class="headerlink" title="工作原理："></a><strong>工作原理</strong>：</h4><ol><li><strong>内存请求</strong>：当进程需要内存时，操作系统为其动态分配合适的内存区域。如果内存不足，操作系统可以通过移动进程来提供更多内存。</li><li><strong>进程迁移</strong>：当进程需要更多内存时，操作系统会将其从当前内存区域移至新的、更大的区域，并更新所有指向原内存地址的引用。</li><li><strong>更新映射</strong>：操作系统会更新段表或页表，确保进程访问的虚拟地址能够正确映射到新的物理地址。</li><li><strong>内存释放</strong>：当进程结束时，操作系统回收其占用的内存区域，并通过紧凑等方法减少碎片。</li></ol><h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a><strong>例子</strong>：</h4><p>假设一个操作系统使用动态重定位分区分配算法来分配内存。进程A请求分配5KB内存，操作系统将其分配到内存地址0x1000到0x2000之间。随后，进程B请求更多内存，操作系统决定将进程A从内存区域0x1000到0x2000迁移到更大的内存区域0x3000到0x4000，并将进程B分配到0x2000到0x3000之间。操作系统更新进程A和B的内存地址映射，以确保它们可以正确访问内存。</p><h4 id="优缺点：-2"><a href="#优缺点：-2" class="headerlink" title="优缺点："></a><strong>优缺点</strong>：</h4><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>灵活性强</strong>：进程可以动态地扩展或缩小内存，避免了内存浪费。</td><td><strong>操作复杂</strong>：动态迁移进程并更新地址映射需要操作系统支持复杂的机制。</td></tr><tr><td><strong>减少碎片</strong>：内存可以根据进程需求动态分配，避免了外部碎片。</td><td><strong>性能开销</strong>：内存重定位会增加一定的性能开销，尤其是更新地址映射时。</td></tr><tr><td><strong>提高内存利用率</strong>：通过动态重定位，操作系统能够更高效地管理内存。</td><td><strong>需要精密的内存管理</strong>：需要有效的内存管理算法来避免引起过多的碎片和开销。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2023/01/12/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/01/12/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>将早年在知乎上的文章搬运于此</p></blockquote><h2 id="1-链表定义"><a href="#1-链表定义" class="headerlink" title="1.链表定义"></a>1.链表定义</h2><p>【1】<em><strong>概念</strong></em>：链表是一种<strong>物理存储结构上非连续、非顺序的存储结构</strong>，数据元素的逻辑顺序是通过链表中的<a href="https://zhida.zhihu.com/search?content_id=232205833&content_type=Article&match_order=1&q=%E6%8C%87%E9%92%88%E9%93%BE%E6%8E%A5&zhida_source=entity">指针链接</a>次序实现的。</p><p><img src="https://pic4.zhimg.com/v2-9c6d0483b0e9e18e611b4667725eeff5_1440w.jpg" alt="img"></p><p>【2】<em><strong>组成</strong></em>：<strong>由一系列节点（Node）通过指针连接而成</strong>，从一个头节点（Head）开始，头节点作为链表的入口点，它包含了对第一个节点的引用。最后一个节点的指针指向一个空值（NULL），表示链表的结束。</p><p><img src="https://picx.zhimg.com/v2-c24072329d7ebdfe5f3a8d18f33252b9_1440w.jpg" alt="img"></p><p>【3】*<strong>存储：*<strong>链表在内存中的存储方式则是</strong>随机存储（见缝插针），</strong>每一个节点分布在内存的不同位置，依靠指针关联起来。（只要有足够的内存空间，就能为链表分配内存）</p><p><img src="https://picx.zhimg.com/v2-e8c10a7f19f7b8ccb8aaaec1cc240b29_1440w.jpg" alt="img"></p><p>【4】***优缺点：***相对于顺序储存（例如数组）：</p><p>优点：链表的<strong>插入操作更快</strong>（ O(1) ），<strong>无需预先分配内存空间</strong></p><p>缺点：失去了<strong>随机读取</strong>的优点（需要从头节点开始依次遍历，直到找到目标节点。），<strong>内存消耗较大</strong>（每个节点都需要存储指向下一个节点的指针）。</p><p>【5】*<strong>对比：*</strong></p><p>链表是通过节点把离散的数据链接成一个表，通过对节点的插入和删除操作从而实现对数据的存取。而数组是通过开辟一段连续的内存来存储数据，这是数组和链表最大的区别。</p><p>数组的每个成员对应链表的节点，成员和节点的数据类型可以是标准的 C 类型或者是 用户自定义的结构体。</p><p>数组有起始地址和结束地址，而链表是一个圈，没有头和尾之分， 但是为了方便节点的插入和删除操作会人为的规定一个根节点。</p><p><img src="https://pic2.zhimg.com/v2-4e7203ba027eb793630e8d40474c9e77_1440w.jpg" alt="img"></p><p>【5】***分类***：链表一般有单向链表，双向链表，<a href="https://zhida.zhihu.com/search?content_id=232205833&content_type=Article&match_order=1&q=%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8&zhida_source=entity">循环链表</a>，带头链表这四种形式。</p><p>常用的两种结构：</p><p><img src="https://pica.zhimg.com/v2-2fd13f5b9b794e36daa5b5455f7ce896_1440w.jpg" alt="img"></p><ol><li>无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的<a href="https://zhida.zhihu.com/search?content_id=232205833&content_type=Article&match_order=1&q=%E9%82%BB%E6%8E%A5%E8%A1%A8&zhida_source=entity">邻接表</a>等等。另外这种结构在笔试面试中出现很多。</li><li>带头<a href="https://zhida.zhihu.com/search?content_id=232205833&content_type=Article&match_order=1&q=%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8&zhida_source=entity">双向循环链表</a>：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单。</li></ol><hr><h2 id="2-链表的实现"><a href="#2-链表的实现" class="headerlink" title="2.链表的实现"></a>2.链表的实现</h2><h3 id="2-1链表的创建"><a href="#2-1链表的创建" class="headerlink" title="2.1链表的创建"></a>2.1链表的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义链表节点结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> data;           <span class="hljs-comment">// 数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一个节点的指针</span><br>&#125;;<br><br><span class="hljs-comment">// 创建链表函数</span><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">createLinkedList</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span><br> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// 头节点指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">tail</span> =</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// 尾节点指针</span><br><br>    <span class="hljs-comment">// 遍历数组，为每个元素创建一个节点，并加入链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 创建新节点并为其分配内存</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        <span class="hljs-keyword">if</span> (newNode == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配失败.&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 设置新节点的数据</span><br>        newNode-&gt;data = arr[i];<br>        newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 如果链表为空，将新节点设置为头节点和尾节点</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            head = tail = newNode;<br>        &#125;<br>        <span class="hljs-comment">// 如果链表非空，将新节点加入到尾部，并更新尾节点指针</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = newNode;<br>            tail = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2链表的插入"><a href="#2-2链表的插入" class="headerlink" title="2.2链表的插入"></a>2.2链表的插入</h3><p><img src="https://pica.zhimg.com/v2-2b74576c4133d98967e430da2a156c6e_b.jpg" alt="动图封面"></p><p>同<a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/296.html">顺序表</a>一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：</p><ul><li>插入到链表的头部，作为首元节点；</li><li>插入到链表中间的某个位置；</li><li>插入到链表的最末端，作为链表中最后一个结点；</li></ul><p><img src="https://pic1.zhimg.com/v2-db33fb334b2347c83cf68606564078b4_1440w.jpg" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs text">// 在链表中插入节点<br>void insert(struct Node** headRef, int position, int value) &#123;<br>    // 创建新节点并为其分配内存<br>    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));<br>    if (newNode == NULL) &#123;<br>        printf(&quot;内存分配失败。\n&quot;);<br>        return;<br>    &#125;<br>    newNode-&gt;data = value;<br><br>    // 如果要插入的位置是链表的头部或链表为空<br>    if (*headRef == NULL || position == 0) &#123;<br>        newNode-&gt;next = *headRef;<br>        *headRef = newNode;<br>        return;<br>    &#125;<br><br>    struct Node* current = *headRef;<br>    int count = 1;<br>    // 找到要插入位置的前一个节点<br>    while (current-&gt;next != NULL &amp;&amp; count &lt; position) &#123;<br>        current = current-&gt;next;<br>        count++;<br>    &#125;<br><br>    // 在指定位置插入节点<br>    newNode-&gt;next = current-&gt;next;<br>    current-&gt;next = newNode;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解惑：{struct Node** headRef}</p><blockquote><p>在链表节点删除中使用<a href="https://zhida.zhihu.com/search?content_id=232205833&content_type=Article&match_order=1&q=%E5%8F%8C%E6%8C%87%E9%92%88&zhida_source=entity">双指针</a>的原因是为了更改指针的指向。<br>在单指针情况下，如果我们想要删除当前节点，我们无法直接修改前一个节点的 next 指针，因为我们只有当前节点的指针。所以我们需要一个额外的指针来保存前一个节点的地址，这个额外的指针就是双指针中的 prev。<br>通过双指针的方式，我们可以在<a href="https://zhida.zhihu.com/search?content_id=232205833&content_type=Article&match_order=1&q=%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8&zhida_source=entity">遍历链表</a>的过程中同时记录前一个节点和当前节点的位置。当找到要删除的节点时，我们可以使用 prev 指针修改前一个节点的 next 指针，将其指向当前节点的下一个节点，从而实现删除操作。同时，我们还可以使用 current 指针来释放要删除的节点的内存。</p></blockquote><h3 id="2-3链表的查询"><a href="#2-3链表的查询" class="headerlink" title="2.3链表的查询"></a>2.3链表的查询</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">// 在链表中查询节点<br>struct Node* search(struct Node* head, int value) &#123;<br>    struct Node* current = head;<br><br>    while (current != NULL) &#123;<br>        if (current-&gt;data == value) &#123;<br>            return current;  // 返回匹配的节点地址<br>        &#125;<br>        current = current-&gt;next;<br>    &#125;<br><br>    return NULL;  // 若没有找到匹配节点，则返回NULL<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4链表的删除"><a href="#2-4链表的删除" class="headerlink" title="2.4链表的删除"></a>2.4链表的删除</h3><p><img src="https://pic3.zhimg.com/v2-e1c49020d6eb531d9a44a316396ef306_1440w.jpg" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">// 在链表中删除节点<br>void delete(struct Node** headRef, int value) &#123;<br>    struct Node* current = *headRef;<br>    struct Node* prev = NULL;<br><br>    // 处理头节点为目标节点的情况<br>    if (current != NULL &amp;&amp; current-&gt;data == value) &#123;<br>        *headRef = current-&gt;next;<br>        free(current);<br>        return;<br>    &#125;<br><br>    // 遍历链表找到要删除的节点<br>    while (current != NULL &amp;&amp; current-&gt;data != value) &#123;<br>        prev = current;<br>        current = current-&gt;next;<br>    &#125;<br><br>    // 如果找到了目标节点，则删除它<br>    if (current != NULL) &#123;<br>        prev-&gt;next = current-&gt;next;<br>        free(current);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5链表的释放"><a href="#2-5链表的释放" class="headerlink" title="2.5链表的释放"></a>2.5链表的释放</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">// 释放链表内存<br>void freeList(struct Node* head) &#123;<br>    struct Node* current = head;<br>    struct Node* next;<br><br>    while (current != NULL) &#123;<br>        next = current-&gt;next;<br>        free(current);<br>        current = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6链表的遍历"><a href="#2-6链表的遍历" class="headerlink" title="2.6链表的遍历"></a>2.6链表的遍历</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">void printLinkedList(struct Node* head) &#123;<br>    struct Node* current = head;<br>    while (current != NULL) &#123;<br>        printf(&quot;%d &quot;, current-&gt;data);<br>        current = current-&gt;next;<br>    &#125;<br>    printf(&quot;\n&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-双向链表"><a href="#3-双向链表" class="headerlink" title="3.双向链表"></a>3.双向链表</h2><h3 id="【1】起源："><a href="#【1】起源：" class="headerlink" title="【1】起源："></a>【1】<em><strong>起源：</strong></em></h3><p>单链表的结点中只有一个指向其后继的指针，使得单链表要访问某个结点的前驱结点时，只能从头开始遍历，访问后驱结点的复杂度为O(1)，访问<a href="https://zhida.zhihu.com/search?content_id=232205833&content_type=Article&match_order=2&q=%E5%89%8D%E9%A9%B1%E7%BB%93%E7%82%B9&zhida_source=entity">前驱结点</a>的复杂度为O(n)。（例如，若实际问题中需要频繁地查找某个结点的前驱结点，使用单链表存储数据显然没有优势，因为单链表的强项是从前往后查找目标元素，不擅长从后往前查找元素。）为了克服上述缺点，引入了双链表。</p><h3 id="【2】定义："><a href="#【2】定义：" class="headerlink" title="*【2】定义：*"></a>*<strong>【2】定义：*</strong></h3><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。</p><p><img src="https://pic2.zhimg.com/v2-a6d17db9e94ce0df7c2b5ea641f0c403_1440w.jpg" alt="img"></p><p>图1：双链表</p><p>从图 1 中可以看到，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：</p><ol><li>指针域：用于指向当前节点的直接前驱节点；</li><li>数据域：用于存储数据元素。</li><li>指针域：用于指向当前节点的直接后继节点；</li></ol><p><img src="https://pic2.zhimg.com/v2-251a1b197b710bb9fb6fafed6a582009_1440w.jpg" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">typedef struct line&#123;<br>    struct line * prior; //指向直接前趋<br>    int data;<br>    struct line * next; //指向直接后继<br>&#125;Line;<br></code></pre></td></tr></table></figure><h3 id="【3】特点："><a href="#【3】特点：" class="headerlink" title="*【3】特点：*"></a>*<strong>【3】特点：*</strong></h3><p>1.每次在插入或删除某个节点时, 需要处理四个节点的引用, 而不是两个. 实现起来要困难一些；</p><p>2.相对于单向链表, 必然占用内存空间更大一些；</p><p>3.既可以从头遍历到尾， 又可以从尾遍历到头；</p><hr><h2 id="4-双向链表的实现"><a href="#4-双向链表的实现" class="headerlink" title="*4.双向链表的实现*"></a>*<strong>4.双向链表的实现*</strong></h2><h3 id="4-1-双向链表的创建"><a href="#4-1-双向链表的创建" class="headerlink" title="*4.1*双向链表的创建"></a>*<strong>4.1*双向链表的创建</strong></h3><p>需要注意的是，与单链表不同，双链表创建过程中，每创建一个新节点都要与其前驱节点建立两次联系，分别是：</p><ul><li>将新节点的 prior 指针指向直接前驱节点；</li><li>将直接前驱节点的 next 指针指向新节点；</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">Line* initLine(Line* head) &#123;<br>    Line* list = NULL;<br>    head = (Line*)malloc(sizeof(Line));//创建链表第一个结点（首元结点）<br>    head-&gt;prior = NULL;<br>    head-&gt;next = NULL;<br>    head-&gt;data = 1;<br>    list = head;<br>    for (int i = 2; i &lt;= 5; i++) &#123;<br>        //创建并初始化一个新结点<br>        Line* body = (Line*)malloc(sizeof(Line));<br>        body-&gt;prior = NULL;<br>        body-&gt;next = NULL;<br>        body-&gt;data = i;<br>        //直接前趋结点的next指针指向新结点<br>        list-&gt;next = body;<br>        //新结点指向直接前趋结点<br>        body-&gt;prior = list;<br>        list = list-&gt;next;<br>    &#125;<br>    return head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2双向链表的添加"><a href="#4-2双向链表的添加" class="headerlink" title="4.2双向链表的添加"></a><strong>4.2双向链表的添加</strong></h3><p>根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：</p><p>1，添加至表头</p><p><img src="https://picx.zhimg.com/v2-004e33caf75840a1bdab0e7f65635c39_1440w.jpg" alt="img"></p><p>2，添加至中间位置</p><p><img src="https://picx.zhimg.com/v2-eae0508c11c0fd0929a35fb3e2cb56f7_1440w.jpg" alt="img"></p><p>3，添加至表尾</p><p><img src="https://pic1.zhimg.com/v2-49924969aee79852e30468fe2481e936_1440w.jpg" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs text">Line* insertLine(Line* head, int data, int add) &#123;<br>    //新建数据域为data的结点<br>    Line* temp = (Line*)malloc(sizeof(Line));<br>    temp-&gt;data = data;<br>    temp-&gt;prior = NULL;<br>    temp-&gt;next = NULL;<br>    //插入到链表头，要特殊考虑<br>    if (add == 1) &#123;<br>        temp-&gt;next = head;<br>        head-&gt;prior = temp;<br>        head = temp;<br>    &#125;<br>    else &#123;<br>        int i;<br>        Line* body = head;<br>        //找到要插入位置的前一个结点<br>        for (i = 1; i &lt; add - 1; i++) &#123;<br>            body = body-&gt;next;<br>            //只要 body 不存在，表明插入位置输入错误<br>            if (!body) &#123;<br>                printf(&quot;插入位置有误！\n&quot;);<br>                return head;<br>            &#125;<br>        &#125;<br>        //判断条件为真，说明插入位置为链表尾，实现第 2 种情况<br>        if (body &amp;&amp; (body-&gt;next == NULL)) &#123;<br>            body-&gt;next = temp;<br>            temp-&gt;prior = body;<br>        &#125;<br>        else &#123;<br>            //第 2 种情况的具体实现<br>            body-&gt;next-&gt;prior = temp;<br>            temp-&gt;next = body-&gt;next;<br>            body-&gt;next = temp;<br>            temp-&gt;prior = body;<br>        &#125;<br>    &#125;<br>    return head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3双向链表的删除"><a href="#4-3双向链表的删除" class="headerlink" title="4.3双向链表的删除"></a><strong>4.3双向链表的删除</strong></h3><p>和添加结点的思想类似，在双向链表中删除目标结点也分为 3 种情况。</p><p>1，删除表头结点</p><p><img src="https://picx.zhimg.com/v2-66cf8b9a6cc816e4a69143a68b662e25_b.jpg" alt="动图封面"></p><p>2，删除表中结点</p><p><img src="https://pic3.zhimg.com/v2-16ad444f55b4b5cf1a2530dc2cc40a0c_1440w.jpg" alt="img"></p><p>3，删除表尾结点</p><p><img src="https://pic3.zhimg.com/v2-d4cef1c4c057c68b005655d48f25e79c_1440w.jpg" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs text">//删除结点的函数，data为要删除结点的数据域的值<br>Line* delLine(Line* head, int data) &#123;<br>    Line* temp = head;<br>    while (temp) &#123;<br>        if (temp-&gt;data == data) &#123;<br>            //删除表头结点<br>            if (temp-&gt;prior == NULL) &#123;<br>                head = head-&gt;next;<br>                if (head) &#123;<br>                    head-&gt;prior = NULL;<br>                    temp-&gt;next = NULL;<br>                &#125;<br>                free(temp);<br>                return head;<br>            &#125;<br>            //删除表中结点<br>            if (temp-&gt;prior &amp;&amp; temp-&gt;next) &#123;<br>                temp-&gt;next-&gt;prior = temp-&gt;prior;<br>                temp-&gt;prior-&gt;next = temp-&gt;next;<br>                free(temp);<br>                return head;<br>            &#125;<br>            //删除表尾结点<br>            if (temp-&gt;next == NULL) &#123;<br>                temp-&gt;prior-&gt;next = NULL;<br>                temp-&gt;prior = NULL;<br>                free(temp);<br>                return head;<br>            &#125;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    printf(&quot;表中没有目标元素，删除失败\n&quot;);<br>    return head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4双向链表的查询"><a href="#4-4双向链表的查询" class="headerlink" title="4.4双向链表的查询"></a>4.4双向链表的查询</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">//head为原双链表，elem表示被查找元素<br>int selectElem(line * head,int elem)&#123;<br>//新建一个指针t，初始化为头指针 head<br>    line * t=head;<br>    int i=1;<br>    while (t) &#123;<br>        if (t-&gt;data==elem) &#123;<br>            return i;<br>        &#125;<br>        i++;<br>        t=t-&gt;next;<br>    &#125;<br>    //程序执行至此处，表示查找失败<br>    return -1;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5双向链表的更改"><a href="#4-5双向链表的更改" class="headerlink" title="4.5双向链表的更改"></a>4.5双向链表的更改</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">//更新函数，其中，add 表示要修改的元素，newElem 为新数据的值<br>void amendElem(Line* p, int oldElem, int newElem) &#123;<br>    Line* temp = p;<br>    int find = 0;<br>    //找到要修改的目标结点<br>    while (temp)<br>    &#123;<br>        if (temp-&gt;data == oldElem) &#123;<br>            find = 1;<br>            break;<br>        &#125;<br>        temp = temp-&gt;next;<br>    &#125;<br>    //成功找到，则进行更改操作<br>    if (find == 1) &#123;<br>        temp-&gt;data = newElem;<br>        return;<br>    &#125;<br>    //查找失败，输出提示信息<br>    printf(&quot;链表中未找到目标元素，更改失败\n&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="5-双向循环链表的简单实现"><a href="#5-双向循环链表的简单实现" class="headerlink" title="5.双向循环链表的简单实现"></a><strong>5.双向循环链表的简单实现</strong></h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs text">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>// 定义双向循环链表结构体<br>struct Node &#123;<br>    int data;<br>    struct Node* prev;<br>    struct Node* next;<br>&#125;;<br><br>// 在链表末尾插入节点<br>void insert(struct Node** headRef, int data) &#123;<br>    // 创建新节点<br>    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));<br>    newNode-&gt;data = data;<br><br>    if (*headRef == NULL) &#123;<br>        // 如果链表为空，让新节点成为唯一一个节点<br>        newNode-&gt;prev = newNode;<br>        newNode-&gt;next = newNode;<br>        *headRef = newNode;<br>    &#125; else &#123;<br>        // 如果链表不为空，在链表末尾插入新节点<br>        struct Node* lastNode = (*headRef)-&gt;prev;<br>        newNode-&gt;prev = lastNode;<br>        newNode-&gt;next = *headRef;<br>        lastNode-&gt;next = newNode;<br>        (*headRef)-&gt;prev = newNode;<br>    &#125;<br>&#125;<br><br>// 在链表中删除指定值的节点<br>void delete(struct Node** headRef, int data) &#123;<br>    if (*headRef == NULL) &#123;<br>        // 链表为空，无需删除<br>        return;<br>    &#125;<br><br>    struct Node* current = *headRef;<br><br>    // 查找要删除的节点<br>    while (current-&gt;data != data &amp;&amp; current-&gt;next != *headRef) &#123;<br>        current = current-&gt;next;<br>    &#125;<br><br>    if (current-&gt;data == data) &#123;<br>        // 找到要删除的节点<br>        if (current-&gt;next == current) &#123;<br>            // 要删除的节点是唯一一个节点<br>            *headRef = NULL;<br>        &#125; else &#123;<br>            // 从链表中删除节点<br>            current-&gt;prev-&gt;next = current-&gt;next;<br>            current-&gt;next-&gt;prev = current-&gt;prev;<br>            if (*headRef == current) &#123;<br>                // 如果要删除的节点是头节点，更新头指针<br>                *headRef = current-&gt;next;<br>            &#125;<br>        &#125;<br>        free(current);<br>    &#125;<br>&#125;<br><br>// 打印链表<br>void printList(struct Node* head) &#123;<br>    if (head != NULL) &#123;<br>        struct Node* current = head;<br>        do &#123;<br>            printf(&quot;%d &quot;, current-&gt;data);<br>            current = current-&gt;next;<br>        &#125; while (current != head);<br>    &#125;<br>    printf(&quot;\n&quot;);<br>&#125;<br><br>// 测试代码<br>int main() &#123;<br>    struct Node* head = NULL;<br><br>    insert(&amp;head, 1);<br>    insert(&amp;head, 2);<br>    insert(&amp;head, 3);<br><br>    printf(&quot;原始链表：&quot;);<br>    printList(head);  // 输出：1 2 3<br><br>    delete(&amp;head, 2);<br><br>    printf(&quot;删除节点后的链表：&quot;);<br>    printList(head);  // 输出：1 3<br><br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据结构与算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU虚拟化与进程</title>
    <link href="/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <url>/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟化-美丽的假象"><a href="#虚拟化-美丽的假象" class="headerlink" title="虚拟化(美丽的假象)"></a>虚拟化(美丽的假象)</h1><p>假设一个计算机只有一个CPU，虚拟化要做的就是将这个CPU虚拟成多个虚拟CPU并分给每一个进程使用，通过<strong>时间分片调度</strong>和<strong>资源隔离</strong>技术，操作系统 会将这个物理 CPU 的使用时间切分成多个时间片，并分配给不同的进程或虚拟机使用。因此，每个应用都以为自己在独占CPU，但实际上只有一个CPU。这样操作系统就创造了美丽的假象——它虚拟化了CPU。</p><h2 id="更好的实现CPU的虚拟化"><a href="#更好的实现CPU的虚拟化" class="headerlink" title="更好的实现CPU的虚拟化"></a>更好的实现CPU的虚拟化</h2><h3 id="机制-受限直接执行"><a href="#机制-受限直接执行" class="headerlink" title="机制(受限直接执行)"></a>机制(受限直接执行)</h3><h4 id="第一个是性能：如何在不增加系统开销的情况下实现虚拟化？"><a href="#第一个是性能：如何在不增加系统开销的情况下实现虚拟化？" class="headerlink" title="第一个是性能：如何在不增加系统开销的情况下实现虚拟化？"></a>第一个是性能：如何在不增加系统开销的情况下实现虚拟化？</h4><p>只需直接在CPU上运行程序即可。因此，当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。表6.1展示了这种基本的直接执行协议（没有任何限制），使用正常的调用并返回跳转到程序的main()，并在稍后回到内核。</p><p><img src="https://s2.loli.net/2024/12/22/QWOf38Za9AJXYgI.png" alt="image-20241222173814892"></p><h4 id="第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？"><a href="#第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？" class="headerlink" title="第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？"></a>第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？</h4><p>控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息。</p><h5 id="一个进程必须能够执行I-O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？"><a href="#一个进程必须能够执行I-O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？" class="headerlink" title="一个进程必须能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？"></a>一个进程必须能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？</h5><p>引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出I&#x2F;O请求。这样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出I&#x2F;O请求和执行所有类型的受限指令。</p><h6 id="如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？"><a href="#如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？" class="headerlink" title="如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？"></a>如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？</h6><p>提供用户程序执行系统调用的能力。它允许内核小心地向用户程序暴露某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。</p><p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</p><p><strong>陷阱如何知道在OS内运行哪些代码？</strong></p><p>发起调用的过程不能指定要跳转到的地址，这样做让程序可以跳转到内核中的任意位置，这显然是一个糟糕的主意（想象一下跳到访问文件的代码，但在权限检查之后。实际上，这种能力很可能让一个狡猾的程序员令内核运行任意代码序列）。因此内核必须谨慎地控制在陷阱上执行的代码。</p><p>内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码？操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器，并且硬件知道在发生系统调用和其他异常事件时要做什么（即跳转到哪段代码）。</p><img src="https://s2.loli.net/2024/12/22/sUVZq4RxSLJcn5p.png" alt="image-20241222174427511" style="zoom:25%;" /><h5 id="操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？"><a href="#操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？" class="headerlink" title="操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？"></a>操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？</h5><p>悖论：如果一个进程在CPU上运行，这就意味着操作系统没有运行。如果操作系统没有运行，它怎么能做事情？</p><h6 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h6><p>操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务。大多数进程通过进行系统调用，将CPU的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程。像这样的系统通常包括一个显式的yield系统调用，它什么都不干，只是将控制权交给操作系统，以便系统可以运行其他进程。</p><p>如果应用程序执行了某些非法操作，也会将控制转移给操作系统。例如，如果应用程序以0为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制CPU（并可能终止违规进程）。</p><p>缺点：如果某个进程（无论是恶意的还是充满缺陷的）进入无限循环，并且从不进行系统调用，会发生什么情况？那时操作系统能做什么？</p><p>即使进程不协作，操作系统如何获得CPU的控制权？操作系统可以做什么来确保流氓进程不会占用机器？</p><h6 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h6><blockquote><p>时钟中断（timer interrupt）[M+63]。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p></blockquote><p>首先，操作系统必须通知硬件哪些代码在发生时钟中断时运行。因此，在启动时，操作系统就是这样做的。其次，在启动过程中，操作系统也必须启动时钟，这当然是一项特权操作。一旦时钟开始运行，操作系统就感到安全了，因为控制权最终会归还给它，因此操作系统可以自由运行用户程序。时钟也可以关闭（也是特权操作），</p><h6 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h6><p>当操作系统重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断更强制执行，都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。</p><p>如果决定进行切换，OS就会执行一些底层代码，即所谓的上下文切换（context switch）。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p><p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222175204613.png" alt="2" style="zoom:25%;" /><p>在此协议中，有两种类型的寄存器保存&#x2F;恢复。第一种是发生时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从A切换到B。在这种情况下，内核寄存器被软件（即OS）明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由A陷入内核，变成好像刚刚由B陷入内核。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p><strong>该如何开发一个考虑调度策略的基本框架？什么是关键假设？哪些指标非常重要？</strong></p><blockquote><p>进程调度算法有很多也很重要这里只做概览性简单介绍，后续会单独讲解</p></blockquote><p><strong>进程调度</strong>是指操作系统为多个进程分配CPU资源的机制，它决定了在任意时刻哪个进程可以使用CPU进行执行。由于系统资源（尤其是CPU）是有限的，而进程通常多于可用的资源，因此需要通过进程调度来公平、高效地管理资源使用。</p><hr><h4 id="进程调度的核心内容"><a href="#进程调度的核心内容" class="headerlink" title="进程调度的核心内容"></a><strong>进程调度的核心内容</strong></h4><table><thead><tr><th><strong>内容</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>调度目标</strong></td><td>在多任务系统中高效利用资源，减少等待时间，保证系统响应和吞吐量。</td></tr><tr><td><strong>调度时机</strong></td><td>- <strong>进程状态变化时</strong>（如运行态到阻塞态）。- <strong>时间片到期</strong>。</td></tr><tr><td><strong>调度算法</strong></td><td>操作系统采用的算法决定了进程调度的公平性与效率。</td></tr><tr><td><strong>调度方式</strong></td><td>可分为抢占式调度和非抢占式调度。</td></tr></tbody></table><hr><h4 id="进程调度的关键步骤"><a href="#进程调度的关键步骤" class="headerlink" title="进程调度的关键步骤"></a><strong>进程调度的关键步骤</strong></h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>1. 进程分类</strong></td><td>区分就绪、运行、阻塞等状态的进程。</td></tr><tr><td><strong>2. 选择进程</strong></td><td>根据调度算法从就绪队列中选取一个进程。</td></tr><tr><td><strong>3. 分配资源</strong></td><td>将CPU资源分配给选定的进程，并切换上下文。</td></tr><tr><td><strong>4. 开始运行</strong></td><td>进程获得CPU后，从上次暂停处继续执行或从头开始执行。</td></tr></tbody></table><hr><h4 id="常见的调度算法"><a href="#常见的调度算法" class="headerlink" title="常见的调度算法"></a><strong>常见的调度算法</strong></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>说明</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>先来先服务（FCFS）</strong></td><td>按到达顺序调度进程，简单但可能导致较长的等待时间。</td><td>任务简单、实时性要求不高的系统。</td></tr><tr><td><strong>短作业优先（SJF）</strong></td><td>优先调度执行时间最短的进程，可能会导致长任务饥饿。</td><td>作业时间可预测的批处理系统。</td></tr><tr><td><strong>时间片轮转（RR）</strong></td><td>每个进程分配固定时间片，时间到则切换到下一个进程。</td><td>交互式系统，例如桌面操作系统。</td></tr><tr><td><strong>优先级调度</strong></td><td>根据进程优先级调度，优先级高的进程先运行。</td><td>实时系统或对任务重要性有要求的环境。</td></tr><tr><td><strong>多级反馈队列调度</strong></td><td>根据进程特性动态调整优先级，综合性较强。</td><td>通用系统，例如桌面和服务器操作系统。</td></tr></tbody></table><hr><h4 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a><strong>调度方式</strong></h4><table><thead><tr><th><strong>方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>非抢占式调度</strong></td><td>进程一旦占用CPU，直到主动放弃或阻塞，才切换到其他进程。</td></tr><tr><td><strong>抢占式调度</strong></td><td>操作系统可以强制中断正在运行的进程，将CPU分配给其他进程。</td></tr></tbody></table><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程（Process）是操作系统中程序的一个运行实例<strong>。它是程序在计算机上的一次</strong>动态执行，包括程序代码和其运行时需要的所有资源。从操作系统的角度看，进程是资源分配的最小单位，也是程序执行的基本单位。【进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。】</p><p><strong>进程的机器状态构成</strong>：程序在运行时可以读取或更新的内容。在任何时刻，机器的哪些部分对执行该程序很重要。</p><ul><li>内存：指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分。</li><li>寄存器：许多指令明确地读取或更新寄存器，因此显然，它们对于执行该进程很重要。</li><li>I&#x2F;O信息：程序也经常访问持久存储设备。此类I&#x2F;O信息可能包含当前打开的文件列表。</li></ul><p><strong>如何将程序转化为进程？</strong></p><table><thead><tr><th><strong>步骤</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>1. 调用系统接口</strong></td><td>使用系统调用创建进程，例如：<code>fork()</code>（Linux）或 <code>CreateProcess()</code>（Windows）。</td></tr><tr><td><strong>2. 分配资源</strong></td><td>为进程分配内存（代码段、数据段、栈段）、文件句柄、I&#x2F;O 缓冲区等。</td></tr><tr><td><strong>3. 加载程序</strong></td><td>将程序的代码和数据从磁盘加载到内存，并为其分配独立的地址空间。</td></tr><tr><td><strong>4. 初始化 PCB</strong></td><td>设置进程控制块（PCB），记录进程 ID、状态、程序计数器等信息。</td></tr><tr><td><strong>5. 设置运行环境</strong></td><td>初始化寄存器、栈指针，设置全局变量和静态变量的初始值。</td></tr><tr><td><strong>6. 加入调度队列</strong></td><td>将新创建的进程放入操作系统的就绪队列，等待调度器分配 CPU。</td></tr><tr><td><strong>7. 开始执行</strong></td><td>调度器分配 CPU 后，进程从入口地址（如 <code>main()</code>）开始执行。</td></tr></tbody></table><h2 id="进程状态及其演变"><a href="#进程状态及其演变" class="headerlink" title="进程状态及其演变"></a>进程状态及其演变</h2><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222180155226.png" alt="3"></p><h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><p>为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——**进程控制块PCB(Process Control Block)**，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。操作系统通过PCB来跟踪和控制进程的运行状态。</p><h4 id="PCB-的作用机制"><a href="#PCB-的作用机制" class="headerlink" title="PCB 的作用机制"></a><strong>PCB 的作用机制</strong></h4><ol><li><strong>进程切换时的角色</strong><ul><li>当发生进程切换时，操作系统将当前进程的CPU状态保存到PCB中，并从新进程的PCB中恢复CPU状态。</li><li>PCB中的上下文信息决定了进程可以从上次暂停的位置继续执行。</li></ul></li><li><strong>进程调度中的作用</strong><ul><li>调度器通过PCB判断进程的状态、优先级等信息，从而选择适合的进程运行。</li></ul></li><li><strong>进程通信中的作用</strong><ul><li>PCB中记录了进程间通信所需的信息，如共享内存的指针等。</li></ul></li></ol><h4 id="PCB-的组成"><a href="#PCB-的组成" class="headerlink" title="PCB 的组成"></a><strong>PCB 的组成</strong></h4><table><thead><tr><th><strong>部分</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 进程标识信息</strong></td><td>- <strong>进程ID</strong>：唯一标识进程的ID号。 - <strong>父进程ID</strong>：创建它的父进程的ID号。</td></tr><tr><td><strong>2. 进程状态信息</strong></td><td>- 当前进程的状态（如就绪、运行、阻塞）。 - 优先级、调度信息等。</td></tr><tr><td><strong>3. CPU寄存器信息</strong></td><td>- 进程切换时保存的寄存器值，如程序计数器、堆栈指针等。</td></tr><tr><td><strong>4. 内存管理信息</strong></td><td>- 指向进程地址空间的指针（如页表指针）。</td></tr><tr><td><strong>5. 文件管理信息</strong></td><td>- 进程打开的文件列表、文件描述符表等。</td></tr><tr><td><strong>6. 资源分配信息</strong></td><td>- 占用的资源信息（如I&#x2F;O设备、信号量等）。</td></tr><tr><td><strong>7. 其他信息</strong></td><td>- 进程所属用户信息、信号处理机制等。</td></tr></tbody></table><h4 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h4><p><strong>线性方式</strong>：将系统种所有PCB都组织在一张线性表中，将该表首地址存在内存的一个专用区域<br>实现简单，开销小，但是每次都需要扫描整张表，适合进程数目不多的系统</p><p><strong>链接方式</strong>：把同一状态的PCB链接成一个队列，形成就绪队列、若干个阻塞队列和空白队列等<br>对其中的就绪队列常按进程优先级的高低排列，优先级高排在队前，此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I&#x2F;O 操作完成的队列和等待分配内存的队列等</p><img src="https://s2.loli.net/2024/12/22/NDSmHrP96vz3URs.png" alt="1" style="zoom: 50%;" /><p><strong>索引方式</strong>：系统根据所有进程的状态建立几张索引表，例如就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中，在每个索引表的表目中，记录具有相应状态的某个PCB在PCB址</p><img src="https://s2.loli.net/2024/12/22/g7KiEPcd14eRoOB.png" alt="2" style="zoom:50%;" /><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><h4 id="什么是父子进程？"><a href="#什么是父子进程？" class="headerlink" title="什么是父子进程？"></a>什么是父子进程？</h4><p>在 Unix 和 Linux中，每个进程都有一个唯一的进程标识符（PID），以及一个父进程标识符（PPID），这两个值使得子进程能够知道它们的父进程是什么。</p><ol><li><strong>PID（Process ID）</strong>：这是操作系统分配给每个进程的唯一标识符。每个进程都有一个唯一的 PID。</li><li><strong>PPID（Parent Process ID）</strong>：这是进程的父进程的 PID。PPID 指示了哪个进程创建了当前进程。</li></ol><p>当进程 A 调用 <code>fork()</code> 时，会创建一个子进程 B。对于子进程 B，它的 PPID 会被设置为进程 A 的 PID。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Process</span> A: PID = <span class="hljs-number">12345</span><br>Parent process: PID = <span class="hljs-number">12345</span>, Child PID = <span class="hljs-number">12346</span><br>Child process: PID = <span class="hljs-number">12346</span>, PPID = <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p><strong>同时父进程会获得一个非零的PID（子进程的PID），而子进程会获得0作为返回值。这使得我们可以通过检查返回值的大小来区分父子进程</strong></p><p><strong>注意这里的返回0并不是将子进程PID设为0</strong>，而是出于以下方面考虑：</p><ul><li><p><strong>区分父进程和子进程的执行流</strong></p><p>当调用 <code>fork()</code> 时，会创建一个新的子进程。<code>fork()</code> 在父进程中返回子进程的 PID，而在子进程中返回 0。这种设计让同一段代码能够在两个不同的进程中执行不同的逻辑。</p></li><li><p><strong>简化错误处理</strong></p><p>如果 <code>fork()</code> 返回一个负值（通常是 -1），这表明进程创建失败。父进程可以立即检查这个返回值并进行相应的错误处理。</p></li><li><p><strong>方便进程间通信和同步</strong></p><p>由于 <code>fork()</code> 在子进程中返回 0，父进程可以使用返回的子进程 PID 来进行进程间的通信和同步操作。例如，父进程可以等待子进程结束，或者通过信号与子进程进行通信。</p></li><li><p><strong>实现多进程并发</strong></p><p><code>fork()</code> 机制使得多进程并发编程变得简单。父进程可以连续调用 <code>fork()</code> 多次，创建多个子进程来处理不同的任务或相同任务的不同部分，从而实现并发处理。</p></li></ul><h4 id="1-进程创建阶段"><a href="#1-进程创建阶段" class="headerlink" title="1. 进程创建阶段"></a><strong>1. 进程创建阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>分配标识</strong></td><td>操作系统为每个新进程分配唯一的进程ID（PID），并在PCB表中为其预留存储位置。</td><td>父进程通过系统调用（如 <code>fork()</code>）创建子进程，子进程获得一个新的PID。</td></tr><tr><td><strong>分配资源</strong></td><td>- 内存分配：分配进程代码段、数据段和堆栈段的内存空间。- 文件表：初始化文件描述符表。</td><td>子进程继承父进程的部分资源（如文件描述符、内存空间的副本）。</td></tr><tr><td><strong>初始化PCB</strong></td><td>初始化PCB内容，包括进程状态设为“就绪”，设置优先级、调度信息等。</td><td>父进程创建子进程时，操作系统会为子进程初始化PCB并赋予初始状态。</td></tr><tr><td><strong>添加到队列</strong></td><td>将新创建的PCB插入到就绪队列中，等待调度程序选中执行。</td><td>父进程和子进程的PCB都被添加到就绪队列中，操作系统会调度执行。</td></tr></tbody></table><h4 id="2-进程执行阶段"><a href="#2-进程执行阶段" class="headerlink" title="2. 进程执行阶段"></a><strong>2. 进程执行阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>调度选择</strong></td><td>调度程序根据进程调度算法（如时间片轮转、优先级调度等），从就绪队列中选取合适进程。</td><td>父进程和子进程都在就绪队列中，操作系统根据调度算法选择其中一个进程执行。</td></tr><tr><td><strong>上下文切换</strong></td><td>- 保存当前运行进程的CPU状态（如寄存器内容、程序计数器）到PCB。- 恢复新进程的CPU状态。</td><td>在父进程和子进程之间，操作系统通过上下文切换保存和恢复进程的状态。</td></tr><tr><td><strong>执行控制</strong></td><td>CPU执行新进程的指令，同时操作系统监控该进程的运行，处理系统调用、中断等事件。</td><td>父进程和子进程在独立的进程空间中执行，操作系统管理并监控它们的运行。</td></tr></tbody></table><h4 id="3-进程阻塞阶段"><a href="#3-进程阻塞阶段" class="headerlink" title="3. 进程阻塞阶段"></a><strong>3. 进程阻塞阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>状态更新</strong></td><td>操作系统将进程的状态从“运行”改为“阻塞”，更新PCB中的状态字段。</td><td>父进程和子进程都可以进入阻塞状态，当它们等待资源或事件时，操作系统会更新其PCB。</td></tr><tr><td><strong>队列管理</strong></td><td>将进程从运行队列移至等待队列，等待资源或事件完成后重新激活。</td><td>被阻塞的父进程或子进程会被移至等待队列，直到事件触发后再次唤醒。</td></tr><tr><td><strong>资源释放</strong></td><td>在阻塞时释放占用的CPU资源，允许调度程序将CPU分配给其他就绪进程。</td><td>阻塞的进程（父进程或子进程）释放CPU资源，操作系统可调度其他进程执行。</td></tr></tbody></table><h4 id="4-进程唤醒阶段"><a href="#4-进程唤醒阶段" class="headerlink" title="4. 进程唤醒阶段"></a><strong>4. 进程唤醒阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>事件触发</strong></td><td>某事件（如I&#x2F;O完成、信号量释放）触发时，通知操作系统唤醒等待的进程。</td><td>子进程阻塞后，当事件触发时，操作系统会唤醒子进程，父进程也可以因为等待子进程结果而被唤醒。</td></tr><tr><td><strong>状态更新</strong></td><td>将进程状态从“阻塞”修改为“就绪”，并更新PCB。</td><td>被唤醒的进程（父进程或子进程）会更新其PCB状态为“就绪”。</td></tr><tr><td><strong>队列操作</strong></td><td>将该进程的PCB从等待队列移至就绪队列，等待调度程序再次选中运行。</td><td>父进程和子进程的PCB会移至就绪队列，等待操作系统再次调度。</td></tr></tbody></table><h4 id="5-进程终止阶段"><a href="#5-进程终止阶段" class="headerlink" title="5. 进程终止阶段"></a><strong>5. 进程终止阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>释放资源</strong></td><td>- 内存释放：释放分配给进程的内存区域。- 文件关闭：关闭进程打开的文件。</td><td>子进程在终止时，释放资源，父进程回收子进程的资源。</td></tr><tr><td><strong>更新PCB</strong></td><td>修改PCB状态为“终止”，从进程表中移除对应记录。</td><td>父进程可能需要处理子进程的终止，更新父进程的状态和资源。</td></tr><tr><td><strong>回收PID</strong></td><td>将进程ID (PID) 回收到操作系统的可用PID池中。</td><td>子进程终止后，其PID被回收，操作系统可分配给新创建的进程。</td></tr><tr><td><strong>通知父进程</strong></td><td>如果是子进程终止，向父进程发送通知（如信号）以处理终止后的资源回收。</td><td>操作系统通过信号（如 <code>SIGCHLD</code>）通知父进程子进程的终止，父进程可回收子进程的资源。</td></tr></tbody></table><h4 id="6-异常处理阶段"><a href="#6-异常处理阶段" class="headerlink" title="6. 异常处理阶段"></a><strong>6. 异常处理阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>中断触发</strong></td><td>当异常发生时，硬件触发中断信号，并将控制权交给操作系统内核的异常处理程序。</td><td>如果父进程或子进程发生异常，操作系统通过中断处理并决定是否终止进程。</td></tr><tr><td><strong>状态保存</strong></td><td>操作系统保存当前进程的状态，以便后续恢复或终止。</td><td>操作系统在处理父进程或子进程的异常时，保存进程状态并采取适当措施。</td></tr><tr><td><strong>异常处理</strong></td><td>- 执行适当的处理策略： 1. 终止进程（如访问非法内存）。 2. 恢复运行（如页错误处理）。</td><td>异常可能导致父进程或子进程的终止或恢复。</td></tr><tr><td><strong>日志记录</strong></td><td>操作系统记录异常信息（如错误码、进程ID）以供系统管理员或开发者调试。</td><td>异常处理日志有助于父进程和子进程的调试和故障排除。</td></tr></tbody></table><h4 id="其他进程创建方式"><a href="#其他进程创建方式" class="headerlink" title="其他进程创建方式"></a>其他进程创建方式</h4><table><thead><tr><th><strong>创建方式</strong></th><th><strong>描述</strong></th><th><strong>典型例子</strong></th></tr></thead><tbody><tr><td><strong>父进程创建子进程</strong></td><td>最常见的进程创建方式，父进程通过系统调用（如 <code>fork()</code> 或 <code>CreateProcess()</code>）创建子进程，子进程继承父进程的部分属性。</td><td>- Unix&#x2F;Linux：<code>fork()</code>- Windows：<code>CreateProcess()</code></td></tr><tr><td><strong>操作系统初始化进程</strong></td><td>操作系统在启动时直接创建一些基础进程，例如初始化进程（如 <code>init</code> 或 <code>systemd</code>）。</td><td>- Linux：<code>init</code> 或 <code>systemd</code>- Windows：<code>System</code></td></tr><tr><td><strong>内核进程</strong></td><td>内核或系统进程在启动时由操作系统内核直接创建，不依赖传统的父进程。这些进程通常由内核的初始化逻辑启动。</td><td>- Linux：<code>kthreadd</code>（内核线程）- Windows：内核线程</td></tr><tr><td><strong>线程创建</strong></td><td>线程是进程中的轻量级任务，线程由进程创建，但并非子进程。它们共享进程的资源，如内存空间和文件描述符。</td><td>- Linux&#x2F;Windows：线程由进程（父进程）创建，通常通过 <code>pthread_create()</code> 或 <code>CreateThread()</code> 调用。</td></tr><tr><td><strong>自身创建（自我复制）</strong></td><td>某些程序（如恶意软件或病毒）可能通过自身复制来创建新的进程，而不依赖任何特定的父进程。</td><td>- 恶意软件&#x2F;病毒通过 <code>fork()</code> 或其他方法自我复制。</td></tr></tbody></table><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步是指多个进程在并发执行时，为了避免由于共享资源访问冲突而导致的不一致性或错误，采取的一些技术手段和机制。进程同步的目的是确保多个进程在执行时能够协调一致地访问共享资源，以避免竞态条件（race condition）、数据不一致等问题。</p><blockquote><p>这一部分将在后来文章的并发部分介绍</p></blockquote><h2 id="进程通信（IPC）"><a href="#进程通信（IPC）" class="headerlink" title="进程通信（IPC）"></a>进程通信（IPC）</h2><p>进程通信主要解决的是 <strong>如何在不同进程之间传递信息或共享数据</strong>。当多个进程需要交换数据、共享资源时，操作系统提供不同的进程通信机制。</p><h3 id="1-管道（Pipe）"><a href="#1-管道（Pipe）" class="headerlink" title="1. 管道（Pipe）"></a>1. <strong>管道（Pipe）</strong></h3><p>Linux的管道机制允许一个进程的输出直接作为另一个进程的输入，从而实现进程间的通信（IPC）。管道有两种：无名管道和命名管道（FIFO）。无名管道通常用于具有亲缘关系的进程之间的通信（如父子进程），而命名管道可以用于任意两个进程之间的通信。</p><h4 id="管道的工作原理"><a href="#管道的工作原理" class="headerlink" title="管道的工作原理"></a>管道的工作原理</h4><p>管道在内核中创建一个缓冲区，一个进程可以向缓冲区写入数据，另一个进程可以从缓冲区读取数据。管道是单向的，即数据只能单方向流动。</p><p><img src="https://s2.loli.net/2024/05/29/WOejUv2nhb1Rqox.png" alt="20200730212919317"></p><h4 id="管道通信与共享内存通信有何区别？"><a href="#管道通信与共享内存通信有何区别？" class="headerlink" title="管道通信与共享内存通信有何区别？"></a>管道通信与共享内存通信有何区别？</h4><p>管道通信适用于有亲缘关系的进程，适合简单的数据传输；而共享内存通信适用于无亲缘关系的进程，适合大量数据共享和对性能要求较高的场景</p><h5 id="管道通信："><a href="#管道通信：" class="headerlink" title="管道通信："></a><strong>管道通信：</strong></h5><ol><li>管道是一种半双工的通信机制，只能在具有亲缘关系的进程之间使用（例如父子进程）。</li><li>管道是基于 I&#x2F;O 流的通信方式，数据写入管道的一端，从另一端读出。</li><li>管道通信是通过操作系统提供的管道文件进行的，可以是匿名管道（只存在于进程间）或命名管道（存在于文件系统中）。</li><li>管道通信适用于需要在两个相关进程之间进行简单数据传输的场景。</li></ol><p><strong>共享内存通信：</strong></p><ol><li>共享内存是一种进程间通信的机制，可以在无亲缘关系的进程之间使用。</li><li>共享内存允许多个进程访问同一块物理内存空间，因此可以实现高效的数据共享。</li><li>共享内存通信需要使用操作系统提供的共享内存 API，通过映射共享内存区域来实现进程间数据共享。</li><li>共享内存通信适用于需要大量数据交换且对性能要求较高的场景，因为它避免了数据复制的开销。</li></ol><h5 id="使用管道的步骤"><a href="#使用管道的步骤" class="headerlink" title="使用管道的步骤"></a>使用管道的步骤</h5><ol><li><strong>创建管道</strong>：使用 <code>pipe()</code> 系统调用创建一个无名管道。</li><li><strong>创建子进程</strong>：使用 <code>fork()</code> 创建子进程。</li><li><strong>重定向输入&#x2F;输出</strong>：使用 <code>dup2()</code> 将管道的读或写端重定向到标准输入或标准输出。</li><li><strong>关闭不需要的管道端</strong>：父进程和子进程都要关闭各自不需要使用的管道端。</li><li><strong>执行程序</strong>：使用 <code>execlp()</code> 或其他 <code>exec</code> 函数执行新程序。</li></ol><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello from parent process!&quot;</span>;<br><br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">if</span> (pipe(pipe_fd) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br><br>        <span class="hljs-comment">// 读取管道</span><br>        <span class="hljs-type">ssize_t</span> nbytes = read(pipe_fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// 打印读取到的消息</span><br>        buf[nbytes] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child received message: %s\n&quot;</span>, buf);<br><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br><br>        <span class="hljs-comment">// 写入管道</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[<span class="hljs-number">1</span>], msg, <span class="hljs-built_in">strlen</span>(msg)) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        wait(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>pipe()</code> 创建一个无名管道，<code>pipe_fd</code> 是一个包含两个文件描述符的数组，<code>pipe_fd[0]</code> 是读端，<code>pipe_fd[1]</code> 是写端。</p><p>在这个示例中没有使用 <code>dup2()</code> 重定向输入&#x2F;输出，而是直接使用文件描述符进行读写。你也可以通过 <code>dup2(pipe_fd[0], STDIN_FILENO)</code> 或 <code>dup2(pipe_fd[1], STDOUT_FILENO)</code> 来重定向标准输入&#x2F;输出。</p><p><strong>注意:当父进程fork()出子进程时，子进程会继承父进程的文件描述符。因此，子进程可以直接使用这些继承而来的文件描述符来读取或写入数据，从而与父进程进行通信。而无需使用<code>dup2()</code>来重定向输入&#x2F;输出。</strong></p><p>将管道的读端重定向到标准输入或将管道的写端重定向到标准输出是实现进程间通信的一种常见方式。这种方法可以实现多个进程之间的数据传输，而无需使用临时文件进行交换。</p><p>例如，如果一个进程需要从另一个进程中读取数据，可以通过将管道的读端重定向到标准输入来实现。这样，另一个进程输出的数据就会被发送到管道中，而第一个进程可以通过标准输入读取这些数据。</p><p>这种方法的好处在于，它提供了一种简单而高效的方式让不同的进程之间进行数据交换，而不需要创建临时文件或者复杂的通信协议。这对于实现诸如管道、重定向、过滤器等功能非常有用，同时也能够方便地实现进程间的通信和协作</p><h3 id="2-消息队列（Message-Queue）"><a href="#2-消息队列（Message-Queue）" class="headerlink" title="2. 消息队列（Message Queue）"></a>2. <strong>消息队列（Message Queue）</strong></h3><p>消息队列是一种允许进程以消息的形式进行通信的机制，多个进程可以向同一个队列中写入消息或从队列中读取消息。</p><ul><li>特点<ul><li>提供异步通信。</li><li>进程可以读取消息队列中的消息，或将消息发送到队列。</li><li>消息队列通常具有先进先出（FIFO）的顺序。</li></ul></li><li><strong>使用场景</strong>：适用于多个进程间异步交换数据的场景。</li></ul><h3 id="3-共享内存（Shared-Memory）"><a href="#3-共享内存（Shared-Memory）" class="headerlink" title="3. 共享内存（Shared Memory）"></a>3. <strong>共享内存（Shared Memory）</strong></h3><p>共享内存是一种允许多个进程访问同一块内存区域的通信方式。共享内存的读写操作直接在内存中进行，因此速度非常快。</p><ul><li>特点<ul><li>高效，因为直接操作内存而不需要通过内核。</li><li>需要同步机制（如互斥锁、信号量）来防止多个进程同时访问共享内存导致的数据竞争。</li></ul></li><li><strong>使用场景</strong>：适用于需要大量数据交换或频繁通信的进程。</li></ul><h3 id="4-信号量（Semaphore）"><a href="#4-信号量（Semaphore）" class="headerlink" title="4. 信号量（Semaphore）"></a>4. <strong>信号量（Semaphore）</strong></h3><p>信号量通常用于同步进程，它也可以用于进程间通信，特别是在控制资源访问时。信号量用于控制对共享资源的访问数量，通常配合其他IPC机制使用。</p><ul><li>特点<ul><li>可以用于同步多个进程的执行顺序。</li><li>信号量的值可以表示资源的数量或者进程的状态（如是否可继续执行）。</li></ul></li><li><strong>使用场景</strong>：用于控制访问资源的同步机制，常与其他IPC方式结合使用。</li></ul><h3 id="5-信号（Signal）"><a href="#5-信号（Signal）" class="headerlink" title="5. 信号（Signal）"></a>5. <strong>信号（Signal）</strong></h3><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="https://s2.loli.net/2024/05/29/lKU72cAyIfePCkz.png" alt="ef5085c798d54fc081611d0d488dfeb1"></p><blockquote><p><strong>信号</strong>：信号是 Linux 进程间通信的一种简单机制。它是由操作系统或进程向另一个进程发送的软件中断，用于通知进程发生了某种事件。</p><p><strong>信号处理程序</strong>：每个信号都与一个信号处理程序相关联，用于在收到信号时执行特定的操作。信号处理程序可以是预定义的函数，也可以是用户自定义的函数。</p><p><strong>信号的发送和接收</strong>：信号可以由内核、其他进程或进程自身发送。接收信号的进程可以选择忽略信号、执行默认操作或安装自定义的信号处理程序。</p><p><strong>常见的信号</strong>：Linux 系统定义了许多标准信号，如 SIGALRM（定时器到期）、SIGINT（终端中断）、SIGKILL（强制终止进程）等。</p><p><strong>信号的处理方式</strong>：每个进程都有一个信号处理表，记录了每个信号的处理方式。可以通过 <code>sigaction()</code> 函数来修改信号处理方式。</p><p><strong>信号的异步性</strong>：信号是异步事件，即进程可能在任何时刻接收到信号，而不一定是在某个特定的程序点。因此，编写信号处理程序时需要注意处理信号的竞态条件和可重入性。</p></blockquote><h5 id="使用Linux信号机制具体步骤："><a href="#使用Linux信号机制具体步骤：" class="headerlink" title="使用Linux信号机制具体步骤："></a>使用Linux信号机制具体步骤：</h5><ol><li><strong>定义信号处理程序</strong>：编写一个函数来处理特定的信号。</li><li><strong>注册信号处理程序</strong>：使用 <code>signal()</code> 或 <code>sigaction()</code> 函数将信号处理程序与特定的信号关联起来。</li><li><strong>触发信号</strong>：通过特定的操作或系统调用触发信号，或使用 <code>kill()</code> 函数向自己或其他进程发送信号。</li></ol><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 定义信号处理程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGINT) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGINT (Ctrl+C). Exiting gracefully...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sig == SIGALRM) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGALRM. Performing scheduled task...\n&quot;</span>);<br>        <span class="hljs-comment">// 在这里执行你需要的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注册信号处理程序</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    sa.sa_handler = signal_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    sigemptyset(&amp;sa.sa_mask);<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGINT handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGALRM handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个定时器，5秒后发送 SIGALRM 信号</span><br>    alarm(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 无限循环，等待信号</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for signals...\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-套接字（Socket）"><a href="#6-套接字（Socket）" class="headerlink" title="6. 套接字（Socket）"></a>6. <strong>套接字（Socket）</strong></h3><p>套接字是一种网络通信机制，允许在不同计算机或同一计算机上运行的不同进程之间进行通信。套接字支持不同协议（如 TCP&#x2F;IP、UDP等）。</p><ul><li>特点<ul><li>支持进程间通信，也支持跨机器的通信。</li><li>可以进行全双工通信，支持发送和接收。</li></ul></li><li><strong>使用场景</strong>：适用于跨网络或本地的进程间通信，广泛用于客户端-服务器架构中的通信。</li></ul><h3 id="7-内存映射文件（Memory-Mapped-Files）"><a href="#7-内存映射文件（Memory-Mapped-Files）" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）"></a>7. <strong>内存映射文件（Memory-Mapped Files）</strong></h3><p>内存映射文件是一种将磁盘上的文件映射到进程的虚拟内存空间的机制。多个进程可以映射同一个文件，进程通过读写内存区域来进行通信。</p><ul><li>特点<ul><li>允许多个进程通过共享的内存映射文件进行通信。</li><li>对文件的修改会立即反映到内存中，从而实现高效的进程间数据共享。</li></ul></li><li><strong>使用场景</strong>：适用于需要高效共享大数据量的场景。</li></ul><h3 id="8-远程过程调用（RPC）"><a href="#8-远程过程调用（RPC）" class="headerlink" title="8. 远程过程调用（RPC）"></a>8. <strong>远程过程调用（RPC）</strong></h3><p>远程过程调用允许进程调用其他计算机或同一计算机上运行的进程的过程。RPC的核心思想是将分布式系统中的调用抽象成“本地调用”，即使实际执行的代码是在远程主机上。</p><ul><li>特点<ul><li>通过代理方式，使得分布式系统中的进程可以像调用本地进程一样调用远程进程。</li><li>在调用过程中，调用者和被调用者可以通过网络通信。</li></ul></li><li><strong>使用场景</strong>：适用于分布式计算、微服务架构中的进程间通信。</li></ul><h3 id="9-管道与FIFO文件（FIFOs）"><a href="#9-管道与FIFO文件（FIFOs）" class="headerlink" title="9. 管道与FIFO文件（FIFOs）"></a>9. <strong>管道与FIFO文件（FIFOs）</strong></h3><p>FIFOs（命名管道）是一种特殊类型的文件，允许进程通过文件进行通信。不同于传统的文件，FIFOs是进程间通信的媒介，可以让一个进程向FIFO文件写数据，另一个进程从中读取。</p><ul><li>特点<ul><li>支持跨进程的通信。</li><li>使用FIFO文件时，进程之间不需要共享内存或使用复杂的同步机制。</li></ul></li><li><strong>使用场景</strong>：适用于跨进程通信的简便场景。</li></ul><h1 id="处理机调度算法"><a href="#处理机调度算法" class="headerlink" title="处理机调度算法"></a>处理机调度算法</h1><h3 id="1-先来先服务算法-FCFS"><a href="#1-先来先服务算法-FCFS" class="headerlink" title="1. 先来先服务算法 (FCFS)"></a>1. 先来先服务算法 (FCFS)</h3><p><strong>定义</strong>：<br>FCFS 是一种最简单的调度算法，按照进程到达就绪队列的顺序进行调度，即先到达的进程先执行。</p><p><strong>特点</strong>：</p><ul><li>非抢占式：一旦进程开始执行，直到完成才能被中断。</li><li>容易实现，但可能会导致长作业阻塞短作业的问题（即“太长的作业可能导致短作业的等待时间过长”）。</li></ul><p><strong>优缺点</strong>：</p><ul><li>优点：实现简单，容易理解。</li><li>缺点：可能导致“饥饿”现象，也即长作业可能一直得不到执行，尤其是在处理短作业的情况下。</li></ul><p>假设有 4 个进程，分别是 P1、P2、P3 和 P4，它们的到达时间和执行时间如下：</p><table><thead><tr><th>进程</th><th>到达时间</th><th>执行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>4</td></tr><tr><td>P2</td><td>1</td><td>3</td></tr><tr><td>P3</td><td>2</td><td>5</td></tr><tr><td>P4</td><td>3</td><td>2</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>根据 FCFS 算法，按照进程到达顺序依次执行。</li><li>进程 P1 到达时，CPU 空闲，因此 P1 开始执行，执行 4 个时间单位。</li><li>进程 P2 到达时，P1 正在执行，P2 等待，直到 P1 执行完。</li><li>进程 P2 执行 3 个时间单位。</li><li>然后 P3 执行 5 个时间单位，最后 P4 执行 2 个时间单位。</li></ul><p><strong>执行顺序</strong>：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>等待时间</strong>：</p><ul><li>P1：等待时间 &#x3D; 0</li><li>P2：等待时间 &#x3D; 4 - 1 &#x3D; 3</li><li>P3：等待时间 &#x3D; 7 - 2 &#x3D; 5</li><li>P4：等待时间 &#x3D; 12 - 3 &#x3D; 9</li></ul><hr><h3 id="2-短作业优先算法-SJF"><a href="#2-短作业优先算法-SJF" class="headerlink" title="2. 短作业优先算法 (SJF)"></a>2. 短作业优先算法 (SJF)</h3><p>SJF 基于每个进程的估计执行时间，选择执行时间最短的进程。它有两种形式：非抢占式和抢占式。</p><h4 id="2-1-非抢占式短作业优先-Non-preemptive-SJF"><a href="#2-1-非抢占式短作业优先-Non-preemptive-SJF" class="headerlink" title="2.1 非抢占式短作业优先 (Non-preemptive SJF)"></a>2.1 非抢占式短作业优先 (Non-preemptive SJF)</h4><p><strong>定义</strong>：<br>在非抢占式 SJF 中，调度选择就绪队列中最短的进程。如果一个进程正在执行，其他进程即使需要更短的时间，也要等到当前进程执行完才有机会执行。</p><p><strong>优缺点</strong>：</p><ul><li>优点：最小化平均等待时间。</li><li>缺点：可能会导致“长作业饥饿”现象。由于长作业总是被短作业抢占，导致长作业可能永远得不到执行。</li></ul><p>假设有相同的 4 个进程，它们的到达时间和执行时间如下：</p><table><thead><tr><th>进程</th><th>到达时间</th><th>执行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>4</td></tr><tr><td>P2</td><td>1</td><td>3</td></tr><tr><td>P3</td><td>2</td><td>5</td></tr><tr><td>P4</td><td>3</td><td>2</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>P1 到达时，CPU 空闲，执行 4 个时间单位。</li><li>到达时间顺序为 P1 → P2 → P3 → P4，但根据 SJF 算法，选择执行时间最短的进程。</li><li>P2 执行，时间为 3，接着是 P4 执行，时间为 2，最后 P3 执行，时间为 5。</li></ul><p><strong>执行顺序</strong>：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>等待时间</strong>：</p><ul><li>P1：等待时间 &#x3D; 0</li><li>P2：等待时间 &#x3D; 4 - 1 &#x3D; 3</li><li>P4：等待时间 &#x3D; 7 - 3 &#x3D; 4</li><li>P3：等待时间 &#x3D; 9 - 2 &#x3D; 7</li></ul><h4 id="2-2-抢占式短作业优先-Preemptive-SJF-SRTF"><a href="#2-2-抢占式短作业优先-Preemptive-SJF-SRTF" class="headerlink" title="2.2 抢占式短作业优先 (Preemptive SJF, SRTF)"></a>2.2 抢占式短作业优先 (Preemptive SJF, SRTF)</h4><p><strong>定义</strong>：<br>在抢占式 SJF 中，如果一个新的进程到达，并且其执行时间比当前执行的进程剩余的时间要短，那么当前进程会被抢占，新的进程将立即执行。</p><p><strong>优缺点</strong>：</p><ul><li>优点：能够保证短作业尽早完成，减少平均等待时间。</li><li>缺点：可能会增加上下文切换的次数，增加开销。</li></ul><p>假设 4 个进程的到达时间和执行时间如下：</p><table><thead><tr><th>进程</th><th>到达时间</th><th>执行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>4</td></tr><tr><td>P2</td><td>1</td><td>3</td></tr><tr><td>P3</td><td>2</td><td>5</td></tr><tr><td>P4</td><td>3</td><td>2</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>P1 开始执行，但在 P2 到达时，P2 的执行时间（3）比 P1 剩余的时间（3）短，因此 P1 被抢占，P2 执行。</li><li>P2 执行完后，P4 的执行时间为 2，比 P1 剩余的时间短，因此 P4 执行。</li><li>然后，P1 和 P3 执行。</li></ul><p><strong>执行顺序</strong>：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">P1 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>-<span class="hljs-number">1</span>)</span> -&gt;</span> P2 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>-<span class="hljs-number">4</span>)</span> -&gt;</span> P4 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>-<span class="hljs-number">6</span>)</span> -&gt;</span> P1 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">6</span>-<span class="hljs-number">7</span>)</span> -&gt;</span> P3 (<span class="hljs-number">7</span>-<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p><strong>等待时间</strong>：</p><ul><li>P1：等待时间 &#x3D; 6 - 0 - 4 &#x3D; 2</li><li>P2：等待时间 &#x3D; 1 - 1 &#x3D; 0</li><li>P3：等待时间 &#x3D; 7 - 2 &#x3D; 5</li><li>P4：等待时间 &#x3D; 4 - 3 &#x3D; 1</li></ul><hr><h3 id="3-优先调度算法-PSA"><a href="#3-优先调度算法-PSA" class="headerlink" title="3. 优先调度算法 (PSA)"></a>3. 优先调度算法 (PSA)</h3><p><strong>定义</strong>：<br>每个进程都会被分配一个优先级，调度器选择具有最高优先级的进程执行。</p><p><strong>特点</strong>：</p><ul><li>可以是抢占式或非抢占式。</li><li>优先级越高的进程优先执行。</li></ul><h4 id="3-1-非抢占式优先调度"><a href="#3-1-非抢占式优先调度" class="headerlink" title="3.1 非抢占式优先调度"></a>3.1 非抢占式优先调度</h4><ul><li>一旦一个进程开始执行，直到完成才会被其他进程抢占。</li><li>如果多个进程有相同的优先级，则使用 FCFS 算法。</li></ul><h4 id="3-2-抢占式优先调度"><a href="#3-2-抢占式优先调度" class="headerlink" title="3.2 抢占式优先调度"></a>3.2 抢占式优先调度</h4><ul><li>如果一个新到的进程的优先级高于当前正在执行的进程，则会发生抢占，新的进程将被调度执行。</li></ul><p><strong>优缺点</strong>：</p><ul><li>优点：优先级高的进程能够得到快速执行，适用于重要的任务。</li><li>缺点：低优先级的进程可能会长期等待，导致饥饿现象。</li></ul><p>假设有 4 个进程，它们的到达时间和执行时间如下，同时每个进程也有一个优先级（数字越大优先级越高）：</p><table><thead><tr><th>进程</th><th>到达时间</th><th>执行时间</th><th>优先级</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>4</td><td>2</td></tr><tr><td>P2</td><td>1</td><td>3</td><td>1</td></tr><tr><td>P3</td><td>2</td><td>5</td><td>4</td></tr><tr><td>P4</td><td>3</td><td>2</td><td>3</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>P1 到达时，CPU 空闲，开始执行。</li><li>P2 到达时，P1 正在执行，等待。</li><li>P3 到达时，它的优先级最高（4），因此抢占 P1 执行。</li><li>然后，P4 执行，最后 P1 和 P2 按顺序执行。</li></ul><p><strong>执行顺序</strong>：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>等待时间</strong>：</p><ul><li>P1：等待时间 &#x3D; 6 - 0 - 4 &#x3D; 2</li><li>P2：等待时间 &#x3D; 6 - 1 &#x3D; 5</li><li>P3：等待时间 &#x3D; 0</li><li>P4：等待时间 &#x3D; 4 - 3 &#x3D; 1</li></ul><h3 id="4-高响应比优先调度算法-HRRN"><a href="#4-高响应比优先调度算法-HRRN" class="headerlink" title="4. 高响应比优先调度算法 (HRRN)"></a>4. 高响应比优先调度算法 (HRRN)</h3><p><strong>定义</strong>：<br>HRRN 是基于响应比来调度进程的一种算法。响应比定义为： R&#x3D;Tw+TcTcR &#x3D; \frac{T_w + T_c}{T_c}R&#x3D;Tc​Tw​+Tc​​ 其中，TwT_wTw​ 是进程等待的时间，TcT_cTc​ 是进程的计算时间。HRRN 通过计算每个进程的响应比，选择响应比最高的进程执行。</p><p><strong>特点</strong>：</p><ul><li>响应比高的进程优先执行，响应比计算考虑了等待时间和计算时间，能够综合考虑进程的等待情况。</li><li>通过动态调整优先级来减少饥饿现象。</li></ul><p><strong>优缺点</strong>：</p><ul><li>优点：比优先级调度更公平，避免了“长作业饥饿”现象。</li><li>缺点：需要实时计算响应比，可能增加一些调度开销。</li></ul><p>假设有 4 个进程，它们的到达时间和执行时间如下：</p><table><thead><tr><th>进程</th><th>到达时间</th><th>执行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>4</td></tr><tr><td>P2</td><td>1</td><td>3</td></tr><tr><td>P3</td><td>2</td><td>5</td></tr><tr><td>P4</td><td>3</td><td>2</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>初始时，所有进程的响应比可以通过公式 <img src="https://s2.loli.net/2025/01/04/5SezB2FfjdOTKxr.png" alt="image-20250104162131081" style="zoom:50%;" /> 来计算（Tw 为等待时间，Tc为执行时间)。</li><li>开始时 P1 执行，因为它是第一个到达的。</li><li>随后 P2 和 P4 会根据响应比来选择优先执行。</li></ul><p><strong>计算响应比</strong>：</p><ul><li>初始：P1 &#x3D; 1.0, P2 &#x3D; 2.33, P3 &#x3D; 1.4, P4 &#x3D; 2.5</li><li>选择 P4 执行（响应比最大），接着选择 P2 和 P3。</li></ul><p><strong>执行顺序</strong>：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">rust<br><br><br>复制代码<br><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>平均等待时间</strong>： HRRN 通过计算响应比动态调整选择执行的进程，避免了长作业饥饿的现象。</p><h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h3 id="1-时间轮转调度算法-Round-Robin-RR"><a href="#1-时间轮转调度算法-Round-Robin-RR" class="headerlink" title="1. 时间轮转调度算法 (Round Robin, RR)"></a>1. 时间轮转调度算法 (Round Robin, RR)</h3><p><strong>定义</strong>：<br> 时间轮转调度算法是最常用的抢占式调度算法，特别适用于时间共享系统。在 RR 算法中，每个进程被分配一个时间片（time quantum），当进程执行完一个时间片后，如果它仍未完成，则被挂起并移到队列末尾等待下一次调度。调度器按照进程的顺序轮流分配 CPU。</p><p><strong>特点</strong>：</p><ul><li>每个进程的时间片相同，公平分配 CPU 时间。</li><li>适用于时间共享系统，如多用户系统。</li></ul><p><strong>优缺点</strong>：</p><ul><li>优点：公平性较好，每个进程都能在有限时间内获得 CPU 时间。</li><li>缺点：时间片的选择至关重要，过长可能导致效率低下，过短会导致过多的上下文切换。</li></ul><p><strong>示意图</strong>： 假设有 4 个进程 P1、P2、P3 和 P4，时间片大小为 2 单位时间，进程到达时间均为 0，执行时间如下：</p><table><thead><tr><th>进程</th><th>执行时间</th></tr></thead><tbody><tr><td>P1</td><td>5</td></tr><tr><td>P2</td><td>3</td></tr><tr><td>P3</td><td>6</td></tr><tr><td>P4</td><td>4</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>P1 执行 2 单位时间，剩余 3 单位时间。</li><li>P2 执行 2 单位时间，剩余 1 单位时间。</li><li>P3 执行 2 单位时间，剩余 4 单位时间。</li><li>P4 执行 2 单位时间，剩余 2 单位时间。</li><li>回到 P1，执行 2 单位时间，剩余 1 单位时间。</li><li>回到 P2，执行完毕，剩余 0 单位时间。</li><li>然后继续其他进程执行。</li></ul><p><strong>执行顺序</strong>：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">P1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>-<span class="hljs-number">2</span>)</span> -&gt;</span> P2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>-<span class="hljs-number">4</span>)</span> -&gt;</span> P3<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>-<span class="hljs-number">6</span>)</span> -&gt;</span> P4<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">6</span>-<span class="hljs-number">8</span>)</span> -&gt;</span> P1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">8</span>-<span class="hljs-number">10</span>)</span> -&gt;</span> P2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">10</span>-<span class="hljs-number">11</span>)</span> -&gt;</span> P3<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">11</span>-<span class="hljs-number">13</span>)</span> -&gt;</span> P4<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">13</span>-<span class="hljs-number">14</span>)</span> -&gt;</span> P3(<span class="hljs-number">14</span>-<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="2-多队列调度算法-Multilevel-Queue-Scheduling"><a href="#2-多队列调度算法-Multilevel-Queue-Scheduling" class="headerlink" title="2. 多队列调度算法 (Multilevel Queue Scheduling)"></a>2. 多队列调度算法 (Multilevel Queue Scheduling)</h3><p><strong>定义</strong>：<br> 多队列调度算法将进程划分为不同的队列，每个队列有不同的优先级。通常，高优先级队列执行时间短、交互性强的进程，低优先级队列执行长时间计算密集型的进程。调度器会根据进程的类型决定其所处的队列。</p><p><strong>特点</strong>：</p><ul><li>每个队列有不同的调度算法（例如：高优先级队列使用 RR，低优先级队列使用 FCFS）。</li><li>适用于需要将进程分配给不同类别的场景。</li></ul><p><strong>优缺点</strong>：</p><ul><li>优点：能有效区分不同类型的进程，保证响应时间。</li><li>缺点：难以平衡各队列的负载，可能导致某些队列的过载或空闲。</li></ul><p><strong>示意图</strong>： 假设有两个队列，一个用于交互性进程，一个用于批处理进程。</p><table><thead><tr><th>进程</th><th>队列</th><th>执行时间</th></tr></thead><tbody><tr><td>P1</td><td>高</td><td>3</td></tr><tr><td>P2</td><td>高</td><td>2</td></tr><tr><td>P3</td><td>低</td><td>6</td></tr><tr><td>P4</td><td>低</td><td>5</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>高优先级队列（交互进程）使用轮转调度算法执行。</li><li>低优先级队列（批处理进程）使用 FCFS 调度算法执行。</li></ul><p><strong>执行顺序</strong>：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> (高优先级队列)<br><span class="hljs-keyword">P</span><span class="hljs-number">3</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> (低优先级队列)<br></code></pre></td></tr></table></figure><hr><h3 id="3-多级反馈队列调度算法-Multilevel-Feedback-Queue-Scheduling"><a href="#3-多级反馈队列调度算法-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="3. 多级反馈队列调度算法 (Multilevel Feedback Queue Scheduling)"></a>3. 多级反馈队列调度算法 (Multilevel Feedback Queue Scheduling)</h3><p><strong>定义</strong>：<br> 多级反馈队列调度算法是多队列调度的扩展，它允许进程根据其行为在不同的队列之间移动。当进程需要更多 CPU 时间时，它将被移动到较低优先级的队列；如果进程表现为短作业，它会被移到较高优先级的队列。这种算法结合了时间共享和优先级调度的优点。</p><p><strong>特点</strong>：</p><ul><li>动态调整进程的队列优先级。</li><li>适用于处理多种类型的进程（短作业、长作业、交互式进程等）。</li></ul><p><strong>优缺点</strong>：</p><ul><li>优点：能够根据进程的行为动态调整队列，避免了饥饿现象。</li><li>缺点：算法较复杂，配置不当可能会导致不稳定性。</li></ul><p><strong>示意图</strong>： 假设有 3 个队列，分别对应不同的优先级和调度算法。</p><table><thead><tr><th>进程</th><th>执行时间</th><th>初始队列</th><th>优先级</th></tr></thead><tbody><tr><td>P1</td><td>3</td><td>队列 1</td><td>1</td></tr><tr><td>P2</td><td>6</td><td>队列 2</td><td>2</td></tr><tr><td>P3</td><td>2</td><td>队列 1</td><td>1</td></tr><tr><td>P4</td><td>8</td><td>队列 3</td><td>3</td></tr></tbody></table><p><strong>执行过程</strong>：</p><ul><li>P1 和 P3 先进入队列 1，并使用 RR 调度。</li><li>P2 进入队列 2，并使用 FCFS 调度。</li><li>P4 进入队列 3，并使用 FCFS 调度。</li><li>如果 P1 和 P3 仍未完成，它们会被转移到较低优先级队列。</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>具体参考：</p><p><a href="https://www.cnblogs.com/wkfvawl/p/11598647.html">操作系统——死锁的概念以及死锁处理策略 - 王陸 - 博客园</a></p><p>资源分配化简</p><p>具体参考：</p><p>[<a href="https://www.cnblogs.com/joiln/p/10253288.html">转]操作系统-资源分配图化简法 - 仔仔的棒棒糖 - 博客园</a></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/2201_75475240/article/details/137777008">【操作系统】7种进程调度算法，及其甘特图的绘制（练习markdown画图）_模拟操作系统进程调度相关算法代码图片-CSDN博客</a></p><p><a href="https://developer.aliyun.com/article/1460903">《操作系统》—— 处理机调度算法-阿里云开发者社区</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="没有内存抽象的年代"><a href="#没有内存抽象的年代" class="headerlink" title="没有内存抽象的年代"></a>没有内存抽象的年代</h1><h2 id="管理方式："><a href="#管理方式：" class="headerlink" title="管理方式："></a>管理方式：</h2><p>程序直接访问和操作的都是物理内存，内存的管理也非常简单，除去操作系统所用的内存之外，全部给用户程序使用，想怎么折腾都行，只要别超出最大的容量。比如当执行如下指令时：mov reg,1000</p><h2 id="带来的问题："><a href="#带来的问题：" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>使得操作系统中存在多进程变得完全不可能，因为如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址1000赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。</p><h1 id="进行抽象-地址空间"><a href="#进行抽象-地址空间" class="headerlink" title="进行抽象:地址空间"></a>进行抽象:地址空间</h1><h2 id="管理方式：-1"><a href="#管理方式：-1" class="headerlink" title="管理方式："></a>管理方式：</h2><p>操作系统给每个进程划分一个区段，把进程对应的内存依旧留在物理内存中，需要的时候就切换到特定的区域。该区域就是操作系统需要对物理内存做一层抽象，也就是「地址空间」，一个进程的地址空间包含了该进程所有相关内存，比如 code &#x2F; stack &#x2F; heap。</p><img src="https://s2.loli.net/2024/12/19/g4KvQb2HiBRXhDZ.png" alt="image-20241219212225816" style="zoom:50%;" /><p><strong>值得注意的是：当程序运行时，heap 和 stack 共用中间 free 的区域</strong></p><p>这里描述的是操作系统提供给运行程序的抽象（abstract）。程序不在物理地址0～16KB的内存中，而是加载在任意的物理地址。当操作系统这样做时，我们说操作系统在虚拟化内存（virtualizing memory），因为运行的程序认为它被加载到特定地址（例如0）的内存中，并且具有非常大的地址空间（例如32位或64位）。现实很不一样。这给该进程应用一种假象：自己独占整个操作系统内存。</p><p>真实的物理内存可能是这样的：</p><img src="https://s2.loli.net/2024/12/19/oAe9GuFCrVI8vw1.png" alt="image-20241219213017762" style="zoom:50%;" /><blockquote><p>虚拟内存三个目标：透明，效率，隔离保护</p></blockquote><p>其中从操作系统从虚拟内存映射到物理内存上时，使用基址寄存器base 和 界限寄存器bounds 可以简单的动态重定位：每个内存地址送到内存之前，都会自动加上基址寄存器的内容。，base 指明从哪里开始，bounds 指定哪里是边界。 因此真实物理地址和虚拟地址之间的关系是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">physical address = <span class="hljs-keyword">virtual</span> address + base<br></code></pre></td></tr></table></figure><p>有时，CPU 上用来做内存地址翻译的也会被叫做「内存管理单元 MMU」</p><h2 id="带来的问题：-1"><a href="#带来的问题：-1" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>抽象虽然解决了多进程覆盖的问题，但可以看到：栈和堆之间，有一大块“空闲”空间。如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。这种基址加界限的方式看来并不像我们期望的那样灵活。</p><h1 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址&#x2F;界限"></a>分段：泛化的基址&#x2F;界限</h1><h2 id="管理方式：-2"><a href="#管理方式：-2" class="headerlink" title="管理方式："></a>管理方式：</h2><p>在MMU中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有 3个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</p><img src="https://s2.loli.net/2024/12/19/yRn1ZmDSaQzK5iP.png" alt="image-20241219214240193" style="zoom: 33%;" /><p>在这其中操作系统使用MMU中的硬件结构来支持分段，使用一组多对基址和界限寄存器。表每个界限寄存器记录了一个段的大小进行管理。</p><p><img src="https://s2.loli.net/2024/12/19/Q7NT9DJR8iEVbua.png" alt="image-20241219214616230"></p><p>段式管理的地址变换如下：</p><p><img src="https://s2.loli.net/2024/12/19/s9A1nWe4zUBTdtg.png" alt="image-20241219214644880"></p><p>栈的管理可以使其反向增长即硬件还需要知道段的增长方向（用一位区分，比如1代表自小而大增长，0反之）。</p><p><img src="https://s2.loli.net/2024/12/19/yVCudXBlvZWOjAb.png" alt="image-20241219215036017"></p><p>随着分段机制的不断改进，为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。</p><p><img src="https://s2.loli.net/2024/12/19/QqbwIY4Rc7Bn6xW.png" alt="image-20241219215126644"></p><p>有了保护位，前面描述的硬件算法也必须改变。除了检查虚拟地址是否越界，硬件还需要检查特定访问是否允许。如果用户进程试图写入只读段，或从非执行段执行指令，硬件会触发异常，让操作系统来处理出错进程。</p><h2 id="带来的问题：-2"><a href="#带来的问题：-2" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>分段虽然大量节省了栈和堆之间没有使用的区域的内存，但也带来了新的问题：</p><p>1.操作系统在上下文切换时应该做什么？即：各个段寄存器中的内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进程运行前，确保这些寄存器被正确地赋值。</p><p>2.管理物理内存的空闲空间。新的地址空间被创建时，操作系统需要在物理内存中为它的段找到空间。之前，我们假设所有的地址空间大小相同，物理内存可以被认为是一些槽块，进程可以放进去。现在，每个进程都有一些段，每个段的大小也可能不同。</p><p>3.分段使物理内存很快充满了许多空闲空间的小洞，因而很难分配给新的段，或扩大已有的段。这种问题被称为<strong>外部碎片</strong></p><img src="https://s2.loli.net/2024/12/19/95MYxJav2tR3lPC.png" alt="image-20241219215544783" style="zoom:25%;" /><p>这里的空闲内存的管理有许多方法，请自行百度</p><h1 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h1><h2 id="管理方式：-3"><a href="#管理方式：-3" class="headerlink" title="管理方式："></a>管理方式：</h2><p>在分段中，随着时间推移将空间切成不同长度的分片以后，空间本身会碎片化（fragmented），分配内存会变得比较困难。这就引出了页式存储：<strong>将空间分割成固定长度的分片</strong>在虚拟内存中，我们称这种思想为分页。分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。</p><img src="https://s2.loli.net/2024/12/19/gpzJwLlqhfS6RMF.png" alt="image-20241219220325363" style="zoom:25%;" /><blockquote><p>技术难点：如何通过页来实现虚拟内存，从而避免分段的问题？基本技术是什么？如何让这些技术运行良好，并尽可能减少空间和时间开销？</p></blockquote><p>通过完善的分页方法，操作系统能够高效地提供地址空间的抽象，不管进程如何使用地址空间。例如，我们不会假定堆和栈的增长方向，以及它们如何使用。另一个优点是分页提供的空闲空间管理的简单性。例如，如果操作系统希望将64字节的小地址空间放到8 页的物理地址空间中，它只要找到4个空闲页。也许操作系统保存了一个所有空闲页的空闲列表（free list），只需要从这个列表中拿出4个空闲页。</p><img src="https://s2.loli.net/2024/12/19/FmvwQhTAifotZzu.png" alt="image-20241219220601987" style="zoom:25%;" /><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。</p><img src="https://s2.loli.net/2024/12/19/xF1zUfctZ65V9YB.png" alt="image-20241219220707385" style="zoom:25%;" /><h3 id="页表带来的问题"><a href="#页表带来的问题" class="headerlink" title="页表带来的问题"></a>页表带来的问题</h3><p>页表带来了一个问题：页表可以变得非常大，因此消耗的内存太多</p><p>由于页表如此之大，我们没有在MMU中利用任何特殊的片上硬件，来存储当前正在运行的进程的页表，而是将每个进程的页表存储在内存中。</p><img src="https://s2.loli.net/2024/12/19/rOUL5Vd8zGEJ3TF.png" alt="image-20241219221140011" style="zoom:25%;" /><p>解决方法有很多比如：</p><ul><li>混合方法：分页和分段</li><li>多级页表</li><li>反向页表</li><li>将页表交换到磁盘</li></ul><p>详细可自行百度</p><h3 id="页式管理地址变换"><a href="#页式管理地址变换" class="headerlink" title="页式管理地址变换"></a>页式管理地址变换</h3><p>在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。</p><p>原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。</p><p>逻辑页号，页内偏移地址－&gt;查进程页表，得物理页号－&gt;物理地址：</p><img src="https://s2.loli.net/2024/12/19/QVSgG42OWY9UANu.jpg" alt="v2-6fd0dc83a485be4df41e8f26a22d5217_1440w" style="zoom: 50%;" /><h3 id="分页带来的另一个问题："><a href="#分页带来的另一个问题：" class="headerlink" title="分页带来的另一个问题："></a>分页带来的另一个问题：</h3><p>使用分页作为核心机制来实现虚拟内存，可能会带来较高的性能开销。因为要使用分页，就要将内存地址空间切分成大量固定大小的单元（页），并且需要记录这些单元的地址映射信息。因为这些映射信息一般存储在物理内存中，所以在转换虚拟地址时，分页逻辑上需要一次额外的内存访问。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受。因此我们面临如下问题：如何加速地址转换如何才能加速虚拟地址转换，尽量避免额外的内存访问？</p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>添加硬件(具有并行查找能力的高速缓冲存储器——快表)所谓的地址转换旁路缓冲存储器（translation-lookaside buffer，TLB[CG68,C95]），它就是频繁发生的虚拟到物理地址转换的硬件缓存（cache）,用来存放当前访问的若干页表项,以加速地址变换的过程。与此对应，主存中的页表也常称为慢表，配有快表的地址变换机对每次内存访问。硬件先检查TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表（其中有全部的转换映射）。</p><p><img src="https://s2.loli.net/2024/12/19/vISmptgqeYFz2Ao.png" alt="727485-20210705142341111-31060538"></p><p>在具有快表的分页机制中，地址的变换过程：</p><ul><li>CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。</li><li>如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li></ul><p>注意：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。</p><h1 id="超越物理内存"><a href="#超越物理内存" class="headerlink" title="超越物理内存"></a>超越物理内存</h1><h2 id="如何超越物理内存？【硬盘交互机制】"><a href="#如何超越物理内存？【硬盘交互机制】" class="headerlink" title="如何超越物理内存？【硬盘交互机制】"></a>如何超越物理内存？【硬盘交互机制】</h2><p>交换空间</p><h2 id="如何决定踢出哪个页？"><a href="#如何决定踢出哪个页？" class="headerlink" title="如何决定踢出哪个页？"></a>如何决定踢出哪个页？</h2><p>替换策略</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2023/01/10/%E6%A0%91(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/"/>
    <url>/2023/01/10/%E6%A0%91(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>将早年在知乎上的文章搬运于此</p></blockquote><p>*<strong>树的由来和作用*</strong></p><blockquote><p>作为一种抽象数据结构，树的概念最早可追溯到图论和数学中的树结构，被数学家用来描述分层结构。而在计算机科学发展中，树最初被引入用于描述文件系统的组织结构，其随着计算机发展，进一步被推广到其他邻域。<br>在树的发展过程中不难发现：计算机中树的设计初衷是为了提供一种高效、可扩展且有层次关系的数据组织方式。例如：结合树的特性可以有效解决：1，基于数组实现的顺序表的增删慢，2，基于链表实现的顺序表的查询慢</p></blockquote><p><img src="https://pic1.zhimg.com/v2-5b871366b4b6bfb81bff004b6f2100aa_1440w.jpg" alt="img"></p><p>图1：普通树</p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是有（n&gt;0）个节点的有限集合，当n&#x3D;0时，为空树，在任意一颗非空树中理应满足：</p><p>1，有且只有一个特定节点被称为根节点</p><p>2，当n&gt;1时（除去根节点外），又有m（m&gt;0）个的节点的有限集合，这m个节点集合本身又是一棵树，被称为根的子树。</p><p>又该定义可以看出树是递归的（定义中包含了本身）。诚然，树本身就是一个递归的抽象数据结构。在树的由来中我们看到树具有分层的逻辑作用，具有两个特点：</p><p>1，根节点没有前驱，除去之外每个节点都只有一个前驱</p><p>2，每个节点都有&gt;&#x3D;1的后驱</p><hr><h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><blockquote><p>祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）<br>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点<br>兄弟节点：拥有共同父节点的节点互称为兄弟节点<br>子节点：一个节点含有的子树的根节点称为该节点的子节点<br>后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）<br>节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推<br>度：节点的子树数目就是节点的度<br>叶子节点：度为零的节点就是叶子节点<br>节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推<br>节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度<br>树的深度：一棵树中节点的最大深度就是树的深度，也称为高度<br>森林：m颗互不相交的树构成的集合就是森林</p></blockquote><hr><h2 id="树的存储结构（实现）"><a href="#树的存储结构（实现）" class="headerlink" title="树的存储结构（实现）"></a>树的存储结构（实现）</h2><h3 id="1，双亲表示法"><a href="#1，双亲表示法" class="headerlink" title="1，双亲表示法"></a>1，双亲表示法</h3><p>双亲表示法采用顺序表（数组）存储普通树，其实现的核心思想是：顺序存储各节点的同时，给节点附加一个记录其父节点位置的变量</p><blockquote><p>注意：根节点没有父节点（父节点又称为双亲节点），故一般将根节点记录父节点的变量置为-1</p></blockquote><p><img src="https://pic4.zhimg.com/v2-e4ba14e739006a6b418d2ed7bc6b93eb_b.webp" alt="动图"></p><p>图2 ：双亲表示法存储普通树示意图</p><p>将图2转化为c语言代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_size 20<span class="hljs-comment">//树的最大节点数量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> DataType;<span class="hljs-comment">//数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Snode</span>//节点的结构</span><br><span class="hljs-class">&#123;</span><br>    DataType data;<br>    <span class="hljs-type">int</span> parent;<br>&#125;Pnode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>//树的结构</span><br><span class="hljs-class">&#123;</span><br>   Pnode tnode[max_size];<br>   <span class="hljs-type">int</span> r,n;<span class="hljs-comment">//根的位置下标和节点数</span><br>&#125;Ptree;<br><span class="hljs-comment">//双亲表示法存储树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitPNode</span><span class="hljs-params">(PTree* tree)</span><br>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输出节点个数:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;((*tree).n));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入结点的值其双亲位于数组中的位置下标:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; (*tree).n; i++)<br>    &#123;<br>        getchar();<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %d&quot;</span>, &amp;ch, &amp;j);<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span>) &#123;<br>            (*tree).r = i;<br>        &#125;<br>        (*tree).tnode[i].data = ch;<br>        (*tree).tnode[i].parent = j;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//以该法找某个节点的父结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">findparent</span><span class="hljs-params">(Ptree tree)</span><br>&#123;<br>   <span class="hljs-type">char</span> a;<br>   <span class="hljs-type">int</span> isfind=<span class="hljs-number">0</span>,ap,i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入孩子结点的值:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*[^\n]&quot;</span>); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*c&quot;</span>);<span class="hljs-comment">//清空输入缓冲区</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;a);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;tree.n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(tree.tnode[i].data==a)<br>        &#123;<br>           ad=tree.tnode[i].parent;<br>           isfind=<span class="hljs-number">1</span>;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c 的父节点为 %c,存储位置下标为 %d\n&quot;</span>, a, tree.tnode[ad].data, ad);<br>           <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>   <span class="hljs-keyword">if</span> (isfind == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;树中无此节点\n&quot;</span>);<br>    &#125; <br>&#125;<br><br><span class="hljs-comment">//以该法找某节点的孩子节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindChilds</span><span class="hljs-params">(PTree tree)</span><br>&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">int</span> isfind = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要父亲结点的值:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*[^\n]&quot;</span>); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*c&quot;</span>);<span class="hljs-comment">//清空输入缓冲区</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;a);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;tree.n;i++)<br>    &#123;<br>       <span class="hljs-keyword">if</span>(tree.tnode[i]==a)<br>       &#123; <br>           <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;tree.n;j++)<br>           &#123;<br>               <span class="hljs-keyword">if</span>(tree.tnode[j].parent==i)<br>               &#123;<br>                   isfind = <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c 是 %c 的孩子\n&quot;</span>, tree.tnode[j].data, a);<br>               &#125;<br>           &#125;<br>            <span class="hljs-keyword">if</span> (isfind == <span class="hljs-number">0</span>) <br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c没有孩子结点\n&quot;</span>, a);<br>            &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此观之：双亲表示法在存储空间上较为高效（使用一个一维数组来存储所有节点的数据），但它在某些操作（如查找子节点）上的效率相对较低（需要遍历整个数组）。</p><h3 id="2，孩子表示法"><a href="#2，孩子表示法" class="headerlink" title="2，孩子表示法"></a>2，孩子表示法</h3><p>孩子表示法存储普通树采用“数组+链表”的组合结构。其存储过程是：从树的根节点开始，使用顺序表依次存储各个节点，与双亲表示法不同的是：孩子表示法会给各个节点配备一个链表，用来存储各节点的孩子节点位于顺序表中的位置。</p><blockquote><p>如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。</p></blockquote><p><img src="https://picx.zhimg.com/v2-dbbf5aca02ba65b6d923c3fb8e16cb7b_b.jpg" alt="动图封面"></p><p>图3：孩子表示法存储普通树示意图</p><p>为此要设计：</p><p><img src="https://pic2.zhimg.com/v2-919838668e17e18db7d1f1ebbb23d2d9_1440w.jpg" alt="img"></p><p>孩子链表的孩子节点</p><p><img src="https://pic4.zhimg.com/v2-4c519028cff218b25f787faf7a97af55_1440w.jpg" alt="img"></p><p>表头数组的表头节点</p><p>将图3转化为C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_size 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DataType char</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTnode</span> //设计孩子节点</span><br><span class="hljs-class">&#123;</span><br>   <span class="hljs-type">int</span> child;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTnode</span>* <span class="hljs-title">next</span>;</span> <br>&#125;ChildPtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>//表头节点</span><br><span class="hljs-class">&#123;</span><br>   DataType data;<br>   ChildPtr* firstchild;<br>&#125;CTbox;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class"> &#123;</span><br>    CTbox nodes[max_size];<span class="hljs-comment">///存储结点的数组</span><br>    <span class="hljs-type">int</span> n,r;<span class="hljs-comment">//节点数量和根的位置</span><br> &#125;Ctree;<br><br><span class="hljs-comment">//孩子表示法存储普通树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">initTree</span><span class="hljs-params">(CTree* tree)</span> &#123;<br>    <span class="hljs-type">int</span> i, num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从根结点开始输入各个结点的值：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tree-&gt;n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--输入第 %d 个节点的值：&quot;</span>, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;(tree-&gt;nodes[i].data));<br>        tree-&gt;nodes[i].firstchild = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----输入节点 %c 的孩子节点数量：&quot;</span>, tree-&gt;nodes[i].data);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>        <span class="hljs-keyword">if</span> (num != <span class="hljs-number">0</span>) &#123;<br>            tree-&gt;nodes[i].firstchild = (ChildPtr*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ChildPtr));<br>            tree-&gt;nodes[i].firstchild-&gt;next = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------输入第 1 个孩子结点在顺序表中的位置：&quot;</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(tree-&gt;nodes[i].firstchild-&gt;child));<br>            ChildPtr* p = tree-&gt;nodes[i].firstchild;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; num; j++) &#123;<br>                ChildPtr* newEle = (ChildPtr*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ChildPtr));<br>                newEle-&gt;next = <span class="hljs-literal">NULL</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------输入第 %d 个孩子节点在顺序表中的位置：&quot;</span>, j + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(newEle-&gt;child));<br>                p-&gt;next = newEle;<br>                p = p-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*[^\n]&quot;</span>); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*c&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//找某个结点的孩子</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">findKids</span><span class="hljs-params">(CTree tree, <span class="hljs-type">char</span> a)</span> &#123;<br>    <span class="hljs-type">int</span> i, hasKids = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tree.n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (tree.nodes[i].data == a) &#123;<br>            ChildPtr* p = tree.nodes[i].firstchild;<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                hasKids = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, tree.nodes[p-&gt;child].data);<br>                p = p-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (hasKids == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;此节点为叶子节点&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 查找节点的双亲节点</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findParent</span><span class="hljs-params">(Ctree tree, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tree.n; i++) &#123;<br>        ChildPtr* childPtr = tree.nodes[i].firstchild;<br>        <span class="hljs-keyword">while</span> (childPtr != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (childPtr-&gt;child == target) <br>            &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            childPtr = childPtr-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 找不到双亲节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由此观之：孩子表示法在存储空间节省、操作灵活等方面有优势（查找子节点方便，易进行节点的插入、删除等操作），但在查找父节点和遍历效率方面存在一定的局限性。</p><blockquote><p>扩展知识：双亲表示法和孩子表示法优缺互补，我们可以将两者合二为一。</p></blockquote><p><img src="https://picx.zhimg.com/v2-e4e288903f2bc99f8f4dd5cfee1340fd_b.jpg" alt="动图封面"></p><p>双亲孩子表示法</p><p>该结构既能快速找到指定节点的父节点，又能快速找到指定节点的孩子节点。该结构的实现方法很简单，只需整合这两节的代码即可，这里不再赘述。</p><h3 id="3，孩子兄弟表示法（二叉树表示法）"><a href="#3，孩子兄弟表示法（二叉树表示法）" class="headerlink" title="3，孩子兄弟表示法（二叉树表示法）"></a>3，孩子兄弟表示法（二叉树表示法）</h3><p>当我们不从上述双亲和孩子的角度出发，继续观察图1那颗普通树，会发现：其任意一棵树， 它的结点的<strong>第一个孩子</strong>和其<strong>右兄弟</strong>如果存在就是唯一的。实现方法便呼之欲出了：<strong>从树的根节点开始，依次存储各个结点的孩子结点和兄弟结点。</strong></p><p><img src="https://pic1.zhimg.com/v2-987cf52e33bf18680d0577d162b6263a_1440w.jpg" alt="img"></p><p>节点结构</p><p>节点设计包括三大部分：</p><ol><li>节点的值；</li><li>指向孩子结点的指针；</li><li>指向兄弟结点的指针；</li></ol><p><img src="https://picx.zhimg.com/v2-3c109ee7a85a38cf0fdce85bb5c579e9_b.jpg" alt="动图封面"></p><p>图4：孩子兄弟表示法</p><p>在以孩子兄弟表示法构建的二叉链表中，如果要查找结点 x 的所有孩子，则只要根据该结点的 firstchild 指针找到它的第一个孩子，然后沿着孩子结点的 nextsibling 指针不断地找它的兄弟结点，就可以找到结点 x 的所有孩子。</p><p>用 C 语言代码表示图4为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElemType char</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span>//节点结构</span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> * <span class="hljs-title">firstchild</span>,*<span class="hljs-title">nextsibling</span>;</span><br>&#125;CSNode,*CSTree;<br><br><span class="hljs-comment">// 创建新节点</span><br>CSTree <span class="hljs-title function_">createNode</span><span class="hljs-params">(ElemType data)</span> &#123;<br>    CSTree newNode = (CSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(CSNode));<br>    newNode-&gt;data = data;<br>    newNode-&gt;firstchild = <span class="hljs-literal">NULL</span>;<br>    newNode-&gt;nextsibling = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br><br><span class="hljs-comment">// 插入子节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertChild</span><span class="hljs-params">(CSTree parent, CSTree child)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">NULL</span> || child == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (parent-&gt;firstchild == <span class="hljs-literal">NULL</span>) &#123;<br>        parent-&gt;firstchild = child;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        CSTree sibling = parent-&gt;firstchild;<br>        <span class="hljs-keyword">while</span> (sibling-&gt;nextsibling != <span class="hljs-literal">NULL</span>) &#123;<br>            sibling = sibling-&gt;nextsibling;<br>        &#125;<br>        sibling-&gt;nextsibling = child;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找节点的双亲节点</span><br>CSTree <span class="hljs-title function_">findParent</span><span class="hljs-params">(CSTree root, CSTree target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || target == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    CSTree parent = <span class="hljs-literal">NULL</span>;<br>    CSTree current = root-&gt;firstchild;<br><br>    <span class="hljs-comment">// 遍历子节点链表，找到目标节点的父节点</span><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (current == target) &#123;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>        parent = current;<br>        current = current-&gt;nextsibling;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归查找目标节点的父节点</span><br>    current = root-&gt;firstchild;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        parent = findParent(current, target);<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> parent;<br>        &#125;<br>        current = current-&gt;nextsibling;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由图1转化图4，显然，通过孩子兄弟表示法，任意一棵复杂的普通树都可以相应转化为一棵二叉树，它们是一一对应的。</p><p>何为二叉树？</p><hr><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是一种有序树，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒（颠倒后的树是另一颗完全不同的树，即使是只有一个子树）。</p><p>作为树的一种，二叉树也是用递归定义的，二叉树是n(n&gt;0)个结点的集合：</p><ol><li>或者为空二叉树，即n&#x3D;0。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li></ol><p>简单理解满足以下条件就是二叉树：</p><ol><li>本身是有序树；</li><li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</li></ol><p><img src="https://pica.zhimg.com/v2-d6f2f6f4e2b623eb9f3a6bd29205dade_1440w.jpg" alt="img"></p><p>二叉树的五种基本形态图</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol><li>二叉树中，第 i 层最多有 2i−1 个结点。</li><li>如果二叉树的深度为 K，那么此二叉树最多有 2k−1 个结点。</li><li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0&#x3D;n2+1。</li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><blockquote><p>开始之前先简单介绍<strong>完全二叉树。</strong>完全二叉树是一棵满足以下条件的二叉树：<br>1，所有非叶子节点都有两个子节点，包括最后一层的非叶子节点。<br>2，最后一层的叶子节点都集中在左侧连续位置。</p></blockquote><p><em>【1】顺序存储结构</em></p><p>二叉树的存储结构就是用<strong>一维数组</strong>存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的<strong>逻辑关系</strong>，比如双亲与孩子之间的关系，左右兄弟之间的关系等。</p><p>首先看一下<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">完全二叉树</a>的顺序存储，如图：</p><p><img src="https://picx.zhimg.com/v2-1b7a5d09c14684fead1d5d2df49f7823_1440w.jpg" alt="img"></p><p>图1-1</p><p>将这颗完全二叉树存储在数组中，相应的下标对应其同样的位置，如图1-2所示</p><p><img src="https://pic3.zhimg.com/v2-a88133b75b1aa1155be3a0e532073706_1440w.jpg" alt="img"></p><p>图1-2</p><p>当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把存在的结点设置为“^”而已。如图1-3中，注意浅色结点表示不存在。</p><p><img src="https://picx.zhimg.com/v2-107ba3122dff8c86f72400f922786549_1440w.jpg" alt="img"></p><p>图1-3</p><p>极端的情况，一颗深度为k的右斜树，他只有k个结点，却需要分配 2k−1 个存储单元，这显然是对存储空间的浪费，<strong>所以顺序存储结构一般只用于完全二叉树</strong>。</p><p><em>【链式存储结构】</em></p><p><em>既然顺序存储结构适用性不强，那就考虑链式存储结构，由于</em>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p><p><img src="https://pica.zhimg.com/v2-bcb3140fa1b5e94c93ca1721e6ec0b74_1440w.jpg" alt="img"></p><p>data是数据域，lchild和rchild是是指针域，分别存放指向左孩子和右孩子的指针</p><p>二叉链表的结点结构定义代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinaryTreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> data;  <span class="hljs-comment">// 节点存储的数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinaryTreeNode</span>* <span class="hljs-title">left</span>;</span>  <span class="hljs-comment">// 左子节点指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinaryTreeNode</span>* <span class="hljs-title">right</span>;</span>  <span class="hljs-comment">// 右子节点指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>结构示意图：</p><p><img src="https://pica.zhimg.com/v2-fc27d82696a699f8996ac548499b0a52_1440w.jpg" alt="img"></p><h3 id="二叉树的简单分类"><a href="#二叉树的简单分类" class="headerlink" title="二叉树的简单分类"></a>二叉树的简单分类</h3><p>1，满二叉树（Full Binary Tree）：在满二叉树中，除了叶子节点外的所有节点都有两个子节点，并且所有的叶子节点都在同一层上。换句话说，满二叉树是一棵高度固定的二叉树。</p><p><img src="https://pica.zhimg.com/v2-aaabc83b3755e7e90bb4d1a26c225ac2_1440w.jpg" alt="img"></p><p>2，完全二叉树（Complete Binary Tree）：完全二叉树是除了最后一层的叶子节点可能不满外，其他所有层的节点都被填满，并且最后一层的节点从左到右地排列。完全二叉树相对灵活，适用于数组或堆的实现。</p><p><img src="https://pic2.zhimg.com/v2-867f5ad6d7bbd64a629bceb9aa0e45dd_1440w.jpg" alt="img"></p><p>3，二叉搜索树（Binary Search Tree）：二叉搜索树是一种特殊的二叉树，它的左子树的所有节点都小于根节点，右子树的所有节点都大于根节点。这个特性使得在二叉搜索树中能够快速地进行查找、插入和删除操作。</p><p><img src="https://pic1.zhimg.com/v2-a122055089c0587b6e063edef9a0b91c_1440w.jpg" alt="img"></p><p>4，平衡二叉树（Balanced Binary Tree）：平衡二叉树是一种高度平衡的二叉树，即左右子树的高度差不超过某个固定值。常见的平衡二叉树有红黑树、AVL树等，它们旨在提供更快的插入、删除和查找操作</p><p><img src="https://pic1.zhimg.com/v2-9887f654c420ac8ad539512d89480190_1440w.jpg" alt="img"></p><p>5，二叉堆是一种满足堆序性质的完全二叉树，常用于实现优先队列和堆排序算法。</p><p>6，线索二叉树是对二叉树的改进，通过添加额外的指针（线索）来提高遍历效率，使得可以直接找到节点的前驱和后继节点。</p><hr><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="【1】先序遍历"><a href="#【1】先序遍历" class="headerlink" title="【1】先序遍历"></a><strong>【1】先序遍历</strong></h3><p>指的是从根结点出发，按照以下步骤访问二叉<a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/313.html">树</a>的每个结点：</p><blockquote><p>1，访问当前结点；<br>2，进入当前结点的左子树，以同样的步骤遍历左子树中的结点；<br>3遍历完当前结点的左子树后，再进入它的右子树，以同样的步骤遍历右子树中的结点；</p></blockquote><p><img src="https://pica.zhimg.com/v2-6ab0c40241f8ab27c8d85dc1e85541ae_1440w.jpg" alt="img"></p><p>先序遍历</p><p>对于顺序表存储的二叉树，递归实现先序遍历二叉树的 C 语言代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T, <span class="hljs-type">int</span> p_node)</span><br>&#123;   <span class="hljs-comment">////根节点的值不为 0，证明二叉树存在</span><br>    <span class="hljs-keyword">if</span>(T[p_node])<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T[p_node]);<br>        <span class="hljs-comment">//先序遍历左子树</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">2</span>*p_node+<span class="hljs-number">1</span>)&lt;max_size)&amp;&amp;(T[<span class="hljs-number">2</span> * p_node + <span class="hljs-number">1</span>])!=<span class="hljs-number">0</span>)<span class="hljs-comment">//确保左子节点的索引不超过数组的长度且判断左子节点的值是否存在</span><br>        &#123;<br>            PreOrderTraverse(T, <span class="hljs-number">2</span> * p_node + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">////最后先序遍历右子树</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">2</span> * p_node + <span class="hljs-number">2</span> &lt; ) &amp;&amp; (T[<span class="hljs-number">2</span> * p_node + <span class="hljs-number">2</span>] != <span class="hljs-number">0</span>))<br>        &#123;<br>           PreOrderTraverse(T, <span class="hljs-number">2</span> * p_node + <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//对于任意一个节点的索引 p_node，它的左子节点的索引可以通过 2 * p_node + 1 计算得到。</span><br><span class="hljs-comment">//这是因为，在满足了完全二叉树的性质下，左子节点的索引总是当前节点索引的两倍加一。</span><br><span class="hljs-comment">//通过这个表达式，可以方便地在数组中定位到二叉树中对应节点的左子节点。</span><br></code></pre></td></tr></table></figure><p>对于<a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/298.html">链表</a>存储的二叉树，递归实现先序遍历二叉树的 C 语言代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-comment">//如果二叉树存在，则遍历二叉树</span><br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,T-&gt;data); <span class="hljs-comment">//调用操作结点数据的函数方法</span><br>        PreOrderTraverse(T-&gt;lchild);<span class="hljs-comment">//访问该结点的左孩子</span><br>        PreOrderTraverse(T-&gt;rchild);<span class="hljs-comment">//访问该结点的右孩子</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【2】中序遍历"><a href="#【2】中序遍历" class="headerlink" title="【2】中序遍历"></a>【2】中序遍历</h3><p>指的是从根结点出发，按照以下步骤访问二叉<a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/313.html">树</a>中的每个结点：</p><blockquote><p>1，先进入当前结点的左子树，以同样的步骤遍历左子树中的结点；<br>2，访问当前结点；<br>3，最后进入当前结点的右子树，以同样的步骤遍历右子树中的结点。</p></blockquote><p><img src="https://pic4.zhimg.com/v2-5e3334562dfa3e6d9f510ad16a4a82a9_1440w.jpg" alt="img"></p><p>顺序表存储的二叉树，递归实现中序遍历的 C 语言程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">INOrderTraverse</span><span class="hljs-params">(BiTree T, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-comment">//递归遍历左子树</span><br>    <span class="hljs-keyword">if</span> (((<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>) &lt; max_size) &amp;&amp; (T[<span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>)) &#123;<br>        INOrderTraverse(T, <span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//访问当前结点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T[p]);<br>    <span class="hljs-comment">//递归遍历右子树</span><br>    <span class="hljs-keyword">if</span> (((<span class="hljs-number">2</span> * p + <span class="hljs-number">2</span>) &lt; max_size) &amp;&amp; (T[<span class="hljs-number">2</span> * p + <span class="hljs-number">2</span>] != <span class="hljs-number">0</span>))&#123;<br>        INOrderTraverse(T, <span class="hljs-number">2</span> * p + <span class="hljs-number">2</span>);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/298.html">链表</a>存储的二叉树，递归实现中序遍历的 C 语言程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">INOrderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        INOrderTraverse(T-&gt;lchild);<span class="hljs-comment">//遍历当前结点的左子树</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,T-&gt;data);     <span class="hljs-comment">//访问当前结点</span><br>        INOrderTraverse(T-&gt;rchild);<span class="hljs-comment">//遍历当前结点的右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【3】后序遍历"><a href="#【3】后序遍历" class="headerlink" title="【3】后序遍历"></a>【3】后序遍历</h3><p>指的是从根结点出发，按照以下步骤访问<a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/313.html">树</a>中的每个结点：</p><blockquote><p>1，优先进入当前结点的左子树，以同样的步骤遍历左子树中的结点；<br>2，如果当前结点没有左子树，则进入它的右子树，以同样的步骤遍历右子树中的结点；<br>3，直到当前结点的左子树和右子树都遍历完后，才访问该结点。</p></blockquote><p><img src="https://pic2.zhimg.com/v2-9bfa9899bf1589dba84f2b0c6e987c85_1440w.jpg" alt="img"></p><p>顺序表存储的二叉树，递归实现后序遍历的 C 语言程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrderTraverse</span><span class="hljs-params">(BiTree T, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; max_size) &amp;&amp; (T[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>)) &#123;<br>        PostOrderTraverse(T, <span class="hljs-number">2</span> * p + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((p * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &lt; max_size) &amp;&amp; (T[p * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>] != <span class="hljs-number">0</span>)) &#123;<br>        PostOrderTraverse(T, <span class="hljs-number">2</span> * p + <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T[p]);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/298.html">链表</a>存储的二叉树，递归实现后序遍历的 C 语言程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        PostOrderTraverse(T-&gt;lchild);<span class="hljs-comment">//遍历左孩子</span><br>        PostOrderTraverse(T-&gt;rchild);<span class="hljs-comment">//遍历右孩子</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【4】层次遍历"><a href="#【4】层次遍历" class="headerlink" title="【4】层次遍历"></a>【4】层次遍历</h3><p>层次遍历二叉树，就是从树的根结点开始，一层一层按照从左往右的次序依次访问树中的结点。<strong>顺序表存储的只能是完全二叉树，普通二叉树必须先转换成完全二叉树后才能存储到顺序表中，因此在实现层次遍历的时候，需要逐个对顺序表中存储的结点进行甄别。</strong></p><p><img src="https://pic1.zhimg.com/v2-e77c19e0b1738b947457932efa152242_1440w.jpg" alt="img"></p><p>层次遍历用链表存储的二叉树，可以借助<a href="https://link.zhihu.com/?target=http://data.biancheng.net/view/300.html">队列</a>存储结构实现，具体方案是：</p><blockquote><p>1，将根结点入队；<br>2，从队列的头部提取一个结点并访问它，将该结点的左孩子和右孩子依次入队；<br>3，重复执行第 2 步，直至队列为空；</p></blockquote><p>链表存储的二叉树，层次遍历二叉树的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TElemType int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NODENUM 7<span class="hljs-comment">//二叉树中结点的个数</span></span><br><span class="hljs-comment">//初始化队头和队尾指针开始时都为0</span><br><span class="hljs-type">int</span> front = <span class="hljs-number">0</span>, rear = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> &#123;</span><br>    TElemType data;<span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span>* <span class="hljs-title">lchild</span>, * <span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span><br>&#125;BiTNode, * BiTree;<br><span class="hljs-comment">//以先序遍历的方式存储二叉树到链表中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateBiTree</span><span class="hljs-params">(BiTree* T)</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    <span class="hljs-comment">//如果输入的值为 0，表示无此结点</span><br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>        *T = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//创建新结点</span><br>        *T = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>        (*T)-&gt;data = num;<br>        CreateBiTree(&amp;((*T)-&gt;lchild));<span class="hljs-comment">//创建该结点的左孩子</span><br>        CreateBiTree(&amp;((*T)-&gt;rchild));<span class="hljs-comment">//创建该结点的右孩子</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//入队函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(BiTree* a, BiTree node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (rear == NODENUM) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列已满，入队失败\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    a[rear++] = node;<br>&#125;<br><span class="hljs-comment">//出队函数</span><br>BiTNode* <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(BiTNode** a)</span> &#123;<br>    <span class="hljs-keyword">if</span> (front == rear) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列为空，出队失败\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> a[front++];<br>&#125;<br><span class="hljs-comment">//层次遍历二叉树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelOrderTraverse</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-comment">//如果二叉树存在，才进行层次遍历</span><br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        BiTree a[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>        BiTree p = <span class="hljs-literal">NULL</span>;<br>        p = T;<br>        <span class="hljs-comment">//根结点入队</span><br>        EnQueue(a, p);<br>        <span class="hljs-comment">//重复执行，直至队列为空</span><br>        <span class="hljs-keyword">while</span> (front &lt; rear)<br>        &#123;<br>            <span class="hljs-comment">//从队列取出一个结点</span><br>            p = DeQueue(a);<br>            <span class="hljs-comment">//访问当前结点</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>            <span class="hljs-comment">//将当前结点的左右孩子依次入队</span><br>            <span class="hljs-keyword">if</span> (p-&gt;lchild) &#123;<br>                EnQueue(a, p-&gt;lchild);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p-&gt;rchild) &#123;<br>                EnQueue(a, p-&gt;rchild);<br>            &#125;<br>        &#125;<br>    &#125; <br>&#125;<br><span class="hljs-comment">//后序遍历二叉树，释放树占用的内存</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DestroyBiTree</span><span class="hljs-params">(BiTree T)</span> &#123;<br>    <span class="hljs-keyword">if</span> (T) &#123;<br>        DestroyBiTree(T-&gt;lchild);<span class="hljs-comment">//销毁左孩子</span><br>        DestroyBiTree(T-&gt;rchild);<span class="hljs-comment">//销毁右孩子</span><br>        <span class="hljs-built_in">free</span>(T);<span class="hljs-comment">//释放结点占用的内存</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>数据结构与算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy初步使用</title>
    <link href="/2022/09/26/Scrapy%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/26/Scrapy%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://docs.scrapy.net.cn/en/latest/intro/overview.html">Scrapy 概览 — Scrapy 2.12.0 文档 - Scrapy 爬虫框架</a></p><p><a href="https://www.kancloud.cn/apachecn/scrapy-doc-zh/1946361">Spider 中间件 · Scrapy 1.6 中文文档 · 看云</a></p></blockquote><h1 id="Scrapy-的架构"><a href="#Scrapy-的架构" class="headerlink" title="Scrapy 的架构"></a>Scrapy 的架构</h1><p><img src="https://s2.loli.net/2024/12/31/PkCru9G47tUENB6.jpg" alt="scrapy"></p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><img src="https://s2.loli.net/2024/12/31/JN6LGeK4WftOyl1.png" alt="scrapy_architecture_02"></p><p>Scrapy 中的数据流由执行引擎控制，流程如下：</p><p><strong>引擎（Engine）</strong> 从 <strong>爬虫（Spider）</strong> 获取初始请求进行爬取</p><ul><li><strong>引擎</strong> 是 Scrapy 的核心组件，负责协调各个部分的工作。</li><li>初始请求是由 <strong>爬虫</strong> 提供的，它通常是爬虫的 <code>start_requests()</code> 方法中生成的，或者通过爬虫的起始 URL 列表。</li><li>引擎会从爬虫获取这些请求，并开始处理它们。</li></ul><p><strong>引擎</strong> 将请求调度到 <strong>调度器（Scheduler）</strong> 中，并请求下一个要爬取的请求</p><ul><li><strong>调度器</strong> 是 Scrapy 中负责管理请求的队列组件。它的作用是接收引擎发送的请求并保存它们，直到需要被处理。</li><li>当引擎收到请求时，它会将该请求交给调度器，调度器将请求排入队列。</li><li>然后，引擎会请求调度器返回下一个待爬取的请求。</li></ul><p><strong>调度器（Scheduler）</strong> 将下一个请求返回给 <strong>引擎（Engine）</strong></p><ul><li>调度器从队列中取出下一个请求，并将其返回给引擎，供引擎处理。</li><li>调度器是一个异步组件，可以高效地管理请求队列，确保爬虫不会因为请求过多而崩溃。</li></ul><p><strong>引擎（Engine）</strong> 将请求发送到 <strong>下载器（Downloader）</strong>，并经过 <strong>下载器中间件（Downloader Middleware）</strong>（<code>process_request()</code>）</p><ul><li><p><strong>下载器</strong> 的作用是实际发起 HTTP 请求并下载页面内容。当引擎从调度器获取到一个请求时，它会将该请求交给下载器。</p></li><li><p>下载器中间件</p><p> 在下载请求之前会执行一些操作，如请求的预处理、代理、用户代理等的设置。</p><ul><li><code>process_request(request, spider)</code> 方法是一个钩子，允许中间件对请求进行修改或拒绝。它可以在请求发出前对请求进行处理。</li></ul></li></ul><ol start="5"><li>页面下载完成后，<strong>下载器（Downloader）</strong> 生成一个 <strong>响应（Response）</strong>（包含该页面），并将其发送到 <strong>引擎（Engine）</strong>，并经过 <strong>下载器中间件（Downloader Middleware）</strong>（<code>process_response()</code>）</li></ol><ul><li><p>下载器完成页面下载后，会将 HTML 页面封装成一个 <code>Response</code> 对象，并返回给引擎。</p></li><li><p>下载器中间件</p><p> 会对响应进行处理，例如处理 cookies、处理重定向等。</p><ul><li><code>process_response(response, request, spider)</code> 方法允许中间件在返回响应前修改响应的内容或进行其他操作。</li></ul></li></ul><p><strong>引擎（Engine）</strong> 从 <strong>下载器（Downloader）</strong> 接收响应，并将其发送到 <strong>爬虫（Spider）</strong> 进行处理，并经过 <strong>爬虫中间件（Spider Middleware）</strong>（<code>process_spider_input()</code>）</p><ul><li><p>引擎收到下载的响应后，会将其发送给相应的爬虫。</p></li><li><p>爬虫中间件</p><p> 会对响应进行处理，例如将响应转化为可用的数据格式。</p><ul><li><code>process_spider_input(response, spider)</code> 方法允许中间件对响应进行处理，比如去除不需要的数据或格式化响应。</li></ul></li></ul><p><strong>爬虫（Spider）</strong> 处理响应，并将提取的项目和新的请求（待跟踪）返回给 <strong>引擎（Engine）</strong>，并经过 <strong>爬虫中间件（Spider Middleware）</strong>（<code>process_spider_output()</code>）</p><ul><li><p>爬虫从响应中提取数据，通常通过选择器（如 XPath 或 CSS 选择器）来提取网页中的信息。</p></li><li><p>爬虫还会根据页面内容生成新的请求（即爬取的链接）供后续继续抓取。爬虫将这些提取的数据（Item）和请求（Request）返回给引擎。</p></li><li><p>爬虫中间件</p></li><li><p>可以对爬虫返回的项目信息和请求进行额外处理，甚至改变返回的内容。</p></li></ul><p>  <code>process_spider_output(response, result, spider)</code> 方法允许中间件修改爬虫返回的项目或请求，通常用来清理数据或添加额外的处理。</p><p><strong>引擎（Engine）</strong> 将处理后的项目发送到 <strong>项目管道（Item Pipeline）</strong>，然后将处理后的请求发送到 <strong>调度器（Scheduler）</strong>，并请求可能的下一个要爬取的请求</p><ul><li><strong>项目管道</strong> 接收爬虫返回的项目并对其进行处理，例如存储到数据库、文件或进行数据清洗等。</li><li>处理后的请求再次被发送到 <strong>调度器</strong>，以便再次执行爬取。</li><li>如果存在更多的请求，流程会再次回到步骤 3，直到调度器没有更多请求为止。</li></ul><p><strong>过程重复</strong>（从步骤 3 开始），直到 <strong>调度器</strong> 中没有更多请求为止</p><ul><li>整个流程会循环执行，每当引擎从调度器获取一个请求并处理时，都会经过上述步骤，直到没有更多请求为止。</li><li>爬虫的工作主要是响应页面请求、提取数据、生成新请求、并将数据通过管道存储等操作。</li></ul><h2 id="易混淆三项对比："><a href="#易混淆三项对比：" class="headerlink" title="易混淆三项对比："></a><strong>易混淆三项对比：</strong></h2><ol><li><strong>下载中间件</strong>：偏重于网络传输层的操作，适用于修改请求和响应的网络属性，如代理设置、状态码处理、解压数据等。</li><li><strong>爬虫中间件</strong>：侧重于爬虫逻辑层的调整，适用于对响应进行预处理、生成新的请求或过滤无效数据等操作。</li><li><strong>项目管道</strong>：专注于数据项的最终处理和存储，适用于深度清洗、数据验证、去重以及持久化到数据库或文件。</li></ol><table><thead><tr><th><strong>维度&#x2F;特性</strong></th><th><strong>下载中间件（Downloader Middleware）</strong></th><th><strong>爬虫中间件（Spider Middleware）</strong></th><th><strong>项目管道（Item Pipeline）</strong></th></tr></thead><tbody><tr><td><strong>数据处理阶段</strong></td><td>网络传输阶段（请求发送到服务器、响应从服务器返回）。</td><td>爬虫逻辑阶段（爬虫接收响应、返回数据和请求）。</td><td>爬取流程的后期（引擎将数据项发送到管道时处理）。</td></tr><tr><td><strong>操作对象</strong></td><td>原始的请求（Request）和响应（Response）。</td><td>爬虫处理后的响应（Response）、数据项（Item）和新请求（Request）。</td><td>爬虫提取并返回的最终数据项（Item）。</td></tr><tr><td><strong>核心功能</strong></td><td>- 修改请求头、设置代理、处理响应状态码、解压缩数据等。</td><td>- 数据预处理、过滤无效数据。- 动态生成请求或过滤请求。</td><td>- 数据清洗与格式化。- 数据验证与去重。- 数据存储（持久化）。</td></tr><tr><td><strong>触发方法</strong></td><td><code>process_request</code>、<code>process_response</code>、<code>process_exception</code>。</td><td><code>process_spider_input</code>、<code>process_spider_output</code>、<code>process_spider_exception</code>。</td><td><code>process_item</code> 方法。</td></tr><tr><td><strong>适用场景</strong></td><td>- 修改网络层的请求，如设置代理 IP、修改 User-Agent。- 处理下载器返回的原始响应数据。</td><td>- 对爬虫的输入响应（如过滤无效页面）。- 对爬虫的输出数据项进行预处理或生成新请求。</td><td>- 清洗数据项的字段（格式化、去重）。- 验证数据的完整性和有效性。- 数据存储到数据库、文件等介质。</td></tr><tr><td><strong>作用阶段</strong></td><td>请求发送到下载器前或响应从下载器返回引擎后。</td><td>数据流进入爬虫或从爬虫返回引擎时。</td><td>引擎将数据项传递到管道时（最终数据处理环节）。</td></tr><tr><td><strong>适合的任务</strong></td><td>- 网络传输优化：如处理 HTTP 状态码、重试机制、gzip 解压缩。</td><td>- 爬虫逻辑调整：如动态生成新的请求，过滤爬虫输入或输出。</td><td>- 数据持久化：如保存到数据库、JSON 文件等。- 数据验证和深度清洗。</td></tr><tr><td><strong>示例场景</strong></td><td>- 使用代理池设置不同的代理 IP。- 过滤非 200 状态码的响应。</td><td>- 对无效的页面响应进行忽略（如过滤 404 页面）。- 根据页面生成新的爬取请求。</td><td>- 将清洗后的商品数据存储到 MySQL 或 MongoDB。</td></tr></tbody></table><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="scrapy是基于什么框架，进行网络异步请求处理的？"><a href="#scrapy是基于什么框架，进行网络异步请求处理的？" class="headerlink" title="scrapy是基于什么框架，进行网络异步请求处理的？"></a>scrapy是基于什么框架，进行网络异步请求处理的？</h2><p>Scrapy 是基于 <strong>Twisted</strong> 框架进行网络异步请求的。Twisted 是一个用于 Python 的异步网络库，它提供了高效的事件驱动框架，支持多种协议，包括 HTTP、FTP、SMTP、IMAP 等。</p><p>Scrapy 的核心架构是事件驱动的，它使用 Twisted 来进行以下几个重要的任务：</p><ol><li><strong>非阻塞 I&#x2F;O</strong>：Twisted 允许 Scrapy 异步地发送 HTTP 请求，而不需要等待响应的返回。在等待响应时，Scrapy 仍然可以继续处理其他请求，提高效率。</li><li><strong>调度和下载请求</strong>：Scrapy 使用 Twisted 的 <code>Deferred</code> 对象来管理和调度请求。当 Scrapy 发送请求时，它并不会阻塞等待结果，而是会返回一个 <code>Deferred</code> 对象，该对象代表一个可能尚未完成的操作。等请求完成时，Scrapy 会通知相关的回调函数来处理响应。</li><li><strong>并发控制</strong>：Scrapy 使用 Twisted 的事件循环来控制异步任务的执行，利用其支持并发的特性，可以高效地处理大量的 I&#x2F;O 操作（如网络请求）。</li><li><strong>异步请求处理</strong>：Scrapy 的爬虫执行流程（如发送请求、处理响应等）都是通过 Twisted 的异步事件机制进行调度的。当请求完成时，Scrapy 会调用相应的回调函数来处理返回的数据。</li></ol><h2 id="scrapy的去重原理"><a href="#scrapy的去重原理" class="headerlink" title="scrapy的去重原理"></a>scrapy的去重原理</h2><p>Scrapy 中的去重机制（指纹去重）主要是为了确保同一个 URL 只会被爬取一次，避免重复请求。Scrapy 通过 <strong>请求的唯一标识符</strong> 来判断请求是否已经被访问过。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="去重过滤器"><a href="#去重过滤器" class="headerlink" title="去重过滤器"></a><strong>去重过滤器</strong></h4><p>Scrapy 使用去重过滤器来处理请求指纹的存储和检查。去重过滤器的核心功能是根据请求的指纹来判断该请求是否已经被处理过。</p><h5 id="主要类和方法："><a href="#主要类和方法：" class="headerlink" title="主要类和方法："></a>主要类和方法：</h5><ul><li><code>scrapy.dupefilters.BaseDupeFilter</code>：这是一个抽象基类，所有具体的去重实现都继承自它。</li><li><code>scrapy.dupefilters.RFPDupeFilter</code>：默认的去重过滤器实现，用于存储请求指纹到内存中的 <code>set</code> 数据结构。</li><li><code>scrapy.dupefilters.RedisDupeFilter</code>：用于存储请求指纹到 Redis 中的去重过滤器，适用于分布式爬虫。</li></ul><h5 id="BaseDupeFilter"><a href="#BaseDupeFilter" class="headerlink" title="BaseDupeFilter"></a>BaseDupeFilter</h5><p><img src="https://s2.loli.net/2025/01/19/FXLPBNQTbfRkd3A.png" alt="image-20250119145852503"></p><p>这是 <code>RFPDupeFilter</code> 的基类，定义了一些基础的接口和方法，像 <code>open</code> 和 <code>close</code>，可以在子类中实现具体的逻辑。</p><h5 id="RFPDupeFilter"><a href="#RFPDupeFilter" class="headerlink" title="RFPDupeFilter"></a>RFPDupeFilter</h5><p><img src="https://s2.loli.net/2025/01/19/HjMVf2GvlDCKRJU.png" alt="image-20250119150228343"></p><p>构造函数 <code>__init__(self, path=None, debug=False)</code>:</p><ul><li><strong><code>path</code></strong>: 用于指定存储已访问请求指纹的文件路径。</li><li><strong><code>debug</code></strong>: 如果启用 debug 模式，它会在日志中详细记录被过滤的请求。</li><li><strong><code>self.fingerprints</code></strong>: 使用一个集合 <code>set</code> 来存储所有已经见过的请求指纹（fingerprint）。</li><li><strong><code>self.file</code></strong>: 如果传入了文件路径，它会将请求指纹存储到文件中。</li></ul><p>主要方法：</p><p><strong><code>from_settings(cls, settings)</code></strong>:</p><ul><li>从 Scrapy 配置文件（<code>settings.py</code>）中读取去重配置，并返回 <code>RFPDupeFilter</code> 实例。</li><li>它从 Scrapy 设置中获取 <code>DUPEFILTER_DEBUG</code> 配置来确定是否开启 debug 模式。</li></ul><p><strong><code>request_seen(self, request)</code></strong>:</p><ul><li>该方法检查当前请求的指纹是否已经存在于 <code>self.fingerprints</code> 集合中。</li><li>如果请求指纹已经存在，返回 <code>True</code>，表示这是一个重复请求，不会再继续处理。</li><li>如果请求指纹不存在，则将其添加到 <code>fingerprints</code> 集合中，并将其写入文件中（如果有文件路径）。</li></ul><p><strong><code>request_fingerprint(self, request)</code></strong>:</p><ul><li>该方法通过 <code>request_fingerprint</code> 函数来生成请求的唯一指纹（默认情况下是基于请求的 URL 生成的指纹）。</li><li>这个函数是 Scrapy 内部用于生成请求指纹的关键函数，它会基于请求的 URL 和其他相关信息生成唯一的哈希值。</li></ul><h6 id="request-fingerprint-request"><a href="#request-fingerprint-request" class="headerlink" title="request_fingerprint(request)"></a>request_fingerprint(request)</h6><p><img src="https://s2.loli.net/2025/01/19/XoeIgMmcRwFQzhS.png" alt="image-20250119150530871"></p><p><code>request_fingerprint</code> 的作用是基于 <code>Request</code> 对象的特征（如 URL、请求头、查询参数等）生成一个唯一的哈希值，作为请求的指纹。</p><p><img src="https://s2.loli.net/2025/01/19/rIpJ5HNT7AjyFMY.png" alt="image-20250119150658463"></p><p>Scrapy 在计算指纹时使用缓存。<code>_deprecated_fingerprint_cache</code> 是一个缓存字典，存储了每个请求的计算结果。<code>cache_key</code> 由 <code>processed_include_headers</code> 和 <code>keep_fragments</code> 组成，用来标识缓存的唯一性。如果相同的请求特征已经被计算过，直接返回缓存结果。</p><p>**<code>hashlib.sha1()</code>**：这里使用了 <code>SHA-1</code> 哈希算法创建指纹计算器。</p><p>**<code>fp.update()</code>**：逐步更新 <code>SHA-1</code> 哈希对象 <code>fp</code>，合并请求的各个特征</p><p>**<code>cache[cache_key] = fp.hexdigest()</code>**：生成指纹后，将它以十六进制字符串的形式存入缓存。</p><h2 id="scrapy是以广度优先还是深度优先进行爬取的呢？"><a href="#scrapy是以广度优先还是深度优先进行爬取的呢？" class="headerlink" title="scrapy是以广度优先还是深度优先进行爬取的呢？"></a>scrapy是以广度优先还是深度优先进行爬取的呢？</h2><p>Scrapy 使用了 <strong>优先队列（PriorityQueue）</strong> 来调度请求，并且默认使用了 <strong>LIFO（后进先出）队列</strong> 来管理请求，这反映了 <strong>深度优先（DFS）</strong> 的爬取顺序。</p><h3 id="1-优先队列的使用"><a href="#1-优先队列的使用" class="headerlink" title="1. 优先队列的使用"></a>1. <strong>优先队列的使用</strong></h3><p>在 <code>Scheduler</code> 类的构造函数中，使用了 <code>PriorityQueue</code> 进行请求的队列管理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dupefilter, jobdir=<span class="hljs-literal">None</span>, dqclass=<span class="hljs-literal">None</span>, mqclass=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                 logunser=<span class="hljs-literal">False</span>, stats=<span class="hljs-literal">None</span>, pqclass=<span class="hljs-literal">None</span>, crawler=<span class="hljs-literal">None</span></span>):<br>        self.df = dupefilter<br>        self.dqdir = self._dqdir(jobdir)<br>        self.pqclass = pqclass  <span class="hljs-comment"># 这里就是指定的优先队列类</span><br>        self.dqclass = dqclass<br>        self.mqclass = mqclass<br>        self.logunser = logunser<br>        self.stats = stats<br>        self.crawler = crawler<br></code></pre></td></tr></table></figure><p>这个优先队列会根据请求的 <code>priority</code> 字段来决定请求的处理顺序。</p><h3 id="2-队列的实现"><a href="#2-队列的实现" class="headerlink" title="2. 队列的实现"></a>2. <strong>队列的实现</strong></h3><p><code>PriorityQueue</code> 的默认实现是基于优先级的。Scrapy 支持同时使用内存队列和磁盘队列。内存队列（<code>mqs</code>）使用内存存储，而磁盘队列（<code>dqs</code>）则会将请求持久化到磁盘。</p><ul><li><code>mqs</code>（内存队列）：使用 <code>PriorityQueue</code>（默认是 <code>LifoQueue</code> 类型，即后进先出）</li><li><code>dqs</code>（磁盘队列）：如果配置了磁盘队列（<code>SCHEDULER_DISK_QUEUE</code>），Scrapy 会使用磁盘队列来存储请求，并且优先从磁盘队列中获取请求。</li></ul><h3 id="3-调度请求的顺序"><a href="#3-调度请求的顺序" class="headerlink" title="3. 调度请求的顺序"></a>3. <strong>调度请求的顺序</strong></h3><ul><li><strong>深度优先（DFS）</strong>：在 <code>Scheduler</code> 类中，<code>next_request</code> 方法从内存队列 <code>mqs</code> 中获取下一个请求（如果内存队列不为空），否则从磁盘队列 <code>dqs</code> 中获取。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">next_request</span>(<span class="hljs-params">self</span>):<br>    request = self.mqs.pop()  <span class="hljs-comment"># 从内存队列中获取请求</span><br>    <span class="hljs-keyword">if</span> request:<br>        self.stats.inc_value(<span class="hljs-string">&#x27;scheduler/dequeued/memory&#x27;</span>, spider=self.spider)<br>    <span class="hljs-keyword">else</span>:<br>        request = self._dqpop()  <span class="hljs-comment"># 如果内存队列为空，从磁盘队列获取</span><br>        <span class="hljs-keyword">if</span> request:<br>            self.stats.inc_value(<span class="hljs-string">&#x27;scheduler/dequeued/disk&#x27;</span>, spider=self.spider)<br>    <span class="hljs-keyword">if</span> request:<br>        self.stats.inc_value(<span class="hljs-string">&#x27;scheduler/dequeued&#x27;</span>, spider=self.spider)<br>    <span class="hljs-keyword">return</span> request<br></code></pre></td></tr></table></figure><p><code>mqs.pop()</code> 和 <code>dqs.pop()</code> 表明请求是通过 <code>LifoQueue</code>（后进先出）来调度的，从而实现了 <strong>深度优先（DFS）</strong> 的爬取策略。</p><h3 id="4-如何实现广度优先（BFS）"><a href="#4-如何实现广度优先（BFS）" class="headerlink" title="4. 如何实现广度优先（BFS）"></a>4. <strong>如何实现广度优先（BFS）</strong></h3><p>如果想使用广度优先（BFS）来调度请求，可以通过调整 Scrapy 配置来修改队列类型。具体来说，使用 <code>Queue</code> 类型的队列来替代 <code>LifoQueue</code>。你可以在 <code>settings.py</code> 中配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># settings.py</span><br>SCHEDULER_PRIORITY_QUEUE = <span class="hljs-string">&#x27;scrapy.queue.PriorityQueue&#x27;</span>  <span class="hljs-comment"># 使用FIFO队列实现广度优先</span><br></code></pre></td></tr></table></figure><p>这会将请求以先进先出的顺序调度，从而实现广度优先爬取。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><blockquote><p>更多的具体参考：<a href="https://docs.scrapy.net.cn/en/latest/faq.html">常见问题 — Scrapy 2.12.0 文档 - Scrapy 爬虫框架</a></p></blockquote><h2 id="内存泄露-内存爆了-栈溢出了，怎么办"><a href="#内存泄露-内存爆了-栈溢出了，怎么办" class="headerlink" title="内存泄露&#x2F;内存爆了&#x2F;栈溢出了，怎么办?"></a>内存泄露&#x2F;内存爆了&#x2F;栈溢出了，怎么办?</h2><p><a href="https://scrapy-chs.readthedocs.io/zh-cn/1.0/topics/leaks.html#topics-leaks">调试内存溢出 — Scrapy 1.0.5 文档</a></p><h2 id="Scrapy如何爬取属性在不同页面的item呢？"><a href="#Scrapy如何爬取属性在不同页面的item呢？" class="headerlink" title="Scrapy如何爬取属性在不同页面的item呢？"></a>Scrapy如何爬取属性在不同页面的item呢？</h2><p><a href="https://docs.scrapy.net.cn/en/latest/faq.html">常见问题 — Scrapy 2.12.0 文档 - Scrapy 爬虫框架</a></p><h2 id="Scrapy支持HTTP代理么？"><a href="#Scrapy支持HTTP代理么？" class="headerlink" title="Scrapy支持HTTP代理么？"></a>Scrapy支持HTTP代理么？</h2><blockquote><p>通过 HttpProxyMiddleware 中间件可以实现。当然也可以通过自定义中间件来实现！</p></blockquote><h2 id="要如何在Spider里模拟用户登录呢"><a href="#要如何在Spider里模拟用户登录呢" class="headerlink" title="要如何在Spider里模拟用户登录呢?"></a>要如何在Spider里模拟用户登录呢?</h2><p><a href="https://docs.scrapy.net.cn/en/latest/topics/request-response.html#request-subclasses">请求和响应 — Scrapy 2.12.0 文档 - Scrapy 爬虫框架</a></p>]]></content>
    
    
    <categories>
      
      <category>数据采集处理</category>
      
      <category>自动化测试与爬虫框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据采集处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础语法概览</title>
    <link href="/2022/09/25/Python%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <url>/2022/09/25/Python%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文仅是由于自己经常多语言开发，对于一些语言时常不用感到陌生或者使用中同其他语言用法混淆，故作此文，仅为自己提供一个Python语言使用的知识体系。</p></blockquote><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python 的数据类型可以大致分为以下几类：基本数据类型、容器数据类型、集合数据类型和其他特殊类型。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>整数 (int)</strong></td><td>整数类型，支持正数、负数及零</td><td><code>x = 10</code>, <code>y = -5</code></td></tr><tr><td><strong>浮点数 (float)</strong></td><td>浮动小数点数，表示实数</td><td><code>x = 10.5</code>, <code>y = -3.14</code></td></tr><tr><td><strong>布尔值 (bool)</strong></td><td>布尔类型，只有 <code>True</code> 和 <code>False</code> 两个值</td><td><code>x = True</code>, <code>y = False</code></td></tr><tr><td><strong>字符串 (str)</strong></td><td>用于存储文本，支持单引号、双引号、三引号表示</td><td><code>s = &quot;Hello&quot;</code>, <code>s2 = &#39;World&#39;</code></td></tr><tr><td><strong>列表 (list)</strong></td><td>可变的、有序集合，支持混合类型元素，允许修改</td><td><code>lst = [1, 2.5, &quot;hello&quot;]</code></td></tr><tr><td><strong>元组 (tuple)</strong></td><td>不可变的、有序集合，支持混合类型元素</td><td><code>tup = (1, 2.5, &quot;hello&quot;)</code></td></tr><tr><td><strong>集合 (set)</strong></td><td>无序、不重复的集合，支持集合运算</td><td><code>s = &#123;1, 2, 3&#125;</code>, <code>s2 = &#123;3, 4, 5&#125;</code></td></tr><tr><td><strong>字典 (dict)</strong></td><td>无序的键值对集合，键唯一，值可重复</td><td><code>d = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</code></td></tr><tr><td><strong>None</strong></td><td>表示“无值”或“空值”，用于表示空对象</td><td><code>x = None</code></td></tr><tr><td><strong>字节串 (bytes)</strong></td><td>不可变的字节序列，用于存储二进制数据</td><td><code>b = b&quot;Hello&quot;</code></td></tr><tr><td><strong>字节数组 (bytearray)</strong></td><td>可变的字节序列，支持二进制数据的修改</td><td><code>ba = bytearray([65, 66, 67])</code></td></tr><tr><td><strong>复数 (complex)</strong></td><td>复数类型，由实数部分和虚数部分组成</td><td><code>z = 1 + 2j</code></td></tr></tbody></table><p><img src="https://s2.loli.net/2024/12/27/gKsiPLTCq57mABH.png" alt="d4368f36a1d54e948f869e59e0cd996c"></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Python 的泛型（Generics）功能与其他强类型语言（如 Java 或 C++）中的泛型不同，因为 Python 是动态类型语言。Python 中并没有显式的泛型概念，而是通过类型注解（Type Hints）和 <code>typing</code> 模块来实现类似于泛型的功能。通过这些方式，可以在函数或类中使用泛型类型来提高代码的可读性和可维护性，同时保持灵活性。</p><h3 id="1-使用-typing-模块中的泛型"><a href="#1-使用-typing-模块中的泛型" class="headerlink" title="1. 使用 typing 模块中的泛型"></a>1. <strong>使用 <code>typing</code> 模块中的泛型</strong></h3><p>Python 提供了 <code>typing</code> 模块来支持类型注解，其中有一些用于定义泛型类型的工具。常用的泛型类型包括：</p><ul><li><code>List</code></li><li><code>Dict</code></li><li><code>Tuple</code></li><li><code>Union</code></li><li><code>Optional</code></li><li><code>TypeVar</code>（类型变量）</li></ul><p>这些泛型类型通过类型注解在不影响 Python 动态类型特性的情况下，表达出不同类型的参数或返回值。</p><h3 id="2-TypeVar-和泛型函数"><a href="#2-TypeVar-和泛型函数" class="headerlink" title="2. TypeVar 和泛型函数"></a>2. <strong><code>TypeVar</code> 和泛型函数</strong></h3><p><code>TypeVar</code> 用于创建一个类型变量，使得我们可以在函数或类中使用任意类型作为参数和返回值，而不需要限制类型。通过 <code>TypeVar</code>，你可以实现类似于 Java 和 C++ 中的泛型功能。</p><h4 id="示例：使用-TypeVar-创建泛型函数"><a href="#示例：使用-TypeVar-创建泛型函数" class="headerlink" title="示例：使用 TypeVar 创建泛型函数"></a>示例：使用 <code>TypeVar</code> 创建泛型函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar, <span class="hljs-type">List</span><br><br>T = TypeVar(<span class="hljs-string">&#x27;T&#x27;</span>)  <span class="hljs-comment"># 定义类型变量 T</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_first_element</span>(<span class="hljs-params">lst: <span class="hljs-type">List</span>[T]</span>) -&gt; T:<br>    <span class="hljs-string">&quot;&quot;&quot;返回列表中的第一个元素&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> lst[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 使用泛型函数</span><br><span class="hljs-built_in">print</span>(get_first_element([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))   <span class="hljs-comment"># 输出: 1，类型是 int</span><br><span class="hljs-built_in">print</span>(get_first_element([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]))  <span class="hljs-comment"># 输出: &#x27;a&#x27;，类型是 str</span><br></code></pre></td></tr></table></figure><ul><li><code>T</code> 是一个类型变量，它允许我们传入不同的类型，而不限制为某个具体类型。</li><li><code>List[T]</code> 表示列表的元素类型是 <code>T</code>，也就是我们传入的实际类型。</li></ul><h3 id="3-Generic-类"><a href="#3-Generic-类" class="headerlink" title="3. Generic 类"></a>3. <strong><code>Generic</code> 类</strong></h3><p><code>Generic</code> 是 <code>typing</code> 模块中的一个类，用来创建泛型类。通过继承 <code>Generic</code>，你可以创建支持不同类型的类。</p><h4 id="示例：使用-Generic-创建泛型类"><a href="#示例：使用-Generic-创建泛型类" class="headerlink" title="示例：使用 Generic 创建泛型类"></a>示例：使用 <code>Generic</code> 创建泛型类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Generic</span>, <span class="hljs-type">List</span>, TypeVar<br><br>T = TypeVar(<span class="hljs-string">&#x27;T&#x27;</span>)  <span class="hljs-comment"># 定义类型变量 T</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>(<span class="hljs-type">Generic</span>[T]):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value: T</span>):<br>        self.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_value</span>(<span class="hljs-params">self</span>) -&gt; T:<br>        <span class="hljs-keyword">return</span> self.value<br><br><span class="hljs-comment"># 创建不同类型的 Box 实例</span><br>int_box = Box(<span class="hljs-number">123</span>)<br>str_box = Box(<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-built_in">print</span>(int_box.get_value())  <span class="hljs-comment"># 输出: 123</span><br><span class="hljs-built_in">print</span>(str_box.get_value())  <span class="hljs-comment"># 输出: hello</span><br></code></pre></td></tr></table></figure><ul><li><code>Box</code> 是一个泛型类，<code>T</code> 代表可以是任何类型。</li><li>通过创建 <code>Box</code> 对象时指定类型，可以保证 <code>Box</code> 中的 <code>value</code> 对应类型一致。</li></ul><h3 id="4-使用-Union-和-Optional"><a href="#4-使用-Union-和-Optional" class="headerlink" title="4. 使用 Union 和 Optional"></a>4. <strong>使用 <code>Union</code> 和 <code>Optional</code></strong></h3><ul><li>**<code>Union</code>**：表示多个类型中的一种，类似于 Java 中的 <code>|</code> 操作符。</li><li>**<code>Optional</code>**：是 <code>Union</code> 的一个特殊情况，表示某个值可以是某个类型或者 <code>None</code>，等同于 <code>Union[T, None]</code>。</li></ul><h4 id="示例：使用-Union-和-Optional"><a href="#示例：使用-Union-和-Optional" class="headerlink" title="示例：使用 Union 和 Optional"></a>示例：使用 <code>Union</code> 和 <code>Optional</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span>, <span class="hljs-type">Optional</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_data</span>(<span class="hljs-params">data: <span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">int</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Received integer: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">str</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Received string: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unknown type&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_value</span>(<span class="hljs-params">data: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No data&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Received: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-built_in">print</span>(handle_data(<span class="hljs-number">42</span>))        <span class="hljs-comment"># 输出: Received integer: 42</span><br><span class="hljs-built_in">print</span>(handle_data(<span class="hljs-string">&quot;Hello&quot;</span>))   <span class="hljs-comment"># 输出: Received string: Hello</span><br><span class="hljs-built_in">print</span>(get_value(<span class="hljs-literal">None</span>))        <span class="hljs-comment"># 输出: No data</span><br></code></pre></td></tr></table></figure><ul><li><code>Union[int, str]</code> 表示参数 <code>data</code> 可以是 <code>int</code> 或 <code>str</code> 类型。</li><li><code>Optional[str]</code> 表示参数 <code>data</code> 可以是 <code>str</code> 类型或 <code>None</code>，即它等价于 <code>Union[str, None]</code>。</li></ul><h3 id="5-泛型约束"><a href="#5-泛型约束" class="headerlink" title="5. 泛型约束"></a>5. <strong>泛型约束</strong></h3><p>在某些情况下，你可能希望限定泛型类型的范围。你可以使用 <code>TypeVar</code> 的 <code>bound</code> 参数来限制类型变量的范围，使其只能是某个类的子类或某些特定类型。</p><h4 id="示例：泛型约束"><a href="#示例：泛型约束" class="headerlink" title="示例：泛型约束"></a>示例：泛型约束</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar, <span class="hljs-type">List</span><br><br>T = TypeVar(<span class="hljs-string">&#x27;T&#x27;</span>, bound=<span class="hljs-built_in">int</span>)  <span class="hljs-comment"># 限制 T 必须是 int 或其子类</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_elements</span>(<span class="hljs-params">lst: <span class="hljs-type">List</span>[T]</span>) -&gt; T:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(lst)<br><br><span class="hljs-built_in">print</span>(sum_elements([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))  <span class="hljs-comment"># 输出: 6</span><br><span class="hljs-comment"># print(sum_elements([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))  # 会报错，类型不匹配</span><br></code></pre></td></tr></table></figure><ul><li><code>TypeVar(&#39;T&#39;, bound=int)</code> 表示 <code>T</code> 必须是 <code>int</code> 或其子类。这样，我们就可以在函数中限定泛型类型。</li></ul><h3 id="6-Callable-和-泛型函数类型"><a href="#6-Callable-和-泛型函数类型" class="headerlink" title="6. Callable 和 泛型函数类型"></a>6. <strong><code>Callable</code> 和 泛型函数类型</strong></h3><p><code>Callable</code> 用来描述一个函数的类型，包括它的参数和返回值类型。它也可以与泛型一起使用。</p><h4 id="示例：使用-Callable-定义泛型函数类型"><a href="#示例：使用-Callable-定义泛型函数类型" class="headerlink" title="示例：使用 Callable 定义泛型函数类型"></a>示例：使用 <code>Callable</code> 定义泛型函数类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Callable</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_function</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span>[[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>], <span class="hljs-built_in">int</span>], x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> func(x, y)<br><br><span class="hljs-comment"># 定义一个加法函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-built_in">print</span>(apply_function(add, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 输出: 8</span><br></code></pre></td></tr></table></figure><ul><li><code>Callable[[int, int], int]</code> 表示该函数类型接收两个 <code>int</code> 参数并返回一个 <code>int</code> 类型的结果。</li><li>你可以将这个类型用于任何符合这个签名的函数。</li></ul><h3 id="7-Iterable-和-Iterator-泛型"><a href="#7-Iterable-和-Iterator-泛型" class="headerlink" title="7. Iterable 和 Iterator 泛型"></a>7. <strong><code>Iterable</code> 和 <code>Iterator</code> 泛型</strong></h3><p>Python 的 <code>Iterable</code> 和 <code>Iterator</code> 是用于表示可迭代对象和迭代器的泛型类型。<code>Iterable</code> 表示一个可以迭代的对象，<code>Iterator</code> 表示一个可以返回下一个元素的对象。</p><h4 id="示例：使用-Iterable-和-Iterator"><a href="#示例：使用-Iterable-和-Iterator" class="headerlink" title="示例：使用 Iterable 和 Iterator"></a>示例：使用 <code>Iterable</code> 和 <code>Iterator</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterable, Iterator<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_elements</span>(<span class="hljs-params">elements: Iterable[<span class="hljs-built_in">int</span>]</span>) -&gt; Iterator[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> elements:<br>        <span class="hljs-keyword">yield</span> element * <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 测试</span><br>result = process_elements([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(result))  <span class="hljs-comment"># 输出: [2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><ul><li><code>Iterable[int]</code> 表示接收一个 <code>int</code> 类型的可迭代对象。</li><li><code>Iterator[int]</code> 表示返回 <code>int</code> 类型的迭代器。</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. <strong>类和对象</strong></h3><ul><li><strong>类（Class）</strong> 是定义对象（实例）行为和属性的模板。它是对象的蓝图。</li><li><strong>对象（Object）</strong> 是类的实例，通过类创建。</li></ul><h4 id="示例：创建一个简单的类和对象"><a href="#示例：创建一个简单的类和对象" class="headerlink" title="示例：创建一个简单的类和对象"></a>示例：创建一个简单的类和对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-comment"># 构造函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name  <span class="hljs-comment"># 实例属性</span><br>        self.age = age    <span class="hljs-comment"># 实例属性</span><br><br>    <span class="hljs-comment"># 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is barking!&quot;</span>)<br><br><span class="hljs-comment"># 创建对象</span><br>dog1 = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 访问属性和方法</span><br><span class="hljs-built_in">print</span>(dog1.name)  <span class="hljs-comment"># 输出: Buddy</span><br><span class="hljs-built_in">print</span>(dog1.age)   <span class="hljs-comment"># 输出: 3</span><br>dog1.bark()       <span class="hljs-comment"># 输出: Buddy is barking!</span><br></code></pre></td></tr></table></figure><h3 id="2-类的构造函数-init"><a href="#2-类的构造函数-init" class="headerlink" title="2. 类的构造函数 (__init__)"></a>2. <strong>类的构造函数 (<code>__init__</code>)</strong></h3><p>在 Python 中，<code>__init__</code> 是一个特殊的方法，用于初始化对象的状态。每次创建一个类的实例时，<code>__init__</code> 方法都会被自动调用。</p><h4 id="示例：构造函数"><a href="#示例：构造函数" class="headerlink" title="示例：构造函数"></a>示例：构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>person1 = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>)<br><span class="hljs-built_in">print</span>(person1.name)  <span class="hljs-comment"># 输出: Alice</span><br><span class="hljs-built_in">print</span>(person1.age)   <span class="hljs-comment"># 输出: 25</span><br></code></pre></td></tr></table></figure><h3 id="3-实例属性和类属性"><a href="#3-实例属性和类属性" class="headerlink" title="3. 实例属性和类属性"></a>3. <strong>实例属性和类属性</strong></h3><ul><li><strong>实例属性</strong> 是与对象相关的属性，通常在 <code>__init__</code> 方法中定义。</li><li><strong>类属性</strong> 是与类本身相关的属性，所有实例共享这个属性。</li></ul><h4 id="示例：实例属性和类属性"><a href="#示例：实例属性和类属性" class="headerlink" title="示例：实例属性和类属性"></a>示例：实例属性和类属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    species = <span class="hljs-string">&quot;Feline&quot;</span>  <span class="hljs-comment"># 类属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name  <span class="hljs-comment"># 实例属性</span><br>        self.age = age    <span class="hljs-comment"># 实例属性</span><br><br>cat1 = Cat(<span class="hljs-string">&quot;Whiskers&quot;</span>, <span class="hljs-number">2</span>)<br>cat2 = Cat(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(cat1.species)  <span class="hljs-comment"># 输出: Feline</span><br><span class="hljs-built_in">print</span>(cat2.species)  <span class="hljs-comment"># 输出: Feline</span><br><span class="hljs-built_in">print</span>(cat1.name)     <span class="hljs-comment"># 输出: Whiskers</span><br><span class="hljs-built_in">print</span>(cat2.name)     <span class="hljs-comment"># 输出: Tom</span><br><br><span class="hljs-comment"># 修改类属性</span><br>Cat.species = <span class="hljs-string">&quot;Wild Feline&quot;</span><br><span class="hljs-built_in">print</span>(cat1.species)  <span class="hljs-comment"># 输出: Wild Feline</span><br><span class="hljs-built_in">print</span>(cat2.species)  <span class="hljs-comment"># 输出: Wild Feline</span><br></code></pre></td></tr></table></figure><h3 id="4-方法（Method）"><a href="#4-方法（Method）" class="headerlink" title="4. 方法（Method）"></a>4. <strong>方法（Method）</strong></h3><p>方法是定义在类内部的函数，通常表示对象的行为。方法的第一个参数通常是 <code>self</code>，表示对象自身。</p><h4 id="示例：定义和调用方法"><a href="#示例：定义和调用方法" class="headerlink" title="示例：定义和调用方法"></a>示例：定义和调用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model</span>):<br>        self.make = make<br>        self.model = model<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display_info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Car make: <span class="hljs-subst">&#123;self.make&#125;</span>, Model: <span class="hljs-subst">&#123;self.model&#125;</span>&quot;</span>)<br><br>car1 = Car(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-string">&quot;Corolla&quot;</span>)<br>car1.display_info()  <span class="hljs-comment"># 输出: Car make: Toyota, Model: Corolla</span><br></code></pre></td></tr></table></figure><h3 id="5-继承（Inheritance）"><a href="#5-继承（Inheritance）" class="headerlink" title="5. 继承（Inheritance）"></a>5. <strong>继承（Inheritance）</strong></h3><p>继承是面向对象编程中的一个重要概念，它允许一个类继承另一个类的属性和方法。继承可以提高代码的复用性。</p><h4 id="示例：继承"><a href="#示例：继承" class="headerlink" title="示例：继承"></a>示例：继承</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> makes a sound!&quot;</span>)<br><br><span class="hljs-comment"># 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> barks!&quot;</span>)<br><br><span class="hljs-comment"># 创建子类实例</span><br>dog = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>)<br>dog.speak()  <span class="hljs-comment"># 输出: Buddy barks!</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 继承自 <code>Animal</code> 类，并且重写了 <code>speak</code> 方法。</p><h3 id="6-多态（Polymorphism）"><a href="#6-多态（Polymorphism）" class="headerlink" title="6. 多态（Polymorphism）"></a>6. <strong>多态（Polymorphism）</strong></h3><p>多态是指相同的方法可以作用于不同类型的对象，表现为不同的行为。通常通过继承和方法重写来实现。</p><h4 id="示例：多态"><a href="#示例：多态" class="headerlink" title="示例：多态"></a>示例：多态</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> chirps!&quot;</span>)<br><br><span class="hljs-comment"># 多态的实现</span><br>animals = [Dog(<span class="hljs-string">&quot;Buddy&quot;</span>), Bird(<span class="hljs-string">&quot;Parrot&quot;</span>)]<br><span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals:<br>    animal.speak()  <span class="hljs-comment"># 不同对象表现出不同的行为</span><br></code></pre></td></tr></table></figure><h3 id="7-封装（Encapsulation）"><a href="#7-封装（Encapsulation）" class="headerlink" title="7. 封装（Encapsulation）"></a>7. <strong>封装（Encapsulation）</strong></h3><p>封装是将数据和方法封装在类中，只通过类的接口进行访问，限制对对象的直接操作。Python 通过“私有化”属性和方法来实现封装。虽然 Python 没有严格的私有化机制，但通过命名约定（前缀双下划线）来表示私有成员。</p><h4 id="示例：封装"><a href="#示例：封装" class="headerlink" title="示例：封装"></a>示例：封装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, owner, balance</span>):<br>        self.owner = owner<br>        self.__balance = balance  <span class="hljs-comment"># 私有属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deposit</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>            self.__balance += amount<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> amount &lt;= self.__balance:<br>            self.__balance -= amount<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Insufficient funds&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_balance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__balance  <span class="hljs-comment"># 通过方法访问私有属性</span><br><br>account = BankAccount(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">1000</span>)<br>account.deposit(<span class="hljs-number">500</span>)<br><span class="hljs-built_in">print</span>(account.get_balance())  <span class="hljs-comment"># 输出: 1500</span><br>account.withdraw(<span class="hljs-number">200</span>)<br><span class="hljs-built_in">print</span>(account.get_balance())  <span class="hljs-comment"># 输出: 1300</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>__balance</code> 是一个私有属性，不能直接从外部访问，只能通过方法来操作。</p><h3 id="8-抽象（Abstraction）"><a href="#8-抽象（Abstraction）" class="headerlink" title="8. 抽象（Abstraction）"></a>8. <strong>抽象（Abstraction）</strong></h3><p>抽象是将实现细节隐藏起来，只暴露接口。Python 可以通过 <code>abc</code> 模块来实现抽象基类（Abstract Base Class，ABC）。抽象类不能实例化，只能作为子类的基类使用。</p><h4 id="示例：抽象类"><a href="#示例：抽象类" class="headerlink" title="示例：抽象类"></a>示例：抽象类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-title class_ inherited__">Shape</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, width, height</span>):<br>        self.width = width<br>        self.height = height<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.width * self.height<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-title class_ inherited__">Shape</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):<br>        self.radius = radius<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * self.radius * self.radius<br><br><span class="hljs-comment"># 创建对象</span><br>rectangle = Rectangle(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(rectangle.area())  <span class="hljs-comment"># 输出: 15</span><br><br>circle = Circle(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(circle.area())  <span class="hljs-comment"># 输出: 50.24</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Shape</code> 是一个抽象基类，包含了一个抽象方法 <code>area</code>，具体的实现由子类 <code>Rectangle</code> 和 <code>Circle</code> 提供。</p><h3 id="9-类方法和静态方法"><a href="#9-类方法和静态方法" class="headerlink" title="9. 类方法和静态方法"></a>9. <strong>类方法和静态方法</strong></h3><ul><li><strong>类方法</strong> 是与类本身相关的方法，而不是与实例相关的。通过 <code>@classmethod</code> 装饰器定义。</li><li><strong>静态方法</strong> 是不依赖于实例或类的方法，通常用于工具函数。通过 <code>@staticmethod</code> 装饰器定义。</li></ul><h4 id="示例：类方法和静态方法"><a href="#示例：类方法和静态方法" class="headerlink" title="示例：类方法和静态方法"></a>示例：类方法和静态方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    class_variable = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        MyClass.class_variable += <span class="hljs-number">1</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">class_method</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Class method: <span class="hljs-subst">&#123;cls.class_variable&#125;</span>&quot;</span>)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">static_method</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Static method&quot;</span>)<br><br><span class="hljs-comment"># 调用类方法和静态方法</span><br>MyClass.class_method()  <span class="hljs-comment"># 输出: Class method: 0</span><br>MyClass.static_method()  <span class="hljs-comment"># 输出: Static method</span><br></code></pre></td></tr></table></figure><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>在 Python 中，并发编程（Concurrency）是指在同一时间段内管理多个任务的执行，而不一定要求它们在同一时刻完全并行执行。Python 提供了多种方式来实现并发编程，包括 <strong>多线程（Threading）</strong>、<strong>多进程（Multiprocessing）</strong> 和 <strong>异步编程（Asyncio）</strong>，每种方式都有其适用的场景和优缺点。</p><h3 id="1-多线程编程（Threading）"><a href="#1-多线程编程（Threading）" class="headerlink" title="1. 多线程编程（Threading）"></a>1. <strong>多线程编程（Threading）</strong></h3><p>Python 的 <code>threading</code> 模块提供了多线程编程的支持，允许你在单个进程中创建多个线程。线程在同一个进程内共享内存空间，因此可以更高效地进行数据共享和通信。</p><p><strong>适用场景：</strong></p><ul><li>适用于 I&#x2F;O 密集型任务（如文件操作、网络请求等）。</li><li>由于 Python 的全局解释器锁（GIL），在 CPU 密集型任务中，多个线程并不能并行执行 Python 代码，而是交替执行。</li></ul><h4 id="示例：使用-threading-模块创建线程"><a href="#示例：使用-threading-模块创建线程" class="headerlink" title="示例：使用 threading 模块创建线程"></a>示例：使用 <code>threading</code> 模块创建线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 定义线程要执行的任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Thread <span class="hljs-subst">&#123;name&#125;</span> started&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟耗时操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Thread <span class="hljs-subst">&#123;name&#125;</span> finished&quot;</span>)<br><br><span class="hljs-comment"># 创建线程</span><br>thread1 = threading.Thread(target=task, args=(<span class="hljs-string">&quot;A&quot;</span>,))<br>thread2 = threading.Thread(target=task, args=(<span class="hljs-string">&quot;B&quot;</span>,))<br><br><span class="hljs-comment"># 启动线程</span><br>thread1.start()<br>thread2.start()<br><br><span class="hljs-comment"># 等待线程执行完毕</span><br>thread1.join()<br>thread2.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Both threads finished&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>start()</code>：启动线程，开始执行目标函数。</li><li><code>join()</code>：等待线程执行完毕。</li></ul><h3 id="2-多进程编程（Multiprocessing）"><a href="#2-多进程编程（Multiprocessing）" class="headerlink" title="2. 多进程编程（Multiprocessing）"></a>2. <strong>多进程编程（Multiprocessing）</strong></h3><p><code>multiprocessing</code> 模块允许你创建多个进程，多个进程可以在多个 CPU 核心上并行执行，因此它特别适合 CPU 密集型任务。每个进程有独立的内存空间和 GIL，因此可以充分利用多核 CPU。</p><p><strong>适用场景：</strong></p><ul><li>适用于 CPU 密集型任务，如图像处理、数据分析等。</li><li>每个进程有独立的内存空间，可以避免 GIL 的影响。</li></ul><h4 id="示例：使用-multiprocessing-模块创建进程"><a href="#示例：使用-multiprocessing-模块创建进程" class="headerlink" title="示例：使用 multiprocessing 模块创建进程"></a>示例：使用 <code>multiprocessing</code> 模块创建进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 定义进程要执行的任务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Process <span class="hljs-subst">&#123;name&#125;</span> started&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟耗时操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Process <span class="hljs-subst">&#123;name&#125;</span> finished&quot;</span>)<br><br><span class="hljs-comment"># 创建进程</span><br>process1 = multiprocessing.Process(target=task, args=(<span class="hljs-string">&quot;A&quot;</span>,))<br>process2 = multiprocessing.Process(target=task, args=(<span class="hljs-string">&quot;B&quot;</span>,))<br><br><span class="hljs-comment"># 启动进程</span><br>process1.start()<br>process2.start()<br><br><span class="hljs-comment"># 等待进程执行完毕</span><br>process1.join()<br>process2.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Both processes finished&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>start()</code>：启动进程，开始执行目标函数。</li><li><code>join()</code>：等待进程执行完毕。</li></ul><h3 id="3-异步编程（Asyncio）"><a href="#3-异步编程（Asyncio）" class="headerlink" title="3. 异步编程（Asyncio）"></a>3. <strong>异步编程（Asyncio）</strong></h3><p>异步编程是一种处理 I&#x2F;O 密集型任务的方式，它通过事件循环（event loop）来调度任务，并使用 <code>async</code> 和 <code>await</code> 关键字来定义协程（coroutine）。Python 的 <code>asyncio</code> 模块是一个异步编程框架，适合用来处理大量 I&#x2F;O 操作（如网络请求、数据库操作等）。</p><p><strong>适用场景：</strong></p><ul><li>适用于 I&#x2F;O 密集型任务，尤其是需要处理大量并发请求（如 Web 服务、爬虫等）。</li><li>异步编程相比多线程和多进程的优势在于，它不需要创建新的线程或进程，因此可以节省大量的系统资源。</li></ul><h4 id="示例：使用-asyncio-模块进行异步编程"><a href="#示例：使用-asyncio-模块进行异步编程" class="headerlink" title="示例：使用 asyncio 模块进行异步编程"></a>示例：使用 <code>asyncio</code> 模块进行异步编程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-comment"># 定义异步任务</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;name&#125;</span> started&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟异步操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;name&#125;</span> finished&quot;</span>)<br><br><span class="hljs-comment"># 定义异步主函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    task1 = asyncio.create_task(task(<span class="hljs-string">&quot;A&quot;</span>))<br>    task2 = asyncio.create_task(task(<span class="hljs-string">&quot;B&quot;</span>))<br><br>    <span class="hljs-comment"># 等待所有任务完成</span><br>    <span class="hljs-keyword">await</span> task1<br>    <span class="hljs-keyword">await</span> task2<br><br><span class="hljs-comment"># 运行事件循环</span><br>asyncio.run(main())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Both tasks finished&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>async def</code>：定义异步函数。</li><li><code>await</code>：挂起协程，等待异步任务完成。</li><li><code>asyncio.run()</code>：运行事件循环，执行异步代码。</li></ul><h3 id="4-并发模型比较"><a href="#4-并发模型比较" class="headerlink" title="4. 并发模型比较"></a>4. <strong>并发模型比较</strong></h3><table><thead><tr><th>特性</th><th>多线程（Threading）</th><th>多进程（Multiprocessing）</th><th>异步编程（Asyncio）</th></tr></thead><tbody><tr><td>适用场景</td><td>I&#x2F;O 密集型任务（如文件操作、网络请求）</td><td>CPU 密集型任务（如计算、图像处理）</td><td>I&#x2F;O 密集型任务（如 Web 服务、爬虫）</td></tr><tr><td>性能</td><td>受 GIL（全局解释器锁）限制，在 CPU 密集型任务中性能较差</td><td>可以充分利用多核 CPU，适合 CPU 密集型任务</td><td>高效处理并发 I&#x2F;O 请求，适合大量并发</td></tr><tr><td>内存使用</td><td>所有线程共享内存空间</td><td>每个进程有独立的内存空间</td><td>事件循环不需要额外的内存开销</td></tr><tr><td>使用难度</td><td>相对简单，但需要处理线程安全问题</td><td>相对复杂，涉及进程间通信、内存共享等</td><td>需要掌握异步编程的基本概念</td></tr></tbody></table><h3 id="5-线程与进程的选择"><a href="#5-线程与进程的选择" class="headerlink" title="5. 线程与进程的选择"></a>5. <strong>线程与进程的选择</strong></h3><ul><li><strong>线程（Threading）</strong>：<ul><li>适用于 I&#x2F;O 密集型任务，如文件操作、网络请求等。</li><li>由于 GIL 的存在，Python 中的线程不能并行执行计算密集型任务（CPU 密集型）。</li></ul></li><li><strong>进程（Multiprocessing）</strong>：<ul><li>适用于 CPU 密集型任务，如数据分析、图像处理等。</li><li>多进程可以充分利用多核 CPU，并且不受 GIL 限制，但它们之间的通信和数据共享相对复杂。</li></ul></li><li><strong>异步编程（Asyncio）</strong>：<ul><li>适用于大量并发的 I&#x2F;O 密集型任务。</li><li>异步编程能够高效地处理大量的并发请求（如 Web 服务），但在 CPU 密集型任务中表现不佳。</li></ul></li></ul><h3 id="6-进程间通信（IPC）和线程间通信"><a href="#6-进程间通信（IPC）和线程间通信" class="headerlink" title="6. 进程间通信（IPC）和线程间通信"></a>6. <strong>进程间通信（IPC）和线程间通信</strong></h3><ul><li><p><strong>进程间通信（IPC）</strong>：</p><ul><li>由于每个进程都有独立的内存空间，它们需要使用特殊的方式来进行通信，如管道（<code>Pipe</code>）、队列（<code>Queue</code>）等。</li></ul><h4 id="示例：使用-Queue-进行进程间通信"><a href="#示例：使用-Queue-进行进程间通信" class="headerlink" title="示例：使用 Queue 进行进程间通信"></a>示例：使用 <code>Queue</code> 进行进程间通信</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(<span class="hljs-params">queue</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        queue.put(i)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Produced: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">queue</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        item = queue.get()<br>        <span class="hljs-keyword">if</span> item <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Consumed: <span class="hljs-subst">&#123;item&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    queue = multiprocessing.Queue()<br>    process1 = multiprocessing.Process(target=producer, args=(queue,))<br>    process2 = multiprocessing.Process(target=consumer, args=(queue,))<br><br>    process1.start()<br>    process2.start()<br><br>    process1.join()<br>    queue.put(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 发送结束信号</span><br>    process2.join()<br></code></pre></td></tr></table></figure></li><li><p><strong>线程间通信</strong>：</p><ul><li>线程间共享内存，因此可以直接通过共享变量、<code>Queue</code> 或 <code>Event</code> 等方式进行通信。</li></ul></li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>在 Python 中，<strong>异常处理</strong>（Exception Handling）用于捕获和处理程序执行过程中可能出现的错误或异常，从而避免程序崩溃并提供适当的错误信息。Python 的异常处理机制通过 <code>try</code>、<code>except</code>、<code>else</code> 和 <code>finally</code> 语句来实现。</p><h3 id="1-基本异常处理结构"><a href="#1-基本异常处理结构" class="headerlink" title="1. 基本异常处理结构"></a>1. <strong>基本异常处理结构</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 可能出现异常的代码</span><br>    <span class="hljs-comment"># 例如除以零错误</span><br>    result = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-comment"># 捕获并处理异常</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>try</code> 块：包含可能会引发异常的代码。</li><li><code>except</code> 块：捕获指定类型的异常，并处理异常。如果没有指定异常类型，它会捕获所有异常。</li><li><code>as</code> 关键字：将异常实例绑定到一个变量，方便后续使用异常信息。</li></ul><h3 id="2-多个-except-语句"><a href="#2-多个-except-语句" class="headerlink" title="2. 多个 except 语句"></a>2. <strong>多个 <code>except</code> 语句</strong></h3><p>你可以使用多个 <code>except</code> 语句来捕获不同类型的异常。这样可以根据异常类型采取不同的处理方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Enter a number: &quot;</span>))<br>    result = <span class="hljs-number">10</span> / x<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: Division by zero is not allowed.&quot;</span>)<br><span class="hljs-keyword">except</span> ValueError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: Invalid input, please enter a number.&quot;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;An unexpected error occurred: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-else-语句"><a href="#3-else-语句" class="headerlink" title="3. else 语句"></a>3. <strong><code>else</code> 语句</strong></h3><p><code>else</code> 语句用于在没有发生异常时执行一些代码。如果 <code>try</code> 块没有引发异常，则会执行 <code>else</code> 块中的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Enter a number: &quot;</span>))<br>    result = <span class="hljs-number">10</span> / x<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: Division by zero is not allowed.&quot;</span>)<br><span class="hljs-keyword">except</span> ValueError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: Invalid input, please enter a number.&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Result is <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-finally-语句"><a href="#4-finally-语句" class="headerlink" title="4. finally 语句"></a>4. <strong><code>finally</code> 语句</strong></h3><p><code>finally</code> 块中的代码无论是否发生异常都会执行，通常用于清理资源，例如关闭文件、数据库连接等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br>    content = file.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error: File not found.&quot;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># 资源清理，保证文件始终被关闭</span><br>    file.close()<br></code></pre></td></tr></table></figure><p>在这个例子中，即使文件打开失败并引发异常，<code>finally</code> 代码块中的 <code>file.close()</code> 也会执行，确保文件资源被正确释放。</p><h3 id="5-自定义异常"><a href="#5-自定义异常" class="headerlink" title="5. 自定义异常"></a>5. <strong>自定义异常</strong></h3><p>Python 允许用户定义自己的异常类，这样可以创建特定的异常类型以适应特定的错误处理需求。自定义异常类通常继承自 <code>Exception</code> 类。</p><h4 id="示例：自定义异常"><a href="#示例：自定义异常" class="headerlink" title="示例：自定义异常"></a>示例：自定义异常</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomError</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, message</span>):<br>        self.message = message<br>        <span class="hljs-built_in">super</span>().__init__(self.message)<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">raise</span> CustomError(<span class="hljs-string">&quot;This is a custom exception!&quot;</span>)<br><span class="hljs-keyword">except</span> CustomError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Custom Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>CustomError</code> 是自定义的异常类，继承自 Python 内置的 <code>Exception</code> 类。</li><li><code>raise</code> 语句用于显式地抛出异常。</li><li><code>super().__init__(self.message)</code> 调用父类 <code>Exception</code> 的构造函数。</li></ul><h3 id="6-捕获所有异常"><a href="#6-捕获所有异常" class="headerlink" title="6. 捕获所有异常"></a>6. <strong>捕获所有异常</strong></h3><p>如果你想捕获所有异常，而不仅仅是某种特定类型的异常，可以使用 <code>except</code> 后不指定异常类型，或指定 <code>Exception</code> 类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 可能引发任何类型异常的代码</span><br>    x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Enter a number: &quot;</span>))<br>    result = <span class="hljs-number">10</span> / x<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;An error occurred: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 捕获所有异常并不推荐在实际编程中广泛使用，最好捕获特定的异常类型以便更好地定位和处理错误。</p><h3 id="7-抛出异常（raise）"><a href="#7-抛出异常（raise）" class="headerlink" title="7. 抛出异常（raise）"></a>7. <strong>抛出异常（<code>raise</code>）</strong></h3><p>在 Python 中，使用 <code>raise</code> 语句来手动抛出异常。可以抛出内置的异常，也可以抛出自定义的异常。</p><h4 id="示例：使用-raise-抛出异常"><a href="#示例：使用-raise-抛出异常" class="headerlink" title="示例：使用 raise 抛出异常"></a>示例：使用 <code>raise</code> 抛出异常</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Cannot divide by zero!&quot;</span>)<br>    <span class="hljs-keyword">return</span> a / b<br><br><span class="hljs-keyword">try</span>:<br>    result = divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>divide</code> 函数会检查除数是否为零，如果为零，则手动抛出 <code>ValueError</code> 异常。</p><h3 id="8-异常链（Exception-Chaining）"><a href="#8-异常链（Exception-Chaining）" class="headerlink" title="8. 异常链（Exception Chaining）"></a>8. <strong>异常链（Exception Chaining）</strong></h3><p>异常链是指在捕获异常时重新抛出另一个异常。Python 提供了 <code>from</code> 关键字来实现异常链。当你在处理一个异常时，如果需要抛出一个新的异常，可以通过 <code>raise new_exception from original_exception</code> 来保持异常链。</p><h4 id="示例：异常链"><a href="#示例：异常链" class="headerlink" title="示例：异常链"></a>示例：异常链</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;not_a_number&quot;</span>)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;A type error occurred&quot;</span>) <span class="hljs-keyword">from</span> e<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ValueError</code> 被捕获并且抛出一个新的 <code>TypeError</code> 异常，同时保持原始异常链。</p><h3 id="9-常见的内置异常类"><a href="#9-常见的内置异常类" class="headerlink" title="9. 常见的内置异常类"></a>9. <strong>常见的内置异常类</strong></h3><p>Python 提供了多种常见的内置异常类来处理不同类型的错误。以下是一些常见的异常类型：</p><table><thead><tr><th>异常类型</th><th>说明</th></tr></thead><tbody><tr><td><code>Exception</code></td><td>所有异常的基类</td></tr><tr><td><code>ValueError</code></td><td>参数类型不正确（例如转换错误）</td></tr><tr><td><code>TypeError</code></td><td>变量类型不匹配</td></tr><tr><td><code>IndexError</code></td><td>序列索引超出范围</td></tr><tr><td><code>KeyError</code></td><td>字典中没有该键</td></tr><tr><td><code>FileNotFoundError</code></td><td>文件未找到</td></tr><tr><td><code>ZeroDivisionError</code></td><td>除以零错误</td></tr><tr><td><code>AttributeError</code></td><td>对象没有该属性</td></tr><tr><td><code>IOError</code></td><td>输入输出操作失败</td></tr><tr><td><code>ImportError</code></td><td>导入模块失败</td></tr><tr><td><code>NameError</code></td><td>使用未定义的变量</td></tr><tr><td><code>RuntimeError</code></td><td>运行时错误</td></tr><tr><td><code>NotImplementedError</code></td><td>功能未实现</td></tr><tr><td><code>OSError</code></td><td>操作系统错误</td></tr></tbody></table><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在 Python 中，内存管理由 Python 解释器自动处理。Python 提供了多种机制来管理内存，确保内存资源能够高效使用，并避免内存泄漏和资源浪费。Python 的内存管理机制主要包括以下几个方面：</p><ol><li><strong>自动内存管理</strong></li><li><strong>内存分配与释放</strong></li><li><strong>垃圾回收（Garbage Collection）</strong></li><li><strong>引用计数（Reference Counting）</strong></li><li><strong>内存池和内存管理优化</strong></li></ol><h3 id="1-自动内存管理"><a href="#1-自动内存管理" class="headerlink" title="1. 自动内存管理"></a>1. <strong>自动内存管理</strong></h3><p>Python 内存管理的一个主要特点是<strong>自动化</strong>。用户无需显式地分配和释放内存（如 C、C++ 中需要手动管理内存）。Python 通过内置的机制自动处理对象的生命周期和内存管理任务，用户只需关注对象的创建和使用。</p><h3 id="2-内存分配与释放"><a href="#2-内存分配与释放" class="headerlink" title="2. 内存分配与释放"></a>2. <strong>内存分配与释放</strong></h3><p>Python 使用了多种内存管理机制，来提高内存分配和释放的效率。每个对象在 Python 中都需要占用内存，这些对象包括基础数据类型（如整数、字符串等）和自定义的类对象。</p><ul><li><strong>内存分配</strong>：Python 对象在内存中通常是通过 <strong>堆</strong>（heap）分配的。当创建一个新的对象时，Python 会为该对象分配一块内存区域。</li><li><strong>内存释放</strong>：当对象不再使用时，Python 会自动回收这些对象所占用的内存。Python 的内存管理通过引用计数和垃圾回收机制来实现内存的自动释放。</li></ul><h3 id="3-引用计数（Reference-Counting）"><a href="#3-引用计数（Reference-Counting）" class="headerlink" title="3. 引用计数（Reference Counting）"></a>3. <strong>引用计数（Reference Counting）</strong></h3><p>Python 使用 <strong>引用计数</strong> 来跟踪每个对象有多少引用。引用计数是 Python 内存管理的核心。每当一个对象被引用时，它的引用计数增加；每当引用该对象的变量超出作用域或被删除时，它的引用计数减少。</p><h4 id="工作机制："><a href="#工作机制：" class="headerlink" title="工作机制："></a>工作机制：</h4><ul><li>当一个对象的引用计数变为零时（没有任何变量或对象引用它），该对象就会被回收，其占用的内存也会被释放。</li><li><strong><code>del</code></strong> 语句和对象超出作用域都会减少对象的引用计数。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br>a = []<br><span class="hljs-built_in">print</span>(sys.getrefcount(a))  <span class="hljs-comment"># 输出引用计数，通常比你预期的多1，因为还有sys.getrefcount的引用</span><br><br>b = a  <span class="hljs-comment"># 增加引用</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(a))  <span class="hljs-comment"># 输出引用计数增加</span><br></code></pre></td></tr></table></figure><p>虽然引用计数机制非常高效，但它也有一个问题：无法解决<strong>循环引用</strong>的问题。即当两个或更多对象相互引用时，即使它们的引用计数为零，Python 也不会自动回收这些对象。</p><h3 id="4-垃圾回收（Garbage-Collection）"><a href="#4-垃圾回收（Garbage-Collection）" class="headerlink" title="4. 垃圾回收（Garbage Collection）"></a>4. <strong>垃圾回收（Garbage Collection）</strong></h3><p>为了处理循环引用的问题，Python 使用了 <strong>垃圾回收</strong>（GC）机制。垃圾回收是一种自动回收不再需要的对象的技术，Python 使用了一种称为 <strong>分代收集</strong>（Generational Collection）的垃圾回收算法。</p><ul><li><p>Python 的垃圾回收机制会定期检查哪些对象不再被引用，并将其从内存中移除。</p></li><li><p>Python 的垃圾回收机制基于 </p><p>分代理论</p><p>，将对象分为三代：</p><ul><li><strong>第 0 代</strong>：最近创建的对象。</li><li><strong>第 1 代</strong>：存活较长时间的对象。</li><li><strong>第 2 代</strong>：存活更长时间的对象。</li></ul></li></ul><p>Python 在垃圾回收过程中优先清理年轻对象（第 0 代）。随着对象的存活时间增加，它们的代数也会增大，回收的频率会减少。</p><h4 id="示例：显示垃圾回收"><a href="#示例：显示垃圾回收" class="headerlink" title="示例：显示垃圾回收"></a>示例：显示垃圾回收</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><br><span class="hljs-comment"># 禁用垃圾回收</span><br>gc.disable()<br><br><span class="hljs-comment"># 启用垃圾回收</span><br>gc.enable()<br><br><span class="hljs-comment"># 手动触发垃圾回收</span><br>gc.collect()<br></code></pre></td></tr></table></figure><h3 id="5-内存池和内存管理优化"><a href="#5-内存池和内存管理优化" class="headerlink" title="5. 内存池和内存管理优化"></a>5. <strong>内存池和内存管理优化</strong></h3><p>Python 在内存管理方面做了很多优化，尤其是在 <strong>小对象</strong> 的分配上。Python 使用了 <strong>内存池</strong>（memory pools）技术来提高内存分配的效率。</p><h4 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h4><ul><li>Python 使用 <code>PyMalloc</code> 内存池来管理小对象的内存分配，特别是对于大小固定的小对象（例如小整数、小字符串等）。</li><li>Python 会将内存按块分配，避免频繁的操作系统内存分配，从而提高性能。</li></ul><h3 id="6-内存管理的优化与调优"><a href="#6-内存管理的优化与调优" class="headerlink" title="6. 内存管理的优化与调优"></a>6. <strong>内存管理的优化与调优</strong></h3><ul><li><strong>对象池化</strong>：Python 中的许多内置类型（如整数、浮点数、字符串等）使用对象池机制，即对于常用的对象（如较小的整数、常见的字符串），Python 会重用内存而不是重新分配。这样可以减少内存的碎片化和内存分配的开销。</li><li><strong>减少内存碎片</strong>：Python 会根据对象的生命周期和存活时间，尽量避免内存碎片化。通过合理的内存池机制和分代回收策略，Python 能够高效地管理内存。</li></ul><h3 id="7-查看内存使用情况"><a href="#7-查看内存使用情况" class="headerlink" title="7. 查看内存使用情况"></a>7. <strong>查看内存使用情况</strong></h3><p>你可以使用一些工具来查看 Python 程序的内存使用情况，比如 <code>sys.getsizeof()</code> 和 <code>gc</code> 模块。</p><ul><li><code>sys.getsizeof()</code> 用于获取对象在内存中的大小。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br>x = <span class="hljs-number">42</span><br><span class="hljs-built_in">print</span>(sys.getsizeof(x))  <span class="hljs-comment"># 输出变量x占用的内存（字节）</span><br></code></pre></td></tr></table></figure><ul><li><code>gc</code> 模块用于检查垃圾回收的状态并触发手动回收。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc<br><br>gc.collect()  <span class="hljs-comment"># 手动触发垃圾回收</span><br><span class="hljs-built_in">print</span>(gc.get_count())  <span class="hljs-comment"># 获取当前垃圾回收器的各代对象数量</span><br></code></pre></td></tr></table></figure><h3 id="8-内存泄漏（Memory-Leak）"><a href="#8-内存泄漏（Memory-Leak）" class="headerlink" title="8. 内存泄漏（Memory Leak）"></a>8. <strong>内存泄漏（Memory Leak）</strong></h3><p>虽然 Python 自动进行内存管理，但内存泄漏仍然可能发生，特别是在复杂的应用程序中。当对象的引用计数没有减少到零时，这些对象无法被垃圾回收，从而导致内存无法释放。</p><ul><li><strong>循环引用</strong>：当两个或多个对象相互引用，且没有外部引用时，Python 的引用计数机制不会回收这些对象。虽然垃圾回收可以解决大部分循环引用的问题，但如果循环引用中的对象包含特殊的资源（如文件句柄、数据库连接等），它们的清理可能不完全，导致内存泄漏。</li><li><strong>解决方法</strong>：<ul><li>使用 <code>weakref</code> 模块来创建弱引用，避免循环引用。</li><li>定期检查程序的内存使用情况，使用 <code>gc</code> 模块来清理不再使用的对象。</li></ul></li></ul><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>Python 的网络编程通过内置的 <code>socket</code> 模块及其他高级模块，如 <code>asyncio</code>、<code>http</code>、<code>socketserver</code> 等，提供了强大的网络通信功能。Python 支持客户端和服务器端的网络通信，包括基于 TCP&#x2F;IP 协议的通信和其他协议的支持。</p><h3 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. <strong>基础概念</strong></h3><p>在网络编程中，我们通常涉及以下几个概念：</p><ul><li><strong>客户端</strong>：请求连接并与服务器进行通信的程序。</li><li><strong>服务器端</strong>：接收客户端请求并响应的程序。</li><li><strong>Socket</strong>：一种网络通信的抽象，允许程序通过网络发送和接收数据。它是基于 IP 地址和端口号进行通信的。</li><li><strong>IP 地址</strong>：标识网络中的每一台设备。</li><li><strong>端口号</strong>：标识计算机上每个进程或应用程序的标识符。</li></ul><h3 id="2-Python-socket-模块"><a href="#2-Python-socket-模块" class="headerlink" title="2. Python socket 模块"></a>2. <strong>Python <code>socket</code> 模块</strong></h3><p><code>socket</code> 模块是 Python 用于网络通信的核心模块，它支持客户端和服务器端的功能。使用 <code>socket</code> 模块，您可以通过网络协议（如 TCP 或 UDP）创建和使用套接字（socket）。</p><h3 id="3-TCP-Socket-编程"><a href="#3-TCP-Socket-编程" class="headerlink" title="3. TCP Socket 编程"></a>3. <strong>TCP Socket 编程</strong></h3><p>TCP（传输控制协议）是面向连接的、可靠的通信协议。使用 TCP 套接字，客户端和服务器可以进行双向数据传输。下面是一个简单的 TCP 网络编程示例，包括服务器端和客户端。</p><h4 id="服务器端（TCP-Server）"><a href="#服务器端（TCP-Server）" class="headerlink" title="服务器端（TCP Server）"></a>服务器端（TCP Server）</h4><p>服务器端程序创建一个 TCP 套接字，绑定到指定的 IP 地址和端口，监听客户端的连接请求，并处理客户端发送的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 创建一个 TCP/IP socket</span><br>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 绑定 IP 地址和端口</span><br>server_address = (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">65432</span>)<br>server_socket.bind(server_address)<br><br><span class="hljs-comment"># 开始监听连接</span><br>server_socket.listen(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Waiting for a connection...&quot;</span>)<br><br><span class="hljs-comment"># 等待连接</span><br>connection, client_address = server_socket.accept()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Connection established with <span class="hljs-subst">&#123;client_address&#125;</span>&quot;</span>)<br>    <br>    <span class="hljs-comment"># 接收数据并发送响应</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        data = connection.recv(<span class="hljs-number">1024</span>)<br>        <span class="hljs-keyword">if</span> data:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received: <span class="hljs-subst">&#123;data.decode()&#125;</span>&quot;</span>)<br>            connection.sendall(<span class="hljs-string">b&#x27;Hello, client&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># 关闭连接</span><br>    connection.close()<br></code></pre></td></tr></table></figure><ul><li><code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code>：创建一个 IPv4 地址族的 TCP 套接字。</li><li><code>bind()</code>：将套接字绑定到指定的 IP 地址和端口。</li><li><code>listen()</code>：开始监听连接，参数指定监听的最大连接数。</li><li><code>accept()</code>：等待客户端连接请求，并返回一个新的套接字和客户端地址。</li></ul><h4 id="客户端（TCP-Client）"><a href="#客户端（TCP-Client）" class="headerlink" title="客户端（TCP Client）"></a>客户端（TCP Client）</h4><p>客户端程序创建一个套接字，连接到服务器，并发送请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 创建一个 TCP/IP socket</span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># 连接到服务器</span><br>server_address = (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">65432</span>)<br>client_socket.connect(server_address)<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 发送数据</span><br>    message = <span class="hljs-string">&#x27;Hello, server&#x27;</span><br>    client_socket.sendall(message.encode())<br><br>    <span class="hljs-comment"># 接收响应</span><br>    data = client_socket.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received from server: <span class="hljs-subst">&#123;data.decode()&#125;</span>&quot;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-comment"># 关闭连接</span><br>    client_socket.close()<br></code></pre></td></tr></table></figure><ul><li><code>connect()</code>：连接到服务器。</li><li><code>sendall()</code>：发送数据到服务器。</li><li><code>recv()</code>：接收服务器返回的数据。</li></ul><h3 id="4-UDP-Socket-编程"><a href="#4-UDP-Socket-编程" class="headerlink" title="4. UDP Socket 编程"></a>4. <strong>UDP Socket 编程</strong></h3><p>UDP（用户数据报协议）是无连接的、不可靠的通信协议。它不像 TCP 那样确保数据的可靠性和顺序，但它比 TCP 更轻量，适用于不需要严格数据传输保障的场景（如实时视频、语音通信等）。</p><h4 id="服务器端（UDP-Server）"><a href="#服务器端（UDP-Server）" class="headerlink" title="服务器端（UDP Server）"></a>服务器端（UDP Server）</h4><p>UDP 服务器不需要绑定到一个特定的客户端连接，而是监听某个端口，并接收来自客户端的报文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 创建一个 UDP 套接字</span><br>server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br><br><span class="hljs-comment"># 绑定 IP 地址和端口</span><br>server_address = (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">65432</span>)<br>server_socket.bind(server_address)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Waiting for messages...&quot;</span>)<br><br><span class="hljs-comment"># 接收数据并发送响应</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    data, client_address = server_socket.recvfrom(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received: <span class="hljs-subst">&#123;data.decode()&#125;</span> from <span class="hljs-subst">&#123;client_address&#125;</span>&quot;</span>)<br>    server_socket.sendto(<span class="hljs-string">b&#x27;Hello, UDP client&#x27;</span>, client_address)<br></code></pre></td></tr></table></figure><h4 id="客户端（UDP-Client）"><a href="#客户端（UDP-Client）" class="headerlink" title="客户端（UDP Client）"></a>客户端（UDP Client）</h4><p>UDP 客户端不需要建立连接，而是直接向服务器发送数据报文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 创建一个 UDP 套接字</span><br>client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br><br><span class="hljs-comment"># 服务器的地址和端口</span><br>server_address = (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">65432</span>)<br><br><span class="hljs-comment"># 发送数据</span><br>message = <span class="hljs-string">&#x27;Hello, UDP server&#x27;</span><br>client_socket.sendto(message.encode(), server_address)<br><br><span class="hljs-comment"># 接收响应</span><br>data, server = client_socket.recvfrom(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received from server: <span class="hljs-subst">&#123;data.decode()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 关闭套接字</span><br>client_socket.close()<br></code></pre></td></tr></table></figure><h3 id="5-异步网络编程（asyncio-模块）"><a href="#5-异步网络编程（asyncio-模块）" class="headerlink" title="5. 异步网络编程（asyncio 模块）"></a>5. <strong>异步网络编程（<code>asyncio</code> 模块）</strong></h3><p>Python 还提供了 <code>asyncio</code> 模块，支持异步 I&#x2F;O 操作，适合需要高并发的网络应用（如 Web 服务器、聊天应用等）。通过 <code>async</code> 和 <code>await</code>，可以处理大量的网络请求，而无需阻塞主线程。</p><h4 id="异步-TCP-服务器（asyncio）"><a href="#异步-TCP-服务器（asyncio）" class="headerlink" title="异步 TCP 服务器（asyncio）"></a>异步 TCP 服务器（<code>asyncio</code>）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_client</span>(<span class="hljs-params">reader, writer</span>):<br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">100</span>)<br>    message = data.decode()<br>    addr = writer.get_extra_info(<span class="hljs-string">&#x27;peername&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Received <span class="hljs-subst">&#123;message&#125;</span> from <span class="hljs-subst">&#123;addr&#125;</span>&quot;</span>)<br><br>    response = <span class="hljs-string">&#x27;Hello, client&#x27;</span><br>    writer.write(response.encode())<br>    <span class="hljs-keyword">await</span> writer.drain()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Closing the connection&quot;</span>)<br>    writer.close()<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    server = <span class="hljs-keyword">await</span> asyncio.start_server(<br>        handle_client, <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">65432</span>)<br>    addr = server.sockets[<span class="hljs-number">0</span>].getsockname()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Serving on <span class="hljs-subst">&#123;addr&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> server:<br>        <span class="hljs-keyword">await</span> server.serve_forever()<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><ul><li><code>asyncio.start_server()</code>：创建异步 TCP 服务器。</li><li><code>await reader.read()</code>：异步地读取客户端发送的数据。</li><li><code>writer.write()</code>：异步地发送数据到客户端。</li></ul><h4 id="异步-TCP-客户端（asyncio）"><a href="#异步-TCP-客户端（asyncio）" class="headerlink" title="异步 TCP 客户端（asyncio）"></a>异步 TCP 客户端（<code>asyncio</code>）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">tcp_client</span>():<br>    reader, writer = <span class="hljs-keyword">await</span> asyncio.open_connection(<br>        <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">65432</span>)<br><br>    message = <span class="hljs-string">&#x27;Hello, server&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Sending: <span class="hljs-subst">&#123;message&#125;</span>&#x27;</span>)<br>    writer.write(message.encode())<br>    <span class="hljs-keyword">await</span> writer.drain()<br><br>    data = <span class="hljs-keyword">await</span> reader.read(<span class="hljs-number">100</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Received: <span class="hljs-subst">&#123;data.decode()&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Closing the connection&#x27;</span>)<br>    writer.close()<br><br>asyncio.run(tcp_client())<br></code></pre></td></tr></table></figure><h3 id="6-HTTP-网络编程"><a href="#6-HTTP-网络编程" class="headerlink" title="6. HTTP 网络编程"></a>6. <strong>HTTP 网络编程</strong></h3><p>除了 TCP 和 UDP，Python 也提供了用于处理 HTTP 协议的库，如 <code>http.client</code>、<code>requests</code> 等。<code>requests</code> 是一个非常流行且易于使用的库，适合发送 HTTP 请求和处理响应。</p><h4 id="使用-requests-库发送-HTTP-请求"><a href="#使用-requests-库发送-HTTP-请求" class="headerlink" title="使用 requests 库发送 HTTP 请求"></a>使用 <code>requests</code> 库发送 HTTP 请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 发送 GET 请求</span><br>response = requests.get(<span class="hljs-string">&#x27;https://www.example.com&#x27;</span>)<br><span class="hljs-built_in">print</span>(response.text)  <span class="hljs-comment"># 打印响应的内容</span><br><br><span class="hljs-comment"># 发送 POST 请求</span><br>data = &#123;<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;<br>response = requests.post(<span class="hljs-string">&#x27;https://www.example.com&#x27;</span>, data=data)<br><span class="hljs-built_in">print</span>(response.text)<br></code></pre></td></tr></table></figure><ul><li><code>requests.get()</code>：发送一个 GET 请求。</li><li><code>requests.post()</code>：发送一个 POST 请求。</li></ul><h3 id="7-HTTP-服务器"><a href="#7-HTTP-服务器" class="headerlink" title="7. HTTP 服务器"></a>7. <strong>HTTP 服务器</strong></h3><p>可以使用 <code>http.server</code> 模块创建一个简单的 HTTP 服务器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> http.server <span class="hljs-keyword">import</span> SimpleHTTPRequestHandler, HTTPServer<br><br><span class="hljs-comment"># 设置服务器地址和端口</span><br>server_address = (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8000</span>)<br>httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Serving HTTP on port 8000&quot;</span>)<br>httpd.serve_forever()<br></code></pre></td></tr></table></figure><ul><li><code>SimpleHTTPRequestHandler</code>：内置的 HTTP 请求处理器，处理静态文件请求。</li><li><code>HTTPServer</code>：HTTP 服务器类。</li></ul><h1 id="文件流处理"><a href="#文件流处理" class="headerlink" title="文件流处理"></a>文件流处理</h1><p>在 Python 中，文件流处理是通过内置的 <code>open()</code> 函数和文件对象的方法来进行的。文件流处理允许程序读取、写入、修改文件内容，并且支持处理大文件的高效方式。</p><h3 id="1-文件操作基本流程"><a href="#1-文件操作基本流程" class="headerlink" title="1. 文件操作基本流程"></a>1. <strong>文件操作基本流程</strong></h3><p>文件流操作的基本流程通常包括以下几个步骤：</p><ol><li><strong>打开文件</strong>：使用 <code>open()</code> 函数。</li><li><strong>读取或写入文件</strong>：通过文件对象的 <code>read()</code>、<code>write()</code>、<code>readline()</code> 等方法来读取或写入内容。</li><li><strong>关闭文件</strong>：使用 <code>close()</code> 方法关闭文件，释放资源。</li></ol><h3 id="2-open-函数"><a href="#2-open-函数" class="headerlink" title="2. open() 函数"></a>2. <strong><code>open()</code> 函数</strong></h3><p><code>open()</code> 函数用于打开文件并返回一个文件对象，供后续的读取或写入操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)  <span class="hljs-comment"># 打开文件进行读取</span><br></code></pre></td></tr></table></figure><ul><li><p>常用模式</p><p>：</p><ul><li><code>&#39;r&#39;</code>：只读模式，文件必须存在。</li><li><code>&#39;w&#39;</code>：写入模式，如果文件存在则覆盖，不存在则创建。</li><li><code>&#39;a&#39;</code>：追加模式，文件不存在则创建，存在则在文件末尾追加内容。</li><li><code>&#39;b&#39;</code>：二进制模式，通常与其他模式一起使用，例如 <code>&#39;rb&#39;</code> 或 <code>&#39;wb&#39;</code>。</li><li><code>&#39;x&#39;</code>：独占创建模式，如果文件已经存在则会引发 <code>FileExistsError</code>。</li></ul></li></ul><h3 id="3-读取文件"><a href="#3-读取文件" class="headerlink" title="3. 读取文件"></a>3. <strong>读取文件</strong></h3><h4 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    content = file.read()  <span class="hljs-comment"># 读取文件所有内容</span><br>    <span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure><ul><li><code>file.read()</code>：读取整个文件内容。</li><li><code>with</code> 语句：用于自动关闭文件，即使发生异常也会确保文件被正确关闭。</li></ul><h4 id="读取文件的每一行"><a href="#读取文件的每一行" class="headerlink" title="读取文件的每一行"></a>读取文件的每一行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    lines = file.readlines()  <span class="hljs-comment"># 读取文件的每一行</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        <span class="hljs-built_in">print</span>(line.strip())  <span class="hljs-comment"># 使用 strip() 去除行末的换行符</span><br></code></pre></td></tr></table></figure><ul><li><code>file.readlines()</code>：读取文件的所有行，返回一个列表，其中每个元素是文件的一行。</li></ul><h4 id="逐行读取文件（适用于大文件）"><a href="#逐行读取文件（适用于大文件）" class="headerlink" title="逐行读取文件（适用于大文件）"></a>逐行读取文件（适用于大文件）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:  <span class="hljs-comment"># 按行读取</span><br>        <span class="hljs-built_in">print</span>(line.strip())<br></code></pre></td></tr></table></figure><ul><li>使用 <code>for</code> 循环按行读取文件可以避免一次性读取整个文件，尤其在处理大文件时更为高效。</li></ul><h3 id="4-写入文件"><a href="#4-写入文件" class="headerlink" title="4. 写入文件"></a>4. <strong>写入文件</strong></h3><h4 id="写入字符串到文件"><a href="#写入字符串到文件" class="headerlink" title="写入字符串到文件"></a>写入字符串到文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>)  <span class="hljs-comment"># 写入内容</span><br></code></pre></td></tr></table></figure><ul><li><code>file.write()</code>：将字符串写入文件，但不会自动添加换行符。</li></ul><h4 id="追加内容到文件"><a href="#追加内容到文件" class="headerlink" title="追加内容到文件"></a>追加内容到文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&quot;This is an additional line.\n&quot;</span>)  <span class="hljs-comment"># 追加内容</span><br></code></pre></td></tr></table></figure><ul><li><code>file.write()</code> 也可以用于追加内容，通过使用 <code>&#39;a&#39;</code> 模式。</li></ul><h4 id="写入多行内容"><a href="#写入多行内容" class="headerlink" title="写入多行内容"></a>写入多行内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    lines = [<span class="hljs-string">&#x27;First line\n&#x27;</span>, <span class="hljs-string">&#x27;Second line\n&#x27;</span>, <span class="hljs-string">&#x27;Third line\n&#x27;</span>]<br>    file.writelines(lines)  <span class="hljs-comment"># 写入多个行</span><br></code></pre></td></tr></table></figure><ul><li><code>file.writelines()</code>：接受一个字符串列表，逐行写入到文件中。注意，这里不会自动添加换行符，需要确保每一行的内容末尾已有换行符。</li></ul><h3 id="5-二进制文件操作"><a href="#5-二进制文件操作" class="headerlink" title="5. 二进制文件操作"></a>5. <strong>二进制文件操作</strong></h3><p>对于图像、音频或其他二进制数据，文件操作需要使用二进制模式 <code>&#39;b&#39;</code>。例如：</p><h4 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;image.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    data = file.read()  <span class="hljs-comment"># 读取二进制数据</span><br>    <span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><ul><li><code>rb</code> 模式用于以二进制方式打开文件，读取图像、音频等二进制文件时非常常见。</li></ul><h4 id="写入二进制文件"><a href="#写入二进制文件" class="headerlink" title="写入二进制文件"></a>写入二进制文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;copy_image.png&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(data)  <span class="hljs-comment"># 将读取的二进制数据写入到新文件</span><br></code></pre></td></tr></table></figure><ul><li><code>wb</code> 模式用于以二进制方式写入文件。</li></ul><h3 id="6-文件指针和文件位置"><a href="#6-文件指针和文件位置" class="headerlink" title="6. 文件指针和文件位置"></a>6. <strong>文件指针和文件位置</strong></h3><p>文件指针用于指示文件当前的读取&#x2F;写入位置。可以使用 <code>seek()</code> 和 <code>tell()</code> 来操作和查询文件指针。</p><ul><li><p><code>seek(offset, whence)</code></p><p>：设置文件指针位置。</p><ul><li><code>offset</code>：偏移量，单位是字节。</li><li><code>whence</code>：参考位置，默认为 <code>os.SEEK_SET</code>（文件开头）。其他值还包括 <code>os.SEEK_CUR</code>（当前位置）和 <code>os.SEEK_END</code>（文件末尾）。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.seek(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 将文件指针移动到第5个字节</span><br>    content = file.read(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 从文件指针位置读取10个字节</span><br>    <span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure><ul><li>**<code>tell()</code>**：返回当前文件指针的位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.seek(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 将文件指针移动到第5个字节</span><br>    <span class="hljs-built_in">print</span>(file.tell())  <span class="hljs-comment"># 输出当前指针的位置（5）</span><br></code></pre></td></tr></table></figure><h3 id="7-文件关闭"><a href="#7-文件关闭" class="headerlink" title="7. 文件关闭"></a>7. <strong>文件关闭</strong></h3><p>虽然使用 <code>with</code> 语句可以自动关闭文件，但如果没有使用 <code>with</code>，你需要手动关闭文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-comment"># 执行文件操作</span><br>file.close()  <span class="hljs-comment"># 关闭文件</span><br></code></pre></td></tr></table></figure><p>确保每次文件操作结束后调用 <code>close()</code> 以释放系统资源。</p><h3 id="8-异常处理"><a href="#8-异常处理" class="headerlink" title="8. 异常处理"></a>8. <strong>异常处理</strong></h3><p>在文件操作中，文件可能不存在、权限不足等，因此需要进行异常处理。使用 <code>try</code>、<code>except</code> 来捕获可能的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;non_existent_file.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        content = file.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;File not found!&quot;</span>)<br><span class="hljs-keyword">except</span> IOError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error reading file!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="9-文件操作常见错误"><a href="#9-文件操作常见错误" class="headerlink" title="9. 文件操作常见错误"></a>9. <strong>文件操作常见错误</strong></h3><ul><li>**<code>FileNotFoundError</code>**：文件未找到。</li><li>**<code>PermissionError</code>**：权限不足，无法访问文件。</li><li>**<code>IOError</code>**：发生了其他 I&#x2F;O 错误。</li></ul><h3 id="10-os-模块与文件处理"><a href="#10-os-模块与文件处理" class="headerlink" title="10. os 模块与文件处理"></a>10. <strong><code>os</code> 模块与文件处理</strong></h3><p>Python 的 <code>os</code> 模块也提供了很多用于文件系统操作的功能，如文件的删除、重命名、查询文件属性等。</p><ul><li><strong>删除文件</strong>：<code>os.remove()</code></li><li><strong>重命名文件</strong>：<code>os.rename()</code></li><li><strong>检查文件是否存在</strong>：<code>os.path.exists()</code></li><li><strong>获取文件大小</strong>：<code>os.path.getsize()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 检查文件是否存在</span><br><span class="hljs-keyword">if</span> os.path.exists(<span class="hljs-string">&#x27;example.txt&#x27;</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;File exists&quot;</span>)<br><br><span class="hljs-comment"># 获取文件大小</span><br>file_size = os.path.getsize(<span class="hljs-string">&#x27;example.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;File size: <span class="hljs-subst">&#123;file_size&#125;</span> bytes&quot;</span>)<br><br><span class="hljs-comment"># 删除文件</span><br>os.remove(<span class="hljs-string">&#x27;example.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="11-文件锁定"><a href="#11-文件锁定" class="headerlink" title="11. 文件锁定"></a>11. <strong>文件锁定</strong></h3><p>如果多个程序或线程需要同时操作同一个文件，可能会发生竞争条件（race condition）。Python 可以使用 <code>fcntl</code> 或 <code>msvcrt</code>（在 Windows 上）来对文件进行锁定。</p><p>。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Selenium学习</title>
    <link href="/2022/09/23/Selenium%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/23/Selenium%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="selenium历程"><a href="#selenium历程" class="headerlink" title="selenium历程"></a><strong>selenium历程</strong></h1><blockquote><p><a href="https://segmentfault.com/a/1190000022207984#item-1">java - Selenium 工作原理 - 个人文章 - SegmentFault 思否</a>这篇文章中作者对selenium的发展历程谈的比较仔细，这里简单总结一下就是：</p></blockquote><ol><li>04年，诞生了Selenium Core，Selenium Core是基于浏览器并且采用JavaScript编程语言的测试工具，运行在浏览器的安全沙箱中，设计理念是将待测试产品、Selenium Core和测试脚本均部署到同一台<a href="https://cloud.tencent.com/product/cvm/?from_column=20065&from=20065">服务器</a>上来完成自动化测试的工作(同源策略问题)。</li><li>05年，Selenium RC诞生，就是selenium1 ，这个时候，Selenium Core其实是Selenium RC的核心。 Selenium RC让待测试产品、Selenium Core和测试脚本三者分散在不同的服务器上。（测试脚本只关心将HTTP请求发送到指定的URL上，selenium本身不需要关心HTTP请求由于什么程序编程语言编写而成） Selenium RC包括两部分：一个是Selenium RC Server，一个是提供各种编程语言的客户端驱动来编写测试脚本 </li><li>07年，Webdriver诞生，WebDriver的设计理念是将端到端测试与底层具体的测试工具分隔离，并采用设计模式Adapter适配器来达到目标。WebDriver的API组织更多的是面向对象。 </li><li>08&#x2F;09年，selenium2诞生，selenium2其实是selenium rc和webdriver的合并，合并的根本原因是相互补充各自的缺点 </li><li>09年，selenium3诞生，这个版本剔除了selenium rc ， 主要由 selenium webdriver和selenium Grid组成， 我们日常使用的其实就是selenium webdriver，至于selenium grid是一个分布式实现自动化测试的工具</li></ol><h1 id="简单谈谈什么是webdriver"><a href="#简单谈谈什么是webdriver" class="headerlink" title="简单谈谈什么是webdriver?"></a>简单谈谈什么是webdriver?</h1><p>在前面简单谈到了Webdriver,在写自动化测试程序时,通常也必须写：</p><p><img src="https://s2.loli.net/2025/01/17/Y6FKudEhliRbByr.png" alt="image-20250117162213156"></p><h3 id="W3C-WebDriver-协议"><a href="#W3C-WebDriver-协议" class="headerlink" title="W3C WebDriver 协议"></a>W3C WebDriver 协议</h3><blockquote><p><strong>W3C WebDriver 协议</strong>（即 <strong>WebDriver W3C Specification</strong>）是一个由 <strong>W3C（World Wide Web Consortium，万维网联盟）</strong> 制定的标准，它定义了 Web 浏览器与自动化客户端（如 Selenium、Appium 等）之间的通信协议。这个协议为浏览器自动化提供了一种标准化的方式，确保不同浏览器和不同的浏览器驱动程序能够实现一致的行为。</p></blockquote><p>W3C WebDriver 协议定义了一个标准的 HTTP API，浏览器驱动通过这个 API 接收和执行命令。其主要组成部分包括：</p><ol><li><strong>命令</strong>（Commands）：定义了与浏览器交互的基本操作。<ul><li><strong>导航命令</strong>（如：<code>GET</code>、<code>BACK</code>、<code>FORWARD</code>、<code>REFRESH</code>）</li><li><strong>元素交互命令</strong>（如：<code>CLICK</code>、<code>SEND_KEYS</code>、<code>CLEAR</code>）</li><li><strong>获取信息命令</strong>（如：<code>GET_TITLE</code>、<code>GET_CURRENT_URL</code>、<code>GET_ELEMENT_TEXT</code>）</li><li><strong>窗口与框架命令</strong>（如：<code>SWITCH_TO_WINDOW</code>、<code>SWITCH_TO_FRAME</code>）</li></ul></li><li><strong>响应</strong>（Responses）：WebDriver 服务器对命令执行后的响应，返回执行结果或错误信息。<ul><li><strong>成功响应</strong>：包含操作的结果（如元素的位置、页面标题等）。</li><li><strong>失败响应</strong>：包含错误信息，通常是由于元素未找到、超时等原因导致的。</li></ul></li><li><strong>会话管理</strong>（Session Management）：定义了如何启动、管理和终止 WebDriver 会话。<ul><li><strong>新建会话</strong>：启动 WebDriver 实例并创建会话，返回一个会话 ID。</li><li><strong>结束会话</strong>：关闭当前会话并退出浏览器。</li></ul></li><li><strong>异步操作</strong>（Asynchronous Operations）：WebDriver 协议支持异步操作，这意味着可以处理长时间运行的操作（如等待元素加载、获取页面截图等）。</li><li><strong>元素定位与交互</strong>：协议定义了元素定位和交互的标准方法，包括通过 ID、名称、类名、XPath、CSS 选择器等方式定位元素，以及与元素进行交互（如点击、输入、清空等）。</li><li><strong>事件与鼠标&#x2F;键盘操作</strong>：WebDriver 协议支持模拟复杂的用户交互行为，例如鼠标悬停、点击、键盘输入、拖放等。</li></ol><h3 id="W3C-WebDriver-协议的工作原理"><a href="#W3C-WebDriver-协议的工作原理" class="headerlink" title="W3C WebDriver 协议的工作原理"></a>W3C WebDriver 协议的工作原理</h3><p>WebDriver 协议基于客户端和服务器的通信模型。其工作过程如下：</p><ol><li>客户端（例如 Selenium）<ul><li>自动化脚本运行在 WebDriver 客户端，它会向 WebDriver 服务器（浏览器驱动）发送 HTTP 请求。</li><li>请求内容通常是一些浏览器操作命令，例如：打开 URL、点击元素、获取页面标题等。</li></ul></li><li>WebDriver 服务器（浏览器驱动）<ul><li>WebDriver 服务器接收到客户端请求后，负责将命令转化为浏览器可执行的操作。</li><li>每个浏览器都有自己的 WebDriver 服务器（如 Chrome 的 <code>chromedriver</code>，Firefox 的 <code>geckodriver</code>，Safari 的 <code>safaridriver</code>），这些驱动程序通过与浏览器的原生 API 进行通信来执行命令。</li></ul></li><li>浏览器<ul><li>浏览器通过其原生接口（如 Chrome 的 DevTools 协议、Firefox 的 Marionette）接收和执行操作。</li><li>浏览器返回执行结果（例如成功、失败、元素位置等）给 WebDriver 服务器，WebDriver 服务器再将结果传递给客户端。</li></ul></li></ol><p><img src="https://s2.loli.net/2025/01/17/D7b5XsZPhECkKSd.png" alt="image-20250117162950019"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="https://s2.loli.net/2025/01/17/1gdZLDiBczHGwNU.png" alt="db533e98a7164936ed5591d6b2609679"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote><p>这里我直接以selenium4.5.0版本为例，并驱动谷歌浏览器</p></blockquote><h3 id="WebDriver"><a href="#WebDriver" class="headerlink" title="WebDriver"></a>WebDriver</h3><p><img src="https://s2.loli.net/2025/01/17/nNovexcErXbDP3Z.png" alt="image-20250117163853540"></p><p>这里可以看出：</p><p>定义了 <code>WebDriver</code> 类的示例，继承自 <code>ChromiumDriver</code> 类，用于控制 Chrome 浏览器并启动 ChromeDriver 服务。</p><ul><li><strong>弃用警告</strong>：许多旧版本的参数已经被弃用（如 <code>executable_path</code>、<code>chrome_options</code>、<code>keep_alive</code>），并且推荐通过 <code>Service</code> 对象来处理这些配置。</li><li><strong><code>Service</code> 对象</strong>：新的配置方式是通过 <code>Service</code> 对象来启动和管理浏览器驱动服务。</li><li><strong>调用父类构造方法</strong>：<code>super().__init__</code> 调用父类 <code>ChromiumDriver</code> 的构造方法，初始化浏览器驱动。传递了浏览器的能力、端口、选项、日志路径等配置。</li></ul><h3 id="ChromiumDriver"><a href="#ChromiumDriver" class="headerlink" title="ChromiumDriver"></a>ChromiumDriver</h3><p><img src="https://s2.loli.net/2025/01/17/7dhIPgrLR69GYl8.png" alt="image-20250117164644929"></p><p><em><strong>关键点分析</strong></em></p><p>**继承自 <code>RemoteWebDriver</code>**：</p><ul><li>该类继承自 <code>RemoteWebDriver</code>，说明它可以在远程浏览器实例上执行命令，通过远程服务器与 Chromium 浏览器进行交互。</li></ul><p>**初始化方法 (<code>__init__</code>)**：</p><ul><li><code>__init__</code> 方法用于初始化 <code>ChromiumDriver</code> 实例。它设置了许多过时的参数（如 <code>port</code>, <code>desired_capabilities</code>, <code>service_log_path</code>, <code>keep_alive</code>），并且建议使用 <code>Service</code> 对象来代替这些配置。</li><li>通过 <code>service</code> 参数传入的 <code>Service</code> 对象负责启动和管理 ChromiumDriver 服务。</li><li>启动服务后，<code>super().__init__()</code> 调用父类的构造方法，初始化 <code>RemoteWebDriver</code>。</li></ul><p>**<code>launch_app</code>**：</p><ul><li>启动指定的 Chromium 应用程序（通过 <code>id</code>）。</li><li>这个功能与 Chrome 或 Edge 的应用启动相关，可以用来启动特定的浏览器应用。</li></ul><p>**网络模拟 (<code>get_network_conditions</code>, <code>set_network_conditions</code>, <code>delete_network_conditions</code>)**：</p><ul><li>这些方法提供了网络条件模拟功能（例如模拟延迟、下载&#x2F;上传速率等）。<code>set_network_conditions</code> 方法可以模拟不同的网络环境，<code>get_network_conditions</code> 用于获取当前的网络条件，<code>delete_network_conditions</code> 用于重置网络模拟。</li></ul><p>**权限管理 (<code>set_permissions</code>)**：</p><ul><li><code>set_permissions</code> 方法允许用户设置 Chromium 浏览器中某些权限（如对剪贴板、摄像头等的访问权限）。</li></ul><p>**执行 Chrome DevTools 协议命令 (<code>execute_cdp_cmd</code>)**：</p><ul><li>通过 <code>execute_cdp_cmd</code> 方法，用户可以执行任意的 Chrome DevTools 协议命令。这为用户提供了更底层的控制功能，允许访问和操作 Chromium 的许多高级功能，例如网络请求、页面加载等。</li></ul><p>**Casting 控制 (<code>get_sinks</code>, <code>set_sink_to_use</code>, <code>start_desktop_mirroring</code>, <code>start_tab_mirroring</code>, <code>stop_casting</code>)**：</p><ul><li>提供与 Chromecast 或类似设备的交互接口。用户可以列出可用的接收器（sinks）、设置接收器、启动&#x2F;停止桌面或标签页镜像等。</li></ul><p><strong><code>quit</code> 方法</strong>：</p><ul><li>关闭浏览器并停止 ChromiumDriver 服务。</li></ul><p><strong><code>create_options</code> 方法</strong>：</p><ul><li>根据 <code>vendor_prefix</code>（浏览器的厂商前缀）创建对应的浏览器配置选项。如果是 Edge 浏览器，则创建 <code>EdgeOptions</code>，否则创建 <code>ChromeOptions</code>。</li></ul><h4 id="start-self"><a href="#start-self" class="headerlink" title="start(self)"></a>start(self)</h4><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250117165145564.png" alt="image-20250117165145564"></p><p>可以看到这里执行了一个cmd命令，这个命令主要是启动了一个ChromeDriver.exe浏览器驱动，我们每次在执行脚本前，程序会自动帮我们启动浏览器驱动，这个效果就跟我们自己手动启动是一样的效果。</p><blockquote><p> 第一步工作我们已经知道了执行脚本webdriver.Chrome()会自动执行 chromedirver.exe驱动程序，然后开启一个进程</p></blockquote><h3 id="RemoteWebDriver"><a href="#RemoteWebDriver" class="headerlink" title="RemoteWebDriver"></a>RemoteWebDriver</h3><p>在ChromiumDriver中我们看到：启动服务后，<code>super().__init__()</code> 调用父类的构造方法，初始化 <code>RemoteWebDriver</code>。接下来就看看这一个父类的初始化</p><p><img src="https://s2.loli.net/2025/01/17/jZSIyfJ2HAW4EuN.png" alt="image-20250117165658882"></p><p>这里有一行最重要的代码，self.start_session(capabilities, browser_profile) 这个方法，继续看一下这个方法的源码做了什么工作</p><p><img src="https://s2.loli.net/2025/01/17/u6p9gklWnRX3ZmK.png" alt="image-20250117170020962"></p><p>用于在 WebDriver 中启动一个新的浏览器会话，并传入指定的（capabilities）进行初始化。</p><p>以上代码都说明了一件事：向地址localhost:4444&#x2F;session发送了一个post请求，参数是json格式的，然后返回特定的响应信息给程序(这里主要就是新建了一个sessionid)，最终打开了浏览器</p><blockquote><p>第二步：成功打开了浏览器</p></blockquote><p>之后再次回到ChromiumDriver，通过</p><p><img src="https://s2.loli.net/2025/01/17/GfDR1PW8sdy2XKl.png" alt="image-20250117170703250"></p><p>执行对应操作</p><h3 id="ChromiumRemoteConnection"><a href="#ChromiumRemoteConnection" class="headerlink" title="ChromiumRemoteConnection"></a>ChromiumRemoteConnection</h3><p><img src="https://s2.loli.net/2025/01/17/4ykmbNUueEw1RO6.png" alt="image-20250117170810253"></p><p><code>ChromiumRemoteConnection</code> 类为与 Chromium 浏览器的远程通信提供了特定的命令接口，开发者可以通过这些命令与浏览器进行更为细致的交互。例如，可以用它来设置模拟的网络条件，执行 Chrome DevTools Protocol 命令，或者与 Cast 设备交互（如启动桌面镜像、控制 Cast 会话等）。</p><p>这些命令大多是通过 HTTP 请求发送到远程 WebDriver 服务，并与 Chromium 浏览器进行交互，类似于其它 WebDriver 命令，但这里特别针对 Chromium 浏览器的需求进行扩展。</p><blockquote><p>所有的操作对应接口地址我们知道了，那么又怎样执行这些接口来达到在浏览器上实现各种操作呢？继续看紧接着接口地址定义下面的源码？</p></blockquote><p><img src="https://s2.loli.net/2025/01/17/rY7p5bNx6Ei1BaC.png" alt="image-20250117171009369"></p><p> 可以看到主要是通过execute方法调用_request方法通过urilib3标准库向服务器发送对应操作请求地址，进而实现了浏览器各种操作。</p><p><img src="https://s2.loli.net/2025/01/17/wfQMNyPYGmD2H5c.png" alt="image-20250117163430758"></p><h2 id="结合案例分析"><a href="#结合案例分析" class="headerlink" title="结合案例分析"></a>结合案例分析</h2><h3 id="1-测试脚本初始化"><a href="#1-测试脚本初始化" class="headerlink" title="1. 测试脚本初始化"></a>1. <strong>测试脚本初始化</strong></h3><p>当你编写一个 Selenium 自动化测试脚本时，它通常会使用一个语言的客户端库（例如 Python 的 <code>selenium</code> 库）。测试脚本通常开始时会导入 Selenium 的相关模块并初始化一个 WebDriver 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-comment"># 初始化 WebDriver</span><br>driver = webdriver.Chrome(executable_path=<span class="hljs-string">&#x27;path_to_chromedriver&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-启动服务与浏览器驱动"><a href="#2-启动服务与浏览器驱动" class="headerlink" title="2. 启动服务与浏览器驱动"></a>2. <strong>启动服务与浏览器驱动</strong></h3><ul><li><strong>服务启动</strong>：WebDriver 会通过启动一个特定的服务来与浏览器驱动程序（例如 <code>chromedriver.exe</code>、<code>geckodriver.exe</code>）通信。这个浏览器驱动程序充当了 WebDriver 客户端与浏览器之间的桥梁。</li><li><strong>浏览器驱动程序</strong>：浏览器驱动程序是一个独立的进程，负责启动和控制实际的浏览器（如 Chrome、Firefox）。浏览器驱动程序通过 WebDriver 协议与 Selenium 客户端进行通信。</li></ul><p>这一部分是浏览器启动的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 启动浏览器并打开指定页面</span><br>driver.get(<span class="hljs-string">&quot;https://www.example.com&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-HTTP-请求与响应机制"><a href="#3-HTTP-请求与响应机制" class="headerlink" title="3. HTTP 请求与响应机制"></a>3. <strong>HTTP 请求与响应机制</strong></h3><ul><li><strong>发送请求</strong>：测试脚本通过 <code>RemoteWebDriver</code> 向浏览器驱动程序发送 HTTP 请求。具体来说，测试脚本执行的每个动作（如打开网页、查找元素、点击等）都会被转换为一个 HTTP 请求，并发送到浏览器驱动程序（远程服务器）。</li><li><strong>浏览器驱动程序解析请求</strong>：浏览器驱动程序接收到 HTTP 请求后，会解析请求并执行相应的操作。例如，如果脚本要求打开一个 URL，浏览器驱动程序会在浏览器中打开指定的网页。</li><li><strong>会话 ID</strong>：浏览器驱动程序启动浏览器时，会生成一个唯一的会话 ID（<code>sessionId</code>），该 ID 会在每个后续请求中携带。通过这个 <code>sessionId</code>，浏览器驱动程序能够识别当前的浏览器会话，并执行相应的操作。</li></ul><p>请求示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.get(<span class="hljs-string">&quot;https://www.example.com&quot;</span>)<br></code></pre></td></tr></table></figure><p>此命令会向浏览器驱动程序发送一个 HTTP 请求，浏览器驱动程序解析该请求并打开网页。</p><h3 id="4-RemoteConnection-与-Remote-Server"><a href="#4-RemoteConnection-与-Remote-Server" class="headerlink" title="4. RemoteConnection 与 Remote Server"></a>4. <strong>RemoteConnection 与 Remote Server</strong></h3><ul><li><strong>RemoteConnection</strong>：在 Selenium 中，<code>RemoteConnection</code> 负责与浏览器驱动程序之间的通信。通过该连接，Selenium 可以发送 HTTP 请求并等待浏览器驱动程序的响应。<code>RemoteConnection</code> 是 WebDriver 与远程浏览器（或远程浏览器驱动程序）之间的桥梁。</li><li><strong>Remote Server</strong>：浏览器驱动程序作为一个远程服务器（remote server）运行，它监听来自客户端（测试脚本）的 HTTP 请求。所有的 Selenium 操作（如查找元素、点击、执行 JavaScript 等）都通过 <code>RemoteConnection</code> 发送到浏览器驱动程序，再由浏览器驱动程序传递给浏览器。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element_by_id(<span class="hljs-string">&quot;login&quot;</span>)<br></code></pre></td></tr></table></figure><p>这条命令会通过 <code>RemoteConnection</code> 将请求发送给浏览器驱动程序，浏览器驱动程序会使用浏览器的 DOM 查找 ID 为 <code>login</code> 的元素并返回结果。</p><blockquote><p>当我们在脚本中执行 <code>driver.find_element_by_id(&quot;login&quot;)</code> 时，实际上是调用了 <code>WebDriver</code> 的 <code>find_element</code> 方法，该方法会将查找元素的请求转化为一个 HTTP 请求发送到浏览器驱动程序。</p><p>在 Selenium 的内部，<code>find_element</code> 方法会调用 <code>RemoteWebDriver</code> 类中的一个方法，这个方法会根据 WebDriver 协议构建请求数据。具体来说，Selenium 通过 <code>RemoteConnection</code> 将该请求转换为一个 <strong>POST</strong> 请求，并且请求的 URL 是 <code>/session/$sessionId/element</code>，其中 <code>$sessionId</code> 是当前浏览器会话的唯一标识符。</p></blockquote><h3 id="5-浏览器驱动程序执行操作"><a href="#5-浏览器驱动程序执行操作" class="headerlink" title="5. 浏览器驱动程序执行操作"></a>5. <strong>浏览器驱动程序执行操作</strong></h3><ul><li><strong>执行浏览器操作</strong>：浏览器驱动程序接收到来自 Selenium 客户端的请求后，会在浏览器中执行相应的动作。比如，浏览器驱动程序会使用浏览器的 API 打开网页、填写表单、点击按钮等。</li><li><strong>返回执行结果</strong>：执行完成后，浏览器驱动程序会将操作结果（如页面加载成功、元素是否找到等）通过 HTTP 响应返回给 Selenium 客户端。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.get(<span class="hljs-string">&quot;https://www.example.com&quot;</span>)<br><span class="hljs-built_in">print</span>(driver.title)  <span class="hljs-comment"># 获取当前页面的标题</span><br></code></pre></td></tr></table></figure><h3 id="6-结果返回到测试脚本"><a href="#6-结果返回到测试脚本" class="headerlink" title="6. 结果返回到测试脚本"></a>6. <strong>结果返回到测试脚本</strong></h3><ul><li><strong>测试结果</strong>：浏览器执行完成后，浏览器驱动程序会把执行的结果（例如页面标题、元素文本、截图等）通过 HTTP 响应返回给测试脚本。测试脚本可以利用这些结果进行验证、断言等操作。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">title = driver.title<br><span class="hljs-keyword">assert</span> title == <span class="hljs-string">&quot;Example Domain&quot;</span>  <span class="hljs-comment"># 验证页面标题</span><br></code></pre></td></tr></table></figure><h3 id="7-浏览器关闭与会话结束"><a href="#7-浏览器关闭与会话结束" class="headerlink" title="7. 浏览器关闭与会话结束"></a>7. <strong>浏览器关闭与会话结束</strong></h3><ul><li><strong>关闭浏览器</strong>：测试脚本完成自动化操作后，通常会调用 <code>driver.quit()</code> 来结束浏览器会话，并关闭浏览器窗口。此时，浏览器驱动程序会接收到关闭浏览器的请求，执行相关操作并结束会话。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.quit()  <span class="hljs-comment"># 关闭浏览器</span><br></code></pre></td></tr></table></figure><h3 id="总结：Selenium-的工作流程"><a href="#总结：Selenium-的工作流程" class="headerlink" title="总结：Selenium 的工作流程"></a>总结：Selenium 的工作流程</h3><ol><li>selenium client(python等语言编写的自动化测试脚本)初始化一个service服务，通过Webdriver启动浏览器驱动程序chromedriver.exe </li><li>通过RemoteWebDriver向浏览器驱动程序发送HTTP请求，浏览器驱动程序解析请求，打开浏览器，并获得sessionid，如果再次对浏览器操作需携带此id </li><li>打开浏览器，绑定特定的端口，把启动后的浏览器作为webdriver的remote server </li><li>打开浏览器后，所有的selenium的操作(访问地址，查找元素等)均通过RemoteConnection链接到remote server，然后使用execute方法调用_request方法通过urlib3向remote server发送请求 </li><li>浏览器通过请求的内容执行对应动作 </li><li>浏览器再把执行的动作结果通过浏览器驱动程序返回给测试脚本</li></ol><h1 id="初步基本使用"><a href="#初步基本使用" class="headerlink" title="初步基本使用"></a>初步基本使用</h1><blockquote><p>初次接触的可以用：<a href="https://seleniumbase.io/demo_page">Web Testing Page</a>练练手</p><p>如何使用—》重点观看官方文档就行了：<br><a href="https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/">入门指南 | Selenium</a></p><p><a href="https://selenium-python-docs-zh.readthedocs.io/zh-cn/latest/">Selenium Python 文档 — selenium-python-docs-zh 2.53.0 文档</a></p><p><a href="https://selenium-python-zh.readthedocs.io/en/latest/getting-started.html">2. 快速入门 — Selenium-Python中文文档 2 documentation</a></p></blockquote><blockquote><p>个人觉得重点在于如何定位元素和一些鼠标事件的触发</p><p>其中定位元素:xpath和css选择器是相对比较重要的，以后有时间单独出文章总结说明</p><p>鼠标事件之类的看看源码，多使用就知道了比如：</p></blockquote><p><img src="https://s2.loli.net/2025/01/17/3xqtUgojYhdbeav.png" alt="image-20250117173104881"></p><p>下面是 <code>ActionChains</code> 类中各个方法的功能总结</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th><th><strong>参数</strong></th><th><strong>返回</strong></th></tr></thead><tbody><tr><td><strong><code>__init__</code></strong></td><td>初始化 <code>ActionChains</code> 对象，创建一个动作链。</td><td>- <code>driver</code>: WebDriver 实例  - <code>duration</code>: 动作持续时间（默认 250ms）</td><td>无</td></tr><tr><td><strong><code>perform</code></strong></td><td>执行存储的所有操作。</td><td>无</td><td>无</td></tr><tr><td><strong><code>reset_actions</code></strong></td><td>清除已经存储的操作。</td><td>无</td><td>无</td></tr><tr><td><strong><code>click</code></strong></td><td>单击元素。</td><td>- <code>on_element</code>: 要点击的元素，默认为当前鼠标位置</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>click_and_hold</code></strong></td><td>按住左键在元素上。</td><td>- <code>on_element</code>: 要按住点击的元素，默认为当前鼠标位置</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>context_click</code></strong></td><td>右键点击（上下文点击）。</td><td>- <code>on_element</code>: 要右键点击的元素，默认为当前鼠标位置</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>double_click</code></strong></td><td>双击元素。</td><td>- <code>on_element</code>: 要双击的元素，默认为当前鼠标位置</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>drag_and_drop</code></strong></td><td>按住左键拖动源元素到目标元素。</td><td>- <code>source</code>: 要按住点击的源元素  - <code>target</code>: 目标元素</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>drag_and_drop_by_offset</code></strong></td><td>按住左键拖动源元素，然后移动到指定偏移位置并释放。</td><td>- <code>source</code>: 要按住点击的源元素  - <code>xoffset</code>: 水平偏移量  - <code>yoffset</code>: 垂直偏移量</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>key_down</code></strong></td><td>按下一个键，通常用于按住修饰键（如 Shift、Ctrl）。</td><td>- <code>value</code>: 要按下的键，来自 <code>Keys</code> 类  - <code>element</code>: 要发送键的元素（可选）</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>key_up</code></strong></td><td>释放一个键。</td><td>- <code>value</code>: 要释放的键，来自 <code>Keys</code> 类  - <code>element</code>: 要发送键的元素（可选）</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>move_by_offset</code></strong></td><td>将鼠标移动到当前位置的偏移量处。</td><td>- <code>xoffset</code>: 水平偏移量  - <code>yoffset</code>: 垂直偏移量</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>move_to_element</code></strong></td><td>将鼠标移动到元素的中间。</td><td>- <code>to_element</code>: 要移动到的 Web 元素</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>move_to_element_with_offset</code></strong></td><td>将鼠标移动到元素的中间，并按指定的偏移量调整位置。</td><td>- <code>to_element</code>: 要移动到的 Web 元素  - <code>xoffset</code>: 水平偏移量  - <code>yoffset</code>: 垂直偏移量</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>pause</code></strong></td><td>暂停所有操作，指定持续时间（秒）。</td><td>- <code>seconds</code>: 暂停的秒数</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>release</code></strong></td><td>在元素上释放鼠标按键。</td><td>- <code>on_element</code>: 要释放的元素，默认为当前鼠标位置</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>send_keys</code></strong></td><td>向当前焦点元素发送按键。</td><td>- <code>keys_to_send</code>: 要发送的按键，来自 <code>Keys</code> 类</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>send_keys_to_element</code></strong></td><td>向指定元素发送按键。</td><td>- <code>element</code>: 要发送按键的元素  - <code>keys_to_send</code>: 要发送的按键，来自 <code>Keys</code> 类</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>scroll_to_element</code></strong></td><td>将元素滚动到视口的底部。</td><td>- <code>element</code>: 要滚动到视口的元素</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>scroll_by_amount</code></strong></td><td>滚动指定的距离（水平和垂直）。</td><td>- <code>delta_x</code>: 水平滚动距离  - <code>delta_y</code>: 垂直滚动距离</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>scroll_from_origin</code></strong></td><td>从指定原点滚动指定的距离。</td><td>- <code>scroll_origin</code>: 滚动原点（元素或视口）  - <code>delta_x</code>: 水平滚动距离  - <code>delta_y</code>: 垂直滚动距离</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>scroll</code></strong></td><td>滚动指定的坐标和距离（已弃用）。</td><td>- <code>x</code>: 起始 X 坐标  - <code>y</code>: 起始 Y 坐标  - <code>delta_x</code>: 水平滚动距离  - <code>delta_y</code>: 垂直滚动距离  - <code>duration</code>: 滚动持续时间（毫秒）  - <code>origin</code>: 滚动原点（默认为 “viewport”）</td><td><code>ActionChains</code> (已弃用)</td></tr><tr><td><strong><code>__enter__</code></strong></td><td>允许 <code>ActionChains</code> 在 <code>with</code> 语句中作为上下文管理器使用。</td><td>无</td><td><code>ActionChains</code></td></tr><tr><td><strong><code>__exit__</code></strong></td><td>允许 <code>ActionChains</code> 在 <code>with</code> 语句中作为上下文管理器使用。</td><td>- <code>_type</code>, <code>_value</code>, <code>_traceback</code>: 上下文管理器传入的参数（通常不使用）</td><td>无</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据采集处理</category>
      
      <category>自动化测试与爬虫框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据采集处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多线程+线程池编写</title>
    <link href="/2022/09/23/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B+%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BC%96%E5%86%99/"/>
    <url>/2022/09/23/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B+%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<blockquote><p>非转载抄袭，早年知乎文章搬运于此</p></blockquote><h2 id="C-多线程-线程池"><a href="#C-多线程-线程池" class="headerlink" title="C++多线程+线程池"></a>C++多线程+线程池</h2><p><img src="https://pic1.zhimg.com/v2-33e87545f91c9f4c1551c7fd9d8ce8ef_720w.jpg?source=d16d100b" alt="C++多线程+线程池（全详解）"></p><p>多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。</p><p><img src="https://picx.zhimg.com/v2-5e71b9c1d4efe72f443c765004d37c18_720w.jpg?source=d16d100b" alt="img"></p><h2 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1.创建线程"></a><strong>1.创建线程</strong></h2><h3 id="1-1无参"><a href="#1-1无参" class="headerlink" title="1.1无参"></a><strong>1.1无参</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_some_work</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//4种正确创建方法（启动线程）</span><br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">(do_some_work)</span></span>;<span class="hljs-comment">//1</span><br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">((do_some_work()))</span></span>;<span class="hljs-comment">//2</span><br>std::thread my_thread&#123;<span class="hljs-built_in">do_some_work</span>()&#125;;<span class="hljs-comment">//3</span><br><br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">([]</span></span><br><span class="hljs-params"><span class="hljs-function">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">do_something();</span></span><br><span class="hljs-params"><span class="hljs-function">do_something_else();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<span class="hljs-comment">//用lambda表达式4</span><br><br><span class="hljs-comment">//错误创建写法</span><br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">(do_some_work())</span></span>;<br><span class="hljs-comment">//错误原因：这里相当与声明了一个名为my_thread的函数，这个函数带有一个参数(函数指针指向没有参</span><br><span class="hljs-comment">//数并返回background_task对象的函数)，返回一个 std::thread 对象的函数，而非启动了一个线程</span><br></code></pre></td></tr></table></figure><h3 id="1-2有参"><a href="#1-2有参" class="headerlink" title="1.2有参"></a>1.2有参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 通过值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFuncByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread function (by value): &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 通过引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFuncByReference</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; num)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread function (by reference): &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>    num += <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">// 通过移动语义传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFuncByMove</span><span class="hljs-params">(std::string&amp;&amp; message)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread function (by move): &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">42</span>;<br>    std::string greeting = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><br>    <span class="hljs-comment">// 通过值传递</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">threadByValue</span><span class="hljs-params">(threadFuncByValue, value)</span></span>;<br><br>    <span class="hljs-comment">// 通过引用传递</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">threadByReference</span><span class="hljs-params">(threadFuncByReference, std::ref(value))</span></span>;<br><br>    <span class="hljs-comment">// 通过移动语义传递</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">threadByMove</span><span class="hljs-params">(threadFuncByMove, std::move(greeting))</span></span>;<br><br>    threadByValue.<span class="hljs-built_in">join</span>();<br>    threadByReference.<span class="hljs-built_in">join</span>();<br>    threadByMove.<span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Main Thread: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：</p><p>1，使用C++线程库启动线程，可以归结为构造 std::thread 对象</p><p>2，为了让编译器识别 std::thread 类，这个简单的例子也要包含<thread>头文件.</p><p>3，线程会在函数运行完毕后自动释放，不推荐利用其他方法强制结束线程，可能会因资源未释放而导致内存泄漏。</p><h2 id="2-线程结束方式"><a href="#2-线程结束方式" class="headerlink" title="2.线程结束方式"></a>2.线程结束方式</h2><p><strong>启动了线程，你需要明确是要等待线程结束</strong>(加入式-join)，<strong>还是让其自主运行(<strong>分离式-detach)。</strong>如果 std::thread 对象销毁之前还没有做出决定，程序就会终止。一般</strong>可以使用<strong>joinable</strong>判断是join模式还是detach模式。</p><p>detach方式：启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。主线程不会等待子线程结束。如果主线程运行结束，程序则结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;子线程1111&quot;</span>&lt;&lt;endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;子线程2222&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">first</span> <span class="hljs-params">( thread_1)</span></span>;  <span class="hljs-comment">// 开启线程，调用：thread_1()</span><br>    <span class="hljs-function">thread <span class="hljs-title">second</span> <span class="hljs-params">(thread_2,<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// 开启线程，调用：thread_2(100)</span><br><br>    first.<span class="hljs-built_in">detach</span>();                <br>    second.<span class="hljs-built_in">detach</span>();            <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;主线程\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>join方式：等待启动的线程完成，才会继续往下执行。join后面的代码不会被执行，除非子线程结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>  <span class="hljs-comment">//cout&lt;&lt;&quot;子线程1111&quot;&lt;&lt;endl;</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>  <span class="hljs-comment">//cout&lt;&lt;&quot;子线程2222&quot;&lt;&lt;endl;</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">thread <span class="hljs-title">first</span> <span class="hljs-params">( thread_1)</span></span>; <span class="hljs-comment">// 开启线程，调用：thread_1()</span><br>    <span class="hljs-function">thread <span class="hljs-title">second</span> <span class="hljs-params">(thread_2,<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// 开启线程，调用：thread_2(100)</span><br><br>    first.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// pauses until first finishes 这个操作完了之后才能destroyed</span><br>    second.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// pauses until second finishes//join完了之后，才能往下执行。</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;主线程\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>1，线程是在thread对象被定义的时候开始执行的，而不是在调用join函数时才执行的，调用join函数只是阻塞等待线程结束并回收资源。</p><p>2，分离的线程（执行过detach的线程）会在调用它的线程结束或自己结束时释放资源。</p><p>3，没有执行<code>join</code>或<code>detach</code>的线程在程序结束时会引发异常</p><p>总结：</p><p><img src="https://picx.zhimg.com/v2-12107c8b9e76e7a918411a779485a0ce_720w.jpg?source=d16d100b" alt="img"></p><p><img src="https://picx.zhimg.com/v2-c06ab506a463febcb2647f99ab3719b8_720w.jpg?source=d16d100b" alt="img"></p><h2 id="3-竞争"><a href="#3-竞争" class="headerlink" title="3.竞争"></a>3.竞争</h2><h3 id="3-1条件竞争"><a href="#3-1条件竞争" class="headerlink" title="3.1条件竞争"></a>3.1条件竞争</h3><p>条件竞争就是两个或者多个进程或者线程同时处理一个资源（全局变量，文件）产生非预想的执行效果，从而产生程序执行流的改变。条件竞争需要如下的条件：</p><p>1，并发：即至少存在两个并发执行流。这里的执行流包括线程，进程，任务等级别的执行流。</p><p>2，共享对象：即多个并发流会访问同一对象。常见的共享对象有共享内存，文件系统，信号。一般来说，这些共享对象是用来使得多个程序执行流相互交流。此外，我们称访问共享对象的代码为临界区。在正常写代码时，这部分应该加锁。</p><p>3，改变对象：即至少有一个控制流会改变竞争对象的状态。因为如果程序只是对对象进行读操作，那么并不会产生条件竞争。</p><h3 id="3-2恶性竞争"><a href="#3-2恶性竞争" class="headerlink" title="3.2恶性竞争"></a>3.2恶性竞争</h3><p>恶性条件竞争通常发生于完成对多于一个的数据块的修改时，</p><p>例如，对两个连接指针的修改因为操作要访问两个独立的数据块，独立的指令将会对数据块将进行修改，并且其中一个线程可能正在进行时，另一个线程就对数据块进行了访问。因为出现的概率太低，条件竞争很难查找，也很难复现。</p><p>如CPU指令连续修改完成后，即使数据结构可以让其他并发线程访问，问题再次复现的几率也相当低。当系统负载增加时，随着执行数量的增加，执行序列的问题复现的概率也在增加，这样的问题只可能会出现在负载比较大的情况下。</p><p>条件竞争通常是时间敏感的，所以程序以调试模式运行时，它们常会完全消失，因为调试模式会影响程序的执行时间(即使影响不多)。</p><p>当你以写多线程程序为生，条件竞争就会成为你的梦魇；编写软件时，我们会使用大量复杂 的操作，用来避免恶性条件竞争：</p><p>1，对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。</p><p>2，对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，<strong>这就是所谓的无锁编程(lock-freeprogramming)。包括：atomic原子操作</strong>。不过，这种方式很难得到正确的结果。</p><p>3，使用事务(transacting)的方式去处理数据结构的更新(这里的”处理”就如同对数据库进行更新一样)。所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“软件事务内存”(software transactional memory(STM))。</p><p>4，<strong>保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量(mutex)。</strong></p><h2 id="4-mutex"><a href="#4-mutex" class="headerlink" title="4.mutex"></a>4.mutex</h2><p>mutex头文件主要声明了与互斥量(mutex)相关的类。mutex提供了4种互斥类型，如下表所示。</p><p><img src="https://picx.zhimg.com/v2-6e427c1a2befdf754c4b07a084973197_720w.jpg?source=d16d100b" alt="img"></p><h3 id="4-1-lock与unlock"><a href="#4-1-lock与unlock" class="headerlink" title="4.1 lock与unlock"></a>4.1 lock与unlock</h3><blockquote><p>lock()：资源上锁<br>unlock()：解锁资源<br>trylock()：查看是否上锁，它有下列3种类情况：<br>（1）未上锁返回false，并锁住；<br>（2）其他线程已经上锁，返回true；<br>（3）同一个线程已经对它上锁，将会产生死锁。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>       <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>         <span class="hljs-comment">// std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>          <span class="hljs-comment">// std::mutex</span></span><br><br>std::mutex mtx;           <span class="hljs-comment">// mutex for critical section</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_block</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span> </span>&#123;<br>  <span class="hljs-comment">// critical section (exclusive access to std::cout signaled by locking mtx):</span><br>  mtx.<span class="hljs-built_in">lock</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) &#123; std::cout &lt;&lt; c; &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  mtx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">th1</span> <span class="hljs-params">(print_block,<span class="hljs-number">50</span>,<span class="hljs-string">&#x27;*&#x27;</span>)</span></span>;<span class="hljs-comment">//线程1：打印*</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">th2</span> <span class="hljs-params">(print_block,<span class="hljs-number">50</span>,<span class="hljs-string">&#x27;$&#x27;</span>)</span></span>;<span class="hljs-comment">//线程2：打印$</span><br><br>  th1.<span class="hljs-built_in">join</span>();<br>  th2.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>1，如果是<strong>不同mutex变量</strong>，因为不涉及到同一资源的竞争，<strong>所</strong>以上列代码运行可能会出现交替打印的情况，或者另一个线程可以修改共同的全局变量！！！</p><h3 id="4-2-lock-guard"><a href="#4-2-lock-guard" class="headerlink" title="4.2 lock_guard"></a>4.2 lock_guard</h3><blockquote><p>创建即加锁，<strong>作用域结束自动析构并解锁</strong>，无需手工解锁<br><strong>不能中途解锁</strong>，必须等作用域结束才解锁<br>不能复制</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> g_i = <span class="hljs-number">0</span>;<br>std::mutex g_i_mutex;  <span class="hljs-comment">// protects g_i，用来保护g_i</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safe_increment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_i_mutex)</span></span>;<br>    ++g_i;<br>    std::cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-comment">// g_i_mutex自动解锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;main id: &quot;</span> &lt;&lt;std::this_thread::<span class="hljs-built_in">get_id</span>()&lt;&lt;std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(safe_increment)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(safe_increment)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：1，需要使用锁的时候，首先考虑使用 lock_guard，因为lock_guard是最简单的锁。</p><h3 id="4-3-unique-lock"><a href="#4-3-unique-lock" class="headerlink" title="4.3 unique_lock"></a>4.3 unique_lock</h3><blockquote><p>创建时可以不锁定（通过指定第二个参数为std::defer_lock），而在需要时再锁定<br><strong>可以随时加锁解锁</strong><br><strong>作用域规则同 lock_grard，析构时自动释放锁</strong><br>不可复制，可移动<br>条件变量需要该类型的锁作为参数（此时必须使用unique_lock）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Box</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Box</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> : num_things&#123;</span>num&#125; &#123;&#125;<br><br>    <span class="hljs-type">int</span> num_things;<br>    std::mutex m;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Box &amp;from, Box &amp;to, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// defer_lock表示暂时unlock，默认自动加锁</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock1</span><span class="hljs-params">(from.m, std::defer_lock)</span></span>;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock2</span><span class="hljs-params">(to.m, std::defer_lock)</span></span>;<br><br>    <span class="hljs-comment">//两个同时加锁</span><br>    std::<span class="hljs-built_in">lock</span>(lock1, lock2);<span class="hljs-comment">//或者使用lock1.lock()</span><br><br>    from.num_things -= num;<br>    to.num_things += num;<br>    <span class="hljs-comment">//作用域结束自动解锁,也可以使用lock1.unlock()手动解锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Box <span class="hljs-title">acc1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-function">Box <span class="hljs-title">acc2</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(transfer, std::ref(acc1), std::ref(acc2), <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(transfer, std::ref(acc2), std::ref(acc1), <span class="hljs-number">5</span>)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;acc1 num_things: &quot;</span> &lt;&lt; acc1.num_things &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;acc2 num_things: &quot;</span> &lt;&lt; acc2.num_things &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-std-atomic"><a href="#5-std-atomic" class="headerlink" title="5.std::atomic"></a>5.std::atomic</h2><p>有两个线程，一个要写数据，一个读数据，如果不加锁，可能会造成读写值混乱，使用<code>std::mutex</code>程序执行不会导致混乱，<strong>但是每一次循环都要加锁解锁是的程序开销很大。</strong>为了提高性能，C++11提供了原子类型(<code>std::atomic&lt;T&gt;</code>)，它提供了多线程间的原子操作，可以把原子操作理解成一种：<strong>不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</strong>它定义在<code>&lt;atomic&gt;</code>头文件中，原子类型是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。从效率上来说，原子操作要比互斥量的方式效率要高。</p><blockquote><p>atomic常见成员函数：<br>load()&#x2F;&#x2F;读取数据<br>store()&#x2F;&#x2F;存储数据<br>fetch_add(val)&#x2F;&#x2F;加法<br>fetch_sub(val)&#x2F;&#x2F;减法<br>exchange()&#x2F;&#x2F;替换</p></blockquote><p>atomic代码使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-comment">// #include &lt;mutex&gt; //这个例子不需要mutex了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>atomic_int n = <span class="hljs-number">0</span>;<span class="hljs-comment">//std::atomic_int只是std::atomic&lt;int&gt;的别名罢了。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">count10000</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>n++;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>thread th[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">for</span> (thread &amp;x : th)<br>x = <span class="hljs-built_in">thread</span>(count10000);<br><span class="hljs-keyword">for</span> (thread &amp;x : th)<br>x.<span class="hljs-built_in">join</span>();<br>cout &lt;&lt; n &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：atomic能够直接当作普通变量使用，成员函数貌似没啥用</p><h2 id="6-condition-variable"><a href="#6-condition-variable" class="headerlink" title="6. condition_variable"></a>6. condition_variable</h2><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p><p>1，一个线程等待条件变量的条件成立而挂起;</p><p>2，另一个线程使条件成立（给出条件成立信号）。</p><p><strong>condition_variable条件变量可以阻塞（wait、wait_for、wait_until）调用的线程直到使用（notify_one或notify_all）通知恢复为止</strong>。</p><p>头文件<condition_variable></p><ul><li>condition_variable</li><li>condition_variable_any</li></ul><p>相同点：两者都能与std::mutex一起使用。</p><p>不同点：前者仅限于与 std::mutex 一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了_any的后缀。condition_variable_any会产生额外的开销。</p><p>注意：</p><p>1，一般只推荐使用condition_variable。除非对灵活性有硬性要求，才会考虑condition_variable_any。</p><p>2，condition_variable必须结合unique_lock使用</p><p>3，condition_variable是一个类，这个类既有构造函数也有析构函数，使用时需要构造对应condition_variable对象</p><p><img src="https://pica.zhimg.com/v2-bfb99dd3088a746b07c53ceced7e80e5_720w.jpg?source=d16d100b" alt="img"></p><h3 id="6-1-wait"><a href="#6-1-wait" class="headerlink" title="6.1 wait"></a>6.1 wait</h3><p>当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。</p><p>在线程被阻塞时，该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait()函数也是自动调用 lck.lock()，使得lck的状态和 wait 函数被调用时相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>           <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>             <span class="hljs-comment">// std::thread, std::this_thread::yield</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>              <span class="hljs-comment">// std::mutex, std::unique_lock</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span> <span class="hljs-comment">// std::condition_variable</span></span><br><br>std::mutex mtx;<br>std::condition_variable cv;<br><br><span class="hljs-type">int</span> cargo = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">shipment_available</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> cargo!=<span class="hljs-number">0</span>;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consume</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<span class="hljs-comment">//自动上锁</span><br>        <span class="hljs-comment">//第二个参数为false才阻塞（wait），阻塞完即unlock，给其它线程资源</span><br>        cv.<span class="hljs-built_in">wait</span>(lck,shipment_available);<br>        <span class="hljs-comment">// consume:</span><br>        std::cout &lt;&lt; cargo &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        cargo=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer_thread</span> <span class="hljs-params">(consume,<span class="hljs-number">10</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i) &#123;<br>        <span class="hljs-comment">//每次cargo每次为0才运行。</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">shipment_available</span>()) std::this_thread::<span class="hljs-built_in">yield</span>();<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br>        cargo = i+<span class="hljs-number">1</span>;<br>        cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    consumer_thread.<span class="hljs-built_in">join</span>();,<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-wait-for"><a href="#6-2-wait-for" class="headerlink" title="6.2 wait_for"></a>6.2 wait_for</h3><p>与std::condition_variable::wait() 类似，不过 wait_for可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。 而一旦超时或者收到了其他线程的通知，wait_for返回，剩下的处理步骤和 wait()类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>           <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>             <span class="hljs-comment">// std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span>             <span class="hljs-comment">// std::chrono::seconds</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>              <span class="hljs-comment">// std::mutex, std::unique_lock</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span> <span class="hljs-comment">// std::condition_variable, std::cv_status</span></span><br><br>std::condition_variable cv;<br><br><span class="hljs-type">int</span> value;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_value</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cin &gt;&gt; value;<br>  cv.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Please, enter an integer (I&#x27;ll be printing dots): \n&quot;</span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">th</span> <span class="hljs-params">(read_value)</span></span>;<br><br>  std::mutex mtx;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br>  <span class="hljs-keyword">while</span> (cv.<span class="hljs-built_in">wait_for</span>(lck,std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>))==std::cv_status::timeout) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;.&#x27;</span> &lt;&lt; std::endl;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>  th.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-std-async"><a href="#7-std-async" class="headerlink" title="7.std::async"></a>7.std::async</h2><blockquote><p>我们已经有多线程thread了，为什么还要有async?<br>线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过 <code>thread.join()</code>得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后<code>join</code>,最后得到结果，这个过程是比较繁琐的。<br>c++11还提供了异步接口<code>std::async</code>，通过这个异步接口可以很方便的获取线程函数的执行结果。<code>std::async</code>会自动创建一个线程去调用 线程函数，它返回一个<code>std::future</code>，这个<code>future</code>中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从<code>future</code>中获取非常方便。<br><code>std::async</code>是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，**<code>std::async</code>是为了 让用户的少费点脑子的，它让这三个对象默契的工作。大概的工作过程是这样的：<code>std::async</code>先将异步操作用<code>std::packaged_task</code>包装起来，然后将异步操作的结果放到<code>std::promise</code>中，**</p></blockquote><h3 id="7-1-理解"><a href="#7-1-理解" class="headerlink" title="7.1 理解"></a>7.1 理解</h3><ol><li>std::async是用来创建异步任务的。</li><li>std::async有两个参数：std::launch::deferred和 std::launch::async</li></ol><h3 id="7-2-异同"><a href="#7-2-异同" class="headerlink" title="7.2 异同"></a>7.2 异同</h3><p>1，std::async()与std::thread()最明显的不同，就是async并不一定创建新的线程</p><p>2，std::thread() 如果系统资源紧张，那么可能创建线程失败，整个程序可能崩溃。</p><p>3，std::thread()创建线程的方式，如果线程返回值，你想拿到这个值也不容易；</p><p>4，std::async()创建异步任务，可能创建也可能不创建线程；并且async调用方式很容易拿到线程入口函数的返回值。</p><h3 id="7-3-参数"><a href="#7-3-参数" class="headerlink" title="7.3 参数"></a>7.3 参数</h3><p>1，参数std::launch::deferred 延迟调用；参数std::launch::async 强制创建一个新线程</p><p>2，如果你用std::launch::deferred来调用async会怎么样？std::launch::deferred延迟调用，延迟到future对象调用get()或者wait()的时候才执行mythread();如果不调用get()或者wait()，mythread()不会执行。</p><p>3，std::launch::async：强制这个异步任务在新线程上执行，这意味着，系统必须要给我创建出新线程来运行mythread();</p><p>4，std::launch::async |std::launch::deferred 这里这个 |：以为这调用async的行为可能是 创建新线程并立即执行，或者没有创建新线程并且延迟调用result.get()才开始执行任务入口函数，两者居其一。</p><p>5，不带额外参数；只给一个入口函数名；默认是应该是std::launch::async |std::launch::deferred，和c)效果一致，换句话说，系统会自行决定是异步（创建新线程）还是同步（不创建新线程）方式运行</p><p><img src="https://pic1.zhimg.com/v2-c4e2561c3af2455e975209f6b83c98b9_720w.jpg?source=d16d100b" alt="img"></p><p><img src="https://picx.zhimg.com/v2-5b7a628dc62e97015f8231c030dcb218_720w.jpg?source=d16d100b" alt="img"></p><h3 id="7-4-注意"><a href="#7-4-注意" class="headerlink" title="7.4 注意"></a>7.4 注意</h3><p>由于系统资源限制：</p><blockquote><p>（1）如果使用std::thread()创建的线程太多，则可能创建线程失败，系统报告异常，崩溃；<br>（2）如果用std::async,一般就不会报异常崩溃，因为如果系统资源紧张导致无法创建新线程的时候，std::async这种不加额外参数的调用就不会创建新线程，而是后续谁调用了future::get()来请求结果，那么这个异步任务就运行在执行这条get()语句所在的线程上。<br>（3）如果你强制std::async创建新线程，那么就必须使用std::launch::async，承受的代价就是系统资源紧张时，可能程序崩溃。经验：一个程序里，线程的数量不易超过100-200，与时间片有关，详情参考操作系统。</p></blockquote><h3 id="7-5-async不确定性问题的解决"><a href="#7-5-async不确定性问题的解决" class="headerlink" title="7.5 async不确定性问题的解决"></a>7.5 async不确定性问题的解决</h3><p>不加额外参数的std::async调用问题，让系统自行决定是否创建新的线程。</p><p>问题的焦点在于 std::future<int> result &#x3D; std::async(mythread)写法，这个异步任务到底 有没有被推迟执行。</p><p>解决代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mythread</span><span class="hljs-params">()</span> <span class="hljs-comment">//线程入口函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mythread start&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid= &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl; <span class="hljs-comment">//打印线程id</span><br> <br>std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">dura</span><span class="hljs-params">(<span class="hljs-number">5000</span>)</span></span>; <span class="hljs-comment">//定一个5秒的时间</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(dura);  <span class="hljs-comment">//休息一定时常</span><br> <br>cout &lt;&lt; <span class="hljs-string">&quot;mythread end&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid= &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl; <span class="hljs-comment">//打印线程id</span><br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;main&quot;</span> &lt;&lt; <span class="hljs-string">&quot;threadid= &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>std::future&lt;<span class="hljs-type">int</span>&gt; result = std::<span class="hljs-built_in">async</span>(mythread);<span class="hljs-comment">//流程并不卡在这里</span><br>cout &lt;&lt; <span class="hljs-string">&quot;continue.....&quot;</span> &lt;&lt; endl;<br> <br><span class="hljs-comment">//枚举类型</span><br>std::future_status status = result.<span class="hljs-built_in">wait_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">0</span>));<span class="hljs-comment">//等待一秒</span><br><br><span class="hljs-keyword">if</span> (status == std::future_status::deferred)<br>&#123;<br><span class="hljs-comment">//线程被延迟执行了，系统资源紧张</span><br>cout &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; endl; <span class="hljs-comment">//此时采取调用mythread()</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == std::future_status::timeout)<span class="hljs-comment">//</span><br>&#123;<br><span class="hljs-comment">//超时：表示线程还没执行完；我想等待你1秒，希望你返回，你没有返回，那么 status = timeout</span><br><span class="hljs-comment">//线程还没执行完</span><br>cout &lt;&lt; <span class="hljs-string">&quot;超时：表示线程还没执行完!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == std::future_status::ready)<br>&#123;<br><span class="hljs-comment">//表示线程成功返回</span><br>cout &lt;&lt; <span class="hljs-string">&quot;线程成功执行完毕，返回!&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>&#125;<br> <br>cout &lt;&lt; <span class="hljs-string">&quot;I love China!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-6使用"><a href="#7-6使用" class="headerlink" title="7.6使用"></a>7.6使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++ Standard: C++17</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">async</span>(launch::async, [](<span class="hljs-type">const</span> <span class="hljs-type">char</span> *message)&#123;<br>cout &lt;&lt; message &lt;&lt; flush;<br>&#125;, <span class="hljs-string">&quot;Hello, &quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;World!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-std-future"><a href="#8-std-future" class="headerlink" title="8.std::future"></a>8.std::future</h2><blockquote><p><code>std::future</code>是一个非常有用也很有意思的东西，简单说<code>std::future</code>提供了一种访问异步操作结果的机制。从字面意思来理解， 它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以同步等待的方式来获取 结果，可以通过查询<code>future</code>的状态（<code>future_status</code>）来获取异步操作的结果。</p></blockquote><p>我们想要从线程中返回异步任务结果，一般需要依靠<strong>全局变量</strong>；从安全角度看，有些不妥；为此C++11提供了std::future类模板，future对象提供访问异步操作结果的机制，很轻松解决从异步任务中返回结果.</p><p>在C++标准库中，有两种“期望”，使用两种类型模板实现:</p><p>唯一期望(unique futures，std::future&lt;&gt;) std::future的实例只能与一个指定事件相关联。</p><p>共享期望(shared futures)(std::shared_future&lt;&gt;) std::shared_future的实例就能关联多个事件。</p><blockquote><p>对于future补充说明如下：<br>std::async 、 std::packaged_task 或 std::promise 能提供一个std::future对象给该异步操作的创建者<br>异步操作的创建者能用各种方法查询、等待或从 std::future 提取值。若异步操作仍未提供值，则这些方法可能阻塞。<br>异步操作准备好发送结果给创建者时，它能通过接口（eg,std::promise::set_value std::future） 修改共享状态的值。</p></blockquote><p>常用函数：</p><p><img src="https://pic1.zhimg.com/v2-d9cd539249372e94330be12fa28f6496_720w.jpg?source=d16d100b" alt="img"></p><p>时序图：</p><p><img src="https://picx.zhimg.com/v2-04ee94590d234a8590988ba6a87f5c15_720w.jpg?source=d16d100b" alt="img"></p><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//通过async来获取异步操作结果</span><br>std::future&lt;<span class="hljs-type">int</span>&gt;  result = std::<span class="hljs-built_in">async</span>([]()&#123; <br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>; <br>&#125;);<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;the future result : &quot;</span> &lt;&lt; result.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;the future status : &quot;</span> &lt;&lt; result.<span class="hljs-built_in">valid</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">try</span><br>&#123;<br>    result.<span class="hljs-built_in">wait</span>();  <span class="hljs-comment">//或者 result.get() ,会异常</span><br>  <span class="hljs-comment">//因此std::future只能用于单线程中调用 ，多线程调用使用std::share_future();</span><br>&#125;<br><span class="hljs-built_in">catch</span> (...)<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;get error....\n &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-std-promise"><a href="#9-std-promise" class="headerlink" title="9.std::promise"></a>9.std::promise</h2><blockquote><p><code>std::promise</code>为获取线程函数中的某个值提供便利，<strong>在线程函数中给外面传进来的<code>promise</code>赋值</strong>，当线程函数执行完成之后就可以通过<code>promise</code>获取该值了，值得注意的是取值是间接的通过<code>promise</code>内部提供的<code>future</code>来获取的。</p></blockquote><p>promise实际上是std::future的一个包装，在讲解future时，我们并没有牵扯到改变future值的问题，但是如果使用thread以引用传递返回值的话，就必须要改变future的值，那么该怎么办呢？实际上，future的值不能被改变，但你可以通过promise来创建一个拥有特定值的future。</p><blockquote><p>future的值不能改变，promise的值可以改变。</p></blockquote><p>常用成员函数：</p><p><img src="https://pic1.zhimg.com/v2-23839785548ec640247bc20a3d2df451_720w.jpg?source=d16d100b" alt="img"></p><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Compiler: MSVC 19.29.30038.1</span><br><span class="hljs-comment">// C++ Standard: C++17</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span> <span class="hljs-comment">// std::promise std::future</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> ... Args&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">sum</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> + ... + args);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> ... Args&gt; <span class="hljs-type">void</span> <span class="hljs-title">sum_thread</span><span class="hljs-params">(promise&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; &amp;val, Args&amp;&amp;... args)</span> </span>&#123;<br>val.<span class="hljs-built_in">set_value</span>(<span class="hljs-built_in">sum</span>(args...));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>promise&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; sum_value;<br><span class="hljs-function">thread <span class="hljs-title">get_sum</span><span class="hljs-params">(sum_thread&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, ref(sum_value), <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;<br>cout &lt;&lt; sum_value.<span class="hljs-built_in">get_future</span>().<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>get_sum.<span class="hljs-built_in">join</span>(); <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-std-packaged-task"><a href="#10-std-packaged-task" class="headerlink" title="10.std::packaged_task"></a>10.<strong>std::packaged_task</strong></h2><p><code>std::packaged_task</code>它包装了一个可调用的目标（如<code>function</code>,<code>lambda expression</code>,<code>bind expression</code>, or another<code>function object</code>）,以便异步调用，<strong>它和<code>promise</code>在某种程度上有点像，<code>promise</code>保存了一个共享状态的值，而<code>packaged_task</code>保存的是一 个函数</strong>。它的基本用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">([]()&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;&#125;)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::ref(task))</span></span>;<br>std::future&lt;<span class="hljs-type">int</span>&gt; f1 = task.<span class="hljs-built_in">get_future</span>();<br><span class="hljs-keyword">auto</span> r1 = f1.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><p>如果读者还没搞清楚他们的关系的话，我就用更通俗的话来解释一下。比如，一个小伙子给一个姑 娘表白真心的时候也许会说：”我许诺 会 给你一个美好的未来“或者”我会努力奋斗为你创造一个美好的未来“。姑娘往往会说：”我等着“。现在我来将这三句话用c++11来翻译一下：</p><p>小伙子说：我许诺会给你一个美好的未来等于c++11中”std::promise a std::future”;<br>小伙子说：我会努力奋斗为你创造一个美好的未来等于c++11中”std::packaged_task a future”;<br>姑娘说：我等着等于c++11中”future.get()&#x2F;wait()”;</p><p>小伙子两句话种有个中差异，自己琢磨一下，这点差异也是<code>std::promise</code>和<code>std::packaged_task</code>的差异。现实中的山盟海 誓靠不靠得住我不知道，但是c++11中的许诺和未来是一定可靠的，发起来了许诺就一定有未来简单实现</p><p>参考文章：<a href="http://link.zhihu.com/?target=https://www.cnblogs.com/bandaoyu/p/16752561.html">https://www.cnblogs.com/bandaoyu/p/16752561.html</a></p><hr><h2 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11.线程池"></a>11.线程池</h2><p><img src="https://picx.zhimg.com/v2-dd3c0a5c88d67f851d74ea74e438e9c1_720w.jpg?source=d16d100b" alt="img"></p><h3 id="11-安全工作队列实现"><a href="#11-安全工作队列实现" class="headerlink" title="11, 安全工作队列实现"></a>11, 安全工作队列实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">safequeue</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>  std::queue&lt;T&gt;m_queue;<br>  std::mutex m_mutex;<br><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">safequeue</span>();<br>  <span class="hljs-built_in">safequeue</span>(safequeue &amp;&amp;other);<br>  ~<span class="hljs-built_in">safequeue</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>     std::unique_lock&lt;std::mutex&gt;<span class="hljs-built_in">lock</span>(m_mutex);<br>     <span class="hljs-keyword">return</span> m_queue.<span class="hljs-built_in">empty</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>     std::unique_lock&lt;std::mutex&gt;<span class="hljs-built_in">lock</span>(m_mutex);<br>     <span class="hljs-keyword">return</span> m_queue.<span class="hljs-built_in">size</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(T &amp;t)</span></span><br><span class="hljs-function">  </span>&#123;<br>     std::unique_lock&lt;std::mutex&gt;<span class="hljs-built_in">lock</span>(m_mutex);<br>     m_queue.<span class="hljs-built_in">emplace</span>(&amp;t);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(T &amp;t)</span></span><br><span class="hljs-function">  </span>&#123;<br>    std::unique_lock&lt;std::mutex&gt;<span class="hljs-built_in">lock</span>(m_mutex);<br>    <span class="hljs-keyword">if</span>(m_queue.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    t=std::<span class="hljs-built_in">move</span>(m_queue.<span class="hljs-built_in">front</span>());<br>    m_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-2-线程池"><a href="#10-2-线程池" class="headerlink" title="10.2 线程池"></a>10.2 线程池</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;D:\code\c++project\C++\src\project\safequeue.c++&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadpool</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadworker</span><br>    &#123;<br>       <span class="hljs-keyword">private</span>:<br>       <span class="hljs-type">int</span> m_id;<br>       threadpool *m_pool;<br><br>       <span class="hljs-keyword">public</span>:<br>       <span class="hljs-built_in">threadworker</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> id,threadpool *pool):<span class="hljs-built_in">m_id</span>(id),<span class="hljs-built_in">m_pool</span>(pool)&#123;&#125;<br><br>       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span><span class="hljs-comment">//重载操作</span></span><br><span class="hljs-function">       </span>&#123;<br>            std::function&lt;<span class="hljs-type">void</span>()&gt; func;<br>            <span class="hljs-type">bool</span> dequeued;<br>            <span class="hljs-keyword">if</span>(!m_pool-&gt;m_shutdown)<br>            &#123;<br>                std::unique_lock&lt;std::mutex&gt;<span class="hljs-built_in">lock</span>(m_pool-&gt;m_conditional_mutex);<br>                <span class="hljs-keyword">if</span>(m_pool-&gt;m_queue.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    m_pool-&gt;m_conditional_lock.<span class="hljs-built_in">wait</span>(lock);<br>                &#125;<br>                dequeued=m_pool-&gt;m_queue.<span class="hljs-built_in">dequeue</span>(func);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dequeued)<br>            &#123;<br>                <span class="hljs-built_in">func</span>();<br>            &#125;<br>       &#125;<br>    &#125;; <br>       <span class="hljs-type">bool</span> m_shutdown;<br>       std::vector&lt;std::thread&gt; m_threads;<br>       safequeue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; m_queue;<br>       std::mutex m_conditional_mutex;<br>       std::condition_variable m_conditional_lock;<br>    <br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">threadpool</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> n_threads=<span class="hljs-number">4</span>):<span class="hljs-built_in">m_threads</span>(std::<span class="hljs-built_in">vector</span>&lt;std::thread&gt;(n_threads)),<span class="hljs-built_in">m_shutdown</span>(<span class="hljs-literal">false</span>)&#123;&#125;<br><br>    <span class="hljs-built_in">threadpool</span>(<span class="hljs-type">const</span> threadpool &amp;)=<span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">threadpool</span>(threadpool &amp;&amp;)=<span class="hljs-keyword">delete</span>;<br>    threadpool &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> threadpool &amp;)=<span class="hljs-keyword">delete</span>;<br>    threadpool &amp;&amp;<span class="hljs-keyword">operator</span>=(threadpool &amp;&amp;)=<span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span><span class="hljs-comment">//初始化分配线程</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m_threads.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            m_threads.<span class="hljs-built_in">at</span>(i)=std::<span class="hljs-built_in">thread</span>(<span class="hljs-built_in">threadworker</span>(i,<span class="hljs-keyword">this</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span><span class="hljs-comment">//关闭线程</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_shutdown=<span class="hljs-literal">true</span>;<br>        m_conditional_lock.<span class="hljs-built_in">notify_all</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m_threads.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>              <span class="hljs-keyword">if</span>( m_threads.<span class="hljs-built_in">at</span>(i).<span class="hljs-built_in">joinable</span>())<br>              &#123;<br>                  m_threads.<span class="hljs-built_in">at</span>(i).<span class="hljs-built_in">join</span>();<br>              &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F,<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">submit</span><span class="hljs-params">(F &amp;&amp;f,Args &amp;&amp;...args)</span>-&gt;std::future&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(f(args...))</span>&gt;</span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-comment">//这段C++代码定义了一个名为`submit`的函数模板。它接受一个可调用对象`f`和一系列参数`args`。</span><br><br><span class="hljs-comment">//函数模板使用了右值引用和可变参数模板的特性。`F &amp;&amp;f`表示对可调用对象`f`进行右值引用，`Args &amp;&amp;...args`表示可变数量的参数`args`，它们都是右值引用。</span><br><br><span class="hljs-comment">//返回类型使用了`std::future&lt;decltype(f(args...))&gt;`，表示返回一个`std::future`对象，该对象的类型是通过调用`f(args...)`来推断的。</span><br><br><span class="hljs-comment">//函数体中没有具体的实现，因此代码块中的大括号是空的。这意味着在使用这个函数模板时，需要根据具体的需求来提供实现。</span><br><br><span class="hljs-comment">//这段代码的目的是定义一个通用的函数模板，用于提交任务并返回一个`std::future`对象，以便在将来某个时刻获取任务的结果。通过使用右值引用和可变参数模板，可以接受不同类型的可调用对象和参数，并返回相应的`std::future`对象。</span><br><br><span class="hljs-comment">//总而言之，这段代码定义了一个通用的函数模板`submit`，用于提交任务并返回一个`std::future`对象，以便在将来获取任务的结果。具体的实现需要根据具体的需求来提供。</span><br><br>         std::function&lt;<span class="hljs-keyword">decltype</span>(f(args...))()&gt; func=std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f),std::forward&lt;Args&gt;(args)...);<span class="hljs-comment">//forward为完美转发</span><br><br><br>         <span class="hljs-keyword">auto</span> task_ptr=std::make_shared&lt;std::packaged_task&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>(args...))()&gt;&gt;(func);<br>         <br>         std::function&lt;<span class="hljs-type">void</span>()&gt;task=[task_ptr]()<br>         &#123;<br>               (*task_ptr)();<br>         &#125;;<br><span class="hljs-comment">//这段C++代码创建了一个`std::function`对象`wrapper_func`，并使用Lambda表达式作为其可调用对象。</span><br><br><span class="hljs-comment">//Lambda表达式`[task_ptr]() &#123; (*task_ptr)(); &#125;`定义了一个匿名函数，没有参数，返回类型为`void`。在函数体中，通过解引用`task_ptr`，调用了指针所指向的可调用对象。</span><br><br><span class="hljs-comment">//这个Lambda表达式被用作初始化`std::function&lt;void()&gt;`对象`wrapper_func`，因此`wrapper_func`成为了一个可调用对象，可以像函数一样被调用。</span><br><br><span class="hljs-comment">//这段代码的作用是将一个指针`task_ptr`所指向的可调用对象进行封装，并通过`std::function`对象`wrapper_func`来调用该可调用对象。通过这种方式，可以将一个具体的任务对象包装成一个可调用对象，并进行进一步的处理和调用。</span><br><br><span class="hljs-comment">//总而言之，这段代码创建了一个`std::function`对象，并使用Lambda表达式将一个指针所指向的可调用对象进行封装。这样可以通过`std::function`对象来调用该可调用对象，并进行进一步的处理。</span><br>         m_queue.<span class="hljs-built_in">enqueue</span>(task);<br><br>         m_conditional_lock.<span class="hljs-built_in">notify_one</span>();<br><br>         <span class="hljs-keyword">return</span> task_ptr-&gt;<span class="hljs-built_in">get_future</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-3-线程池测试"><a href="#10-3-线程池测试" class="headerlink" title="10.3 线程池测试"></a>10.3 线程池测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;D:\code\c++project\C++\src\project\threadpool.c++&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><br>std::random_device rd; <span class="hljs-comment">// 真实随机数产生器</span><br><br><span class="hljs-function">std::mt19937 <span class="hljs-title">mt</span><span class="hljs-params">(rd())</span></span>; <span class="hljs-comment">//生成计算随机数mt</span><br><br><span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-number">-1000</span>, <span class="hljs-number">1000</span>)</span></span>; <span class="hljs-comment">//生成-1000到1000之间的离散均匀分布数</span><br><br><span class="hljs-keyword">auto</span> rnd = std::<span class="hljs-built_in">bind</span>(dist, mt);<br><br><span class="hljs-comment">// 设置线程睡眠时间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simulate_hard_computation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">2000</span> + <span class="hljs-built_in">rnd</span>()));<br>&#125;<br><br><span class="hljs-comment">// 添加两个数字的简单函数并打印结果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">simulate_hard_computation</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> res = a * b;<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 添加并输出结果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiply_output</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;out, <span class="hljs-type">const</span> <span class="hljs-type">int</span> a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">simulate_hard_computation</span>();<br>    out = a * b;<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; out &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 结果返回</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply_return</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">simulate_hard_computation</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> res = a * b;<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建3个线程的线程池</span><br>    <span class="hljs-function">threadpool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><br>    <span class="hljs-comment">// 初始化线程池</span><br>    pool.<span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 提交乘法操作，总共30个</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">10</span>; ++j)<br>        &#123;<br>            pool.<span class="hljs-built_in">submit</span>(multiply, i, j);<br>        &#125;<br><br>    <span class="hljs-comment">// 使用ref传递的输出参数提交函数</span><br>    <span class="hljs-type">int</span> output_ref;<br>    <span class="hljs-keyword">auto</span> future1 = pool.<span class="hljs-built_in">submit</span>(multiply_output, std::<span class="hljs-built_in">ref</span>(output_ref), <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// 等待乘法输出完成</span><br>    future1.<span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; output_ref &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用return参数提交函数</span><br>    <span class="hljs-keyword">auto</span> future2 = pool.<span class="hljs-built_in">submit</span>(multiply_return, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 等待乘法输出完成</span><br>    <span class="hljs-type">int</span> res = future2.<span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Last operation result is equals to &quot;</span> &lt;&lt; res &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 关闭线程池</span><br>    pool.<span class="hljs-built_in">shutdown</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">example</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-线程在网络编程中的应用"><a href="#12-线程在网络编程中的应用" class="headerlink" title="12.线程在网络编程中的应用"></a>12.线程在网络编程中的应用</h2><p>此处详解可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/650758773">计算机菜鸟一枚：C++网络编程+线程（全详解入门）</a></p><p>这里不做赘述。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11特性</title>
    <link href="/2022/09/22/C++11%E7%89%B9%E6%80%A7/"/>
    <url>/2022/09/22/C++11%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>非转载抄袭，早年知乎文章搬运于此</p></blockquote><p><img src="https://pic3.zhimg.com/v2-c8dff71a81b319c59ac9976f0090bc24_1440w.jpg" alt="img"></p><h2 id="1-并发支持"><a href="#1-并发支持" class="headerlink" title="1.并发支持"></a>1.并发支持</h2><h3 id="1-1内存模型"><a href="#1-1内存模型" class="headerlink" title="1.1内存模型"></a>1.1内存模型</h3><p>C++11引入了一个新的内存模型，即C++11内存模型（C++11 memory model）。它定义了多线程并发环境下对共享数据的访问和修改行为，以及对原子操作和同步操作的语义。在这些之上，C++11还提供了对原子类型和无锁编程的支持，并且与之集成。</p><p>C++11内存模型确保了一些基本的原则：</p><ol><li>原子性（Atomicity）：对于原子类型（std::atomic），其成员函数的操作是原子的，不会被其他线程中断。</li><li>可见性（Visibility）：对于非原子类型，通过使用互斥量或同步操作来确保共享数据的可见性，即在一个线程中对共享数据的修改会立即反映到其他线程中。</li><li>有序性（Ordering）：通过同步操作（如互斥量、原子操作的memory_order参数等）来定义操作的顺序性，从而在多线程环境中确定操作和事件的相对顺序。</li></ol><h3 id="1-2线程与锁"><a href="#1-2线程与锁" class="headerlink" title="1.2线程与锁"></a>1.2线程与锁</h3><blockquote><p>C++ 对线程和锁级别编程的支持是 POSIX 和 Windows 所提供的线程和锁的类型安全变体<br>• thread——系统的执行线程，支持 join() 和 detach()<br>• mutex——系统的互斥锁，支持 lock()、unlock() 和保证 unlock() 的 RAII 方式<br>• condition_variable——系统中线程间进行事件通信的条件变量<br>• thread_local——线程本地存储</p></blockquote><p>线程和锁模型需要使用某种形式的同步来避免竞争条件。C++11 为此提供了标准 的 mutex（互斥锁）</p><h3 id="1-3期值（future）"><a href="#1-3期值（future）" class="headerlink" title="1.3期值（future）"></a>1.3期值（future）</h3><p>C++11 提供了：</p><p>• future——一个句柄，通过它你可以从一个共享的单对象缓冲区中 get() 一个值，可能需要等待某个 promise 将该值放入缓冲区。</p><p>• promise——一个句柄，通过它你可以将一个值 put() 到一个共享的单对象缓冲区，可能会唤醒某个等待 future 的 thread。</p><p>• packaged_task——一个类，它使得设置一个函数在线程上异步执行变得容易，由 future 来接受 promise 返回的结果。</p><p>• async()——一个函数，可以启动一个任务并在另一个 thread 上执行。</p><p><strong>对于以上内容的详解请移步到这篇文章：<a href="https://zhuanlan.zhihu.com/p/650522122">计算机菜鸟一枚：C++多线程+线程池（全详解）</a></strong></p><p>这里不做赘述。</p><hr><h2 id="2-简化使用"><a href="#2-简化使用" class="headerlink" title="2.简化使用"></a>2.简化使用</h2><h3 id="2-1auto-和-decltype"><a href="#2-1auto-和-decltype" class="headerlink" title="2.1auto 和 decltype"></a>2.1auto 和 decltype</h3><blockquote><p>C++11中用auto关键字来支持自动类型推导。用decltype推导表达式类型。头文件：#include<typeinfo></p></blockquote><p>auto：让编译器在编译器就推导出变量的类型，可以通过&#x3D;右边的类型推导出变量的类型。（前提是定义一个变量时对其进行初始化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 10是int型，可以自动推导出a是int</span><br></code></pre></td></tr></table></figure><p>decltype：用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。（decltypde是不需要推导变量初始化的，根据的是表达式对变量的类型就可以推导。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> varname = value;<br><span class="hljs-keyword">decltype</span>(exp) varname = value;<br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">10.8</span>) x;  <span class="hljs-comment">//x 被推导成了 double</span><br></code></pre></td></tr></table></figure><p>两者区别：</p><p>1，auto用于变量的类型推导，根据初始化表达式的类型来推导变量的类型，常用于简化代码和处理复杂类型。而decltype则用于获取表达式的类型，保留修饰符，并且可以进行表达式求值。</p><p>2，auto在初始化时进行类型推导，而decltype直接查询表达式的类型，可以用于任何表达式，包括没有初始化的变量。</p><p>3，auto在编译期间确定类型，并且无法更改。而decltype在运行时才确定表达式的类型。</p><p>4，auto适用于简单的类型推导，而decltype适用于复杂的类型推导和获取表达式的结果类型。</p><h3 id="2-2范围-for"><a href="#2-2范围-for" class="headerlink" title="2.2范围 for"></a>2.2范围 for</h3><p>在C++11中，引入了范围for循环（Range-based for loop），它提供了一种简洁而直观的方式来遍历容器、数组、字符串和其他可迭代对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> element : container) &#123;<br>    <span class="hljs-comment">// 操作每个元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>element</code> 是一个变量，用于存储容器中的每个元素的值。<code>container</code> 是一个可迭代对象，例如数组、标准库容器或自定义容器。</p><p>范围for循环的工作原理是，它会自动遍历容器中的每个元素，并将当前元素的值赋给 <code>element</code> 变量，然后执行循环体中的代码块。循环体会针对容器中的每个元素执行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//实例：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> number : numbers) &#123;<br>        std::cout &lt;&lt; number &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3资源管理指针"><a href="#2-3资源管理指针" class="headerlink" title="2.3资源管理指针"></a>2.3资源管理指针</h3><p>在C++11中，引入了新的智能指针类，用于更安全和方便地管理动态分配的资源，避免内存泄漏和悬空指针等问题。以下是C++11中的三种主要智能指针：</p><p>【1】<code>std::unique_ptr</code>：</p><p>1，<code>std::unique_ptr</code> 是一种独占式智能指针，用于管理唯一的对象，确保只有一个指针可以访问该对象。</p><p>2，使用 <code>std::unique_ptr</code> 可以自动释放动态分配的内存，当指针超出作用域或被重置时，它会自动删除所管理的对象。</p><p>3，通过 <code>std::make_unique</code> 函数可以创建 <code>std::unique_ptr</code> 对象，如：<code>std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);</code></p><p>【2】std: :shared_ptr：</p><p>1，<code>std::shared_ptr</code> 是一种共享式智能指针，多个指针可以同时共享对同一对象的拥有权。</p><p>2，<code>std::shared_ptr</code> 使用引用计数技术追踪所管理对象的引用数量，当引用计数变为零时，自动销毁所管理的对象。</p><p>3，通过 <code>std::make_shared</code> 函数可以创建 <code>std::shared_ptr</code> 对象，如：<code>std::shared_ptr&lt;int&gt; ptr = std::make_shared&lt;int&gt;(42);</code></p><p>【3】<code>std::weak_ptr</code>：</p><p>1，<code>std::weak_ptr</code> 是一种弱引用智能指针，它可以解决 <code>std::shared_ptr</code> 的循环引用问题。</p><p>2，<code>std::weak_ptr</code> 指向 <code>std::shared_ptr</code> 管理的对象，但不会增加引用计数。因此，当所有 <code>std::shared_ptr</code> 对象超出作用域后，即使还有 <code>std::weak_ptr</code> 对象存在，所管理的对象也会被销毁。</p><p>3，通过 <code>std::shared_ptr</code> 的 <code>std::weak_ptr</code> 构造函数可以创建 <code>std::weak_ptr</code> 对象，如：<code>std::weak_ptr&lt;int&gt; weakPtr = sharedPtr;</code></p><p><strong>注意：“它们的确智能，但它们仍然是指针。”除非我们确实需要指针，否则，简单地使用局部变量会更好</strong></p><p><strong>参考文章：</strong><a href="https://link.zhihu.com/?target=http://t.csdn.cn/CfDZr">http://t.csdn.cn/CfDZr</a></p><h3 id="2-4统一初始化"><a href="#2-4统一初始化" class="headerlink" title="2.4统一初始化"></a><strong>2.4统一初始化</strong></h3><p>C++11 引入了统一初始化（Uniform Initialization）语法，这使得对象的初始化更加一致和简洁。使用统一初始化，可以通过多种方式来初始化对象，无论是基本类型、类类型还是数组都可以使用相同的语法。</p><p>在 C++11 中，统一初始化有以下几种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 直接初始化一个整数</span><br><span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;  <span class="hljs-comment">// 直接初始化一个字符串对象</span><br><br><span class="hljs-type">int</span> y = x;  <span class="hljs-comment">// 使用拷贝初始化将 x 的值赋给 y</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 使用拷贝初始化进行向量初始化</span><br><br><span class="hljs-type">int</span> z&#123;<span class="hljs-number">123</span>&#125;;  <span class="hljs-comment">// 使用列表初始化一个整数</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; nums&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 使用列表初始化初始化一个向量</span><br>std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p&#123;<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>&#125;;  <span class="hljs-comment">// 使用列表初始化初始化一个键值对</span><br></code></pre></td></tr></table></figure><h3 id="2-5nullptr"><a href="#2-5nullptr" class="headerlink" title="2.5nullptr"></a>2.5nullptr</h3><p>nullptr是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func ptr&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func i&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 编译失败，会产生二义性</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 输出func ptr</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6constexpr-函数"><a href="#2-6constexpr-函数" class="headerlink" title="2.6constexpr 函数"></a>2.6constexpr 函数</h3><p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p><p>常量表达式（const experssion）是指：</p><p>(1)值不会改变</p><p>(2)在编译过程就能得到计算结果的表达式。</p><p>constexpr和const的区别：</p><p>两者都代表可读，</p><p>const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，</p><p>而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">func</span>(i);<span class="hljs-comment">// 普通函数</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 编译期间就会被计算出来</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7explicit"><a href="#2-7explicit" class="headerlink" title="2.7explicit"></a>2.7explicit</h3><p>explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看explicit的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;value&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a = <span class="hljs-number">1</span>; <span class="hljs-comment">// error，不可以隐式转换</span><br>    <span class="hljs-function">A <span class="hljs-title">aa</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// ok</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8final-override"><a href="#2-8final-override" class="headerlink" title="2.8final &amp; override"></a>2.8final &amp; override</h3><p>c++11关于继承新增了两个关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 确保func被重写</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;derived&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fu</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// error，基类没有fu()，不可以被重写</span><br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="2-9右值引用"><a href="#2-9右值引用" class="headerlink" title="2.9右值引用"></a>2.9右值引用</h3><p>C++ 中的右值引用（Rvalue reference）是一种引用类型，它用于绑定到临时对象或将要被移动的对象（右值）。通过右值引用，我们可以对右值进行有效的操作，如移动语义和完美转发。</p><p>右值引用的语法是在类型后面加上 <code>&amp;&amp;</code>，例如 <code>int&amp;&amp;</code> 表示一个右值引用到 int 类型的对象。右值引用只能绑定到右值，不能绑定到左值。</p><p>右值引用主要有两个重要的应用场景：移动语义和完美转发。</p><p>【1】移动语义： 右值引用使得我们可以实现高效的资源管理，尤其是在处理动态分配的内存或大型对象时。通过移动语义，我们可以将资源从一个对象转移到另一个对象，避免了不必要的拷贝开销。<br>通过定义移动构造函数和移动赋值运算符，并使用右值引用参数，可以实现对资源的高效转移。移动构造函数用于在构造对象时从临时或将要被销毁的对象中“窃取”资源，移动赋值运算符用于在对象已存在时将资源从右值赋值给对象。这样，在资源转移完成后，原始对象就不再拥有该资源，而新对象拥有该资源，避免了多余的内存分配和拷贝操作。</p><p>【2】完美转发： 完美转发是指在函数模板中保持参数的值类别（左值或右值）并将其转发到其他函数，以实现泛型编程中的通用参数传递。通过使用右值引用和模板参数推导，可以实现参数类型的自动推导和类型保持。<br>在函数模板中使用右值引用参数可以接收右值和左值，并保持参数的原始类型。结合 <code>std::forward</code> 可以实现完美转发，将参数以原始类型转发到其他函数。这样，在调用模板函数时，参数的值类别被保留，从而选择正确的函数进行处理。</p><p>右值引用在 C++11 中引入，它的出现在很大程度上优化了资源管理和提升了代码的性能。它为移动语义和完美转发提供了重要的基础，并在现代 C++ 开发中广泛应用。</p><h3 id="2-10移动语义"><a href="#2-10移动语义" class="headerlink" title="2.10移动语义"></a>2.10移动语义</h3><p>C++11 引入了移动语义（Move Semantics）的概念，旨在提高对象的性能和效率。移动语义通过转移资源所有权，避免不必要的拷贝操作，从而更高效地管理对象。</p><p>在传统的拷贝语义中，当我们将一个对象赋值给另一个对象或者作为函数参数传递时，会进行对象的拷贝操作，这包括复制所有成员变量的值、分配内存等。在某些情况下，这种拷贝操作是非常昂贵的，特别是对于大型对象或者资源密集型的操作。</p><p>移动语义通过引入右值引用（Rvalue Reference）来解决这个问题。右值引用使用 <code>&amp;&amp;</code> 语法进行声明，表示一个临时对象或者即将销毁的对象。在移动语义中，我们可以将资源的所有权从一个对象转移到另一个对象，而不需要进行昂贵的拷贝操作。</p><p>在使用移动语义时，可以借助 <code>std::move</code> 函数将左值转换为右值引用，以便进行移动操作。下面是一个简单的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyObject</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Default constructor&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 假设需要分配大量内存或进行其他资源密集型操作</span><br>    &#125;<br><br>    <span class="hljs-built_in">MyObject</span>(<span class="hljs-type">const</span> MyObject&amp; other) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 实现对象的拷贝操作</span><br>    &#125;<br><br>    <span class="hljs-built_in">MyObject</span>(MyObject&amp;&amp; other) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 实现对象的移动操作</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyObject obj1;  <span class="hljs-comment">// 调用默认构造函数</span><br><br>    <span class="hljs-function">MyObject <span class="hljs-title">obj2</span><span class="hljs-params">(obj1)</span></span>;  <span class="hljs-comment">// 调用拷贝构造函数，拷贝 obj1 的值到 obj2</span><br>    <span class="hljs-function">MyObject <span class="hljs-title">obj3</span><span class="hljs-params">(std::move(obj1))</span></span>;  <span class="hljs-comment">// 调用移动构造函数，将 obj1 的值转移到 obj3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过移动语义，我们可以避免不必要的拷贝操作，提高代码的性能和效率。特别是对于容器类（如 <code>std::vector</code>、<code>std::string</code>）或动态分配的资源，利用移动语义可以显著降低内存分配和复制的开销。</p><p>需要注意的是，移动构造函数的实现通常是将源对象指针设置为 nullptr，以确保在析构时不会释放已经被转移的资源。此外，移动构造函数和拷贝构造函数应该遵循特定的语义规范，以确保正确、可预期的行为。</p><h3 id="2-11完美转发"><a href="#2-11完美转发" class="headerlink" title="2.11完美转发"></a>2.11完美转发</h3><p>完美转发（perfect forwarding）是 C++ 中用于保持传递参数类型和转发函数调用的机制。它通常与模板和右值引用一起使用，以实现泛型编程中的参数传递。</p><p>在传统的函数调用中，如果我们想要将一个函数的参数传递给另一个函数，通常可以直接通过值传递或引用传递来实现。但是问题在于，当我们希望将参数以原始类型（值类型或引用类型）传递给另一个函数时，需要显式指定参数的类型，而无法自动推导。</p><p>完美转发解决了这个问题，它允许我们在一层函数中接收参数，并将其转发到另一层函数，同时保持参数的原始类型。这样就可以实现泛型编程中的通用参数传递，不再需要手动指定参数类型。</p><p>完美转发的核心是使用了两种类型：通用引用和 <code>std::forward</code>。</p><ol><li>通用引用（Universal Reference）是指使用了 <code>auto&amp;&amp;</code> 或模板参数推导结合引用折叠规则的引用类型。通用引用可以绑定到左值或右值，并保持参数的原始类型。</li><li><code>std::forward</code> 是一个条件转发的工具函数，用于根据参数的原始类型，选择性地将参数转发为左值引用或右值引用。它的使用场景通常是在模板函数或模板类中，用于将参数转发到另一个函数。</li></ol><p>下面是一个简单的示例，演示了完美转发的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">processValue</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; value)</span><br> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Lvalue: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    value = <span class="hljs-number">42</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">processValue</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; value)</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Rvalue: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//forwardValue 是一个模板函数，它使用了通用引用来接收参数，并使用 std::forward 将参数转发给 processValue 函数。通过 std::forward，参数的原始类型可以被保持，并且传递给正确的版本进行处理。</span><br>template&lt;typename T&gt;<br><span class="hljs-type">void</span> <span class="hljs-title function_">forwardValue</span><span class="hljs-params">(T&amp;&amp; value)</span> <br>&#123;<br>    processValue(<span class="hljs-built_in">std</span>::forward&lt;T&gt;(value));<br>&#125;<br><br><span class="hljs-comment">//在 main 函数中，我们先传递了一个左值 x 给 forwardValue 函数，然后传递了一个右值 20。通过完美转发，参数的类型被正确地保持，并且分别调用了 processValue 的左值版本和右值版本。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><br>    forwardValue(x);  <span class="hljs-comment">// 传递左值</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;After forwarding, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    forwardValue(<span class="hljs-number">20</span>);  <span class="hljs-comment">// 传递右值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//在上述示例中，我们定义了两个函数：processValue 和 forwardValue。processValue 函数重载了一个接收左值引用和右值引用参数的版本，分别对左值和右值做出不同的处理。</span><br></code></pre></td></tr></table></figure><p>需要注意的是，在使用完美转发时，通常需要使用模板函数，并搭配通用引用的语法。这样可以保持参数的原始类型，并进行类型推导，从而实现泛型编程中的参数转发。</p><p>总结来说，完美转发是一种保持参数类型并转发函数调用的机制。它利用通用引用和 <code>std::forward</code> 实现了参数的泛型传递，避免了手动指定参数类型的问题，增强了代码的重用性和灵活性。</p><p>参考文章：</p><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/u011852872/article/details/127076918?ops_request_misc=&request_id=&biz_id=102&utm_term=c++%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-127076918.nonecase&spm=1018.2226.3001.4187%23_6">C++入门(三)：移动语义_龙俊杰的读书笔记的博客-CSDN博客</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/sunchaothu/p/11392116.html">C++ 11的移动语义 - 行者孙 - 博客园</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/xiaobingqianrui/p/9064260.html">C++11新特性之右值引用(&amp;&amp;)、移动语义(move)、完美转换(forward) - Fate0729 - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/455848360">弘竣：一文入魂：妈妈再也不担心我不懂C++移动语义了</a></p><p><a href="https://zhuanlan.zhihu.com/p/398817111">ICOODE：c++11的移动语义和完美转发</a></p><h2 id="3-改进对泛型编程的支持"><a href="#3-改进对泛型编程的支持" class="headerlink" title="3.改进对泛型编程的支持"></a>3.改进对泛型编程的支持</h2><h3 id="3-1lambda-表达式"><a href="#3-1lambda-表达式" class="headerlink" title="3.1lambda 表达式"></a>3.1lambda 表达式</h3><p>C++11 引入了 Lambda 表达式，Lambda 表达式是一种匿名函数，可以在需要函数的地方定义并使用它，而无需显式命名函数。</p><p>Lambda 表达式的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">[capture <span class="hljs-built_in">list</span>](parameters) -&gt; return_type &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>capture list</code> 指定要捕获的变量列表（即Lambda表达式中可访问的外部变量），<code>parameters</code> 是Lambda函数的参数列表，<code>return_type</code> 是返回类型（可以使用 <code>auto</code> 自动推导），<code>函数体</code> 则是实现具体功能的代码块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单实例</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 使用 Lambda 表达式打印变量 x 的值</span><br>    <span class="hljs-keyword">auto</span> printX = [x]() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;;<br><br>    <span class="hljs-built_in">printX</span>();  <span class="hljs-comment">// 调用 Lambda 函数</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2变参模板"><a href="#3-2变参模板" class="headerlink" title="3.2变参模板"></a>3.2变参模板</h3><p>C++11 引入了变参模板（Variadic Template），它允许函数或类模板接受任意数量的参数。这使得我们能够定义更加灵活的函数和类模板，支持可变数量的参数。</p><p>在 C++11 中，使用 <code>...</code> 表示变参模板。下面是一个简单示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 使用变参模板实现递归打印函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T first, Args... args)</span> </span>&#123;<br>    std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">print</span>(args...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">4.5</span>);  <span class="hljs-comment">// 调用变参模板函数 print</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了函数模板，变参模板也可以应用于类模板。通过对模板参数包使用 <code>...</code>，可以接受任意数量和类型的模板参数，从而实现更加灵活的类模板定义。</p><h3 id="3-3别名"><a href="#3-3别名" class="headerlink" title="3.3别名"></a>3.3别名</h3><p>在 C++11 中，引入了类型别名（Type Alias）功能，允许为已有的类型定义一个新的名称。这种类型别名可以提高代码的可读性、简化复杂类型的书写，并且可以方便地修改类型定义而不需要改变使用该类型的代码。</p><p>C++11 提供了两种方式来创建类型别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> myInt;  <span class="hljs-comment">// 将 int 定义为 myInt 类型的别名</span><br><span class="hljs-keyword">typedef</span> std::vector&lt;<span class="hljs-type">int</span>&gt; IntVector;  <span class="hljs-comment">// 将 std::vector&lt;int&gt; 定义为 IntVector 类型的别名</span><br><br><span class="hljs-keyword">using</span> myInt = <span class="hljs-type">int</span>;  <span class="hljs-comment">// 将 int 定义为 myInt 类型的别名</span><br><span class="hljs-keyword">using</span> IntVector = std::vector&lt;<span class="hljs-type">int</span>&gt;;  <span class="hljs-comment">// 将 std::vector&lt;int&gt; 定义为 IntVector 类型的别名</span><br><br><span class="hljs-keyword">using</span> StringList = std::list&lt;std::string&gt;;  <span class="hljs-comment">// 将 std::list&lt;std::string&gt; 定义为 StringList 类型的别名</span><br><span class="hljs-keyword">using</span> IntMatrix = std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;;  <span class="hljs-comment">// 将 std::vector&lt;std::vector&lt;int&gt;&gt; 定义为 IntMatrix 类型的别名</span><br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，类型别名并不会创建新的类型，它只是为现有类型提供了一个新的名称。因此，类型别名与原始类型在大多数情况下是完全等价的，并且可以互相交换使用。</p></blockquote><h3 id="3-4tuple"><a href="#3-4tuple" class="headerlink" title="3.4tuple"></a>3.4tuple</h3><p>在 C++11 中引入了 <code>std::tuple</code> 类模板，它是一个通用的元组（Tuple）类，用于存储多个不同类型的值。<code>std::tuple</code> 可以看作是一个固定大小的、类型安全的、不可修改的集合。</p><p>使用 <code>std::tuple</code> 可以方便地组合多个值，而无需定义新的结构体或类。下面是一个简单的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个包含 int、double 和字符串的 tuple</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">myTuple</span><span class="hljs-params">(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 使用 std::get 访问 tuple 中的元素（通过索引）</span><br>    <span class="hljs-type">int</span> intValue = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(myTuple);<br>    <span class="hljs-type">double</span> doubleValue = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(myTuple);<br>    std::string stringValue = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(myTuple);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int value: &quot;</span> &lt;&lt; intValue &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;double value: &quot;</span> &lt;&lt; doubleValue &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;string value: &quot;</span> &lt;&lt; stringValue &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了使用 <code>std::get</code> 函数，还可以使用结构化绑定（Structured Binding）来解包元组中的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">myTuple</span><span class="hljs-params">(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 结构化绑定解包 tuple 中的值</span><br>    <span class="hljs-keyword">auto</span> [intValue, doubleValue, stringValue] = myTuple;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int value: &quot;</span> &lt;&lt; intValue &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;double value: &quot;</span> &lt;&lt; doubleValue &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;string value: &quot;</span> &lt;&lt; stringValue &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-51ba025a8b408d83ac6ab111fefacd9a_1440w.jpg" alt="img"></p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/139515439">程序喵大人：c++11新特性，所有知识点都在这了！</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA语法概览</title>
    <link href="/2022/09/19/java%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <url>/2022/09/19/java%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文仅是由于自己经常多语言开发，对于一些语言时常不用感到陌生或者使用中同其他语言用法混淆，故作此文，仅为自己提供一个java语言使用的知识体系。</p></blockquote><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在 Java 中，数据类型可以分为两大类：<strong>基本数据类型</strong>和 <strong>引用数据类型</strong></p><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. <strong>基本数据类型</strong></h2><p>Java 的基本数据类型是由 Java 提供的基本类型，不是对象类型。它们的存储方式是直接的，不会存储指向其他对象的引用。</p><table><thead><tr><th>数据类型</th><th>大小</th><th>默认值</th><th>范围&#x2F;说明</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1 byte</td><td>0</td><td>-128 到 127</td></tr><tr><td><code>short</code></td><td>2 bytes</td><td>0</td><td>-32,768 到 32,767</td></tr><tr><td><code>int</code></td><td>4 bytes</td><td>0</td><td>-2^31 到 2^31 - 1</td></tr><tr><td><code>long</code></td><td>8 bytes</td><td>0L</td><td>-2^63 到 2^63 - 1</td></tr><tr><td><code>float</code></td><td>4 bytes</td><td>0.0f</td><td>32 位单精度浮动数（可以表示较大的数值）</td></tr><tr><td><code>double</code></td><td>8 bytes</td><td>0.0d</td><td>64 位双精度浮动数（精度较高）</td></tr><tr><td><code>char</code></td><td>2 bytes</td><td>‘\u0000’</td><td>单一字符（0 到 65535，表示 Unicode 字符）</td></tr><tr><td><code>boolean</code></td><td>1 byte</td><td>false</td><td>仅有两种值：<code>true</code> 或 <code>false</code></td></tr></tbody></table><h2 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2. 引用数据类型"></a>2. <strong>引用数据类型</strong></h2><p>引用数据类型是指通过引用来访问对象的类型。引用数据类型包括 <strong>类</strong>、<strong>接口</strong>、<strong>数组</strong> 等，它们的变量存储的是对实际数据对象的引用（地址），而不是数据本身。</p><h3 id="常见引用数据类型"><a href="#常见引用数据类型" class="headerlink" title="常见引用数据类型"></a>常见引用数据类型</h3><ul><li><strong>类</strong>（Class）：定义对象的蓝图（类），如 <code>String</code>, <code>Scanner</code>, <code>ArrayList</code> 等。</li><li><strong>接口</strong>（Interface）：定义一组方法供实现类去实现。</li><li><strong>数组</strong>（Array）：存储相同类型元素的集合。</li></ul><h3 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a><strong>基本数据类型和引用数据类型的区别</strong></h3><table><thead><tr><th>特性</th><th>基本数据类型</th><th>引用数据类型</th></tr></thead><tbody><tr><td>存储方式</td><td>直接存储值</td><td>存储引用（地址）</td></tr><tr><td>默认值</td><td>每种类型有固定的默认值</td><td>默认值是 <code>null</code></td></tr><tr><td>内存分配</td><td>栈内存（直接存储值）</td><td>堆内存（存储对象）</td></tr><tr><td>示例</td><td><code>int</code>, <code>char</code>, <code>float</code>, <code>boolean</code></td><td><code>String</code>, <code>Array</code>, <code>Class</code></td></tr></tbody></table><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a><strong>自动装箱与拆箱</strong></h3><p>Java 提供了自动装箱和拆箱的机制，使得基本数据类型和它们的包装类（例如 <code>Integer</code>, <code>Character</code>, <code>Double</code> 等）之间能够相互转换。</p><ul><li><strong>自动装箱</strong>：将基本数据类型转换为对应的包装类对象（如 <code>int</code> 转为 <code>Integer</code>）。</li><li><strong>拆箱</strong>：将包装类对象转换为基本数据类型（如 <code>Integer</code> 转为 <code>int</code>）。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Java 中没有 <code>struct</code> 这种数据类型。但是可以通过其他方式实现类似的功能，主要是通过 <strong>类（class）</strong> 和 <strong>对象</strong>。</p><h4 id="1-使用类（class）"><a href="#1-使用类（class）" class="headerlink" title="1. 使用类（class）"></a>1. <strong>使用类（class）</strong></h4><p>在 Java 中，可以使用 <code>class</code> 来组织和封装数据。类可以包含不同类型的字段和方法，类似于 C&#x2F;C++ 中的 <code>struct</code>。不过，与 <code>struct</code> 不同的是，Java 的 <code>class</code> 还可以定义方法和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    Point(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 方法可以在类中定义</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;x: &quot;</span> + x + <span class="hljs-string">&quot;, y: &quot;</span> + y);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        p.print();  <span class="hljs-comment">// 输出: x: 10, y: 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Point</code> 类类似于 C&#x2F;C++ 中的 <code>struct</code>，用于存储 <code>x</code> 和 <code>y</code> 两个字段。不同的是，Java 中的 <code>class</code> 可以有构造函数、方法、继承等特性，而 <code>struct</code> 只是一个简单的数据存储结构。</p><h4 id="2-匿名类（仅存储数据，类似简单结构体）"><a href="#2-匿名类（仅存储数据，类似简单结构体）" class="headerlink" title="2. 匿名类（仅存储数据，类似简单结构体）"></a>2. <strong>匿名类</strong>（仅存储数据，类似简单结构体）</h4><p>Java 也允许使用匿名类来实现类似 <code>struct</code> 的效果，特别是当你需要一个只包含数据的简单对象时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用匿名类表示一个简单的结构体</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        &#125;;<br>        <br>        System.out.println(<span class="hljs-string">&quot;x: &quot;</span> + point.x + <span class="hljs-string">&quot;, y: &quot;</span> + point.y);  <span class="hljs-comment">// x: 10, y: 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，这种方式在实际开发中并不常见，通常使用普通类来封装数据。</p><h1 id="数据结构的封装"><a href="#数据结构的封装" class="headerlink" title="数据结构的封装"></a>数据结构的封装</h1><p><a href="https://blog.csdn.net/m0_67322837/article/details/124322953">Java集合框架最全详解(看这篇就够了)_java 集合框架-CSDN博客</a></p><p>在 Java 中，类似于 C++ 的 STL（标准模板库），提供了一系列<strong>封装好的数据结构</strong>和<strong>算法</strong>，这包括像 <code>HashMap</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code> 等常见的容器类。Java 的集合框架提供了这些常用的数据结构的实现，它们都位于 <code>java.util</code> 包中。</p><p><img src="https://s2.loli.net/2024/12/27/dtbHo15zarR9YAG.png" alt="6dd69077f31574ee88c9ca2944178f2d"></p><table><thead><tr><th><strong>数据结构</strong></th><th><strong>基本使用</strong></th><th><strong>底层实现结构</strong></th></tr></thead><tbody><tr><td><strong><code>ArrayList</code></strong></td><td>存储元素并提供按索引访问，支持动态数组，允许重复元素。常用于需要频繁随机访问的场景。</td><td>动态数组（<code>Object[]</code>）</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>实现 <code>List</code> 和 <code>Queue</code> 接口，用于存储元素的链表，支持插入和删除操作。</td><td>双向链表（<code>Node</code> 对象，包含指向前后元素的指针）</td></tr><tr><td><strong><code>HashMap</code></strong></td><td>存储键值对映射，允许 <code>null</code> 键和值，元素无序，支持快速查找。</td><td>哈希表（<code>Node[]</code> 数组，链式哈希冲突解决）</td></tr><tr><td><strong><code>TreeMap</code></strong></td><td>存储键值对映射，按键有序排列，支持 <code>Comparator</code> 定制排序。</td><td>红黑树（<code>Red-Black Tree</code>）</td></tr><tr><td><strong><code>HashSet</code></strong></td><td>存储唯一的元素，允许 <code>null</code>，不保证元素顺序。</td><td>哈希表（基于 <code>HashMap</code>）</td></tr><tr><td><strong><code>LinkedHashSet</code></strong></td><td>存储唯一的元素，保持插入顺序，允许 <code>null</code>。</td><td>双向链表 + 哈希表（<code>HashMap</code> + 链表）</td></tr><tr><td><strong><code>TreeSet</code></strong></td><td>存储唯一的元素，按自然顺序排序，或根据提供的 <code>Comparator</code> 排序。</td><td>红黑树（<code>Red-Black Tree</code>）</td></tr><tr><td><strong><code>PriorityQueue</code></strong></td><td>存储具有优先级的元素，按照优先级进行排序。</td><td>堆（通常是二叉堆）</td></tr><tr><td><strong><code>ArrayDeque</code></strong></td><td>实现 <code>Deque</code> 接口，用作双端队列，支持在两端快速插入和删除元素。</td><td>动态数组（<code>Object[]</code>）</td></tr><tr><td><strong><code>LinkedList</code></strong></td><td>实现 <code>Deque</code> 接口，用作双端队列，也可以作为栈或队列使用。</td><td>双向链表（<code>Node</code> 对象）</td></tr><tr><td><strong><code>Stack</code></strong></td><td>提供先进后出的栈（LIFO）结构，通常用于递归、深度优先搜索等场景。</td><td>数组或链表（继承自 <code>Vector</code>）</td></tr><tr><td><strong><code>Vector</code></strong></td><td>类似于 <code>ArrayList</code>，但它是线程安全的，适用于多线程场景。</td><td>动态数组（<code>Object[]</code>）</td></tr><tr><td><strong><code>EnumSet</code></strong></td><td>用于枚举类型的集合，提供高效的实现，适用于枚举类型的存储和操作。</td><td>位向量（<code>Bit vector</code>）</td></tr><tr><td><strong><code>EnumMap</code></strong></td><td>用于枚举键的映射，提供高效的 <code>Map</code> 实现。</td><td>数组（<code>Enum[]</code>）</td></tr></tbody></table><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><a href="https://blog.csdn.net/weixin_45395059/article/details/126006369">Java 中的泛型（两万字超全详解）_java 泛型-CSDN博客</a></p><blockquote><p><strong>泛型（Generics）</strong> 是一种允许在类、接口、方法定义时不指定具体数据类型，而是使用类型参数来表示的机制。泛型的主要目的是让代码更加灵活和类型安全，同时减少冗余的类型转换和增强代码的重用性。</p></blockquote><p>在 Java 中，泛型广泛应用于集合框架（如 <code>List&lt;T&gt;</code>、<code>Map&lt;K, V&gt;</code>）和其他类库，它允许开发者在编写代码时使用类型参数来替代具体类型，使得同一段代码可以处理不同类型的数据，而无需对每种类型编写重复的代码。</p><h3 id="泛型的基本概念"><a href="#泛型的基本概念" class="headerlink" title="泛型的基本概念"></a>泛型的基本概念</h3><ol><li><strong>类型参数化</strong>：通过泛型，代码可以在编译时绑定类型参数。开发者可以指定类型，在运行时通过传递不同的类型参数来实现相同的逻辑。</li><li><strong>类型安全</strong>：泛型使得类型信息在编译时得到检查，从而避免了常见的类型转换错误，例如将 <code>Object</code> 类型转换为不兼容的类型。</li></ol><h3 id="泛型的基本语法"><a href="#泛型的基本语法" class="headerlink" title="泛型的基本语法"></a>泛型的基本语法</h3><p>在 Java 中，泛型通常用于以下三种情形：</p><ol><li><p><strong>泛型类</strong></p><ul><li>在类定义时，使用尖括号（<code>&lt;&gt;</code>）来声明类型参数。例如：<code>List&lt;T&gt;</code>、<code>Map&lt;K, V&gt;</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T value;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>T</code> 是类型参数，<code>Box&lt;T&gt;</code> 表示可以存储任意类型的数据（例如 <code>Box&lt;Integer&gt;</code>、<code>Box&lt;String&gt;</code>）。</p></li><li><p><strong>泛型方法</strong></p><ul><li>可以在方法的返回类型前面声明类型参数，以实现方法的泛型功能。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(T[] array)</span> &#123;<br>    <span class="hljs-keyword">for</span> (T element : array) &#123;<br>        System.out.println(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法可以接受任何类型的数组并打印数组内容。</p></li><li><p><strong>泛型接口</strong></p><ul><li>可以为接口声明泛型，从而使得接口的实现类可以根据具体类型进行选择。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T other)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="泛型的类型参数"><a href="#泛型的类型参数" class="headerlink" title="泛型的类型参数"></a>泛型的类型参数</h3><p>在 Java 中，泛型可以有多个类型参数，通常由一个或多个字母表示。常见的字母表示如下：</p><ul><li><code>T</code>（Type）：表示某种类型，通常用于类、接口或方法中。</li><li><code>E</code>（Element）：表示集合中的元素类型。</li><li><code>K</code>（Key）：表示 <code>Map</code> 中的键类型。</li><li><code>V</code>（Value）：表示 <code>Map</code> 中的值类型。</li><li><code>N</code>（Number）：表示数字类型。</li><li><code>S</code>、<code>U</code>、<code>V</code> 等：通常用于表示多个不同的类型参数。</li></ul><h3 id="泛型的限制（泛型的通配符）"><a href="#泛型的限制（泛型的通配符）" class="headerlink" title="泛型的限制（泛型的通配符）"></a>泛型的限制（泛型的通配符）</h3><p>Java 泛型具有一些限制和特性，特别是“通配符”（Wildcard）机制，它允许在泛型中使用 <code>?</code> 来表示不指定具体类型。</p><ol><li><p>**<code>? extends T</code>**：表示类型为 <code>T</code> 或 <code>T</code> 的子类型。</p><ul><li>用于限定泛型只能是某个类型或其子类型的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumbers</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Number num : list) &#123;<br>        System.out.println(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>**<code>? super T</code>**：表示类型为 <code>T</code> 或 <code>T</code> 的父类型。</p><ul><li>用于限定泛型只能是某个类型或其父类型的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumbers</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Integer&gt; list)</span> &#123;<br>    list.add(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 允许添加 Integer 类型或其父类型的数据</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>在 Java 中，泛型是通过<strong>类型擦除</strong>实现的。这意味着在运行时，所有泛型类型都会被替换为原始类型（通常是 <code>Object</code>）。因此，泛型类型的具体类型参数仅在编译时存在，运行时并不保留。例如，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在运行时都被视为 <code>List</code>。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>在 Java 中，面向对象编程（OOP）是编程的一种范式，它基于四个核心概念：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong> 和 <strong>抽象</strong>。当然这也是所有面对对象语言中的核心概念。笔者这里并不赘述仅仅聊聊java相较于其他语言(C++)的使用特点：</p><table><thead><tr><th>特性</th><th><strong>Java</strong></th><th><strong>C++</strong></th></tr></thead><tbody><tr><td><strong>类的定义</strong></td><td>类通过 <code>class</code> 关键字定义。类可以包含构造方法、成员变量、成员方法等。</td><td>类通过 <code>class</code> 或 <code>struct</code> 关键字定义。 <code>struct</code> 默认成员是 public，<code>class</code> 默认成员是 private。</td></tr><tr><td><strong>继承</strong></td><td>extends关键字,Java 支持单继承（一个类只能继承一个父类），但通过接口支持多重继承。</td><td>C++ 支持多重继承（一个类可以继承多个父类）。</td></tr><tr><td><strong>构造函数</strong></td><td>Java 类中的构造函数没有返回值，且不能重载构造函数的类型；构造函数默认调用父类的构造函数（使用 <code>super()</code>）。</td><td>C++ 类中的构造函数没有返回值，可以重载多个构造函数；构造函数不自动调用父类构造函数，需要显式调用 <code>base()</code>。</td></tr><tr><td><strong>析构函数</strong></td><td>Java 使用垃圾回收机制（GC）自动管理内存，不需要析构函数。</td><td>C++ 中使用析构函数（<code>~ClassName()</code>）来释放内存或做清理工作。</td></tr><tr><td><strong>多态</strong></td><td>使用方法重载和方法重写实现多态。</td><td>使用方法重载和方法重写实现多态。C++ 支持虚函数和纯虚函数。</td></tr><tr><td><strong>接口</strong></td><td>Java 中的接口用 <code>interface</code> 关键字定义，接口不能有具体的实现（除了默认方法）。一个类可以实现多个接口。</td><td>C++ 没有接口的概念，可以通过纯虚类（abstract class）来模拟接口。一个类可以继承多个纯虚类，模拟多重继承。</td></tr><tr><td><strong>抽象类</strong></td><td>abstract关键字定义,Java 支持抽象类，抽象类不能实例化，必须由子类实现其中的抽象方法。</td><td>C++ 支持抽象类，抽象类可以包含已实现的方法，但必须包含纯虚函数（<code>= 0</code>）来实现抽象行为。</td></tr><tr><td><strong>访问修饰符</strong></td><td>Java 提供 <code>public</code>、<code>private</code>、<code>protected</code> 和包级（默认）访问修饰符来控制成员的访问权限。</td><td>C++ 提供 <code>public</code>、<code>private</code>、<code>protected</code> 访问修饰符，还可以使用友元（friend）机制来控制访问权限。</td></tr><tr><td><strong>垃圾回收</strong></td><td>Java 有自动垃圾回收机制（GC），程序员无需手动管理内存。</td><td>C++ 没有垃圾回收机制，程序员必须手动管理内存（使用 <code>new</code> 和 <code>delete</code>）。</td></tr><tr><td><strong>内存管理</strong></td><td>Java 中的对象由 JVM 管理内存，使用自动垃圾回收。</td><td>C++ 使用 <code>new</code> 和 <code>delete</code> 关键字显式分配和释放内存。</td></tr><tr><td><strong>异常处理</strong></td><td>Java 提供 <code>try-catch-finally</code> 机制，所有异常必须处理（Checked Exception 和 Unchecked Exception）。</td><td>C++ 使用 <code>try-catch</code> 机制，但不像 Java 那样要求处理所有异常。</td></tr><tr><td><strong>多线程支持</strong></td><td>Java 提供内建的多线程支持，通过 <code>Thread</code> 类和 <code>Runnable</code> 接口进行多线程编程。</td><td>C++ 本身没有内建的多线程支持，但通过外部库（如 pthreads 或 C++11 的 <code>&lt;thread&gt;</code>）来实现多线程。</td></tr><tr><td><strong>平台依赖性</strong></td><td>Java 是跨平台的（”Write Once, Run Anywhere”），通过 JVM 实现跨平台。</td><td>C++ 是编译型语言，程序与平台绑定，必须针对不同操作系统编译。</td></tr><tr><td><strong>模板（Templates）</strong></td><td>Java 不支持模板，使用泛型（Generics）来实现类型安全的集合类等功能。</td><td>C++ 支持模板（<code>template</code>）机制，允许在编译时生成特定类型的代码。</td></tr><tr><td><strong>内存布局</strong></td><td>Java 的内存由 JVM 管理，使用堆和栈来存储对象和局部变量。</td><td>C++ 直接管理内存，使用堆、栈、全局静态变量等存储结构。</td></tr><tr><td><strong>运算符重载</strong></td><td>Java 不支持运算符重载。</td><td>C++ 支持运算符重载，允许开发者为自定义类型重载常见运算符（如 <code>+</code>、<code>-</code>）。</td></tr><tr><td><strong>命名空间</strong></td><td>Java 使用包（<code>package</code>）来组织类和避免命名冲突。</td><td>C++ 使用命名空间（<code>namespace</code>）来避免命名冲突。</td></tr></tbody></table><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 Java 中，<strong>接口（Interface）</strong> 是一种抽象类型，它定义了一组方法的签名（方法名称、参数、返回类型），但不提供方法的具体实现。接口是一种规范或合同，任何类实现该接口时，必须提供接口中定义的所有方法的实现。</p><h3 id="接口的主要特点"><a href="#接口的主要特点" class="headerlink" title="接口的主要特点"></a>接口的主要特点</h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>定义方法的签名</strong></td><td>接口只定义方法的名称、参数类型和返回类型，不提供方法的具体实现。通过接口实现多态和抽象。</td></tr><tr><td><strong>不能实例化</strong></td><td>接口不能直接创建实例，因为它没有实现任何方法。必须由类通过 <code>implements</code> 关键字来实现接口，提供方法的具体实现。</td></tr><tr><td><strong>支持多重继承</strong></td><td>接口允许一个类实现多个接口，这解决了 Java 单继承的局限性。一个类可以继承多个接口的行为。</td></tr><tr><td><strong>方法的默认实现</strong></td><td>Java 8 引入了接口中的 <strong>默认方法</strong>（<code>default</code>），允许接口提供方法的默认实现，避免每个实现类都必须重复实现相同方法。</td></tr><tr><td><strong>常量</strong></td><td>接口可以包含常量，所有接口中的字段默认是 <code>public static final</code>（即公共、静态、常量）。无需显式声明，编译器会隐式添加。</td></tr><tr><td><strong>静态方法</strong></td><td>从 Java 8 开始，接口可以包含静态方法，这些方法只能通过接口名来调用，不能通过实现类调用。</td></tr><tr><td><strong>多态和灵活的接口设计</strong></td><td>接口常用于定义行为规范，具体的实现由不同的类来提供。接口支持多态，允许通过接口类型的引用来调用实现类的方法。可以实现不同类的统一行为。</td></tr></tbody></table><h3 id="接口的语法"><a href="#接口的语法" class="headerlink" title="接口的语法"></a>接口的语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceName</span> &#123;<br>    <span class="hljs-comment">// 常量（默认public static final）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">// 抽象方法（默认public abstract）</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">// 默认方法（从Java 8开始）</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a default method.&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 静态方法（从Java 8开始）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><ul><li><strong>实现接口的类</strong>：类通过 <code>implements</code> 关键字实现接口。</li><li>类实现接口时，必须提供接口中所有方法的实现（除非该类是抽象类）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceName</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method 1 implementation&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Method 2 implementation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><table><thead><tr><th>特性</th><th><strong>接口（Interface）</strong></th><th><strong>抽象类（Abstract Class）</strong></th></tr></thead><tbody><tr><td><strong>方法</strong></td><td>只能有抽象方法（Java 8 以后可以有默认方法和静态方法）</td><td>可以有抽象方法和已实现的方法（Java 8 以后也可以有默认方法）</td></tr><tr><td><strong>成员变量</strong></td><td>默认是 <code>public static final</code>（常量）</td><td>可以有实例变量，可以是任意访问修饰符</td></tr><tr><td><strong>多重继承</strong></td><td>支持多继承，一个类可以实现多个接口</td><td>不支持多重继承，一个类只能继承一个抽象类</td></tr><tr><td><strong>构造方法</strong></td><td>没有构造方法</td><td>可以有构造方法</td></tr><tr><td><strong>访问修饰符</strong></td><td>方法默认是 <code>public</code>，字段默认是 <code>public static final</code></td><td>可以使用任意访问修饰符（<code>private</code>、<code>protected</code>、<code>public</code>）</td></tr><tr><td><strong>是否可以实例化</strong></td><td>不能实例化</td><td>不能实例化</td></tr><tr><td><strong>用途</strong></td><td>用于定义类的行为规范，多个类可以实现相同的接口</td><td>用于提供类的基本功能和共享代码，子类可以继承并扩展</td></tr></tbody></table><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h3 id="1-线程（Thread）"><a href="#1-线程（Thread）" class="headerlink" title="1. 线程（Thread）"></a>1. <strong>线程（Thread）</strong></h3><p>Java 中的线程是程序执行的基本单位。每个线程都有一个执行路径，称为执行线程。</p><h4 id="创建线程的方式："><a href="#创建线程的方式：" class="headerlink" title="创建线程的方式："></a>创建线程的方式：</h4><ol><li><p><strong>继承 <code>Thread</code> 类</strong>：</p><ul><li>通过继承 <code>Thread</code> 类并重写其 <code>run()</code> 方法来创建线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Thread is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();  <span class="hljs-comment">// 启动线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实现 <code>Runnable</code> 接口</strong>：</p><ul><li>通过实现 <code>Runnable</code> 接口并重写 <code>run()</code> 方法来创建线程。<code>Runnable</code> 是函数式接口，可以使用 Lambda 表达式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Runnable is running&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        thread.start();  <span class="hljs-comment">// 启动线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 Lambda 表达式（Java 8 及以上）</strong>：</p><ul><li>可以用 Lambda 表达式来简化 <code>Runnable</code> 接口的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;Thread is running via Lambda&quot;</span>));<br>        thread.start();  <span class="hljs-comment">// 启动线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-线程池（Executor）"><a href="#2-线程池（Executor）" class="headerlink" title="2. 线程池（Executor）"></a>2. <strong>线程池（Executor）</strong></h3><p>线程池通过预创建一定数量的线程来管理线程的生命周期，避免频繁创建和销毁线程的开销。Java 提供了 <code>Executor</code> 框架来管理线程池。</p><h4 id="常用线程池："><a href="#常用线程池：" class="headerlink" title="常用线程池："></a>常用线程池：</h4><ol><li><p>**<code>ExecutorService</code>**：Java 提供了 <code>ExecutorService</code> 接口，用于管理线程池，并提供提交任务、关闭线程池等方法。</p></li><li><p><strong><code>Executors</code> 工厂类</strong>：通过 <code>Executors</code> 工厂类可以创建不同类型的线程池。</p><ul><li><strong>固定大小线程池</strong>：适用于并发量大且可预估的场景。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;Task 1&quot;</span>));<br>executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;Task 2&quot;</span>));<br>executor.shutdown();  <span class="hljs-comment">// 关闭线程池</span><br></code></pre></td></tr></table></figure><ul><li><strong>单线程池</strong>：只有一个工作线程，适用于顺序执行任务的场景。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;Single Threaded Task&quot;</span>));<br>executor.shutdown();<br></code></pre></td></tr></table></figure><ul><li><strong>缓存线程池</strong>：线程池根据需要创建新线程，适用于任务量动态变化的场景。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;Dynamic Thread Pool Task&quot;</span>));<br>executor.shutdown();<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-同步（Synchronization）"><a href="#3-同步（Synchronization）" class="headerlink" title="3. 同步（Synchronization）"></a>3. <strong>同步（Synchronization）</strong></h3><p>在并发编程中，多个线程可能会共享资源，导致数据不一致的情况。为了避免并发冲突，Java 提供了同步机制。</p><h4 id="同步方法："><a href="#同步方法：" class="headerlink" title="同步方法："></a>同步方法：</h4><p>通过 <code>synchronized</code> 关键字，可以确保同一时刻只有一个线程能执行该方法，从而避免多个线程同时访问共享资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="同步代码块："><a href="#同步代码块：" class="headerlink" title="同步代码块："></a>同步代码块：</h4><p>除了同步整个方法外，还可以使用 <code>synchronized</code> 关键字同步代码块，控制访问的代码范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="锁（Lock）："><a href="#锁（Lock）：" class="headerlink" title="锁（Lock）："></a>锁（Lock）：</h4><p>Java 提供了 <code>Lock</code> 接口和相关类（如 <code>ReentrantLock</code>）来实现更细粒度的锁控制。与 <code>synchronized</code> 不同，<code>Lock</code> 提供了尝试获取锁、定时锁和公平锁等功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();  <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();  <span class="hljs-comment">// 释放锁</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-线程通信（wait-notify）"><a href="#4-线程通信（wait-notify）" class="headerlink" title="4. 线程通信（wait&#x2F;notify）"></a>4. <strong>线程通信（wait&#x2F;notify）</strong></h3><p>线程之间的协调和通信是并发编程中的重要问题。Java 提供了 <code>Object</code> 类中的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法来实现线程间的通信。</p><ul><li>**<code>wait()</code>**：使当前线程进入等待状态，直到被唤醒。</li><li>**<code>notify()</code>**：唤醒一个在该对象监视器上等待的线程。</li><li>**<code>notifyAll()</code>**：唤醒所有在该对象监视器上等待的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (item &gt; <span class="hljs-number">0</span>) &#123;<br>            wait();  <span class="hljs-comment">// 如果已有产品，等待消费</span><br>        &#125;<br>        item++;<br>        System.out.println(<span class="hljs-string">&quot;Produced item: &quot;</span> + item);<br>        notify();  <span class="hljs-comment">// 通知消费者</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (item == <span class="hljs-number">0</span>) &#123;<br>            wait();  <span class="hljs-comment">// 如果没有产品，等待生产</span><br>        &#125;<br>        item--;<br>        System.out.println(<span class="hljs-string">&quot;Consumed item: &quot;</span> + item);<br>        notify();  <span class="hljs-comment">// 通知生产者</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-并发工具类（java-util-concurrent-包）"><a href="#5-并发工具类（java-util-concurrent-包）" class="headerlink" title="5. 并发工具类（java.util.concurrent 包）"></a>5. <strong>并发工具类（<code>java.util.concurrent</code> 包）</strong></h3><p>Java 提供了很多类来简化并发编程，减少开发者手动管理线程和锁的负担。</p><h4 id="常用工具类："><a href="#常用工具类：" class="headerlink" title="常用工具类："></a>常用工具类：</h4><ul><li><p>**<code>CountDownLatch</code>**：使一个或多个线程等待直到某个操作完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>latch.countDown();  <span class="hljs-comment">// 计数器减1</span><br>latch.await();  <span class="hljs-comment">// 等待计数器为0</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>CyclicBarrier</code>**：用于同步多个线程，使其在某个点上等待其他线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">3</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;All threads are ready&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>**<code>Semaphore</code>**：控制同时访问某一资源的线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 允许3个线程同时访问</span><br>semaphore.acquire();  <span class="hljs-comment">// 获取许可</span><br>semaphore.release();  <span class="hljs-comment">// 释放许可</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>ExecutorService</code>**：用于管理线程池并执行任务。</p></li><li><p>**<code>Future</code>**：表示异步计算的结果，可以在计算完成之前获取结果。</p></li><li><p>**<code>ReentrantLock</code>**：提供了比 <code>synchronized</code> 更灵活的锁机制。</p></li><li><p><strong><code>AtomicInteger</code>、<code>AtomicLong</code></strong> 等：提供原子性操作的类，适用于并发环境下的数值操作。</p></li></ul><p>在 Java 中，<strong>进程</strong>的创建与管理通常是由操作系统来控制的，而 Java 本身是通过 <strong>线程</strong> 来实现并发和并行操作的。虽然 Java 提供了一些用于启动和管理外部进程的工具，但它并不像一些低级编程语言（如 C 或 C++）那样直接提供创建进程的功能。</p><h3 id="Java-如何管理进程"><a href="#Java-如何管理进程" class="headerlink" title="Java 如何管理进程"></a>Java 如何管理进程</h3><p>虽然 Java 本身不提供像 <code>fork()</code> 或 <code>exec()</code> 这样的低级系统调用来直接创建进程，但 Java 可以通过以下方式启动和管理外部进程：</p><h4 id="1-使用-ProcessBuilder-类"><a href="#1-使用-ProcessBuilder-类" class="headerlink" title="1. 使用 ProcessBuilder 类"></a>1. <strong>使用 <code>ProcessBuilder</code> 类</strong></h4><p>Java 提供了 <code>ProcessBuilder</code> 类来启动操作系统上的外部进程。通过 <code>ProcessBuilder</code>，你可以创建、启动、控制和管理进程。</p><h4 id="2-使用-Runtime-getRuntime-exec-方法"><a href="#2-使用-Runtime-getRuntime-exec-方法" class="headerlink" title="2. 使用 Runtime.getRuntime().exec() 方法"></a>2. <strong>使用 <code>Runtime.getRuntime().exec()</code> 方法</strong></h4><p><code>Runtime.getRuntime().exec()</code> 方法也可以用来启动外部进程。它可以执行系统命令，启动程序，或运行脚本。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Java 的异常处理机制是基于 <strong>try-catch-finally</strong> 块的，旨在捕捉和处理程序运行过程中可能出现的错误。通过异常处理，程序可以在遇到错误时不直接崩溃，而是采取一些补救措施，从而提升程序的鲁棒性。</p><h3 id="1-异常的分类"><a href="#1-异常的分类" class="headerlink" title="1. 异常的分类"></a>1. <strong>异常的分类</strong></h3><p>Java 中的异常分为两大类：</p><ul><li><strong>Checked Exceptions（已检查异常）</strong>：<ul><li>这些异常是编译器强制要求必须处理的异常。通常发生在程序运行时，且不容易预见的错误。例如，文件操作、数据库连接、网络通信等可能出现的问题。</li><li>Checked 异常必须要么通过 <code>try-catch</code> 块处理，要么通过 <code>throws</code> 关键字声明抛出。</li><li>例子：<code>IOException</code>, <code>SQLException</code>, <code>ClassNotFoundException</code> 等。</li></ul></li><li><strong>Unchecked Exceptions（未检查异常）</strong>：<ul><li>这些异常是运行时异常，也叫 <strong>运行时异常</strong>。它们通常是程序逻辑错误或开发者的疏忽导致的错误，例如空指针引用、数组越界等。</li><li>Unchecked 异常是继承自 <code>RuntimeException</code> 类的异常。它们不需要强制捕获，可以选择性地处理。</li><li>例子：<code>NullPointerException</code>, <code>ArrayIndexOutOfBoundsException</code>, <code>ArithmeticException</code> 等。</li></ul></li></ul><h3 id="2-Java-异常处理的基本语法"><a href="#2-Java-异常处理的基本语法" class="headerlink" title="2. Java 异常处理的基本语法"></a>2. <strong>Java 异常处理的基本语法</strong></h3><h4 id="1-try-catch-finally-结构"><a href="#1-try-catch-finally-结构" class="headerlink" title="1) try-catch-finally 结构"></a>1) <strong>try-catch-finally 结构</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 e1) &#123;<br>    <span class="hljs-comment">// 处理 ExceptionType1 类型的异常</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 e2) &#123;<br>    <span class="hljs-comment">// 处理 ExceptionType2 类型的异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 不管是否发生异常，都会执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>try</code> 块</strong>：用于包装可能会抛出异常的代码。当 <code>try</code> 块中的代码抛出异常时，会立即跳转到相应的 <code>catch</code> 块。</li><li><strong><code>catch</code> 块</strong>：用于捕获异常并进行处理。可以有多个 <code>catch</code> 块来捕获不同类型的异常。如果 <code>try</code> 中抛出异常，程序将跳转到第一个匹配的 <code>catch</code> 块进行处理。</li><li><strong><code>finally</code> 块</strong>：不管是否发生异常，<code>finally</code> 块中的代码都会被执行。常用于释放资源（如文件流、数据库连接等）。如果没有 <code>catch</code> 块，<code>finally</code> 也会执行。</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;  <span class="hljs-comment">// 会抛出 ArithmeticException</span><br>        &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Error: Division by zero&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;This will always run&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>Division by zero<br>This will always run<br></code></pre></td></tr></table></figure><h3 id="3-异常的传播与声明（throws）"><a href="#3-异常的传播与声明（throws）" class="headerlink" title="3. 异常的传播与声明（throws）"></a>3. <strong>异常的传播与声明（<code>throws</code>）</strong></h3><p>有些异常可能在方法内部无法处理，而需要将它们传递给调用该方法的地方。使用 <code>throws</code> 关键字来声明异常，使得方法的调用者可以决定如何处理这些异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 可能抛出 IOException 的代码</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;File not found&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>throws</code> 后面列出的异常是指该方法可能抛出的异常类型。</li><li>如果方法声明了 <code>throws</code>，调用该方法的代码必须处理该异常（使用 <code>try-catch</code>）或者将异常进一步声明传递。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            methodThatThrowsException();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Caught exception: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodThatThrowsException</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;An IOException occurred&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4. 自定义异常"></a>4. <strong>自定义异常</strong></h3><p>Java 允许开发者根据需求自定义异常类。自定义异常类通常继承自 <code>Exception</code> 类（如果是已检查异常）或者 <code>RuntimeException</code> 类（如果是未检查异常）。</p><h4 id="自定义已检查异常："><a href="#自定义已检查异常：" class="headerlink" title="自定义已检查异常："></a>自定义已检查异常：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCheckedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCheckedException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义未检查异常："><a href="#自定义未检查异常：" class="headerlink" title="自定义未检查异常："></a>自定义未检查异常：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUncheckedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyUncheckedException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-异常的链式调用"><a href="#5-异常的链式调用" class="headerlink" title="5. 异常的链式调用"></a>5. <strong>异常的链式调用</strong></h3><p>Java 允许将异常作为参数传递给另一个异常，形成异常链。这样可以更详细地描述错误发生的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChainedException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>(<span class="hljs-string">&quot;Arithmetic error&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;New exception caused by ArithmeticException&quot;</span>, e);  <span class="hljs-comment">// 异常链</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Caught Exception: &quot;</span> + e.getMessage());<br>            System.out.println(<span class="hljs-string">&quot;Cause: &quot;</span> + e.getCause());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Caught <span class="hljs-keyword">Exception</span>: <span class="hljs-built_in">New</span> <span class="hljs-keyword">exception</span> caused <span class="hljs-keyword">by</span> ArithmeticException<br>Cause: java.lang.ArithmeticException: Arithmetic error<br></code></pre></td></tr></table></figure><h3 id="6-常见的异常类"><a href="#6-常见的异常类" class="headerlink" title="6. 常见的异常类"></a>6. <strong>常见的异常类</strong></h3><table><thead><tr><th>异常类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Exception</code></td><td>所有异常的父类，用于已检查异常。</td><td><code>IOException</code>, <code>SQLException</code>, <code>ClassNotFoundException</code></td></tr><tr><td><code>RuntimeException</code></td><td>运行时异常的父类，用于未检查异常。</td><td><code>NullPointerException</code>, <code>ArithmeticException</code></td></tr><tr><td><code>IOException</code></td><td>输入输出异常，通常在文件操作、网络通信等中出现。</td><td><code>FileNotFoundException</code>, <code>EOFException</code></td></tr><tr><td><code>SQLException</code></td><td>数据库操作异常。</td><td><code>SQLSyntaxErrorException</code>, <code>SQLTimeoutException</code></td></tr><tr><td><code>NullPointerException</code></td><td>空指针异常，指向对象的引用为空。</td><td><code>String str = null; str.length();</code></td></tr><tr><td><code>ArithmeticException</code></td><td>数学运算异常，通常用于除零等错误。</td><td><code>int x = 1 / 0;</code></td></tr><tr><td><code>ArrayIndexOutOfBoundsException</code></td><td>数组下标越界异常。</td><td><code>int[] arr = new int[3]; int x = arr[5];</code></td></tr></tbody></table><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在 Java 中，内存的分配和回收主要是由 <strong>JVM</strong>（Java 虚拟机）负责的，程序员无需手动释放内存。Java 提供了 <strong>垃圾回收机制</strong>（Garbage Collection，简称 GC），自动处理不再使用的对象的内存释放工作。因此，在 Java 中，开发者不需要像 C&#x2F;C++ 那样显式地调用 <code>free()</code> 或 <code>delete</code> 来释放内存。</p><p>不过，尽管 JVM 自动进行垃圾回收，程序员仍然需要遵循一些编程规范和最佳实践，以避免内存泄漏和过多的垃圾回收，从而影响程序的性能。</p><h3 id="1-自动垃圾回收机制"><a href="#1-自动垃圾回收机制" class="headerlink" title="1. 自动垃圾回收机制"></a>1. <strong>自动垃圾回收机制</strong></h3><p>Java 的垃圾回收机制会在程序运行过程中自动回收不再使用的对象。垃圾回收器通过以下几个步骤来处理内存：</p><ul><li><strong>标记（Marking）</strong>：垃圾回收器会标记所有仍然可以通过程序中的其他对象或变量引用到的对象。</li><li><strong>清除（Sweeping）</strong>：回收器会删除没有被标记的对象，即那些不再被引用的对象，释放其占用的内存。</li><li><strong>压缩（Compact）</strong>：有时，垃圾回收器会整理内存，压缩存活对象的内存，以减少内存碎片。</li></ul><h3 id="2-内存不需要手动释放"><a href="#2-内存不需要手动释放" class="headerlink" title="2. 内存不需要手动释放"></a>2. <strong>内存不需要手动释放</strong></h3><p>Java 中的内存释放完全由垃圾回收器控制，因此程序员不需要显式地释放内存。垃圾回收器会在以下情况下自动回收不再使用的对象：</p><ul><li>对象没有任何活动线程持有对它的引用。</li><li>对象超出了作用域，或者显式地将其设置为 <code>null</code>。</li></ul><p>例如，如果一个对象不再被引用，它就成为垃圾回收器的候选对象，在合适的时间点，垃圾回收器会自动清理这些对象占用的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">java复制代码<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个对象</span><br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <br>        <span class="hljs-comment">// 让 obj 变量不再引用该对象</span><br>        obj = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 这里，obj 就不再引用 MyClass 对象，它将被垃圾回收器标记为可回收</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 一个简单的类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一部分，篇幅较大以后有时间单独了解</p><p><a href="https://blog.csdn.net/Liveor_Die/article/details/77895631">java内存管理（堆、栈、方法区）_java方法进栈内存分配-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/12510425657">Java 内存管理 “通关秘籍”：原理吃透，优化无忧，实战称王 - 知乎</a></p><p><a href="https://javaguide.cn/java/jvm/memory-area.html">Java内存区域详解（重点） | JavaGuide</a></p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>Java 的网络编程功能非常强大，它提供了丰富的 API 用于进行网络通信，支持 TCP、UDP、HTTP 等协议的客户端和服务端编程。Java 的 <code>java.net</code> 包是进行网络编程的核心库，涵盖了从低级别的套接字操作到高层次的 HTTP 请求等功能。</p><h3 id="1-TCP-网络编程"><a href="#1-TCP-网络编程" class="headerlink" title="1. TCP 网络编程"></a>1. <strong>TCP 网络编程</strong></h3><p>Java 中的 TCP 网络编程主要依赖 <code>ServerSocket</code> 和 <code>Socket</code> 类来实现客户端和服务端之间的通信。</p><h4 id="1-TCP-服务端"><a href="#1-TCP-服务端" class="headerlink" title="(1) TCP 服务端"></a>(1) <strong>TCP 服务端</strong></h4><p>服务端通过 <code>ServerSocket</code> 类来监听客户端连接，并通过 <code>accept()</code> 方法接受连接。</p><h5 id="示例：TCP-服务端"><a href="#示例：TCP-服务端" class="headerlink" title="示例：TCP 服务端"></a>示例：TCP 服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建一个ServerSocket监听在端口 8080</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            System.out.println(<span class="hljs-string">&quot;Server is listening on port 8080...&quot;</span>);<br>            <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 等待并接受客户端连接</span><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;Client connected: &quot;</span> + clientSocket.getInetAddress());<br><br>                <span class="hljs-comment">// 创建输入输出流</span><br>                <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(clientSocket.getInputStream()));<br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="hljs-literal">true</span>);<br>                <br>                String message;<br>                <span class="hljs-keyword">while</span> ((message = in.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Received from client: &quot;</span> + message);<br>                    out.println(<span class="hljs-string">&quot;Echo: &quot;</span> + message);  <span class="hljs-comment">// 将接收到的消息回传给客户端</span><br>                &#125;<br><br>                <span class="hljs-comment">// 关闭连接</span><br>                in.close();<br>                out.close();<br>                clientSocket.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>ServerSocket</code> 用于服务端监听某个端口。</li><li><code>accept()</code> 方法阻塞，直到有客户端连接到该端口。</li><li>客户端连接后，创建 <code>BufferedReader</code> 和 <code>PrintWriter</code> 用于数据的读写。</li></ul><h4 id="2-TCP-客户端"><a href="#2-TCP-客户端" class="headerlink" title="(2) TCP 客户端"></a>(2) <strong>TCP 客户端</strong></h4><p>客户端使用 <code>Socket</code> 类与服务端建立连接，之后可以向服务端发送请求，并读取返回的响应。</p><h5 id="示例：TCP-客户端"><a href="#示例：TCP-客户端" class="headerlink" title="示例：TCP 客户端"></a>示例：TCP 客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 连接到服务端（localhost:8080）</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>            System.out.println(<span class="hljs-string">&quot;Connected to server&quot;</span>);<br><br>            <span class="hljs-comment">// 创建输入输出流</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream(), <span class="hljs-literal">true</span>);<br><br>            <span class="hljs-comment">// 发送请求到服务端</span><br>            out.println(<span class="hljs-string">&quot;Hello, Server!&quot;</span>);<br>            <br>            <span class="hljs-comment">// 接收并打印服务端的响应</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> in.readLine();<br>            System.out.println(<span class="hljs-string">&quot;Received from server: &quot;</span> + response);<br><br>            <span class="hljs-comment">// 关闭连接</span><br>            in.close();<br>            out.close();<br>            socket.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Socket</code> 类用于客户端与服务端的连接，指定服务端的 IP 地址和端口号。</li><li><code>PrintWriter</code> 用于向服务端发送数据，<code>BufferedReader</code> 用于读取服务端的响应。</li></ul><h3 id="2-UDP-网络编程"><a href="#2-UDP-网络编程" class="headerlink" title="2. UDP 网络编程"></a>2. <strong>UDP 网络编程</strong></h3><p>UDP 是一种无连接的协议，Java 提供了 <code>DatagramSocket</code> 和 <code>DatagramPacket</code> 类来进行 UDP 通信。</p><h4 id="1-UDP-服务端"><a href="#1-UDP-服务端" class="headerlink" title="(1) UDP 服务端"></a>(1) <strong>UDP 服务端</strong></h4><p>UDP 服务端通过 <code>DatagramSocket</code> 监听指定端口，并通过 <code>DatagramPacket</code> 接收来自客户端的数据。</p><h5 id="示例：UDP-服务端"><a href="#示例：UDP-服务端" class="headerlink" title="示例：UDP 服务端"></a>示例：UDP 服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建一个DatagramSocket，监听端口 8080</span><br>            <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8080</span>);<br>            System.out.println(<span class="hljs-string">&quot;UDP Server is listening on port 8080...&quot;</span>);<br><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br><br>            <span class="hljs-comment">// 接收客户端的数据</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                socket.receive(packet);  <span class="hljs-comment">// 阻塞，直到接收到数据</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(), <span class="hljs-number">0</span>, packet.getLength());<br>                System.out.println(<span class="hljs-string">&quot;Received from client: &quot;</span> + message);<br><br>                <span class="hljs-comment">// 发送响应给客户端</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Echo: &quot;</span> + message;<br>                <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">responsePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(response.getBytes(),<br>                        response.length(), packet.getAddress(), packet.getPort());<br>                socket.send(responsePacket);  <span class="hljs-comment">// 发送响应</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>DatagramSocket</code> 用于接收和发送 UDP 数据包。</li><li><code>DatagramPacket</code> 用于表示数据包，包含数据和目标地址。</li><li><code>socket.receive(packet)</code> 用于接收数据包，<code>socket.send(packet)</code> 用于发送数据包。</li></ul><h4 id="2-UDP-客户端"><a href="#2-UDP-客户端" class="headerlink" title="(2) UDP 客户端"></a>(2) <strong>UDP 客户端</strong></h4><p>UDP 客户端通过 <code>DatagramSocket</code> 发送数据包，并等待服务端的响应。</p><h5 id="示例：UDP-客户端"><a href="#示例：UDP-客户端" class="headerlink" title="示例：UDP 客户端"></a>示例：UDP 客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建DatagramSocket</span><br>            <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br>            <span class="hljs-type">InetAddress</span> <span class="hljs-variable">serverAddress</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>);<br><br>            <span class="hljs-comment">// 发送数据到服务端</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, Server!&quot;</span>;<br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(message.getBytes(), message.length(), serverAddress, <span class="hljs-number">8080</span>);<br>            socket.send(packet);<br>            System.out.println(<span class="hljs-string">&quot;Sent to server: &quot;</span> + message);<br><br>            <span class="hljs-comment">// 接收服务端响应</span><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">responsePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length);<br>            socket.receive(responsePacket);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(responsePacket.getData(), <span class="hljs-number">0</span>, responsePacket.getLength());<br>            System.out.println(<span class="hljs-string">&quot;Received from server: &quot;</span> + response);<br><br>            <span class="hljs-comment">// 关闭Socket</span><br>            socket.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>DatagramSocket</code> 用于客户端发送和接收数据包。</li><li><code>DatagramPacket</code> 用于发送和接收数据包，其中 <code>InetAddress</code> 表示目标地址。</li></ul><h3 id="3-HTTP-网络编程"><a href="#3-HTTP-网络编程" class="headerlink" title="3. HTTP 网络编程"></a>3. <strong>HTTP 网络编程</strong></h3><p>Java 提供了 <code>HttpURLConnection</code> 类来处理 HTTP 请求和响应，也可以使用更高层次的库如 <code>Apache HttpClient</code> 来简化操作。</p><h4 id="1-HTTP-客户端"><a href="#1-HTTP-客户端" class="headerlink" title="(1) HTTP 客户端"></a>(1) <strong>HTTP 客户端</strong></h4><p>使用 <code>HttpURLConnection</code> 发送 HTTP 请求，读取响应。</p><h5 id="示例：HTTP-客户端"><a href="#示例：HTTP-客户端" class="headerlink" title="示例：HTTP 客户端"></a>示例：HTTP 客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTTPClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>);<br>            <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>            connection.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br><br>            <span class="hljs-comment">// 读取服务器返回的响应</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(connection.getInputStream()));<br>            String inputLine;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-keyword">while</span> ((inputLine = in.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                response.append(inputLine);<br>            &#125;<br>            in.close();<br><br>            <span class="hljs-comment">// 打印响应内容</span><br>            System.out.println(<span class="hljs-string">&quot;Response from server: &quot;</span> + response.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>HttpURLConnection</code> 类用于处理 HTTP 请求和响应。</li><li>通过 <code>connection.getInputStream()</code> 获取响应内容，使用 <code>BufferedReader</code> 逐行读取。</li></ul><h4 id="2-HTTP-服务端"><a href="#2-HTTP-服务端" class="headerlink" title="(2) HTTP 服务端"></a>(2) <strong>HTTP 服务端</strong></h4><p>Java 中可以使用 <code>HttpServer</code> 来创建简单的 HTTP 服务端。<code>HttpServer</code> 是 Java 6 引入的，可以用于处理基本的 HTTP 请求。</p><h5 id="示例：HTTP-服务端"><a href="#示例：HTTP-服务端" class="headerlink" title="示例：HTTP 服务端"></a>示例：HTTP 服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.net.httpserver.*;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTTPServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建 HttpServer 实例，监听 8080 端口</span><br>        <span class="hljs-type">HttpServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> HttpServer.create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>), <span class="hljs-number">0</span>);<br>        server.createContext(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(HttpExchange exchange)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>                exchange.sendResponseHeaders(<span class="hljs-number">200</span>, response.getBytes().length);<br>                <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> exchange.getResponseBody();<br>                os.write(response.getBytes());<br>                os.close();<br>            &#125;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;HTTP Server is listening on port 8080...&quot;</span>);<br>        server.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>HttpServer.create</code> 创建一个 HTTP 服务端。</li><li><code>createContext</code> 用于注册 URL 路径及对应的处理器。</li><li>通过 <code>exchange.sendResponseHeaders</code> 发送响应头，通过 <code>exchange.getResponseBody()</code> 获取输出流写入响应数据。</li></ul><h1 id="文件流处理"><a href="#文件流处理" class="headerlink" title="文件流处理"></a>文件流处理</h1><p>Java 的文件流处理主要通过 <code>java.io</code> 包中的类来实现文件的读写操作。Java 支持多种文件操作方式，包括字节流和字符流，文件的输入输出流（I&#x2F;O）在实际编程中应用广泛。下面将介绍 Java 中常用的文件流操作。</p><h3 id="1-字节流与字符流"><a href="#1-字节流与字符流" class="headerlink" title="1. 字节流与字符流"></a>1. <strong>字节流与字符流</strong></h3><ul><li><strong>字节流</strong>：处理所有类型的 I&#x2F;O，包括图像、音频、视频等二进制文件。通过 <code>InputStream</code> 和 <code>OutputStream</code> 类及其子类来实现。</li><li><strong>字符流</strong>：专门处理字符数据，适合读取文本文件。字符流使用 <code>Reader</code> 和 <code>Writer</code> 类及其子类。</li></ul><h3 id="2-字节流操作"><a href="#2-字节流操作" class="headerlink" title="2. 字节流操作"></a>2. <strong>字节流操作</strong></h3><h4 id="1-字节输入流"><a href="#1-字节输入流" class="headerlink" title="(1) 字节输入流"></a>(1) <strong>字节输入流</strong></h4><p>字节输入流用于读取文件中的字节数据，<code>FileInputStream</code> 是字节输入流的常用类。</p><h5 id="示例：读取文件的字节内容"><a href="#示例：读取文件的字节内容" class="headerlink" title="示例：读取文件的字节内容"></a>示例：读取文件的字节内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;example.txt&quot;</span>);<br><br>            <span class="hljs-type">int</span> byteData;<br>            <span class="hljs-keyword">while</span> ((byteData = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) byteData);  <span class="hljs-comment">// 将字节数据转换为字符并打印</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fis != <span class="hljs-literal">null</span>) &#123;<br>                    fis.close();  <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>FileInputStream</code> 用于从文件中读取字节数据。</li><li><code>fis.read()</code> 读取一个字节的数据，直到文件结束返回 <code>-1</code>。</li></ul><h4 id="2-字节输出流"><a href="#2-字节输出流" class="headerlink" title="(2) 字节输出流"></a>(2) <strong>字节输出流</strong></h4><p>字节输出流用于向文件写入字节数据，<code>FileOutputStream</code> 是字节输出流的常用类。</p><h5 id="示例：向文件写入字节内容"><a href="#示例：向文件写入字节内容" class="headerlink" title="示例：向文件写入字节内容"></a>示例：向文件写入字节内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>            fos.write(content.getBytes());  <span class="hljs-comment">// 将字符串转换为字节数组并写入文件</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fos != <span class="hljs-literal">null</span>) &#123;<br>                    fos.close();  <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>FileOutputStream</code> 用于向文件写入字节数据。</li><li><code>fos.write()</code> 将字节数据写入文件中。</li></ul><h3 id="3-字符流操作"><a href="#3-字符流操作" class="headerlink" title="3. 字符流操作"></a>3. <strong>字符流操作</strong></h3><p>字符流处理字符数据，适合读取和写入文本文件。字符流的基类是 <code>Reader</code> 和 <code>Writer</code>。</p><h4 id="1-字符输入流"><a href="#1-字符输入流" class="headerlink" title="(1) 字符输入流"></a>(1) <strong>字符输入流</strong></h4><p>字符输入流用于读取文件中的字符数据，<code>FileReader</code> 是字符输入流的常用类。</p><h5 id="示例：读取文件的字符内容"><a href="#示例：读取文件的字符内容" class="headerlink" title="示例：读取文件的字符内容"></a>示例：读取文件的字符内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;example.txt&quot;</span>);<br><br>            <span class="hljs-type">int</span> charData;<br>            <span class="hljs-keyword">while</span> ((charData = fr.read()) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.print((<span class="hljs-type">char</span>) charData);  <span class="hljs-comment">// 打印字符数据</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fr != <span class="hljs-literal">null</span>) &#123;<br>                    fr.close();  <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>FileReader</code> 用于读取字符数据。</li><li><code>fr.read()</code> 读取一个字符数据，直到文件结束返回 <code>-1</code>。</li></ul><h4 id="2-字符输出流"><a href="#2-字符输出流" class="headerlink" title="(2) 字符输出流"></a>(2) <strong>字符输出流</strong></h4><p>字符输出流用于向文件写入字符数据，<code>FileWriter</code> 是字符输出流的常用类。</p><h5 id="示例：向文件写入字符内容"><a href="#示例：向文件写入字符内容" class="headerlink" title="示例：向文件写入字符内容"></a>示例：向文件写入字符内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>            fw.write(content);  <span class="hljs-comment">// 将字符串写入文件</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (fw != <span class="hljs-literal">null</span>) &#123;<br>                    fw.close();  <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>FileWriter</code> 用于写入字符数据。</li><li><code>fw.write()</code> 将字符数据写入文件中。</li></ul><h3 id="4-缓冲流操作"><a href="#4-缓冲流操作" class="headerlink" title="4. 缓冲流操作"></a>4. <strong>缓冲流操作</strong></h3><p>缓冲流提供了一个缓冲区来提高文件读写的效率。常见的缓冲流类有 <code>BufferedReader</code> 和 <code>BufferedWriter</code>，它们通常与字符流结合使用。</p><h4 id="1-缓冲字符输入流"><a href="#1-缓冲字符输入流" class="headerlink" title="(1) 缓冲字符输入流"></a>(1) <strong>缓冲字符输入流</strong></h4><p><code>BufferedReader</code> 用于缓冲读取字符数据，可以高效地按行读取文本文件。</p><h5 id="示例：使用-BufferedReader-按行读取文件"><a href="#示例：使用-BufferedReader-按行读取文件" class="headerlink" title="示例：使用 BufferedReader 按行读取文件"></a>示例：使用 <code>BufferedReader</code> 按行读取文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReaderExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;example.txt&quot;</span>));<br><br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(line);  <span class="hljs-comment">// 打印每一行</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;<br>                    br.close();  <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>BufferedReader</code> 使用缓冲区按行读取文件。</li><li><code>br.readLine()</code> 读取一行文本，直到文件末尾返回 <code>null</code>。</li></ul><h4 id="2-缓冲字符输出流"><a href="#2-缓冲字符输出流" class="headerlink" title="(2) 缓冲字符输出流"></a>(2) <strong>缓冲字符输出流</strong></h4><p><code>BufferedWriter</code> 用于缓冲写入字符数据，可以高效地按行写入文本文件。</p><h5 id="示例：使用-BufferedWriter-按行写入文件"><a href="#示例：使用-BufferedWriter-按行写入文件" class="headerlink" title="示例：使用 BufferedWriter 按行写入文件"></a>示例：使用 <code>BufferedWriter</code> 按行写入文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedWriterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>));<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>            bw.write(content);  <span class="hljs-comment">// 写入字符内容</span><br>            bw.newLine();  <span class="hljs-comment">// 添加换行</span><br>            bw.write(<span class="hljs-string">&quot;Second Line&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (bw != <span class="hljs-literal">null</span>) &#123;<br>                    bw.close();  <span class="hljs-comment">// 关闭流</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>BufferedWriter</code> 提供高效的字符写入操作。</li><li><code>bw.newLine()</code> 用于写入换行符。</li></ul><h3 id="5-复制文件"><a href="#5-复制文件" class="headerlink" title="5. 复制文件"></a>5. <strong>复制文件</strong></h3><p>通过字节流或字符流可以实现文件复制。通常使用缓冲流来提高效率。</p><h4 id="示例：使用字节流复制文件"><a href="#示例：使用字节流复制文件" class="headerlink" title="示例：使用字节流复制文件"></a>示例：使用字节流复制文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;source.txt&quot;</span>);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;destination.txt&quot;</span>)) &#123;<br><br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> bytesRead;<br>            <span class="hljs-keyword">while</span> ((bytesRead = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                fos.write(buffer, <span class="hljs-number">0</span>, bytesRead);<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;File copied successfully!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例：使用字符流复制文件"><a href="#示例：使用字符流复制文件" class="headerlink" title="示例：使用字符流复制文件"></a>示例：使用字符流复制文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopyWithCharsExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;source.txt&quot;</span>);<br>             <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;destination.txt&quot;</span>)) &#123;<br><br>            <span class="hljs-type">int</span> charRead;<br>            <span class="hljs-keyword">while</span> ((charRead = fr.read()) != -<span class="hljs-number">1</span>) &#123;<br>                fw.write(charRead);<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;File copied successfully!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket网络编程</title>
    <link href="/2022/09/15/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/09/15/socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>非转载抄袭，早年知乎文章搬运于此</p></blockquote><h2 id="socket网络编程（服务器-客户端）步骤："><a href="#socket网络编程（服务器-客户端）步骤：" class="headerlink" title="socket网络编程（服务器-客户端）步骤："></a>socket网络编程（服务器-客户端）步骤：</h2><p><img src="https://picx.zhimg.com/v2-4b82afb967276c528c052b4be434061d_720w.jpg?source=d16d100b" alt="img"></p><p><img src="https://picx.zhimg.com/v2-d8ece2f84fdb67371d7d30fc4b7810da_720w.jpg?source=d16d100b" alt="img"></p><p>关于socket套接字请参考：<a href="https://zhuanlan.zhihu.com/p/646873436">计算机菜鸟一枚：计算机网络知识点总结（一）应用层</a></p><h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><p>必须要有的头文件和库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br></code></pre></td></tr></table></figure><h3 id="1-socket函数"><a href="#1-socket函数" class="headerlink" title="1.socket函数"></a>1.socket函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SOCKET <span class="hljs-title">socket</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> af,<span class="hljs-comment">//地址类型，常用IPv4地址：AF_INET，和IPv6地址：AF_INET6</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> type, <span class="hljs-comment">//套接字类型，常用TCP协议：SOCK_STREAM,UDP协议：SOCK_DGRAM</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> protocol <span class="hljs-comment">//协议类型，一般填0，自动选择即可</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-comment">//返回值，INVALID_SOCKET失败，该宏实则定义为-1，否则成功</span><br></code></pre></td></tr></table></figure><p>函数使用：</p><p>本教程使用 IPv4 地址，参数 af 的值为 PF_INET。如果使用 SOCK_STREAM 传输数据，那么满足这两个条件的协议只有 TCP，因此可以这样来调用 socket() 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tcp_socket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);  <span class="hljs-comment">//IPPROTO_TCP表示TCP协议</span><br></code></pre></td></tr></table></figure><h3 id="2-bind函数"><a href="#2-bind函数" class="headerlink" title="2.bind函数"></a>2.bind函数</h3><p>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">SOCKET s, <span class="hljs-comment">//创建的socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">sockaddr * name, <span class="hljs-comment">//包含地址和端口的结构体</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> namelen <span class="hljs-comment">//sockaddr 结构长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>函数使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS <span class="hljs-comment">//vs环境下必须定义，否则无法使用inet_addr函数</span></span><br>sockaddr_in addr;<br>addr.sin_family = AF_INET; <span class="hljs-comment">//地址为IPv4协议</span><br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>); <span class="hljs-comment">//端口为9999</span><br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>); <span class="hljs-comment">//具体绑定本机的地址</span><br>ret=<span class="hljs-built_in">bind</span>(sock,(sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr)); <span class="hljs-comment">//绑定</span><br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;绑定地址端口失败&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 sockaddr_in 结构体，然后再强制转换为 sockaddr 类型，后边会讲解为什么这样做。</p><p>补充：</p><p>sockaddr_in 结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>&#123;<br>    <span class="hljs-type">sa_family_t</span>     sin_family;   <span class="hljs-comment">//地址族（Address Family），也就是地址类型</span><br>    <span class="hljs-type">uint16_t</span>        sin_port;     <span class="hljs-comment">//16位的端口号</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>  sin_addr;     <span class="hljs-comment">//32位IP地址</span><br>    <span class="hljs-type">char</span>            sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">//不使用，一般用0填充</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>sin_family 和 socket() 的第一个参数的含义相同，取值也要保持一致。</p><p>sin_prot 为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 0<del>65536，但 0</del>1023 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。</p><p>in_addr 结构体：</p><p>sockaddr_in 的第3个成员是 in_addr 类型的结构体，该结构体只包含一个成员，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>&#123;<br>    <span class="hljs-type">in_addr_t</span>  s_addr;  <span class="hljs-comment">//32位的IP地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>in_addr_t 在头文件 &lt;netinet&#x2F;in.h&gt; 中定义，等价于 unsigned long，长度为4个字节。也就是说，s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换</p><p>此处详细请参考：<a href="http://link.zhihu.com/?target=https://blog.csdn.net/qq_41854911/article/details/121448143%23t7">【C&#x2F;C++服务器开发】socket网络编程函数接口详解_socket接口_小熊coder的博客-CSDN博客</a></p><h3 id="3-listen函数"><a href="#3-listen函数" class="headerlink" title="3.listen函数"></a>3.listen函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">SOCKET s, <span class="hljs-comment">//要监听的socket</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> backlog <span class="hljs-comment">//等待连接的最大队列长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-comment">//返回值：返回SOCKET_ERROR失败，该宏被定义为-1，否则成功，返回值为0</span><br></code></pre></td></tr></table></figure><p>函数使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sock, <span class="hljs-type">int</span> backlog)</span></span>;  <span class="hljs-comment">//Linux</span><br></code></pre></td></tr></table></figure><h3 id="4-accept函数"><a href="#4-accept函数" class="headerlink" title="4.accept函数"></a>4.accept函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SOCKET <span class="hljs-title">accept</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">SOCKET s, <span class="hljs-comment">//接收的socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">sockaddr* addr, <span class="hljs-comment">//接收到客户端的地址信息</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> * addrlen <span class="hljs-comment">//地址信息长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-comment">//返回值：返回INVALID_SOCKET失败，该宏定义为-1，否则成功返回客户端的套接字，可进行发送和接收消息</span><br></code></pre></td></tr></table></figure><p>函数使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">sockaddr addrCli;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(addrCli);<br>SOCKET sockCli=<span class="hljs-built_in">accept</span>(sock,&amp;addrCli,&amp;len);<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>1，accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。<br>2，listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</p></blockquote><h3 id="5-send函数"><a href="#5-send函数" class="headerlink" title="5.send函数"></a>5.send函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">SOCKET s,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">char</span> * buf,<span class="hljs-comment">//要发送的内容</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> len, <span class="hljs-comment">//内容长度</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> flags <span class="hljs-comment">//一般为0，拷贝到程序中就立即删除内核中的数据,或MSG_DONTROUTE:要求传输层不要将数据路由出去，MSG_OOB：标志数据应该被带外发送</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-comment">//返回值：-1（或宏SOCKET_ERROR）表示发送失败，否则返回发送成功的字节数</span><br></code></pre></td></tr></table></figure><p>函数使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buf[<span class="hljs-number">0xFF</span>] = <span class="hljs-string">&quot;我是服务器&quot;</span>;<br>ret=<span class="hljs-built_in">send</span>(sockCli, buf, <span class="hljs-built_in">strlen</span>(buf),<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="6-recv函数"><a href="#6-recv函数" class="headerlink" title="6.recv函数"></a>6.recv函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recv</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">SOCKET s, <span class="hljs-comment">//套接字</span></span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">char</span> * buf, <span class="hljs-comment">//接受数据的缓存区</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> len, <span class="hljs-comment">//缓存区大小</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> flags <span class="hljs-comment">//标志，一般填0，将消息拷贝到应用程序中，将内核中的数据删除，还可以填MSG_PEEK,只取数据，不从内核中删除数据，MSG_OOB：处理带外数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-comment">//返回值：小于等于0都表示出错，大于0则表示接收成功的数据大小</span><br></code></pre></td></tr></table></figure><p>函数使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ret=<span class="hljs-built_in">recv</span>(sockCli,buf,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="7-connect函数"><a href="#7-connect函数" class="headerlink" title="7.connect函数"></a>7.connect函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">SOCKET s, <span class="hljs-comment">//与服务器连接的socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">sockaddr* name, <span class="hljs-comment">//服务器的地址端口</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> namelen <span class="hljs-comment">//上个参数结构体的长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-comment">//返回值：-1失败，否则成功</span><br></code></pre></td></tr></table></figure><p>函数使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">sockaddr_in addr;<br>addr.sin_family = AF_INET;<br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>);<br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">connect</span>(sock, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br></code></pre></td></tr></table></figure><h3 id="8-write函数"><a href="#8-write函数" class="headerlink" title="8.write函数"></a>8.write函数</h3><blockquote><p>使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。</p></blockquote><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="9-read函数"><a href="#9-read函数" class="headerlink" title="9.read函数"></a>9.read函数</h3><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> nbytes)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="10-closesocket函数"><a href="#10-closesocket函数" class="headerlink" title="10.closesocket函数"></a>10.closesocket函数</h3><blockquote><p>该函数就是关闭不用的socket，释放资源</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closesocket</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">SOCKET s <span class="hljs-comment">//要关闭的socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="11-WSACleanup函数"><a href="#11-WSACleanup函数" class="headerlink" title="11.WSACleanup函数"></a>11.WSACleanup函数</h3><blockquote><p>无任何参数，直接调用即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">WSACleanup</span>();<br></code></pre></td></tr></table></figure><h3 id="12-其他"><a href="#12-其他" class="headerlink" title="12.其他"></a>12.其他</h3><ul><li>inet_addr:负责将我们平时看到的网络地址127.0.0.1等转化为网络字节序</li><li>inet_ntoa：负责将网络字节序还原为我们平时看到的字符串127.0.0.1等</li></ul><p>这种函数名有固定的意义：</p><ul><li>h:home</li><li>n:network</li><li>s:short</li><li>l:long</li></ul><p>htons：意思就是本机字节序转到网络字节序，short类型的长度</p><p>ntohs：意思就是网络字节序转到本机字节序，short类型的长度</p><hr><h2 id="1-单线程网络编程"><a href="#1-单线程网络编程" class="headerlink" title="1.单线程网络编程"></a>1.单线程网络编程</h2><h3 id="1-1，服务器开发"><a href="#1-1，服务器开发" class="headerlink" title="1.1，服务器开发"></a>1.1，服务器开发</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>WSADATA data;<br><span class="hljs-type">int</span> ret=<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),&amp;data);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;初始化网络错误！&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>SOCKET sock=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (sock == <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建套接字失败&quot;</span>;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>sockaddr_in addr;<br>addr.sin_family = AF_INET;<br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>);<br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>ret=<span class="hljs-built_in">bind</span>(sock,(sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;绑定地址端口失败&quot;</span>;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>ret=<span class="hljs-built_in">listen</span>(sock,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;监听套接字失败&quot;</span>;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>sockaddr addrCli;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(addrCli);<br>SOCKET sockCli=<span class="hljs-built_in">accept</span>(sock,&amp;addrCli,&amp;len);<br><span class="hljs-keyword">if</span> (sockCli == <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;接收客户端连接失败&quot;</span>;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">0xFF</span>] = <span class="hljs-string">&quot;我是服务器&quot;</span>;<br>ret=<span class="hljs-built_in">send</span>(sockCli, buf, <span class="hljs-built_in">strlen</span>(buf)+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;发送信息失败&quot;</span>;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>ret=<span class="hljs-built_in">recv</span>(sockCli,buf,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;接受客户端数据失败&quot;</span>;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">WSACleanup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2，客户端开发"><a href="#1-2，客户端开发" class="headerlink" title="1.2，客户端开发"></a>1.2，客户端开发</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>WSADATA data;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;data);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;初始化网络错误！&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>SOCKET sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>sockaddr_in addr;<br>addr.sin_family = AF_INET;<br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>);<br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">connect</span>(sock, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">WSACleanup</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;连接服务器失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">0xFF</span>];<br>ret=<span class="hljs-built_in">recv</span>(sock,buf,<span class="hljs-built_in">sizeof</span>(buf),<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">WSACleanup</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;接收服务器数据失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;服务器：&quot;</span> &lt;&lt; buf &lt;&lt; endl;<br><br>ret=<span class="hljs-built_in">send</span>(sock,buf,ret,<span class="hljs-number">0</span>); <span class="hljs-comment">//将接收到的数据发回服务器</span><br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">WSACleanup</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;发送服务器数据失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">WSACleanup</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="2，多线程网络编程"><a href="#2，多线程网络编程" class="headerlink" title="2，多线程网络编程"></a>2，多线程网络编程</h2><p>如果想要实现多人通信就必须依赖多线程的方式来解决</p><h3 id="2-1服务器开发"><a href="#2-1服务器开发" class="headerlink" title="2.1服务器开发"></a>2.1服务器开发</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Winsock2.h&gt;</span><span class="hljs-comment">//socket头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>);<span class="hljs-comment">//socket库</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> WAIT_TIME=<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> buffer_size=<span class="hljs-number">1024</span>;<span class="hljs-comment">//缓冲区的大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> max_link_num=<span class="hljs-number">10</span>;<span class="hljs-comment">//最大客户端链接数量</span><br>SOCKET clinsock[max_link_num];<span class="hljs-comment">//客户端套接字为0的是服务器</span><br>WSAEVENT clinevent[max_link_num];<span class="hljs-comment">//客户端事件 0号为服务端,它用于让程序的一部分等待来自另一部分的信号</span><br>SOCKADDR_IN clinaddr[max_link_num];<span class="hljs-comment">//客户端地址</span><br><span class="hljs-type">int</span> total;<span class="hljs-comment">//目前链接的总数</span><br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">servEventThread</span><span class="hljs-params">(LPVOID IpParameter)</span></span>;<span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化socket库</span><br>    WSADATA data;<span class="hljs-comment">//获取版本信息</span><br>    <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),&amp;data);<span class="hljs-comment">//MAKEWORD（主版本，副版本）</span><br><br>    <span class="hljs-comment">//创建socket（）</span><br>    SOCKET servsock=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<span class="hljs-comment">//面对网络的流式套接字-&gt;AF_INET：IP地址族，用IP协议版本4。SOCK_STREAM：面对连接的流式套接字。0：使用的默认协议</span><br><br>    <span class="hljs-comment">//将服务器地址打包进一个结构体中</span><br>    sockaddr_in servaddr;<span class="hljs-comment">//sockaddr_in （sockaddr）是internat下套接字的地址形式</span><br>    servaddr.sin_family=AF_INET;<span class="hljs-comment">//sin_family为协议簇ipv4</span><br>    servaddr.sin_addr.S_un.S_addr=<span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<span class="hljs-comment">//服务端地址设置为本地回环地址,将IP地址转化为32位网络字节</span><br>    servaddr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-number">12345</span>);<span class="hljs-comment">//s设置端口号,htons：意思就是本机字节序转到网络字节序，short类型的长度</span><br><br>    <span class="hljs-comment">//绑定服务端的socket和打包好的地址</span><br>    <span class="hljs-built_in">bind</span>(servsock,(SOCKADDR*)&amp;servaddr,<span class="hljs-built_in">sizeof</span>(servaddr));<br><br>    <span class="hljs-comment">//给客户端绑定一个事件对象，用来接收客户端发来的链接</span><br>    WSAEVENT servEvent=<span class="hljs-built_in">WSACreateEvent</span>();<br>    <span class="hljs-built_in">WSAEventSelect</span>(servsock,servEvent,FD_ALL_EVENTS);<br>    <br>    clinsock[<span class="hljs-number">0</span>]=servsock;<br>    clinevent[<span class="hljs-number">0</span>]=servEvent;<br><br>    <span class="hljs-comment">//开启监听</span><br>    <span class="hljs-built_in">listen</span>(servsock,<span class="hljs-number">10</span>);<span class="hljs-comment">//等待连接的最大队列长度</span><br><br><br>    <span class="hljs-built_in">CloseHandle</span>(<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, servEventThread, (LPVOID)&amp;servsock, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">//创建一个线程，并将该线程的句柄存储在一个句柄变量中。这个线程将执行`servEventThread`函数，并且将`servsock`作为参数传递给该函数。`CreateThread`函数的返回值是线程的句柄，通过`CloseHandle`函数来关闭这个句柄，以释放资源</span><br><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;start communiate&quot;</span> &lt;&lt; endl;<br>connect;<br>    <br>    <span class="hljs-comment">//（用于读取用户输入的内容，并将其发送给所有已连接的套接字，实现了消息的广播功能）</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123; <br>        <span class="hljs-comment">//声明了两个字符数组变量contentbuf和sendbuf，用于存储用户输入的内容和发送给套接字的消息。</span><br>        <span class="hljs-type">char</span> contentbuf[buffer_size]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">char</span> sendbuf[buffer_size]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//使用cin.getline()函数读取用户输入的内容，并将其存储在contentbuf数组中。</span><br>        cin.<span class="hljs-built_in">getline</span>(contentbuf,<span class="hljs-built_in">sizeof</span>(contentbuf));<br>        <span class="hljs-comment">//使用sprintf()函数将用户输入的内容加上前缀&quot;[智能小易]&quot;，并将结果存储在sendbuf数组中。</span><br>        <span class="hljs-built_in">sprintf</span>(sendbuf,<span class="hljs-string">&quot;[AI]%s&quot;</span>, contentbuf);<br>        <span class="hljs-comment">//使用for循环遍历所有已连接的套接字，使用send()函数将sendbuf数组中的内容发送给每个套接字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=total;j++)<br>        &#123;<br>            <span class="hljs-built_in">send</span>(clinsock[j],sendbuf,<span class="hljs-built_in">sizeof</span>(sendbuf),<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">servEventThread</span><span class="hljs-params">(LPVOID IpParameter)</span></span><br><span class="hljs-function"></span>&#123;<br>    SOCKET servsock=*(SOCKET*)IpParameter;<span class="hljs-comment">//LPVOID为空指针类型，需要先转成SOCKET类型再引用，即可使用传入的SOCKET</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;total+<span class="hljs-number">1</span>;i++)<br>        &#123;<br>            <span class="hljs-comment">//若有一个客户端链接，total==1，循环两次，包含客户端和服务端</span><br><span class="hljs-comment">//对每一个终端（客户端和服务端），查看是否发生事件，等待WAIT_TIME毫秒</span><br>            <span class="hljs-type">int</span> index=<span class="hljs-built_in">WSAWaitForMultipleEvents</span>(<span class="hljs-number">1</span>,&amp;clinevent[i],<span class="hljs-literal">false</span>,WAIT_TIME,<span class="hljs-number">0</span>);<span class="hljs-comment">//返回事件发生的索引</span><br>            index-=WSA_WAIT_EVENT_0;<span class="hljs-comment">//此时index为发生事件的终端下标</span><br>            <span class="hljs-comment">//如果出错或者超时，即跳过此终端</span><br>            <span class="hljs-keyword">if</span>(index==WSA_WAIT_TIMEOUT||index==WSA_WAIT_FAILED)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//1，没有事件发生，执行以下操作：</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">//1，可以获取特定套接字cliSock[i]上发生的网络事件，并将其存储在networkEvents结构体变量中。</span><br>                WSANETWORKEVENTS networkEvents;<span class="hljs-comment">//声明一个名为networkEvents的WSANETWORKEVENTS结构体变量</span><br>                <span class="hljs-built_in">WSAEnumNetworkEvents</span>(clinsock[i],clinevent[i],&amp;networkEvents);<span class="hljs-comment">//调用WSAEnumNetworkEvents函数，用于获取与指定套接字相关联的网络事件</span><br>                <br>                <span class="hljs-comment">//如果网络事件中包含FD_ACCEPT（表示有新的连接请求），则执行以下操作</span><br>                <span class="hljs-keyword">if</span>(networkEvents.lNetworkEvents &amp; FD_ACCEPT)<span class="hljs-comment">//`lNetworkEvents` 字段存储了发生的网络事件的掩码</span><br>                &#123;<br>                    <span class="hljs-comment">//检查FD_ACCEPT_BIT对应的错误码，如果不为0，则输出连接出现错误的信息，并继续下一次循环。</span><br>                    <span class="hljs-keyword">if</span>(networkEvents.iErrorCode[FD_ACCEPT_BIT]!=<span class="hljs-number">0</span>)<span class="hljs-comment">//</span><br>                    &#123;<br>                        cout&lt;&lt;<span class="hljs-string">&quot;error connect&quot;</span>&lt;&lt;networkEvents.iErrorCode[FD_ACCEPT_BIT]&lt;&lt;endl;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//如果当前连接数（total）加1小于最大连接数（max_link_num），则执行以下操作：</span><br>                    <span class="hljs-keyword">if</span>(total+<span class="hljs-number">1</span>&lt;max_link_num)<br>                    &#123;<br>                        <span class="hljs-comment">//获取新连接的地址长度（addrlen），并使用accept函数接受新的连接请求，返回一个新的套接字（newsock）</span><br>                        <span class="hljs-type">int</span> nextindex=total+<span class="hljs-number">1</span>;<br>                        <span class="hljs-type">int</span> addrlen=<span class="hljs-built_in">sizeof</span>(SOCKADDR);<br>                        SOCKET newsock=<span class="hljs-built_in">accept</span>(servsock,(SOCKADDR*)&amp;clinaddr[nextindex],&amp;addrlen);<br><br>                        <span class="hljs-comment">// 如果新的套接字不是无效套接字（INVALID_SOCKET），则执行以下操作：</span><br>                        <span class="hljs-keyword">if</span>(newsock!=INVALID_SOCKET)<br>                        &#123;<br>                            <span class="hljs-comment">//将新的套接字（newsock）保存到clinsock数组中的下一个位置（nextindex）</span><br>                            clinsock[nextindex]=newsock;<br>                            <span class="hljs-comment">//创建一个新的事件（newevent）并将新的套接字（newsock）与该事件关联，监听FD_CLOSE、FD_READ和FD_WRITE事件</span><br>                            WSAEVENT newevent=<span class="hljs-built_in">WSACreateEvent</span>();<br>                            <span class="hljs-built_in">WSAEventSelect</span>(clinsock[nextindex],newevent,FD_CLOSE | FD_READ | FD_WRITE);<br>                            <span class="hljs-comment">//将新的事件（newevent）保存到clinevent数组中的下一个位置（nextindex）</span><br>                            clinevent[nextindex] = newevent;<br>                            <span class="hljs-comment">//连接数加一</span><br>total++;<br><br>                            <span class="hljs-comment">// 构造一个欢迎消息（buf），包含游客的IP地址，并发送给所有已连接的套接字。</span><br>                            <span class="hljs-type">char</span> buf[buffer_size] = <span class="hljs-string">&quot;[AI]welcome IP:&quot;</span>;<br><span class="hljs-built_in">strcat</span>(buf, <span class="hljs-built_in">inet_ntoa</span>(clinaddr[nextindex].sin_addr));<br><span class="hljs-built_in">strcat</span>(buf, <span class="hljs-string">&quot;)had came&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;=total; j++)<br>&#123;<br><br><span class="hljs-built_in">send</span>(clinsock[j], buf, <span class="hljs-built_in">sizeof</span>(buf),<span class="hljs-number">0</span>);<br><br>&#125;<br>                        &#125;<br>                   &#125;<br>                &#125; <br>            <br>             <span class="hljs-comment">//如果网络事件中包含FD_CLOSE（表示有连接关闭），则执行以下操作：</span><br>             <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(networkEvents.lNetworkEvents &amp; FD_CLOSE)<br>             &#123;<br>                <span class="hljs-comment">//减少当前连接数（total）的值。</span><br>                total--;<br>                cout&lt;&lt;<span class="hljs-string">&quot;#&quot;</span>&lt;&lt;i&lt;&lt;endl;<br><br>                <span class="hljs-comment">//关闭对应的套接字（clinsock[i]）</span><br>                <span class="hljs-built_in">closesocket</span>(clinsock[i]);<br>                <span class="hljs-comment">//关闭对应的事件（clinevent[i]）。</span><br>                <span class="hljs-built_in">WSACloseEvent</span>(clinevent[i]);<br>                <br>                <span class="hljs-comment">//将后面的连接信息（clinsock、clinevent和clinaddr数组）向前移动一个位置，覆盖掉被关闭的连接信息。</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;total;j++)<br>                &#123;<br>                    clinsock[j]=clinsock[j+<span class="hljs-number">1</span>];<br>                    clinevent[j]=clinevent[j+<span class="hljs-number">1</span>];<br>                    clinaddr[j]=clinaddr[j+<span class="hljs-number">1</span>];<br>                &#125;<br>                <br>                <span class="hljs-comment">//构造一个退出消息（buf），包含退出的IP地址，并发送给所有已连接的套接字</span><br>                <span class="hljs-type">char</span> buf[buffer_size]=<span class="hljs-string">&quot;[AI](IP:&quot;</span>;<br>                <span class="hljs-built_in">strcat</span>(buf,<span class="hljs-built_in">inet_ntoa</span>(clinaddr[i].sin_addr));<br>                <span class="hljs-built_in">strcat</span>(buf, <span class="hljs-string">&quot;)quit&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;=total; j++)<br>&#123;<br><span class="hljs-built_in">send</span>(clinsock[j], buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-number">0</span>);<br> <br>&#125;<br><br>             &#125;<br>          <br>             <span class="hljs-comment">//如果网络事件中包含FD_READ（表示有数据可读取），则执行以下操作：</span><br>             <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(networkEvents.lNetworkEvents &amp; FD_READ)<br>             &#123;<br>                <span class="hljs-comment">//创建一个缓冲区（buffer）和一个用于存储格式化后消息的缓冲区（buffer1）。</span><br>                <span class="hljs-type">char</span> buffer[buffer_size]=&#123;<span class="hljs-number">0</span>&#125;;<br>                <span class="hljs-type">char</span> buffer1[buffer_size]=&#123;<span class="hljs-number">0</span>&#125;;<br>                <br>                <span class="hljs-comment">//遍历所有已连接的套接字（从1到total）</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=total;i++)<br>                &#123;<br>                    <span class="hljs-comment">//使用recv函数接收套接字中的数据，并返回接收到的字节数（nrecv）</span><br>                    <span class="hljs-type">int</span> nrecv=<span class="hljs-built_in">recv</span>(clinsock[i],buffer,<span class="hljs-built_in">sizeof</span>(buffer),<span class="hljs-number">0</span>);<br>                    <span class="hljs-comment">//如果接收到的字节数大于0，则执行以下操作：</span><br>                    <span class="hljs-keyword">if</span>(nrecv&gt;<span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-comment">//将接收到的数据格式化为带有连接索引号的消息（buffer1）</span><br>                        <span class="hljs-built_in">sprintf</span>(buffer1,<span class="hljs-string">&quot;[#%d]%s&quot;</span>,i,buffer);<br>                        <span class="hljs-comment">//输出格式化后的消息（buffer1）</span><br>                        cout&lt;&lt;buffer1&lt;&lt;endl;<br>                        <span class="hljs-comment">//遍历所有已连接的套接字，并将格式化后的消息发送给每个套接字。</span><br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;total;k++)<br>                        &#123;<br>                            <span class="hljs-built_in">send</span>(clinsock[k],buffer1,<span class="hljs-built_in">sizeof</span>(buffer1),<span class="hljs-number">0</span>);<br>                        &#125;<br><br>                     &#125;<br><br>                 &#125;<br>              &#125;<br>            &#125;<br>        &#125; <br>    &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>   <br></code></pre></td></tr></table></figure><h3 id="2-2客户端开发"><a href="#2-2客户端开发" class="headerlink" title="2.2客户端开发"></a>2.2客户端开发</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUFFER_SIZE = <span class="hljs-number">1024</span>;<span class="hljs-comment">//缓冲区大小</span><br> <br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">recvMsgThread</span><span class="hljs-params">(LPVOID IpParameter)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    WSADATA data;<br>    <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),&amp;data);<br><br>    SOCKET clinsock=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br>   <br>    sockaddr_in clinaddr;<br>    clinaddr.sin_family=AF_INET;<br>    clinaddr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    clinaddr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-number">12345</span>);<br>    <span class="hljs-comment">//设置服务器的地址和端口信息，将其存储在sockaddr_in结构体对象中</span><br>    sockaddr_in sockaddr;<br>    sockaddr.sin_family=AF_INET;<br>    sockaddr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    sockaddr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-number">12345</span>);<br><br>    <span class="hljs-comment">//调用connect函数来连接到服务器。如果连接出现错误，会输出错误代码</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(clinsock,(SOCKADDR*)&amp;sockaddr,<span class="hljs-built_in">sizeof</span>(SOCKADDR))==SOCKET_ERROR)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">//创建一个线程来接收服务器发送的消息。线程函数是recvMsgThread，它通过参数传递了客户端套接字</span><br>    <span class="hljs-built_in">CloseHandle</span>(<span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, recvMsgThread, (LPVOID)&amp;clinsock, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">//通过循环读取用户输入的消息，并发送给服务器。如果用户输入&quot;quit&quot;，则退出聊天室。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <br>&#123;<br><span class="hljs-type">char</span> buf[BUFFER_SIZE] = &#123; <span class="hljs-number">0</span> &#125;;<br>cin.<span class="hljs-built_in">getline</span>(buf,<span class="hljs-built_in">sizeof</span>(buf));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;quit&quot;</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//若输入“quit”，则退出聊天室</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-built_in">send</span>(clinsock, buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">closesocket</span>(clinsock);<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">recvMsgThread</span><span class="hljs-params">(LPVOID IpParameter)</span></span><br><span class="hljs-function"></span>&#123;<br>      SOCKET clinsock = *(SOCKET*)IpParameter;<span class="hljs-comment">//函数首先将传入的IpParameter转换为SOCKET类型，并赋值给变量clinsock。</span><br><br>      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>      &#123;<br>        <span class="hljs-type">char</span> buffer[BUFFER_SIZE]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//定义一个大小为BUFFER_SIZE的字符数组buffer，并将其所有元素初始化为0</span><br>        <span class="hljs-type">int</span> nrecv=<span class="hljs-built_in">recv</span>(clinsock,buffer,<span class="hljs-built_in">sizeof</span>(buffer),<span class="hljs-number">0</span>);<span class="hljs-comment">//调用recv函数接收来自clinsock的数据，并将接收到的数据存储在buffer中</span><br>        <span class="hljs-keyword">if</span>(recv&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//如果接收到的字节数大于0，则将buffer中的内容输出到标准输出流（cout）。</span><br>        &#123;<br>             cout&lt;&lt;buffer&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;don&#x27;t connect&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lxml,BeautifulSoup和Requet基本使用</title>
    <link href="/2022/09/15/Lxml,BeautifulSoup%E5%92%8CRequet%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/15/Lxml,BeautifulSoup%E5%92%8CRequet%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><blockquote><p>更具体的请浏览官方文档：<a href="https://requests.readthedocs.io/projects/cn/zh-cn/latest/user/advanced.html#session-objects">高级用法 — Requests 2.18.1 文档</a></p></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="请求与响应对象"><a href="#请求与响应对象" class="headerlink" title="请求与响应对象"></a>请求与响应对象</h3><p>任何时候进行了类似 requests.get() 的调用，你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 <code>requests</code> 得到一个从服务器返回的响应就会产生一个 <code>Response</code> 对象。该响应对象包含服务器返回的所有信息，也包含你原来创建的 <code>Request</code> 对象。</p><h4 id="requests参数"><a href="#requests参数" class="headerlink" title="requests参数"></a>requests参数</h4><img src="https://s2.loli.net/2024/12/31/gJET28GUlPdymMV.png" alt="image-20241231180931825" style="zoom:50%;" /><h5 id="参数具体信息"><a href="#参数具体信息" class="headerlink" title="参数具体信息"></a>参数具体信息</h5><p><img src="https://s2.loli.net/2024/12/31/lZoW1nmPJtYBDy6.png" alt="image-20241231181023697"></p><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><h5 id="1-get-方法"><a href="#1-get-方法" class="headerlink" title="1.get()方法"></a>1.get()方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>x = requests.get(<span class="hljs-string">&#x27;https://begtut.com&#x27;</span>)<br><span class="hljs-built_in">print</span>(x.status_code) <br></code></pre></td></tr></table></figure><h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p><img src="https://s2.loli.net/2024/12/31/NulWHZrzRhjJ9eV.png" alt="image-20241231182011680"></p><h5 id="2-post-方法"><a href="#2-post-方法" class="headerlink" title="2.post()方法"></a>2.post()方法</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><br>r = requests.post(<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>, data=payload)<br><span class="hljs-built_in">print</span>(r.text)<br></code></pre></td></tr></table></figure><h6 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h6><p><img src="https://s2.loli.net/2024/12/31/D8rRlEuxy5jtMSe.png" alt="image-20241231182223726"></p><h3 id="requests-Response-对象"><a href="#requests-Response-对象" class="headerlink" title="requests.Response 对象"></a>requests.Response 对象</h3><table><thead><tr><th><strong>属性&#x2F;方法</strong></th><th><strong>类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td><code>status_code</code></td><td><code>int</code></td><td align="left">HTTP 响应的状态码。例如，200 表示请求成功，404 表示未找到，500 表示服务器错误等。</td></tr><tr><td><code>text</code></td><td><code>str</code></td><td align="left">响应体的内容，通常为文本数据，如 HTML 或 XML 格式的响应。</td></tr><tr><td><code>json()</code></td><td><code>dict</code></td><td align="left">如果响应内容是 JSON 格式，调用该方法会将其解析为 Python 字典对象。</td></tr><tr><td><code>content</code></td><td><code>bytes</code></td><td align="left">响应体的原始字节内容。如果响应是二进制数据（如图片、视频等），使用此属性。</td></tr><tr><td><code>headers</code></td><td><code>dict</code></td><td align="left">响应的 HTTP 头部，包含键值对，例如 <code>Content-Type</code>、<code>Server</code> 等。</td></tr><tr><td><code>cookies</code></td><td><code>RequestsCookieJar</code></td><td align="left">响应中的 cookies 信息，通常用来存储客户端和服务器之间的会话信息。</td></tr><tr><td><code>url</code></td><td><code>str</code></td><td align="left">最终请求的 URL，可能与传递的 URL 不同，因为可能发生了重定向。</td></tr><tr><td><code>encoding</code></td><td><code>str</code></td><td align="left">响应内容的字符编码（例如 <code>utf-8</code>）。</td></tr><tr><td><code>reason</code></td><td><code>str</code></td><td align="left">HTTP 响应的状态说明。例如，”OK” 或 “Not Found” 等。</td></tr><tr><td><code>ok</code></td><td><code>bool</code></td><td align="left">如果响应状态码为 2xx，则返回 <code>True</code>，表示请求成功；否则返回 <code>False</code>。</td></tr><tr><td><code>elapsed</code></td><td><code>timedelta</code></td><td align="left">请求耗时的 <code>timedelta</code> 对象，表示请求从开始到结束所用的时间。</td></tr><tr><td><code>history</code></td><td><code>list</code></td><td align="left">如果发生了重定向，这个属性将包含响应的历史记录。</td></tr><tr><td><code>is_redirect</code></td><td><code>bool</code></td><td align="left">如果响应是重定向响应（如 301 或 302），返回 <code>True</code>。</td></tr><tr><td><code>is_permanent_redirect</code></td><td><code>bool</code></td><td align="left">如果响应是永久重定向（如 301），返回 <code>True</code>。</td></tr><tr><td><code>iter_content(chunk_size=1)</code></td><td><code>iterator</code></td><td align="left">按块读取响应内容，适合处理大文件的下载，<code>chunk_size</code> 设置每块数据的大小。</td></tr><tr><td><code>iter_lines(chunk_size=1)</code></td><td><code>iterator</code></td><td align="left">按行迭代响应体内容，适合逐行处理大文本数据。</td></tr><tr><td><code>raise_for_status()</code></td><td><code>None</code></td><td align="left">如果响应的状态码表示请求失败（如 4xx 或 5xx 错误），抛出异常。</td></tr><tr><td><code>close()</code></td><td><code>None</code></td><td align="left">关闭连接，释放底层资源。</td></tr><tr><td><code>request</code></td><td><code>Request</code></td><td align="left">返回用于生成此响应的请求对象。</td></tr><tr><td><code>raw</code></td><td><code>urllib3.response.HTTPResponse</code></td><td align="left">响应的底层 <code>HTTPResponse</code> 对象，提供更多底层的控制选项。</td></tr><tr><td><code>apparent_encoding</code></td><td><code>str</code></td><td align="left"><code>requests</code> 根据内容检测的编码类型，而非通过 HTTP 头部获取的编码。</td></tr><tr><td><code>_content</code></td><td><code>bytes</code></td><td align="left">内部存储的响应内容，通常通过 <code>r.content</code> 访问。</td></tr><tr><td><code>_content_consumed</code></td><td><code>bool</code></td><td align="left">标识响应内容是否已被消耗。如果内容已经消费（例如通过 <code>text</code> 或 <code>json()</code>），则为 <code>True</code>。</td></tr><tr><td><code>_next</code></td><td><code>Response</code></td><td align="left">用于处理响应流中的下一个响应对象（通常与流式请求相关）。</td></tr><tr><td><code>close()</code></td><td><code>None</code></td><td align="left">关闭该响应的底层连接。</td></tr></tbody></table><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="会话对象"><a href="#会话对象" class="headerlink" title="会话对象"></a>会话对象</h3><p>在 Web 开发中，<strong>cookie</strong> 用于存储客户端（浏览器）和服务器之间的会话信息，例如登录状态、用户设置等。当你访问网站时，服务器可能会向你的浏览器发送一个 cookie，浏览器会在后续的请求中将这个 cookie 发送回服务器。</p><p>通常，每次使用 <code>requests.get()</code> 或 <code>requests.post()</code> 发出请求时，这些请求都是独立的，它们不共享任何信息。也就是说，每次请求都没有记住上次请求的状态。</p><p>会话对象的作用：</p><ol><li><p><strong>跨请求保持 cookie</strong>：当你使用 <code>requests.Session()</code> 创建一个会话对象时，它会自动保存和管理会话期间的 <strong>cookie</strong>。这意味着，当你向同一个服务器发送多个请求时，前一个请求的 cookie 会被保存下来并在下一个请求中自动使用，从而模拟了在浏览器中的持续会话。</p><p>例如，当你登录一个网站时，服务器可能会设置一个 <code>session_id</code> cookie。使用会话对象后，后续的请求会自动携带这个 <code>session_id</code>，使得服务器可以识别你仍然是同一个用户，而不需要重新登录。</p></li><li><p><strong>连接池和性能提升</strong>：使用会话对象还能够通过 <strong>连接池</strong> 功能重用底层的 TCP 连接，减少了每次请求时重新建立连接的开销，从而提高性能，特别是在对同一主机进行多个请求时。</p></li></ol><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 创建一个会话对象</span><br>session = requests.Session()<br><br><span class="hljs-comment"># 发送第一个请求，服务器返回 cookie</span><br>response1 = session.get(<span class="hljs-string">&#x27;https://example.com/login&#x27;</span>)<br><span class="hljs-built_in">print</span>(response1.cookies)  <span class="hljs-comment"># 打印服务器返回的 cookie</span><br><br><span class="hljs-comment"># 发送第二个请求，会话对象自动携带上次的 cookie</span><br>response2 = session.get(<span class="hljs-string">&#x27;https://example.com/dashboard&#x27;</span>)<br><span class="hljs-built_in">print</span>(response2.cookies)  <span class="hljs-comment"># 你可以看到第二个请求携带了第一个请求的 cookie</span><br><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>特性</strong></th><th><strong><code>requests.request()</code></strong></th><th><strong><code>requests.Session().request()</code></strong></th></tr></thead><tbody><tr><td><strong>会话管理</strong></td><td>每次请求都是独立的，没有会话管理</td><td>会话对象自动管理 cookie 和连接池</td></tr><tr><td><strong>连接复用</strong></td><td>每次请求建立新的 TCP 连接</td><td>会话对象复用底层 TCP 连接，提高性能</td></tr><tr><td><strong>性能</strong></td><td>性能较差，因为每次请求都需要重新连接</td><td>性能较好，适合多次请求，避免重复建立连接</td></tr><tr><td><strong>用途</strong></td><td>适用于单次请求或不需要保持会话的场景</td><td>适用于需要保持会话的场景，如登录后的连续请求</td></tr><tr><td><strong>状态保持（如 cookie）</strong></td><td>不会自动保持状态，每次请求需要显式传递</td><td>自动保持状态（例如 cookies），后续请求自动带上</td></tr><tr><td><strong>实例化对象</strong></td><td>不需要创建会话对象，直接发起请求</td><td>需要创建 <code>Session</code> 对象并通过该对象发起请求</td></tr></tbody></table><h4 id="requests-request-和-requests-Session-request"><a href="#requests-request-和-requests-Session-request" class="headerlink" title="requests.request() 和 requests.Session().request()"></a><code>requests.request()</code> 和 <code>requests.Session().request()</code></h4><p><code>requests.request()</code> 方法和 <code>requests.Session().request()</code> 方法都可以用来发起 HTTP 请求，但它们在实现方式和使用场景上有所不同。虽然两者都调用了 <code>Session</code> 类的 <code>request()</code> 方法，但其差异主要体现在 <strong>会话管理</strong> 和 <strong>内部实现</strong> 上。</p><h5 id="两者调用-Session-类的-request-方法的区别"><a href="#两者调用-Session-类的-request-方法的区别" class="headerlink" title="两者调用 Session 类的 request() 方法的区别?"></a><strong>两者调用 <code>Session</code> 类的 <code>request()</code> 方法的区别</strong>?</h5><ul><li>**<code>requests.request()</code>**：<ul><li>是一个 <strong>顶级函数</strong>，调用时会临时创建一个新的 <code>Session</code> 对象，并在该对象上发起请求。每次调用 <code>requests.request()</code> 都是一次 <strong>独立的请求</strong>，请求之间没有任何共享状态（如 cookies 或连接池）。</li><li>它并不保持会话状态，每次请求都没有连接池和 cookie 管理。</li></ul></li><li>**<code>requests.Session().request()</code>**：<ul><li>这是 <code>Session</code> 类的 <strong>实例方法</strong>，会话对象用于 <strong>跨多个请求保持会话状态</strong>（例如自动携带 cookies、HTTP 头部、连接池复用等）。</li><li>使用 <code>Session()</code> 对象，你可以在多个请求之间保持相同的会话信息，如登录的 cookies，不需要每次手动传递请求参数。。</li></ul></li></ul><h5 id="代码实现上的差异"><a href="#代码实现上的差异" class="headerlink" title="代码实现上的差异"></a><strong>代码实现上的差异</strong></h5><p><code>requests.request()</code> 会在内部新建一个 <code>Session</code> 对象，而 <code>requests.Session().request()</code> 则使用已经创建好的 <code>Session</code> 对象。以下是它们的简化实现：</p><h6 id="requests-request-实现："><a href="#requests-request-实现：" class="headerlink" title="requests.request() 实现："></a><code>requests.request()</code> 实现：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> Session<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">method, url, **kwargs</span>):<br>    <span class="hljs-comment"># 每次都创建一个新的 Session 对象</span><br>    session = Session()<br>    <span class="hljs-keyword">return</span> session.request(method, url, **kwargs)<br></code></pre></td></tr></table></figure><h6 id="requests-Session-request-实现："><a href="#requests-Session-request-实现：" class="headerlink" title="requests.Session().request() 实现："></a><code>requests.Session().request()</code> 实现：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 使用已有的 Session 对象发起请求</span><br>session = requests.Session()<br>response = session.request(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://example.com&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="Lxml"><a href="#Lxml" class="headerlink" title="Lxml"></a>Lxml</h1><blockquote><p><a href="https://lxml.de/">lxml - Processing XML and HTML with Python</a></p></blockquote><p><code>lxml</code> 是一个用于处理 XML 和 HTML 的 Python 库，它提供了对 XML 和 HTML 的高效解析和操作能力。</p><h2 id="HTML-和-XML-之间的区别"><a href="#HTML-和-XML-之间的区别" class="headerlink" title="HTML 和 XML 之间的区别"></a>HTML 和 XML 之间的区别</h2><p><strong>XML</strong> 是一种面向数据的标记语言，专注于描述和传输结构化信息；它注重可扩展性和自定义，适合数据存储和交换。</p><p><strong>HTML</strong> 是一种面向显示的标记语言，专注于内容的呈现和用户交互；它结构固定且宽松，适合网页设计。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>XML（可扩展标记语言）</strong></th><th><strong>HTML（超文本标记语言）</strong></th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>用于表示、存储和传输数据，强调数据的<strong>结构化</strong>和<strong>自定义</strong>。</td><td>用于<strong>展示</strong>网页内容，描述文档的外观和行为。</td></tr><tr><td><strong>语法规则</strong></td><td>严格：标签必须正确嵌套，属性值必须用引号，必须有根标签。</td><td>宽松：标签可以不完全闭合，不区分大小写，错误不会阻止文档渲染。</td></tr><tr><td><strong>标签定义</strong></td><td>用户可以自定义标签。</td><td>使用预定义的固定标签（如 <code>&lt;html&gt;</code>、<code>&lt;div&gt;</code>）。</td></tr><tr><td><strong>数据格式</strong></td><td>数据驱动：描述数据及其结构，通常无视觉呈现。</td><td>视觉驱动：用来定义文档的结构和视觉内容。</td></tr><tr><td><strong>用途</strong></td><td>数据交换（如配置文件、Web 服务接口）。</td><td>构建和展示网页内容。</td></tr><tr><td><strong>可扩展性</strong></td><td>完全支持：用户可以根据需求定义自己的标签和结构。</td><td>不支持扩展：只能使用 HTML 标准定义的标签。</td></tr><tr><td><strong>显示功能</strong></td><td>仅存储数据，无法直接定义数据如何显示。</td><td>专为显示内容设计，提供文本、图像、超链接等显示功能。</td></tr><tr><td><strong>严格性</strong></td><td>严格遵守规则，错误会导致解析失败。</td><td>宽容性强，小错误不会影响页面渲染。</td></tr><tr><td><strong>案例用途</strong></td><td>配置文件（如 <code>.xml</code> 文件）、数据交换（如 SOAP、RSS）。</td><td>网页设计、超媒体文档展示。</td></tr><tr><td><strong>属性</strong></td><td>属性仅用于提供额外信息，内容以文本为主。</td><td>属性用于控制页面的外观和行为（如 <code>style</code>、<code>class</code>）。</td></tr><tr><td><strong>大小写敏感性</strong></td><td>区分大小写：<code>&lt;Tag&gt;</code> 和 <code>&lt;tag&gt;</code> 是不同的标签。</td><td>不区分大小写：<code>&lt;Tag&gt;</code> 和 <code>&lt;tag&gt;</code> 是等价的。</td></tr><tr><td><strong>解析工具</strong></td><td>通常需要专用的解析器（如 <code>lxml</code>、<code>ElementTree</code>）。</td><td>浏览器原生支持，无需额外解析工具。</td></tr><tr><td><strong>支持的标准</strong></td><td>W3C XML 标准。</td><td>W3C HTML 和 HTML5 标准。</td></tr><tr><td><strong>数据验证</strong></td><td>支持数据验证（如通过 DTD 或 XML Schema 验证）。</td><td>不支持数据验证，仅为文档展示服务。</td></tr><tr><td><strong>与 CSS 的集成</strong></td><td>通常不直接集成 CSS，需结合 HTML 或其他技术实现样式。</td><td>天生与 CSS 集成，用于控制页面样式和布局。</td></tr><tr><td><strong>与 JavaScript 的集成</strong></td><td>通常作为数据源（如通过 AJAX 获取和解析 XML 数据）。</td><td>可以直接与 JavaScript 结合，实现交互式网页功能。</td></tr><tr><td><strong>人类可读性</strong></td><td>设计为机器和人类都易于理解，适合存储复杂的结构化数据。</td><td>面向人类设计，主要用于网页内容和交互的编写。</td></tr></tbody></table><h2 id="lxml-模块组成及功能概览"><a href="#lxml-模块组成及功能概览" class="headerlink" title="lxml 模块组成及功能概览"></a>lxml 模块组成及功能概览</h2><table><thead><tr><th><strong>模块</strong></th><th><strong>功能描述</strong></th><th><strong>常见方法&#x2F;功能</strong></th></tr></thead><tbody><tr><td><strong>lxml.etree</strong></td><td>核心模块，用于解析、生成、查询和修改 XML 和 HTML 文档。</td><td><code>parse()</code>、<code>fromstring()</code>、<code>Element()</code>、<code>XPath()</code>、<code>tostring()</code>、节点操作（如 <code>append()</code>、<code>remove()</code>）。</td></tr><tr><td><strong>lxml.html</strong></td><td>专门处理 HTML，支持修复不规范 HTML 结构并提供更高级操作接口。</td><td><code>html.parse()</code>、<code>html.fromstring()</code>、<code>html.tostring()</code>、CSS 选择器功能（配合 <code>CSSSelector</code>）。</td></tr><tr><td><strong>lxml.xpath</strong></td><td>提供 XPath 查询功能，用于快速查找和筛选 XML&#x2F;HTML 元素。</td><td><code>XPath()</code>、<code>XPathResult()</code>，通过 <code>element.xpath()</code> 执行查询。</td></tr><tr><td><strong>lxml.objectify</strong></td><td>将 XML 数据转换为 Python 对象，支持属性访问方式操作 XML 数据。</td><td><code>objectify.fromstring()</code>、<code>objectify.Element()</code>，动态生成属性和子元素。</td></tr><tr><td><strong>lxml.etree.CDATA</strong></td><td>用于表示 XML 文档中的 CDATA 部分，处理不需要转义的字符数据。</td><td>无直接方法，适用于定义和操作 CDATA 节点内容。</td></tr><tr><td><strong>lxml.html.CSSSelector</strong></td><td>提供 CSS 选择器支持，通过 CSS 风格选择器查找文档中的元素（类似 jQuery）。</td><td><code>CSSSelector(selector)</code>，基于 CSS 选择器的元素查询。</td></tr><tr><td><strong>lxml.etree.XMLParser</strong></td><td>XML 解析器，支持标准的 XML 文档解析。</td><td><code>XMLParser()</code>，支持自定义解析行为。</td></tr><tr><td><strong>lxml.etree.HTMLParser</strong></td><td>HTML 解析器，支持修复不规范 HTML 并解析为 HTML 文档。</td><td><code>HTMLParser()</code>，适合处理不规范的网页内容。</td></tr><tr><td><strong>lxml.builder</strong></td><td>提供动态构建 XML 文档的能力，通过类对象生成 XML 元素并组装完整文档。</td><td><code>builder.ElementMaker()</code>，创建元素构建器，支持动态 XML 生成。</td></tr></tbody></table><hr><p><strong>模块功能对比与适用场景</strong></p><table><thead><tr><th><strong>模块名称</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>lxml.etree</strong></td><td>通用 XML 和 HTML 操作，适用于标准文档的解析、修改和生成。</td></tr><tr><td><strong>lxml.html</strong></td><td>处理 HTML 文档的高级需求，适合网页爬虫和修复不规范 HTML。</td></tr><tr><td><strong>lxml.xpath</strong></td><td>基于 XPath 的快速节点查询，适合大规模 XML&#x2F;HTML 数据的精准查找。</td></tr><tr><td><strong>lxml.objectify</strong></td><td>将 XML 转为对象，适合需要通过属性访问 XML 节点的场景。</td></tr><tr><td><strong>lxml.builder</strong></td><td>动态生成 XML，适用于需要灵活构建复杂 XML 文档的情况。</td></tr><tr><td><strong>lxml.html.CSSSelector</strong></td><td>使用 CSS 选择器查找 HTML 元素，适用于熟悉 CSS 的开发者操作 HTML。</td></tr><tr><td><strong>XMLParser&#x2F;HTMLParser</strong></td><td>定制 XML&#x2F;HTML 解析行为，适合需要特殊解析规则的应用。</td></tr></tbody></table><hr><h2 id="lxml-etree-和-lxml-html-对比"><a href="#lxml-etree-和-lxml-html-对比" class="headerlink" title="lxml.etree 和 lxml.html 对比"></a><strong><code>lxml.etree</code> 和 <code>lxml.html</code> 对比</strong></h2><table><thead><tr><th><strong>对比维度</strong></th><th><strong>lxml.etree</strong></th><th><strong>lxml.html</strong></th></tr></thead><tbody><tr><td><strong>模块性质</strong></td><td>核心模块，用于解析、生成、查询和修改 XML 和 HTML。</td><td>基于 <code>lxml.etree</code> 的扩展模块，专门处理 HTML 文档，特别是不规范 HTML。</td></tr><tr><td><strong>支持文档类型</strong></td><td>XML 和 HTML，主要面向标准化文档，要求严格符合 XML 规范。</td><td>专注 HTML，适用于不规范 HTML 文档，自动修复结构问题。</td></tr><tr><td><strong>解析器</strong></td><td>标准的 XML 解析器（<code>XMLParser</code> 和 <code>HTMLParser</code>），对标准要求严格。</td><td>使用基于 HTML 的解析器，对缺失闭合标签、不匹配标签等容错处理更强。</td></tr><tr><td><strong>容错能力</strong></td><td>面向 XML 标准，容错能力较弱。</td><td>面向 HTML 标准，自动修复常见的 HTML 错误，例如闭合标签补全、修复嵌套问题。</td></tr><tr><td><strong>功能扩展</strong></td><td>提供标准的 XML&#x2F;HTML 解析和操作功能，支持 XPath、XSLT、节点增删改查等操作。</td><td>在继承 <code>lxml.etree</code> 功能的基础上，提供 CSS 选择器支持、HTML 特定修复功能以及对不规范文档的优化。</td></tr><tr><td><strong>自动修复</strong></td><td>仅对 XML 规范严格处理，不会自动修复文档结构问题。</td><td>能修复不规范的 HTML，例如缺失的 <code>&lt;/html&gt;</code> 或不完整的标签。</td></tr><tr><td><strong>CSS 选择器支持</strong></td><td>不支持 CSS 选择器，只能通过 XPath 查询。</td><td>支持 CSS 选择器查询，提供 <code>CSSSelector</code> 类，简化 HTML 元素的查询。</td></tr><tr><td><strong>适用场景</strong></td><td>需要严格处理 XML 或标准 HTML 的场景，如配置文件、API 数据解析等。</td><td>适合处理网页爬虫和 HTML 文档操作，尤其是不规范 HTML 的解析和修复场景。</td></tr><tr><td><strong>示例方法</strong></td><td><code>etree.parse()</code>、<code>etree.fromstring()</code>、<code>etree.Element()</code>、<code>XPath()</code>。</td><td><code>html.parse()</code>、<code>html.fromstring()</code>、<code>CSSSelector()</code>、自动补全和修复 HTML 结构问题。</td></tr></tbody></table><hr><h2 id="lxml-etree-常用属性与方法"><a href="#lxml-etree-常用属性与方法" class="headerlink" title="lxml.etree 常用属性与方法"></a><strong><code>lxml.etree</code> 常用属性与方法</strong></h2><h3 id="1-核心类及作用"><a href="#1-核心类及作用" class="headerlink" title="1. 核心类及作用"></a><strong>1. 核心类及作用</strong></h3><table><thead><tr><th><strong>类名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>Element</code></td><td>表示 XML&#x2F;HTML 文档中的节点，支持各种节点操作。</td></tr><tr><td><code>ElementTree</code></td><td>表示整个文档树结构，用于管理和操作根节点及其子节点。</td></tr><tr><td><code>XMLParser</code></td><td>用于解析 XML 文档，支持自定义解析行为。</td></tr><tr><td><code>HTMLParser</code></td><td>用于解析 HTML 文档，支持容错处理。</td></tr><tr><td><code>XPath</code></td><td>表示 XPath 表达式，便于对文档进行高级查询。</td></tr><tr><td><code>XSLT</code></td><td>表示 XSLT 转换对象，用于对 XML 文档进行样式转换。</td></tr></tbody></table><hr><h3 id="2-Element-类常用属性和方法"><a href="#2-Element-类常用属性和方法" class="headerlink" title="2. Element 类常用属性和方法"></a><strong>2. <code>Element</code> 类常用属性和方法</strong></h3><table><thead><tr><th><strong>属性&#x2F;方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>属性</strong></td><td></td></tr><tr><td><code>tag</code></td><td>返回节点的标签名（字符串）。</td></tr><tr><td><code>attrib</code></td><td>返回节点的属性字典（键值对可修改）。</td></tr><tr><td><code>text</code></td><td>返回节点的文本内容（可读写）。</td></tr><tr><td><code>tail</code></td><td>返回节点的尾部文本（紧接在节点后面的文本）。</td></tr><tr><td><strong>方法</strong></td><td></td></tr><tr><td><code>append(element)</code></td><td>向当前节点的子节点列表中追加一个子元素。</td></tr><tr><td><code>extend(elements)</code></td><td>向当前节点追加多个子元素。</td></tr><tr><td><code>find(path)</code></td><td>按 XPath 查询子节点，返回第一个匹配的子节点。</td></tr><tr><td><code>findall(path)</code></td><td>按 XPath 查询所有匹配的子节点，返回列表。</td></tr><tr><td><code>findtext(path)</code></td><td>按 XPath 查询子节点并返回其文本内容。</td></tr><tr><td><code>get(key, default=None)</code></td><td>获取指定属性的值，若不存在返回默认值。</td></tr><tr><td><code>set(key, value)</code></td><td>设置指定属性的值。</td></tr><tr><td><code>keys()</code></td><td>返回节点所有属性的键。</td></tr><tr><td><code>items()</code></td><td>返回节点所有属性的键值对。</td></tr><tr><td><code>insert(index, element)</code></td><td>在指定位置插入子节点。</td></tr><tr><td><code>remove(element)</code></td><td>删除指定的子节点。</td></tr><tr><td><code>clear()</code></td><td>清除当前节点的所有内容（文本、子节点和属性）。</td></tr><tr><td><code>iter(tag=None)</code></td><td>深度优先遍历当前节点及其所有子节点。</td></tr><tr><td><code>iterchildren(tag=None)</code></td><td>遍历当前节点的直接子节点。</td></tr><tr><td><code>itertext()</code></td><td>遍历当前节点及其子节点中的所有文本内容。</td></tr></tbody></table><hr><h3 id="3-ElementTree-类常用属性和方法"><a href="#3-ElementTree-类常用属性和方法" class="headerlink" title="3. ElementTree 类常用属性和方法"></a><strong>3. <code>ElementTree</code> 类常用属性和方法</strong></h3><table><thead><tr><th><strong>属性&#x2F;方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>属性</strong></td><td></td></tr><tr><td><code>docinfo</code></td><td>返回文档的元信息（如编码、DTD 等）。</td></tr><tr><td><code>getroot()</code></td><td>返回文档的根节点。</td></tr><tr><td><strong>方法</strong></td><td></td></tr><tr><td><code>find(path)</code></td><td>在整棵树中查找第一个匹配的节点。</td></tr><tr><td><code>findall(path)</code></td><td>在整棵树中查找所有匹配的节点，返回列表。</td></tr><tr><td><code>findtext(path)</code></td><td>返回匹配节点的文本内容。</td></tr><tr><td><code>write(file, encoding=None, xml_declaration=None)</code></td><td>将文档树写入文件。</td></tr><tr><td><code>xpath(expression)</code></td><td>使用 XPath 表达式查询文档树。</td></tr></tbody></table><hr><h3 id="4-解析相关函数"><a href="#4-解析相关函数" class="headerlink" title="4. 解析相关函数"></a><strong>4. 解析相关函数</strong></h3><table><thead><tr><th><strong>函数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>XML(string)</code></td><td>解析 XML 字符串，返回根节点。</td></tr><tr><td><code>HTML(string)</code></td><td>解析 HTML 字符串，返回根节点。</td></tr><tr><td><code>parse(file)</code></td><td>从文件解析 XML&#x2F;HTML 文档。</td></tr><tr><td><code>fromstring(string)</code></td><td>解析 XML&#x2F;HTML 字符串，返回根节点。</td></tr><tr><td><code>tostring(element, pretty_print=False)</code></td><td>将节点序列化为字符串。</td></tr></tbody></table><hr><h3 id="5-文档创建与序列化"><a href="#5-文档创建与序列化" class="headerlink" title="5. 文档创建与序列化"></a><strong>5. 文档创建与序列化</strong></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>创建</strong></td><td></td></tr><tr><td><code>Element(tag, attrib=None, **extra)</code></td><td>创建一个新的节点。</td></tr><tr><td><code>SubElement(parent, tag, attrib=None, **extra)</code></td><td>向父节点中创建子节点。</td></tr><tr><td><code>Comment(text)</code></td><td>创建注释节点。</td></tr><tr><td><code>ProcessingInstruction(target, text=None)</code></td><td>创建处理指令节点。</td></tr><tr><td><strong>序列化</strong></td><td></td></tr><tr><td><code>tostring(element, encoding=None, pretty_print=False)</code></td><td>将节点序列化为字符串。</td></tr><tr><td><code>ElementTree.write(file, encoding=None, xml_declaration=None)</code></td><td>将整个树写入文件。</td></tr></tbody></table><hr><h4 id="6-XPath-类常用方法"><a href="#6-XPath-类常用方法" class="headerlink" title="6. XPath 类常用方法"></a><strong>6. XPath 类常用方法</strong></h4><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>evaluate(tree_or_element)</code></td><td>在指定的树或节点上运行 XPath 表达式，返回匹配结果。</td></tr><tr><td><code>find(tree_or_element)</code></td><td>返回第一个匹配的节点。</td></tr><tr><td><code>findall(tree_or_element)</code></td><td>返回所有匹配的节点，返回列表。</td></tr></tbody></table><hr><h3 id="示例代码对比"><a href="#示例代码对比" class="headerlink" title="示例代码对比"></a><strong>示例代码对比</strong></h3><h4 id="XML-文档操作"><a href="#XML-文档操作" class="headerlink" title="XML 文档操作"></a><strong>XML 文档操作</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><span class="hljs-comment"># 创建 XML</span><br>root = etree.Element(<span class="hljs-string">&quot;root&quot;</span>)<br>child = etree.SubElement(root, <span class="hljs-string">&quot;child&quot;</span>, attrib=&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;test&quot;</span>&#125;)<br>child.text = <span class="hljs-string">&quot;Hello, XML!&quot;</span><br><br><span class="hljs-comment"># 打印序列化后的 XML</span><br><span class="hljs-built_in">print</span>(etree.tostring(root, pretty_print=<span class="hljs-literal">True</span>).decode())<br></code></pre></td></tr></table></figure><h4 id="XPath-查询"><a href="#XPath-查询" class="headerlink" title="XPath 查询"></a><strong>XPath 查询</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><span class="hljs-comment"># 创建 XML</span><br>root = etree.Element(<span class="hljs-string">&quot;root&quot;</span>)<br>etree.SubElement(root, <span class="hljs-string">&quot;child&quot;</span>, attrib=&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>&#125;).text = <span class="hljs-string">&quot;Value A&quot;</span><br>etree.SubElement(root, <span class="hljs-string">&quot;child&quot;</span>, attrib=&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>&#125;).text = <span class="hljs-string">&quot;Value B&quot;</span><br><br><span class="hljs-comment"># XPath 查询</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[@name=&#x27;A&#x27;]/text()&quot;</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 [&#x27;Value A&#x27;]</span><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th><strong>功能</strong></th><th><strong>推荐方法&#x2F;类</strong></th></tr></thead><tbody><tr><td>创建节点和文档</td><td><code>Element</code>、<code>SubElement</code></td></tr><tr><td>序列化为字符串或写入文件</td><td><code>tostring()</code>、<code>ElementTree.write()</code></td></tr><tr><td>查询节点</td><td><code>find()</code>、<code>findall()</code>、<code>xpath()</code></td></tr><tr><td>修改节点属性或文本</td><td><code>set()</code>、<code>attrib</code>、<code>text</code></td></tr><tr><td>遍历节点</td><td><code>iter()</code>、<code>iterchildren()</code></td></tr></tbody></table><h2 id="XPath-的基本语法规则"><a href="#XPath-的基本语法规则" class="headerlink" title="XPath 的基本语法规则"></a>XPath 的基本语法规则</h2><h3 id="lxml-库的-XPath-语法与使用指南"><a href="#lxml-库的-XPath-语法与使用指南" class="headerlink" title="lxml 库的 XPath 语法与使用指南"></a><strong><code>lxml</code> 库的 XPath 语法与使用指南</strong></h3><p>XPath（XML Path Language）是一种用于定位 XML&#x2F;HTML 文档中节点的语言，它支持节点查询、条件筛选以及多种操作功能。在 Python 的 <code>lxml.etree</code> 中，XPath 是 XML 和 HTML 查询的核心。</p><p>以下内容将介绍 XPath 的常用语法规则和 <code>lxml</code> 中的使用方法。</p><hr><h3 id="1-XPath-的基本语法规则"><a href="#1-XPath-的基本语法规则" class="headerlink" title="1. XPath 的基本语法规则"></a><strong>1. XPath 的基本语法规则</strong></h3><h4 id="1-1-基础节点选择"><a href="#1-1-基础节点选择" class="headerlink" title="1.1 基础节点选择"></a><strong>1.1 基础节点选择</strong></h4><table><thead><tr><th><strong>表达式</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>/</code></td><td>根节点选择。</td><td><code>/root</code> 选择根节点 <code>&lt;root&gt;</code>。</td></tr><tr><td><code>//</code></td><td>从文档的任意位置选择匹配的节点（不局限于直接子节点）。</td><td><code>//child</code> 选择文档中所有的 <code>&lt;child&gt;</code> 节点。</td></tr><tr><td><code>.</code></td><td>当前节点。</td><td><code>.</code> 表示当前节点。</td></tr><tr><td><code>..</code></td><td>父节点。</td><td><code>..</code> 表示当前节点的父节点。</td></tr><tr><td><code>@</code></td><td>属性选择器，用于选择节点属性值。</td><td><code>//@id</code> 选择所有节点的 <code>id</code> 属性。</td></tr></tbody></table><h4 id="1-2-条件筛选"><a href="#1-2-条件筛选" class="headerlink" title="1.2 条件筛选"></a><strong>1.2 条件筛选</strong></h4><table><thead><tr><th><strong>表达式</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>[condition]</code></td><td>筛选符合条件的节点。</td><td><code>//child[@name=&#39;A&#39;]</code> 选择属性 <code>name=&quot;A&quot;</code> 的 <code>&lt;child&gt;</code> 节点。</td></tr><tr><td><code>position()</code></td><td>返回节点的当前位置（从 1 开始）。</td><td><code>//child[position()=1]</code> 选择第一个 <code>&lt;child&gt;</code> 节点。</td></tr><tr><td><code>last()</code></td><td>返回节点集的最后一个位置。</td><td><code>//child[last()]</code> 选择最后一个 <code>&lt;child&gt;</code> 节点。</td></tr></tbody></table><h4 id="1-3-文本选择"><a href="#1-3-文本选择" class="headerlink" title="1.3 文本选择"></a><strong>1.3 文本选择</strong></h4><table><thead><tr><th><strong>表达式</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>text()</code></td><td>选择节点的文本内容。</td><td><code>//child/text()</code> 选择 <code>&lt;child&gt;</code> 节点的文本内容。</td></tr><tr><td><code>contains()</code></td><td>检查字符串是否包含子串。</td><td><code>//child[contains(@name, &#39;part&#39;)]</code> 选择 <code>name</code> 属性包含 <code>part</code> 的节点。</td></tr><tr><td><code>starts-with()</code></td><td>检查字符串是否以某子串开头。</td><td><code>//child[starts-with(@name, &#39;prefix&#39;)]</code> 选择 <code>name</code> 属性以 <code>prefix</code> 开头的节点。</td></tr></tbody></table><h4 id="1-4-逻辑与算术运算"><a href="#1-4-逻辑与算术运算" class="headerlink" title="1.4 逻辑与算术运算"></a><strong>1.4 逻辑与算术运算</strong></h4><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>and</code></td><td>与运算。</td><td><code>//child[@id=&#39;1&#39; and @name=&#39;A&#39;]</code></td></tr><tr><td><code>or</code></td><td>或运算。</td><td><code>//child[@id=&#39;1&#39; or @name=&#39;A&#39;]</code></td></tr><tr><td><code>=</code></td><td>等于。</td><td><code>//child[@id=&#39;1&#39;]</code></td></tr><tr><td><code>!=</code></td><td>不等于。</td><td><code>//child[@id!=&#39;1&#39;]</code></td></tr><tr><td><code>&lt;</code> &#x2F; <code>&lt;=</code></td><td>小于 &#x2F; 小于等于。</td><td><code>//child[@count&lt;5]</code></td></tr><tr><td><code>&gt;</code> &#x2F; <code>&gt;=</code></td><td>大于 &#x2F; 大于等于。</td><td><code>//child[@count&gt;10]</code></td></tr></tbody></table><hr><h3 id="2-使用-lxml-的-XPath-功能"><a href="#2-使用-lxml-的-XPath-功能" class="headerlink" title="2. 使用 lxml 的 XPath 功能"></a><strong>2. 使用 <code>lxml</code> 的 XPath 功能</strong></h3><h4 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a><strong>2.1 基本用法</strong></h4><p><code>lxml</code> 提供了以下方法用于执行 XPath 查询：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>xpath(expression)</code></td><td>返回匹配的节点、属性或值（可能是列表、单个节点或字符串）。</td></tr></tbody></table><hr><h4 id="2-2-示例代码"><a href="#2-2-示例代码" class="headerlink" title="2.2 示例代码"></a><strong>2.2 示例代码</strong></h4><h5 id="（1）基本查询"><a href="#（1）基本查询" class="headerlink" title="（1）基本查询"></a><strong>（1）基本查询</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><span class="hljs-comment"># 创建 XML 文档</span><br>xml_data = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;root&gt;</span><br><span class="hljs-string">    &lt;child id=&quot;1&quot; name=&quot;A&quot;&gt;Value A&lt;/child&gt;</span><br><span class="hljs-string">    &lt;child id=&quot;2&quot; name=&quot;B&quot;&gt;Value B&lt;/child&gt;</span><br><span class="hljs-string">    &lt;child id=&quot;3&quot; name=&quot;C&quot;&gt;Value C&lt;/child&gt;</span><br><span class="hljs-string">&lt;/root&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>root = etree.fromstring(xml_data)<br><br><span class="hljs-comment"># 查询所有子节点</span><br>children = root.xpath(<span class="hljs-string">&quot;//child&quot;</span>)<br><span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> children:<br>    <span class="hljs-built_in">print</span>(child.tag, child.attrib)  <span class="hljs-comment"># 输出子节点的标签和属性</span><br><br><span class="hljs-comment"># 查询特定属性的节点</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[@name=&#x27;A&#x27;]&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>].text)  <span class="hljs-comment"># 输出 &#x27;Value A&#x27;</span><br></code></pre></td></tr></table></figure><hr><h5 id="（2）查询文本和属性"><a href="#（2）查询文本和属性" class="headerlink" title="（2）查询文本和属性"></a><strong>（2）查询文本和属性</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询节点的文本内容</span><br>texts = root.xpath(<span class="hljs-string">&quot;//child/text()&quot;</span>)<br><span class="hljs-built_in">print</span>(texts)  <span class="hljs-comment"># 输出 [&#x27;Value A&#x27;, &#x27;Value B&#x27;, &#x27;Value C&#x27;]</span><br><br><span class="hljs-comment"># 查询特定属性</span><br>attributes = root.xpath(<span class="hljs-string">&quot;//child/@name&quot;</span>)<br><span class="hljs-built_in">print</span>(attributes)  <span class="hljs-comment"># 输出 [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></code></pre></td></tr></table></figure><hr><h5 id="（3）使用条件筛选"><a href="#（3）使用条件筛选" class="headerlink" title="（3）使用条件筛选"></a><strong>（3）使用条件筛选</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 筛选 id=2 的节点</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[@id=&#x27;2&#x27;]&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>].text)  <span class="hljs-comment"># 输出 &#x27;Value B&#x27;</span><br><br><span class="hljs-comment"># 筛选包含特定子串的节点</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[contains(@name, &#x27;C&#x27;)]&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>].text)  <span class="hljs-comment"># 输出 &#x27;Value C&#x27;</span><br><br><span class="hljs-comment"># 筛选位置</span><br>first_child = root.xpath(<span class="hljs-string">&quot;//child[position()=1]&quot;</span>)<br><span class="hljs-built_in">print</span>(first_child[<span class="hljs-number">0</span>].text)  <span class="hljs-comment"># 输出 &#x27;Value A&#x27;</span><br></code></pre></td></tr></table></figure><hr><h5 id="（4）复杂查询与逻辑运算"><a href="#（4）复杂查询与逻辑运算" class="headerlink" title="（4）复杂查询与逻辑运算"></a><strong>（4）复杂查询与逻辑运算</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询同时满足多个条件的节点</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[@id=&#x27;1&#x27; and @name=&#x27;A&#x27;]&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>].text)  <span class="hljs-comment"># 输出 &#x27;Value A&#x27;</span><br><br><span class="hljs-comment"># 查询多个条件中满足任意一个的节点</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[@id=&#x27;1&#x27; or @name=&#x27;C&#x27;]&quot;</span>)<br><span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(r.text)  <span class="hljs-comment"># 输出 &#x27;Value A&#x27; 和 &#x27;Value C&#x27;</span><br></code></pre></td></tr></table></figure><hr><h5 id="（5）查询父节点、祖先节点"><a href="#（5）查询父节点、祖先节点" class="headerlink" title="（5）查询父节点、祖先节点"></a><strong>（5）查询父节点、祖先节点</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询父节点</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[@id=&#x27;1&#x27;]/..&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>].tag)  <span class="hljs-comment"># 输出 &#x27;root&#x27;</span><br><br><span class="hljs-comment"># 查询祖先节点</span><br>result = root.xpath(<span class="hljs-string">&quot;//child[@id=&#x27;1&#x27;]/ancestor::root&quot;</span>)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>].tag)  <span class="hljs-comment"># 输出 &#x27;root&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-XPath-高级用法"><a href="#3-XPath-高级用法" class="headerlink" title="3. XPath 高级用法"></a><strong>3. XPath 高级用法</strong></h3><h4 id="3-1-轴选择器（Axes）"><a href="#3-1-轴选择器（Axes）" class="headerlink" title="3.1 轴选择器（Axes）"></a><strong>3.1 轴选择器（Axes）</strong></h4><table><thead><tr><th><strong>轴</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>child::</code></td><td>子节点（默认轴，可省略）。</td><td><code>child::child</code> 等同于 <code>child</code>。</td></tr><tr><td><code>parent::</code></td><td>父节点。</td><td><code>//child/parent::root</code></td></tr><tr><td><code>ancestor::</code></td><td>祖先节点。</td><td><code>//child/ancestor::root</code></td></tr><tr><td><code>descendant::</code></td><td>后代节点（不包括自身）。</td><td><code>//root/descendant::child</code></td></tr><tr><td><code>self::</code></td><td>当前节点自身。</td><td><code>//child/self::child</code></td></tr><tr><td><code>following-sibling::</code></td><td>当前节点的后续兄弟节点。</td><td><code>//child[@id=&#39;1&#39;]/following-sibling::child</code></td></tr></tbody></table><hr><h4 id="3-2-使用命名空间"><a href="#3-2-使用命名空间" class="headerlink" title="3.2 使用命名空间"></a><strong>3.2 使用命名空间</strong></h4><p>如果 XML 使用了命名空间，查询需要指定命名空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 带命名空间的 XML</span><br>xml_ns = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;root xmlns:ns=&quot;http://example.com/ns&quot;&gt;</span><br><span class="hljs-string">    &lt;ns:child id=&quot;1&quot;&gt;Value A&lt;/ns:child&gt;</span><br><span class="hljs-string">&lt;/root&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>root = etree.fromstring(xml_ns)<br><br><span class="hljs-comment"># 使用命名空间查询</span><br>ns = &#123;<span class="hljs-string">&#x27;ns&#x27;</span>: <span class="hljs-string">&#x27;http://example.com/ns&#x27;</span>&#125;<br>result = root.xpath(<span class="hljs-string">&quot;//ns:child&quot;</span>, namespaces=ns)<br><span class="hljs-built_in">print</span>(result[<span class="hljs-number">0</span>].text)  <span class="hljs-comment"># 输出 &#x27;Value A&#x27;</span><br></code></pre></td></tr></table></figure><hr><h1 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h1><blockquote><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">Beautiful Soup 4.12.0 文档 — Beautiful Soup 4.12.0 documentation</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据采集处理</category>
      
      <category>数据请求与解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据采集处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL容器用法</title>
    <link href="/2022/09/10/C++STL%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"/>
    <url>/2022/09/10/C++STL%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>非转载抄袭，早年知乎文章搬运于此</p></blockquote><h2 id="C-STL容器用法"><a href="#C-STL容器用法" class="headerlink" title="C++STL容器用法"></a>C++STL容器用法</h2><p><img src="https://pic1.zhimg.com/v2-a7d6f66d59d5a83496ec8b4b2b16a382_720w.jpg?source=d16d100b" alt="img"></p><h2 id="1-序列式容器"><a href="#1-序列式容器" class="headerlink" title="1.序列式容器"></a>1.序列式容器</h2><h3 id="1-1容器概观与分类"><a href="#1-1容器概观与分类" class="headerlink" title="1.1容器概观与分类"></a>1.1容器概观与分类</h3><p><img src="https://picx.zhimg.com/v2-70a79ae983d2ec3e2225537b3e7f21f9_720w.jpg?source=d16d100b" alt="img"></p><p>顺序容器是C++标准库提供的一类容器，它们按照元素在容器中的顺序进行存储和访问。顺序容器内的元素以线性的方式排列，因此可以通过迭代器按顺序遍历、插入和删除元素。</p><p>与关联式容器（如 set、map）不同，顺序容器并不要求元素具有固定的排序关系或唯一的键。相反，顺序容器仅根据元素在容器中的插入顺序来组织元素。</p><h2 id="2-vector"><a href="#2-vector" class="headerlink" title="2 vector"></a>2 vector</h2><h3 id="【1】简介："><a href="#【1】简介：" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p>1,vector是表示可变大小数组的序列容器。</p><p>2,就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</p><p>3,本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。</p><p>4,vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。</p><p>5,与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。</p><h3 id="【2】vector声明及初始化"><a href="#【2】vector声明及初始化" class="headerlink" title="【2】vector声明及初始化"></a>【2】<strong>vector声明及初始化</strong></h3><blockquote><p><strong>头文件：#include<vector></strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;<span class="hljs-comment">//声明一个int型向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<span class="hljs-comment">//声明一个初始大小为5的int向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//声明一个初始大小为10且值都是1的向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(tmp)</span></span>;<span class="hljs-comment">//声明并用tmp向量初始化vec向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(vec.begin(), vec.begin() + <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//用向量vec的第0个到第2个值初始化tmp</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(arr, arr + <span class="hljs-number">5</span>)</span></span>;<span class="hljs-comment">//将arr数组的元素用于初始化vec向量</span><br><span class="hljs-comment">//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，</span><br><span class="hljs-comment">//这个主要是为了和vec.end()指针统一。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(&amp;arr[<span class="hljs-number">1</span>], &amp;arr[<span class="hljs-number">4</span>])</span></span>; <span class="hljs-comment">//将arr[1]~arr[4]范围内的元素作为vec的初始值</span><br></code></pre></td></tr></table></figure><blockquote><p>在创建好空容器的基础上，还可以通过调用 reserve() 成员函数来增加容器的容量：vec.reserve(20);</p></blockquote><h3 id="【3】方法"><a href="#【3】方法" class="headerlink" title="【3】方法"></a>【3】方法</h3><p><strong>1，iterators（迭代器）</strong></p><p><img src="https://picx.zhimg.com/v2-c80217b237cf9d77f721dc56a0a5798c_720w.jpg?source=d16d100b" alt="img"></p><p><strong>2,Capacity（容量）</strong></p><p><img src="https://picx.zhimg.com/v2-ee35399437f353543f36a1b641d2d5a8_720w.jpg?source=d16d100b" alt="img"></p><p><strong>3,Element access（元素访问）</strong></p><p><img src="https://picx.zhimg.com/v2-3cedd542872b26e36370fc848858baad_720w.jpg?source=d16d100b" alt="img"></p><p><strong>4,Modifiers（修改器）</strong></p><p><img src="https://picx.zhimg.com/v2-77080d4ff97b41cb07bc3884cbf6ecf0_720w.jpg?source=d16d100b" alt="img"></p><p><strong>常见具体使用：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs text">//push_back和pop_back用法简单<br>vector&lt;int&gt; arr;<br>for (int i = 0; i &lt; 5; i++)<br>&#123;<br>    arr.push_back(i);<br>&#125;<br>for (int i = 0; i &lt; 5; i++)<br>&#123;<br>    arr.pop_back();<br>&#125;<br><br>arr.emplace(10);<br><br>//在arr的头部插入值为10的元素<br>vector&lt;int&gt; arr;<br>arr.insert(arr.begin(), 10);<br><br>vector&lt;int&gt; arr&#123;1, 2, 3, 4, 5&#125;;<br>//删除arr开头往后偏移两个位置的元素，即arr的第三个元素，3<br>arr.erase(arr.begin() + 2);<br>//删除arr.begin()到arr.begin()+2之间的元素，删除两个;即删除arr.begin()而不到arr.begin()+2的元素<br>arr.erase(arr.begin(), arr.begin() + 2);<br><br>//将arr修改为范围[arrs.begin, arrs.end]内的元素<br>vector&lt;int&gt; arr = &#123;5, 4, 3, 2, 1&#125;;<br>vector&lt;int&gt; arrs = &#123; 1, 2, 3, 4, 5 &#125;;<br>arr.assign(arrs.begin(), arrs.end());<br><br>//扩容<br>vector&lt;int&gt; arr;<br>for (int i = 0; i &lt; 20; i++)<br>&#123;<br>    arr.push_back(i);<br>    cout &lt;&lt; arr.size() &lt;&lt; &quot; &quot; &lt;&lt; arr.capacity() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【4】常用算法"><a href="#【4】常用算法" class="headerlink" title="【4】常用算法"></a>【4】常用算法</h3><p>1，遍历元素</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">vector&lt;int&gt;::iterator it;<br>for (it = vec.begin(); it != vec.end(); it++)<br>    cout &lt;&lt; *it &lt;&lt; endl;<br>//或者<br>for (size_t i = 0; i &lt; vec.size(); i++) &#123;<br>cout &lt;&lt; vec.at(i) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>2，元素翻转</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">#include &lt;algorithm&gt;<br>reverse(vec.begin(), vec.end());<br></code></pre></td></tr></table></figure><p>3，元素排序</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">#include &lt;algorithm&gt;<br>sort(vec.begin(), vec.end()); //采用的是从小到大的排序<br>//如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法:<br>bool Comp(const int&amp; a, const int&amp; b) &#123;<br>return a &gt; b;<br>&#125;<br>sort(vec.begin(), vec.end(), Comp);<br></code></pre></td></tr></table></figure><h3 id="【5】适用场景"><a href="#【5】适用场景" class="headerlink" title="【5】适用场景"></a>【5】适用场景</h3><p>需要频繁在末尾插入和删除元素，并且不需要在中间或头部插入删除。</p><p>需要高效地进行随机访问，即通过索引访问元素。</p><p>元素数量会动态变化，但不会经常在中间或头部插入删除。</p><h2 id="3-list"><a href="#3-list" class="headerlink" title="3 list"></a>3 list</h2><h3 id="【1】简介：-1"><a href="#【1】简介：-1" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p>1，list是C++STL容器中的顺序容器，这里的顺序容器区别于关联容器，指的是元素在容器中的位置与大小无关。list和vector不同，vector是顺序存储的，内存是连续的；list底层实际上是双向链表，list的内存是分散的，内存可以在各个位置分布。</p><p>2，基于双向链表的数据结构，list具有array、vector、deque等不具备的优势：在任意位置插入和删除元素的时间复杂度O(1)，移动元素的效率也很高。因为元素之间是通过指针联系的，在某个元素间插入一个元素改变那指针的指向就可以了。</p><p>3，但是正因为底层是双向链表，无法像vector那样通过**下标[]**直接访问元素，需要从头（尾）遍历元素找到元素。</p><blockquote><p>如果需要大量数据的插入和删除，而对数据的随机访问比较少，使用list是个不错的选择。</p></blockquote><p><img src="https://picx.zhimg.com/v2-f578b4c1827630dc77c9263613cbf46d_720w.jpg?source=d16d100b" alt="img"></p><p>list 双向链表容器的存储结构示意图</p><h3 id="【2】list声明及初始化"><a href="#【2】list声明及初始化" class="headerlink" title="【2】list声明及初始化"></a>【2】list声明及初始化</h3><blockquote><p>头文件：#include<list></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">list&lt;int&gt; a; // 定义一个int类型的列表a<br>list&lt;int&gt; a(10); // 定义一个int类型的列表a，并设置初始大小为10<br>list&lt;int&gt; a(10, 1); // 定义一个int类型的列表a，并设置初始大小为10且初始值都为1<br>list&lt;int&gt; b(a); // 定义并用列表a初始化列表b<br>deque&lt;int&gt; b(a.begin(), ++a.end()); // 将列表a中的第1个元素作为列表b的初始值<br><br>int n[] = &#123; 1, 2, 3, 4, 5 &#125;;//使用数组来初始化向量<br>list&lt;int&gt; a(n, n + 5); // 将数组n的前5个元素作为列表a的初值<br></code></pre></td></tr></table></figure><h3 id="【3】方法-1"><a href="#【3】方法-1" class="headerlink" title="【3】方法"></a>【3】方法</h3><p>1<strong>，iterators（迭代器）</strong></p><p><em>同vector一致，往后不加赘述</em></p><p>2<strong>，Capacity（容量）</strong></p><p><img src="https://pic1.zhimg.com/v2-68a492b995869ac844e67e3f4b86213f_720w.jpg?source=d16d100b" alt="img"></p><p>3，<strong>Element access（元素访问）</strong></p><p><img src="https://picx.zhimg.com/v2-8aaffc4fd57951134721962dcbd213c9_720w.jpg?source=d16d100b" alt="img"></p><p>4,<strong>Modifiers（修改器）</strong></p><p><img src="https://picx.zhimg.com/v2-8c38383dccfd54ea1a0ff135a4fae821_720w.jpg?source=d16d100b" alt="img"></p><p>5,<strong>list operations</strong>：</p><p><img src="https://picx.zhimg.com/v2-40a9e2be34cd3d17b374dd742cbd34d1_720w.jpg?source=d16d100b" alt="img"></p><p>具体常见用法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs text">//从当前容器的某个迭代器开始，将另一个list容器的某个元素加入当前容器，<br>//splice的用法其实和insert很像，不过splice只能操作list，而insert可以是其他类型的容器。<br>list&lt;int&gt; values = &#123;4, 5, 6&#125;;<br>list&lt;int&gt; values2 = &#123; 1, 2, 3 &#125;;<br>values.splice(values.begin(), values2, values2.begin());//最后values = &#123;1,4,5,6&#125;<br><br>//remove：删除值为val的所有元素<br>list&lt;int&gt; values = &#123;1, 2, 3, 1, 2, 3&#125;;<br>values.remove(2);//values = &#123;1,3,1,3&#125;<br><br>//unique可以删除list容器中相邻的相同元素，只留下一个。注意，是相邻的相同元素，不相邻的即使之前出现也不会删除的。<br>list&lt;int&gt; values = &#123;1, 1, 2, 2, 3, 4, 3&#125;;<br>values.unique();//values = &#123;1,2,3,4,3&#125;<br><br>//sort顾名思义就是排序，和算法中的sort一致。<br>//用法，直接对整个list排序，默认升序；降序输入参数：greater&lt; int &gt;()<br>list&lt;int&gt; values = &#123;1, 9, 2, 2, 3, 4, 3&#125;;<br>values.sort();//升序<br>values.sort(greater&lt;int&gt;());//降序<br><br>//合并两个实现已经排好序的list容器，两者合并后的list容器仍然是有序的。<br>list&lt;int&gt; values = &#123; 1,3,5 &#125;;<br>list&lt;int&gt; values2 = &#123; 2, 4, 6 &#125;;<br>values.merge(values2);<br><br>//将list容器中的元素翻转。<br>list&lt;int&gt; values = &#123; 1,3,5 &#125;;<br>values.reverse();//values = &#123;5,3,1&#125;<br></code></pre></td></tr></table></figure><h3 id="【4】对比vector"><a href="#【4】对比vector" class="headerlink" title="【4】对比vector"></a>【4】对比vector</h3><p>1,vector有size和capacity，一个是当前容器大小，另一个是可以存储容器大小；而list只有size，因为list不需要扩容，所以不需要提前预留空间。</p><p>2,vector访问容器可以通过下标[]和at，而list只能直接访问头部和尾部元素，访问某个具体元素需要遍历list。</p><p>3,因为list是双向链表，可以从头部加入元素，而vector只能尾部插入。</p><p>4,list内置了一些算法中的方法，如：sort、reverse，并且可以轻松删除元素：remove、remoce_if；而vector并不具备。</p><p>总的来说，list相对于vector，插入和删除简单，访问难。</p><p><img src="https://pica.zhimg.com/v2-a65e73e0324bb4982ed613734383cd05_720w.jpg?source=d16d100b" alt="img"></p><blockquote><p>再次注意:list没有提供[]和at()！！！！</p></blockquote><h3 id="【5】适用场景-1"><a href="#【5】适用场景-1" class="headerlink" title="【5】适用场景"></a>【5】适用场景</h3><p>需要频繁在中间或头部插入和删除元素。</p><p>不需要进行随机访问，而是通过迭代器遍历容器元素。</p><p>元素数量会动态变化，且需要高效地进行插入和删除操作。</p><h2 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h2><h3 id="【1】简介：-2"><a href="#【1】简介：-2" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p><code>std::deque</code>（双端队列）是 C++ 标准库中的一个容器类，它代表了一个动态大小的双向队列。Deque 表示”double-ended queue”，它允许在两端进行高效的插入和删除操作。</p><p>与 <code>std::vector</code> 不同，<code>std::deque</code> 的内部实现并非连续存储的数组，而是一系列连续的存储块，每个块都是独立分配的。这使得 <code>std::deque</code> 能够在两端快速执行插入和删除操作，不需要移动整个队列的元素。</p><p><code>std::deque</code> 提供了以下一些重要的特性和操作：</p><p>1，动态大小：<code>std::deque</code> 具有动态大小的能力，可以根据需要自动增加或减小。</p><p>2，快速插入和删除：相对于 <code>std::vector</code>，<code>std::deque</code> 在头部和尾部进行插入和删除操作的时间复杂度是常数级别的，即 O(1)。</p><p>3，随机访问：与 <code>std::vector</code> 类似，<code>std::deque</code> 支持通过索引进行随机访问，可以以常数时间 O(1) 访问指定位置的元素。</p><p>4，双向迭代器：<code>std::deque</code> 提供了双向迭代器，可以遍历从头到尾或者从尾到头的元素序列。</p><p>5，低效的中间插入和删除：相对于头部和尾部的操作，<code>std::deque</code> 在中间进行插入和删除操作的时间复杂度是线性级别的，即 O(n)，因为它需要移动元素块。</p><p>总的来说，<code>std::deque</code> 是一个灵活、高效的容器，特别适用于需要频繁在两端进行插入和删除操作的场景。它可以作为 <code>std::vector</code> 的替代选择，提供更好的性能和扩展性。</p><p><img src="https://pic1.zhimg.com/v2-62424a0865a17d39cb344b2de83a7744_720w.jpg?source=d16d100b" alt="img"></p><blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p></blockquote><h3 id="【2】deque声"><a href="#【2】deque声" class="headerlink" title="【2】deque声"></a>【2】deque声</h3><blockquote><p>头文件：#include<deque></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">deque&lt;int&gt; a; // 定义一个int类型的双端队列a<br>deque&lt;int&gt; a(10); // 定义一个int类型的双端队列a，并设置初始大小为10<br>deque&lt;int&gt; a(10, 1); // 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1<br>deque&lt;int&gt; b(a); // 定义并用双端队列a初始化双端队列b<br>deque&lt;int&gt; b(a.begin(), a.begin()+3); // 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值<br><br>int n[] = &#123; 1, 2, 3, 4, 5 &#125;;<br>// 将数组n的前5个元素作为双端队列a的初值<br>// 说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，<br>// 这个主要是为了和deque.end()指针统一。<br>deque&lt;int&gt; a(n, n + 5); <br>deque&lt;int&gt; a(&amp;n[1], &amp;n[4]); // 将n[1]、n[2]、n[3]作为双端队列a的初值<br></code></pre></td></tr></table></figure><h3 id="【3】方法-2"><a href="#【3】方法-2" class="headerlink" title="【3】方法"></a>【3】方法</h3><p>deque 与 vector 的用法基本一致，除了以下几处不同：</p><ul><li>deque 没有 capacity() 函数，而 vector 有；</li><li>deque 有 push_front() 和 pop_front() 函数，而 vector 没有；</li><li>deque 没有 data()和reserve() 函数，而 vector 有。</li></ul><blockquote><p>和 array、vector 相同，<a href="http://link.zhihu.com/?target=http://c.biancheng.net/cplus/">C++</a>11 标准库新增的 begin() 和 end() 这 2 个全局函数也适用于 deque 容器。这 2 个函数的操作对象既可以是容器，也可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的<a href="http://link.zhihu.com/?target=http://c.biancheng.net/c/80/">指针</a>，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p></blockquote><h3 id="【4】适用场景"><a href="#【4】适用场景" class="headerlink" title="【4】适用场景"></a>【4】适用场景</h3><p>需要频繁在头部和尾部插入和删除元素，并且需要高效地进行这些操作。<br>需要随机访问元素，即通过索引访问元素。<br>元素数量会动态变化，但不会经常在中间插入删除。</p><p><img src="https://pic1.zhimg.com/v2-7e27da091bfba07269fd7dd5f946577e_720w.jpg?source=d16d100b" alt="img"></p><p>5 <strong>总结</strong></p><p>(1) vector</p><p>内部数据结构：数组。</p><p>随机访问每个元素，所需要的时间为常量。</p><p>在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化。</p><p>可动态增加或减少元素，内存管理自动完成，但程序员可以使用reserve()成员函数来管理内存。</p><p>vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过capacity()-size()个元素插入vector中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。</p><p>(2)deque</p><p>内部数据结构：数组。</p><p>随机访问每个元素，所需要的时间为常量。</p><p>在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化。</p><p>可动态增加或减少元素，内存管理自动完成，不提供用于内存管理的成员函数。</p><p>增加任何元素都将使deque的迭代器失效。在deque的中间删除元素将使迭代器失效。在deque的头或尾删除元素时，只有指向该元素的迭代器失效。</p><p>(3)list</p><p>内部数据结构：双向环状链表。</p><p>不能随机访问一个元素。</p><p>可双向遍历。</p><p>在开头、末尾和中间任何地方增加或删除元素所需时间都为常量。</p><p>可动态增加或减少元素，内存管理自动完成。</p><p>增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</p><p><strong>6 比较选择</strong></p><p>仅仅作为Map使用：采用静态数组</p><p>保存定长数据，使用时也是全部遍历：采用动态数组（长度一开始就固定的话静态数组也行）</p><p>保存不定长数组，需要动态增加的能力，侧重于寻找数据的速度：采用vector</p><p>保存不定长数组，需要动态增加的能力，侧重于增加删除数据的速度：采用list</p><p>对数据有复杂操作，即需要前后增删数据的能力，又要良好的数据访问速度：采用deque</p><p>对数据中间的增删操作比较多：采用list，建议在排序的基础上，批量进行增删可以对运行效率提供最大的保证</p><p>注意：</p><p>对于 vector 和 deque，使用随机访问时注意不要越界；</p><p>对于 vector 的非尾部插入删除和 deque的非首尾插入删除，会导致部分元素的移动，这是需要考虑之前正在用的迭代器、指针或索引是否需要调整；</p><blockquote><p>由于篇幅限制，本文只涉及到STL常见容器使用详解，如果你对<strong>STL其他内容</strong>感兴趣或者<strong>想要深入探讨容器的实现的细节</strong>，可以在评论区发“111”或者具体的哪一部分，我将结合STL源码深入解析并尽快更新。</p></blockquote><p><img src="https://pica.zhimg.com/v2-97d3679c5080f76b60a6b620f7dddefa_720w.jpg?source=d16d100b" alt="img"></p><p>参考文章：<a href="http://link.zhihu.com/?target=http://t.csdn.cn/uAGqm">http://t.csdn.cn/uAGqm</a></p><p><a href="http://link.zhihu.com/?target=https://www.cnblogs.com/yrm1160029237/p/10291315.html">C++–STL之vector, list, deque容器对比与常用函数</a></p><h2 id="1-关联式容器"><a href="#1-关联式容器" class="headerlink" title="1.关联式容器"></a>1.关联式容器</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><p>关联式容器是C++标准库提供的一类容器，它们以”键”（key）和”值”（value）的形式存储和访问数据。关联式容器使用键来唯一标识每个元素，并根据键来进行快速的查找、插入和删除操作。</p><p>与顺序容器（如 vector、list）不同，关联式容器内部的元素并不按照它们在容器中的位置进行存储。相反，关联式容器使用特定的数据结构（例如二叉搜索树、哈希表）来组织元素，以便能够在常数时间复杂度或对数时间复杂度内执行查找操作。</p><p>关联式容器提供了以下几个重要的特点：</p><p>1，唯一键：关联式容器中的键是唯一的，不允许重复的键存在。这意味着每个键只能对应一个值。</p><p>2，自动排序（有序关联式容器）：某些关联式容器（如 set、map）会根据键的大小进行排序。这样，元素被插入容器时会自动按照顺序进行排列。</p><p>3，快速查找：通过键来查找元素时，关联式容器提供了高效的查找算法，使得查找操作具有较快的速度。</p><p>4，高效的插入和删除：与顺序容器相比，关联式容器在插入和删除元素时通常具有更高的效率。然而，具体的性能取决于容器的类型及实际使用情况。</p><p>关联式容器的一些常见用途包括索引、字典、集合等。通过使用关联式容器，我们可以根据键快速查找对应的值，而无需遍历整个容器。</p><h2 id="2-map"><a href="#2-map" class="headerlink" title="2 map"></a>2 map</h2><p>前提：</p><p>1、pair类型</p><p><code>std::pair</code> 是 C++ 标准库中定义的模板类，用于将两个值组合在一起形成一个对偶（pair）。每个 <code>std::pair</code> 对象都包含两个公共成员变量：<code>first</code> 和 <code>second</code>。通常有以下的一些定义和初始化的一些方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">pair&lt;T1, T2&gt; p;<br>pair&lt;T1, T2&gt; p(v1, v2);<br>make_pair(v1, v2)<br></code></pre></td></tr></table></figure><p>上述第一种方法是定义了一个空的pair对象p，第二种方法是定义了包含初始值为v1和v2的pair对象p。第三种方法是以v1和v2值创建的一个新的pair对象。</p><p>1.2、pair对象的一些操作</p><p>除此之外，pair对象还有一些方法，如取出pair对象中的每一个成员的值：</p><ul><li><code>p.first</code></li><li><code>p.second</code></li></ul><h3 id="【1】简介：-3"><a href="#【1】简介：-3" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p>1，std::map是一种关联容器，即以key-value键值对的形式存储数据。</p><p>2，map底层实现是红黑树，而C++11新增容器unordered_map与map用法基本一致，但底层是：哈希表。</p><p>3，红黑树是一种平衡二叉树，而平衡二叉树在二叉排序树基础上的，所以红黑树也就有排序的特性（unordered_map没有排序）。可以做到在O(log n)时间内完成查找，插入和删除，在对单次时间敏感的场景下比较建议使用map做为容器。</p><p>4，作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。</p><p>5，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序</p><p>6，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改</p><h3 id="【2】map声明及初始化"><a href="#【2】map声明及初始化" class="headerlink" title="【2】map声明及初始化"></a>【2】map声明及初始化</h3><blockquote><p>头文件：#include<map></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs text">//map是键-值对的组合，有以下的一些定义的方法：<br>map&lt;k, v&gt; m;<br>map&lt;k, v&gt; m(m2);<br>map&lt;k, v&gt; m(b, e);<br><br>std::map&lt;std::string, int&gt;myMap;//通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器<br><br>std::map&lt;std::string, int&gt;myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;;//当然在创建 map 容器的同时，也可以进行初始化<br><br>//再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：<br>std::map&lt;std::string, int&gt;myMap&#123;std::make_pair(&quot;C语言教程&quot;,10),std::make_pair(&quot;STL教程&quot;,20)&#125;;<br><br>//在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。<br>std::map&lt;std::string, int&gt;newMap(myMap);<br><br>//map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。<br>std::map&lt;std::string, int&gt;myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;;<br>std::map&lt;std::string, int&gt;newMap(++myMap.begin(), myMap.end());<br><br>//C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数<br>#创建一个会返回临时 map 对象的函数<br>std::map&lt;std::string,int&gt; disMap() &#123;<br>    std::map&lt;std::string, int&gt;tempMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;;<br>    return tempMap;<br>&#125;<br>//调用 map 类模板的移动构造函数创建 newMap 容器<br>std::map&lt;std::string, int&gt;newMap(disMap());<br></code></pre></td></tr></table></figure><h3 id="【3】方法-3"><a href="#【3】方法-3" class="headerlink" title="【3】方法"></a>【3】方法</h3><p>1，iterators</p><p><img src="https://pic1.zhimg.com/v2-3de50f418bf59ed81fca28a27c6effb6_720w.jpg?source=d16d100b" alt="img"></p><p>2，capacity</p><p><img src="https://pica.zhimg.com/v2-65b549b1002bbfb8ea6e828ebd775909_720w.jpg?source=d16d100b" alt="img"></p><p>3，Element access</p><p><img src="https://pica.zhimg.com/v2-b286a197cde980904f3dcf32e2535054_720w.jpg?source=d16d100b" alt="img"></p><p>4，Modifiers</p><p><img src="https://pic1.zhimg.com/v2-f5f8338569006d40e2748dd8f5a05246_720w.jpg?source=d16d100b" alt="img"></p><p>5，Operations</p><p><img src="https://pic1.zhimg.com/v2-fc3393ea466d4dba0a0b813c41455b6a_720w.jpg?source=d16d100b" alt="img"></p><p>具体常见用法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs text">//map中元素的插入<br>#include &lt;stdio.h&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>int main()&#123;<br>        map&lt;int, int&gt; mp;<br>        for (int i = 0; i &lt; 10; i ++)&#123;<br>                mp[i] = i;<br>        &#125;<br>        for (int i = 10; i &lt; 20; i++)&#123;<br>                mp.insert(make_pair(i, i));<br>        &#125;<br>        map&lt;int, int&gt;::iterator it;<br>        for (it = mp.begin(); it != mp.end(); it++)&#123;<br>                printf(&quot;%d--&gt;%d\n&quot;, it-&gt;first, it-&gt;second);<br>        &#125;<br>        return 0;<br>&#125;<br><br>//map中元素的查找和读取<br>#include &lt;stdio.h&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>int main()&#123;<br>        map&lt;int, int&gt; mp;<br>        for (int i = 0; i &lt; 20; i++)&#123;<br>                mp.insert(make_pair(i, i));<br>        &#125;<br><br>        if (mp.count(0))&#123;<br>                printf(&quot;yes!\n&quot;);<br>        &#125;else&#123;<br>                printf(&quot;no!\n&quot;);<br>        &#125;<br><br>        map&lt;int, int&gt;::iterator it_find;<br>        it_find = mp.find(0);<br>        if (it_find != mp.end())&#123;<br>                it_find-&gt;second = 20;<br>        &#125;else&#123;<br>                printf(&quot;no!\n&quot;);<br>        &#125;<br><br>        map&lt;int, int&gt;::iterator it;<br>        for (it = mp.begin(); it != mp.end(); it++)&#123;<br>                printf(&quot;%d-&gt;%d\n&quot;, it-&gt;first, it-&gt;second);<br>        &#125;<br>        return 0;<br>&#125;<br><br>//从map中删除元素<br>#include &lt;stdio.h&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>int main()&#123;<br>        map&lt;int, int&gt; mp;<br>        for (int i = 0; i &lt; 20; i++)&#123;<br>                mp.insert(make_pair(i, i));<br>        &#125;<br><br>        mp.erase(0);<br><br>        mp.erase(mp.begin());<br><br>        map&lt;int, int&gt;::iterator it;<br>        for (it = mp.begin(); it != mp.end(); it++)&#123;<br>                printf(&quot;%d-&gt;%d\n&quot;, it-&gt;first, it-&gt;second);<br>        &#125;<br><br><br>        return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考文章：<a href="http://link.zhihu.com/?target=http://t.csdn.cn/MWXQs">http://t.csdn.cn/MWXQs</a></p><h3 id="【4】适用场景-1"><a href="#【4】适用场景-1" class="headerlink" title="【4】适用场景"></a>【4】适用场景</h3><p>1，字典&#x2F;映射：std::map 可以用作字典或映射结构，其中每个键与一个值相关联。通过键的快速查找，可以有效地检索、插入和删除与特定键相关联的值。</p><p>2，数据索引：<code>std::map</code> 可用于构建索引，例如按照姓名、学号或其他唯一标识符对数据进行索引。通过使用键进行快速检索，可以避免遍历整个数据集。</p><p>3，有序操作：由于 <code>std::map</code> 内部的元素是有序的，因此它适用于需要按键进行顺序遍历或查找的场景。例如，可以使用 <code>std::map</code> 实现计划表、时间线等应用。</p><p>需要注意的是，与其他容器相比，<code>std::map</code> 在插入和删除元素时的性能可能较低。如果不需要自动排序的特性，或者关注更高的插入和删除性能，可以考虑使用 <code>std::unordered_map</code>（哈希表）作为替代方案。</p><h2 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h2><h3 id="【1】简介：-4"><a href="#【1】简介：-4" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p><code>std::set</code> 是 C++ 标准库中的一个关联式容器，它按有序方式存储唯一元素的集合。<code>std::set</code> 中的元素自动按照严格弱序（Strict Weak Ordering）排序，并且每个元素都是唯一的。这意味着 <code>std::set</code> 中的元素是按照特定顺序排列并且不会存在重复值。</p><p>下面是一些 <code>std::set</code> 的特点和用途：</p><p>1，自动排序：<code>std::set</code> 内部使用红黑树（一种自平衡的二叉搜索树）实现，因此元素在容器中按照严格弱序排序。这使得元素能够以有序的方式存储，方便进行遍历和搜索操作。</p><p>2，唯一性：<code>std::set</code> 中的元素是唯一的，相同的元素只会在容器中存在一个副本。这可以确保每个元素在集合中的唯一性。</p><p>3，插入和查找效率高：由于 <code>std::set</code> 内部使用红黑树实现，插入和查找元素的时间复杂度为 O(log n)，其中 n 是容器中的元素数目。这使得 <code>std::set</code> 适合于需要高效地插入和查找元素的情况。</p><p>2，集合运算：<code>std::set</code> 还提供了一些方便的集合操作，如并集、交集、差集等。可以使用这些操作对多个 <code>std::set</code> 进行组合和操作。</p><h3 id="【2】set声明及初始化"><a href="#【2】set声明及初始化" class="headerlink" title="【2】set声明及初始化"></a>【2】set声明及初始化</h3><blockquote><p>头文件：#include <set></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">//调用默认构造函数，创建空的 set 容器<br>std::set&lt;std::string&gt; myset;<br>//除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化<br>std::set&lt;std::string&gt; myset&#123;&quot;/java/&quot;,&quot;/stl/&quot;,&quot;/python/&quot;&#125;;<br>// set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。<br>std::set&lt;std::string&gt; copyset(myset);<br>//在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器<br>std::set&lt;std::string&gt; myset&#123; &quot;/java/&quot;，&quot;/stl/&quot;,&quot;/python/&quot; &#125;;<br>std::set&lt;std::string&gt; copyset(++myset.begin(), myset.end())<br></code></pre></td></tr></table></figure><h3 id="【3】方法-4"><a href="#【3】方法-4" class="headerlink" title="【3】方法"></a>【3】方法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">begin();            // 返回指向第一个元素的迭代器<br>end();              // 返回指向迭代器的最末尾处（即最后一个元素的下一个位置）<br>clear();           // 清除所有元素<br>count();            // 返回某个值元素的个数<br>empty();            // 如果集合为空，返回true<br>equal_range();      //返回集合中与给定值相等的上下限的两个迭代器<br>erase()–删除集合中的元素<br>find()–返回一个指向被查找到元素的迭代器<br>get_allocator()–返回集合的分配器<br>insert()–在集合中插入元素<br>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器<br>key_comp()–返回一个用于元素间值比较的函数<br>max_size()–返回集合能容纳的元素的最大限值<br>rbegin()–返回指向集合中最后一个元素的反向迭代器<br>rend()–返回指向集合中第一个元素的反向迭代器<br>size()–集合中元素的数目<br>swap()–交换两个集合变量<br>upper_bound()–返回大于某个值元素的迭代器<br>value_comp()–返回一个用于比较元素间的值的函数<br></code></pre></td></tr></table></figure><h3 id="【4】适用场景-2"><a href="#【4】适用场景-2" class="headerlink" title="【4】适用场景"></a>【4】适用场景</h3><p><code>std::set</code> 在 C++ 中是一个非常常用的容器，适用于各种场景。以下是一些使用 <code>std::set</code> 的典型场景：</p><p>1，唯一元素的集合：<code>std::set</code> 中的元素是唯一的，它会自动去重，这使得它非常适合存储一组需要保持唯一性的元素。例如，存储用户的唯一标识符、集合中不重复的字符串等。</p><p>2，元素的有序存储：<code>std::set</code> 使用红黑树实现，可以确保元素以严格弱序（Strict Weak Ordering）进行排序。这使得 <code>std::set</code> 适用于需要按照特定顺序存储元素，并能够高效地进行查找、遍历和范围操作的场景。</p><p>3，频繁的插入和查找操作：由于 <code>std::set</code> 内部使用红黑树实现，插入和查找元素的平均时间复杂度为 O(log n)，其中 n 是容器中的元素数目。这使得 <code>std::set</code> 在需要频繁进行插入和查找操作的情况下非常高效。</p><p>4，集合运算：<code>std::set</code> 提供了方便的集合操作，如并集、交集、差集等。它可以与其他 <code>std::set</code> 容器进行组合和操作，方便地进行集合运算。</p><p>5，中间插入和删除操作：与 <code>std::vector</code> 不同，<code>std::set</code> 中插入和删除操作不会导致元素的移动，这对于大型元素或者需要保持迭代器稳定性的场景非常有用。插入和删除操作的时间复杂度为 O(log n)。</p><p>综上所述，<code>std::set</code> 是一个适用于需要存储唯一、有序元素并且需要高效插入、查找和集合操作的场景。它提供了方便的接口和良好的性能，是 C++ 标准库中常用的容器之一。</p><p>参考文章：<a href="http://link.zhihu.com/?target=http://c.biancheng.net/stl/map_set/">C++ STL关联式容器详解</a></p><p><a href="http://link.zhihu.com/?target=https://blog.csdn.net/yas12345678/article/details/52601454?fromshare=blogdetail">C++中set用法详解_c++ set_Donny-You的博客-CSDN博</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++指针详解</title>
    <link href="/2022/09/02/%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/09/02/%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>非抄袭，早年知乎文章搬运于此</p></blockquote><h1 id="C-C-指针详解"><a href="#C-C-指针详解" class="headerlink" title="C&#x2F;C++指针详解"></a>C&#x2F;C++指针详解</h1><p><img src="https://pica.zhimg.com/v2-dd4431b0606973940b96b4f11452591b_720w.jpg?source=d16d100b" alt="一文彻底搞懂C/C++指针（超详细-小白专属）"></p><h2 id="1-变量的内存实质"><a href="#1-变量的内存实质" class="headerlink" title="1.变量的内存实质"></a>1.变量的内存实质</h2><p>要理解 C 指针，我认为一定要理解 C 中“变量”的存储实质，所以我就从”变量“这个东西开始讲起吧</p><p><strong>1.1C语言中变量的实质</strong></p><p><img src="https://pica.zhimg.com/v2-fbd84fae64bae5bfcd9b0302af56ccb3_720w.jpg?source=d16d100b" alt="img"></p><p>内存空间</p><p>正如电影院给座位编号，内存作为一个存放数据的空间。自然也要编号，这就是我们所说的<strong>内存编址</strong></p><p>内存是按一个字节接着一个字节的次序进行编址，如上图所示。每个字节都有个编号，我们称之为<strong>内存地址</strong></p><p>接着看以下的 C&#x2F;C++语言变量声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i;<br><span class="hljs-type">char</span> a;<br></code></pre></td></tr></table></figure><p>每次我们要使用某变量时都要事先这样声明它，它其实是内存中申请了一个名为 i 的整型变量宽度的空间（DOS 下的 16 位编程中其宽度为 2 个字节），和一个名为 a 的字符型变量宽度的空间（占 1 个字节）</p><p><img src="https://pica.zhimg.com/v2-df82fc18beece731c7783157f9dcff11_720w.jpg?source=d16d100b" alt="img"></p><p>内存映像</p><p><strong>1.2赋值给变量</strong></p><p>再看如下赋值:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">i=<span class="hljs-number">30</span>;<br>a=<span class="hljs-string">&#x27;t&#x27;</span>;<br></code></pre></td></tr></table></figure><p>形象化理解如下：</p><p><img src="https://picx.zhimg.com/v2-9c59a56a58d861d3f244101df902c222_720w.jpg?source=d16d100b" alt="img"></p><p><strong>1.3变量在哪里？</strong></p><p>学习指针时，经常看到 &amp;i ,我们可以这样读它：返回 i 变量的地址编号。以上图的内存映象为例，屏幕上显示的不是 i 值 30，而是显示 i 的内存地址编号 6 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br> <span class="hljs-type">int</span> i = <span class="hljs-number">39</span>; <br> <span class="hljs-built_in">printf</span>(“%d\n”, i); <span class="hljs-comment">/*①*/</span> <br> <span class="hljs-built_in">printf</span>(“%d\n”, &amp;i); <span class="hljs-comment">/*②*/</span> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>现在你可知道①、②两个 printf 分别在屏幕上输出的是 i 的什么东西啊?</p><p>好啦！下面我们就开始真正进入指针的学习了。</p><h2 id="2-指针是什么？"><a href="#2-指针是什么？" class="headerlink" title="2.指针是什么？"></a>2.指针是什么？</h2><p>指针在很多初学者眼里是座高山，进而将其妖魔化。其实无论从生活还是内存的角度都是平常易懂的。</p><blockquote><p>生活上的例子：<br>比如说你要我借给你一本书，我到了你宿舍，但是 你人不在宿舍，于是我把书放在你的 2 层 3 号的书架上，并写了一张纸条放在你的桌上。纸条上写着：你要的书在第 2 层 3 号的书架上。当你回来时，看到这张纸条，你就知道了我借与你的书放在哪了。你想想看，这张纸条的作用，纸条本身不是书，它上面也没有放着书。那么你又如何知道书的位置呢？因为纸条上写着书的位置嘛！其实这张纸条就是一个指针了。</p></blockquote><p>下面看一条声明一个<strong>指向整型变量</strong>的指针的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *pi;<br></code></pre></td></tr></table></figure><blockquote><p>注意：指针本身也只是个变量，与上一篇中说的变量并没有实质的区别。不信你看下图：</p></blockquote><p><img src="https://pic1.zhimg.com/v2-89b43e00998fcf6aeedddeb4c5eaba87_720w.jpg?source=d16d100b" alt="img"></p><p>再如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pi = &amp;i;<br></code></pre></td></tr></table></figure><p>这是返回 i 变量的地址编 号。整句的意思就是把 i 地址的编号赋值给 pi，也就是你在 pi 里面写上 i 的地址编号。</p><p><img src="https://pic1.zhimg.com/v2-dfbfa81c5b02bad4e8f4d338d3db4a89_720w.jpg?source=d16d100b" alt="img"></p><p>你看，执行完 pi&#x3D;&amp;i 后，在图示中的内存中，pi 的值是 6。这个 6 就是 i 变量的地址编号，这样 pi 就指向了变量 i 了。你看，pi 与那张纸条有什么区别？pi 不就是那张纸条嘛！上面写着 i 的地址，而 i 就是那个本书。你现在看 懂了吗？因此，我们就把 pi 称为指针。所以你要记住，指针变量所存的内容就是内存的地址编号！</p><h2 id="3-指针与数组名"><a href="#3-指针与数组名" class="headerlink" title="3.指针与数组名"></a>3.指针与数组名</h2><p>数组名其实也就是指针，但指针是指针变量，而数组名只是一个指针常量（其值是不能修改的，因此不能类似这样操作：a++）。</p><h2 id="4-const-int-pi与int-const-pi-的区别"><a href="#4-const-int-pi与int-const-pi-的区别" class="headerlink" title="4.const int *pi与int *const pi 的区别"></a>4.const int *pi与int *const pi 的区别</h2><p>开始之前先了解一下const</p><blockquote><p>在C语言中，<code>const</code> 是一个关键字，用于声明常量。<br>声明为 <code>const</code> 的变量表示其值在程序执行期间不能被修改，即它是不可变的。<code>const</code> 可以用于以下几种情况：<br>声明常量：使用 <code>const</code> 关键字可以声明一个常量，并且要在声明时进行初始化。例如：<code>const int MAX_SIZE = 100;</code><br>函数参数：在函数的参数列表中，使用 <code>const</code> 关键字可以指定某个参数是只读的，即函数内部不会修改该参数的值。这样做可以增加代码的可读性和安全性。例如：<code>void printArray(const int arr[], int size);</code><br>指针类型：在指针类型前面加上 <code>const</code> 关键字，可以声明一个指向常量的指针。这意味着通过该指针不能修改所指向的值，但可以修改指针本身。例如：<code>const int* ptr;</code><br>常量指针：在指针变量前加上 <code>const</code> 关键字，可以声明一个常量指针，即指针本身是不可修改的，但可以修改所指向的值。例如：<code>int* const ptr;</code><br>常量修饰符：<code>const</code> 关键字也可以用于修饰函数返回类型、结构体成员、全局变量等，表明其为只读的。</p></blockquote><p>在该章中有几个时常令人混淆的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *pi；<span class="hljs-comment">//1</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *pi；<span class="hljs-comment">//2</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> pi；<span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><p>直接给结论：</p><p>1，int 与 const 哪个放前哪个放后都是一样的（const int ic;与 int const ic;一样。也就是说，它们是相同的）</p><blockquote><p>原因：<br>有了 const 修饰的 *pi 我们不称它为变量，而称符号常量</p></blockquote><p>2，如果 const 修饰在<em>pi 前，则不能改的是</em>pi(即不能类似这样：*pi&#x3D;50; 赋值)而不是指 pi。</p><blockquote><p>原因：<br>首先 const 修饰的是整个<em>pi（注意，我写的是</em>pi 而不是 pi）。所以*pi 是常量，是不能被赋值的（虽然 pi 所指的 i2 是变量，不是常量）。 其次，pi 前并没有用 const 修饰，所以 pi 是指针变量，能被赋值重新指 向另一内存地址的。</p></blockquote><p>3，如果 const 是直接写在 pi 前，则 pi 不能改(即不能类似这样：pi&#x3D;&i; 赋值)</p><blockquote><p>原因：<br>1）pi 因为有了 const 的修饰，所以只是一个指针常量：也就是说 pi 值 是不可修改的（即 pi 不可以重新指向 i2 这个变量了）（请看第 4 行的注释）。<br>2）整个<em>pi 的前面没有 const 的修饰。也就是说，</em>pi 是变量而不是常 量，所以我们可以通过*pi 来修改它所指内存 i1 的值<br>总之一句话，这次的 pi 是一个指向 int 变量类型数据的指针常量</p></blockquote><p><strong>补充：</strong></p><p>情况一：int *pi 指针指向 const int i 常量的情况</p><blockquote><p>注意事项：const int 类型的 i的地址是不能赋值给指向 int 类型地址的指 针 pi 的。否则 pi 岂不是能修改 i1 的值了吗！</p></blockquote><p>情况二：const int *pi 指针指向 const int i1 的情况</p><blockquote><p>两个类型相同，可以这样赋值。很显然，i1 的值无论是通过 pi 还是 i1 都不能修改的。</p></blockquote><p>情况三：用 const int *const pi 声明的指针</p><blockquote><p>pi 值不能改，也不能通过 pi 修改 i 的值。因为不管是*pi 还是 pi 都是 const 的。</p></blockquote><h2 id="5-函数参数的传递"><a href="#5-函数参数的传递" class="headerlink" title="5.函数参数的传递"></a>5.函数参数的传递</h2><h3 id="【1】值传递"><a href="#【1】值传递" class="headerlink" title="【1】值传递"></a>【1】值传递</h3><p>在开始之前先做一道题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Exchg1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-comment">/* 定义中的x,y变量被称为Exchg1函数的形式参数 */</span> <br>&#123; <br>   <span class="hljs-type">int</span> tmp; <br>   tmp = x; <br>   x = y; <br>   y = tmp; <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d, y = %d.\n&quot;</span>, x, y); <br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>     <span class="hljs-type">int</span> a = <span class="hljs-number">4</span>,b = <span class="hljs-number">6</span>; <br>     Exchg1(a, b); <span class="hljs-comment">/*a,b 变量为 Exchg1 函数的实际参数。*/</span> <br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d.\n”, a, b); </span><br><span class="hljs-string">     return 0; </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>输出结果： x &#x3D; 6, y &#x3D; 4. a &#x3D; 4, b &#x3D; 6.</p><p>奇怪，明明我把 a、b 分别代入了 x、y 中，并在函数里完成了两个变量值 的交换，为什么 a，b 变量值还是没有交换（仍然是 a &#x3D; 4、b &#x3D; 6，而不是 a &#x3D; 6、b &#x3D; 4）？如果你也会有这个疑问，那是因为你根本就不知实参 a、b 与形参 x，y 的关系了。</p><p>Exchg1(a, b)时所完成的操作代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = a; <span class="hljs-comment">/* ← */</span> <br><span class="hljs-type">int</span> y = b; <span class="hljs-comment">/* ← 注意这里，头两行是调用函数时的隐含操作 */</span> （让我们产生了前述的迷惑）<br><span class="hljs-type">int</span> tmp; <br>tmp = x; <br>x = y; <br>y = tmp;<br></code></pre></td></tr></table></figure><p><strong>原来 ，其实函数在调用时是隐含地把实参 a、b 的值分别赋值给了 x、y， 之后在你写的 Exchg1 函数体内再也没有对 a、b 进行任何的操作了。交换的只 是 x、y 变量。并不是 a、b。当然 a、b 的值没有改变啦！函数只是把 a、b 的 值通过赋值传递给了 x、y，函数里头操作的只是 x、y 的值并不是 a、b 的值。 这就是所谓的参数的值传递了</strong></p><h3 id="【2】地址传递"><a href="#【2】地址传递" class="headerlink" title="【2】地址传递"></a><strong>【2】地址传递</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Exchg2</span><span class="hljs-params">(<span class="hljs-type">int</span> *px, <span class="hljs-type">int</span> *py)</span> <br>&#123; <br>   <span class="hljs-type">int</span> tmp = *px; <br>   *px = *py; <br>   *py = tmp; <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*px = %d, *py = %d.\n&quot;</span>, *px, *py); <br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>     <span class="hljs-type">int</span> a = <span class="hljs-number">4</span>; <br>     <span class="hljs-type">int</span> b = <span class="hljs-number">6</span>; <br>     Exchg2(&amp;a, &amp;b); <br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d.\n”, a, b); </span><br><span class="hljs-string">     return 0; </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>输出结果: *px &#x3D; 6, *py &#x3D; 4. a &#x3D; 6, b &#x3D; 4.</p><p>同理调用Exchg2(&amp;a,&amp;b)时发生隐含操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">px = &amp;a; <span class="hljs-comment">/* ← */</span> <br>py = &amp;b; <span class="hljs-comment">/* ← 请注意这两行，它是调用 Exchg2 的隐含动作。*/</span><br></code></pre></td></tr></table></figure><p><strong>这样，有了头两行的隐含赋值操作。我们现在已经可以看出，指针 px、py 的值已经分别是 a、b 变量的地址值了。接下来，对*px、*py 的操作当然也就 是对 a、b 变量本身的操作了。所以函数里头的交换就是对 a、b 值的交换了， 这就是所谓的地址传递</strong></p><h3 id="【3】引用传递"><a href="#【3】引用传递" class="headerlink" title="【3】引用传递"></a><strong>【3】引用传递</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Exchg3</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> <span class="hljs-comment">/* 注意定义处的形式参数的格式与值传递不同 */</span> <br>&#123; <br>     <span class="hljs-type">int</span> tmp = x; <br>     x = y; <br>     y = tmp; <br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d, y = %d.\n&quot;</span>, x, y); <br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>   <span class="hljs-type">int</span> a = <span class="hljs-number">4</span>; <br>   <span class="hljs-type">int</span> b = <span class="hljs-number">6</span>; <br>   Exchg3(a, b); <span class="hljs-comment">/*注意：这里调用方式与值传递一样*/</span> <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d.\n”, a, b); </span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>输出结果： x &#x3D; 6, y &#x3D; 4. a &#x3D; 6, b &#x3D; 4. &#x2F;<em>这个输出结果与值传递不同。</em>&#x2F;</p><p>同值传递一样的隐含操作，<strong>但是 x、y 前都有一个取地址符号“&amp;”。有 了这个，调用 Exchg3 时函数会将 a、b 分别代替了 x、y 了，我们称：x、y 分别引用了 a、b 变量。这样函数里头操作的其实就是实参 a、b 本身了，也就 是说函数里是可以直接修改到 a、b 的值了</strong></p><h3 id="【4】值传递与引用传递"><a href="#【4】值传递与引用传递" class="headerlink" title="【4】值传递与引用传递"></a><strong>【4】</strong>值传递与引用传递</h3><blockquote><p>1）在函数定义格式上有不同： 值传递在定义处是：Exchg1(int x, int y); 引用传递在这义处是：Exchg3(int &amp;x, int &amp;y);<br>2）调用时有相同的格式： 值传递：Exchg1(a, b); 引用传递：Exchg3(a, b);<br>3）功能上是不同的： 值传递的函数里操作的不是 a、b 变量本身，只是将 a、b 值赋给了 x、y。 函数里操作的只是 x、y 变量而不是 a、b，显示 a、b 的值不会被 Exchg1 函数 所修改。 引用传递 Exchg3(a, b)函数里是用 a、b 分别代替了 x、y。函数里操作 的就是 a、b 变量的本身，因此 a、b 的值可在函数里被修改的</p></blockquote><h2 id="6-指向另一指针的指针"><a href="#6-指向另一指针的指针" class="headerlink" title="6.指向另一指针的指针"></a>6.指向另一指针的指针</h2><p>看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">short</span> <span class="hljs-type">int</span> **ppi; <span class="hljs-comment">/* 这是一个指向指针的指针，注意有两个“*”*/</span> <br>*ppi = &amp;pi;<br></code></pre></td></tr></table></figure><p>第一句：short int **ppi; —— 声明了一个指针变量 ppi，这个 ppi 是用来存储（或称指向）一个 short int * 类型指针变量的地址。</p><p>第二句：&amp;pi 那就是取 pi 的地址，**ppi &#x3D; &amp;pi 就是把 pi 的地址赋给 了 ppi。即将地址值 9 赋值给 ppi。</p><p>如下图：</p><p><img src="https://pic1.zhimg.com/v2-e7e71db20a1832c8f9ee0534206976a7_720w.jpg?source=d16d100b" alt="img"></p><blockquote><p>从图中看出，指针变量 ppi 的内容就是指针变量 pi 的起始地址。于是……<br>ppi 的值是多少呢？—— 9。<br>*ppi 的值是多少呢？—— 5，即 pi 的值。<br>*<em>ppi 的值是多少呢？——50，即 i 的值，也是</em>pi 的值。</p></blockquote><h2 id="7-函数名与函数指针"><a href="#7-函数名与函数指针" class="headerlink" title="7.函数名与函数指针"></a>7.函数名与函数指针</h2><p>就像某一数据变量的内存地址可以存储在相应的指针变量中一样，函数的首地址也以存储在某个函数指针变量里的。这样，我就可以通过这个函数指针变量来调用所指向的函数了。</p><blockquote><p>函数指针变量的声明：<br>void (<em>FunP)(int) ; &#x2F;</em> 也可写成 void (<em>FunP)(int x)</em>&#x2F;<br>通过函数指针变量调用函数：<br>MyFun &#x3D; &FunP; &#x2F;* 将 FunP 函数的地址赋给 MyFun 变量 *&#x2F;<br>(<em>FunP)(20); &#x2F;</em> （★）这是通过函数指针变量 FunP 来调用 MyFun 函数的。 *&#x2F;</p></blockquote><p><strong>函数指针可作为某个函数的参数</strong></p><blockquote><p>函数指针可以像普通变量一样作为函数的参数进行传递。具体步骤如下：<br>1.定义函数指针类型：首先需要定义一个函数指针类型，它描述了所指向函数的参数类型和返回类型。例如，<code>typedef void (*FuncPtr)(int);</code> 定义了一个函数指针类型 <code>FuncPtr</code>，它指向一个参数为 <code>int</code>，返回类型为 <code>void</code> 的函数。<br>2.声明函数参数：在函数声明或定义时，将函数指针作为函数的参数之一，参数类型为上一步定义的函数指针类型。例如，<code>void process(FuncPtr func, int data);</code> 声明了一个函数 <code>process</code>，它接受一个函数指针 <code>func</code> 和一个 <code>int</code> 类型的参数 <code>data</code>。<br>3.传递函数指针：在调用函数时，可以将一个符合函数指针类型的函数的地址传递给函数参数。例如，<code>process(myFunction, 42);</code> 将函数 <code>myFunction</code> 的地址和 <code>42</code> 作为参数传递给函数 <code>process</code>。<br>4.在函数内部使用函数指针：在函数内部，可以通过函数指针来调用相应的函数。例如，在 <code>process</code> 函数内部可以通过 <code>func(data)</code> 来调用传入的函数指针所指向的函数。</p></blockquote><p>补充说明一点，在函数的声明处：</p><blockquote><p>void MyFun(int); &#x2F;*不能写成 void (<em>MyFun)(int)。</em>&#x2F;<br>void (*FunP)(int); &#x2F;<em>不能写成 void FunP(int)。</em>&#x2F;</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识JVM</title>
    <link href="/2022/08/21/%E5%88%9D%E8%AF%86JVM/"/>
    <url>/2022/08/21/%E5%88%9D%E8%AF%86JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。java语言跨平台的秘密</p><h1 id="Java如何被JVM所运行？"><a href="#Java如何被JVM所运行？" class="headerlink" title="Java如何被JVM所运行？"></a>Java如何被JVM所运行？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">Java 源文件 --&gt; 编译器 --&gt; .<span class="hljs-keyword">class</span>字节码文件--&gt; 类加载器--&gt;JVM<br></code></pre></td></tr></table></figure><h2 id="1-什么是-class字节码文件？"><a href="#1-什么是-class字节码文件？" class="headerlink" title="1.什么是.class字节码文件？"></a>1.什么是.class字节码文件？</h2><p>在 Java 中，JVM 可以理解的代码叫作字节码，也就是 .class 文件，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，并且保留了解释型语言可移植的特点，而通过即时编译器（JIT）又有编译型语言执行效率高的特点。所以 Java 程序运行时比较高效，同时 Java 通过字节码文件和虚拟机之间的关系，实现了平台无关性，一次编译，各平台都可运行。</p><p><a href="https://www.cnblogs.com/code-duck/p/13568004.html#%E4%BA%8C-class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">Class文件结构（详细解读） - codeduck - 博客园</a></p><h3 id="1-1-class文件与java源代码中的class类有什么联系和区别？"><a href="#1-1-class文件与java源代码中的class类有什么联系和区别？" class="headerlink" title="1.1 .class文件与java源代码中的class类有什么联系和区别？"></a>1.1 .class文件与java源代码中的class类有什么联系和区别？</h3><h2 id="2-怎么编译成-class字节码文件？"><a href="#2-怎么编译成-class字节码文件？" class="headerlink" title="2.怎么编译成.class字节码文件？"></a>2.怎么编译成.class字节码文件？</h2><p><a href="https://blog.csdn.net/weixin_44688973/article/details/125757836">Java文件是怎么编译成Class文件的_java编译成class-CSDN博客</a></p><p>答：编译原理相关，暂时略过</p><h2 id="3-类加载器工作原理"><a href="#3-类加载器工作原理" class="headerlink" title="3.类加载器工作原理"></a>3.类加载器工作原理</h2><h3 id="3-1-什么是双亲委派机制"><a href="#3-1-什么是双亲委派机制" class="headerlink" title="3.1 什么是双亲委派机制"></a>3.1 什么是双亲委派机制</h3><p>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器。（类加载器之间的父子关系不是以继承的关系实现，而是使用组合关系来复用父加载器的代码）</p><p><img src="https://s2.loli.net/2024/10/04/Klyv9UDehVc4uNT.webp" alt="双亲委派机制"></p><p>如果类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层级的类加载器都是如此，因此所有请求最终都会被传到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。因此，加载过程可以看成自底向上检查类是否已经加载，然后自顶向下加载类。整个过程就是一个递归的过程</p><p>整个过程：</p><ol><li><strong>自定义类加载器</strong>收到类加载请求，首先检查缓存是否已经加载该类。</li><li>如果未找到，则将请求<strong>委派给父类加载器</strong>，父类加载器首先会检查自己是否已经加载过该类（调用 <code>findLoadedClass()</code>）。如果找到，则返回该类，类加载过程结束。如果找不到，则继续将请求委派给其父类加载器</li><li>逐层向上，直到最顶层的<strong>启动类加载器（Bootstrap ClassLoader）</strong>。</li><li><strong>启动类加载器</strong>检查核心类库，能加载则返回，若不能加载则返回 <code>null</code>，传递控制权回给下层加载器。它的<strong>子类加载器</strong>将获得加载类的机会，并且尝试自己去加载该类。加载成功，则类加载过程结束。如果它也无法加载，则返回 <code>null</code>，传递控制权回给下层加载器</li><li>各层加载器依次返回，若父加载器未加载到类，则最底层的<strong>自定义类加载器</strong>通过 <code>findClass()</code> 方法尝试自己加载该类。</li><li>成功加载后，类会被缓存，加载过程结束。如果所有加载器都未能加载，抛出 <code>ClassNotFoundException</code>。</li></ol><p><img src="https://s2.loli.net/2024/10/04/C1XeMY9PkpbfL5F.png" alt="双亲委派"></p><p>双亲委派模型的优点：</p><ol><li><p>使用双亲委派模型来组织类加载器之间的关系，Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p></li><li><p>避免类的重复加载，当父类加载器已经加载了该类时，子类加载器就没必要再加载一次。</p></li><li><p>解决各个类加载器的基础类的统一问题，越基础的类由越上层的加载器进行加载。避免Java核心API中的类被随意替换，规避风险，防止核心API库被随意篡改。</p></li></ol><blockquote><p>例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的 Java 类，可以正常编译，但是永远无法被加载运行。</p></blockquote><h1 id="JVM的组成与运行原理？"><a href="#JVM的组成与运行原理？" class="headerlink" title="JVM的组成与运行原理？"></a>JVM的组成与运行原理？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">.<span class="hljs-keyword">class</span>字节码文件 --&gt; JVM --&gt; 机器码<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/15/zQjNwtq1Ef2UKv3.png" alt="1"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="本地方法栈和程序计数器"><a href="#本地方法栈和程序计数器" class="headerlink" title="本地方法栈和程序计数器"></a>本地方法栈和程序计数器</h3><p>native 修饰的方法就是本地方法，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区（method area）</strong>只是 <strong>JVM 规范</strong>中定义的一个概念，用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="虚拟机栈和虚拟机堆"><a href="#虚拟机栈和虚拟机堆" class="headerlink" title="虚拟机栈和虚拟机堆"></a>虚拟机栈和虚拟机堆</h3><blockquote><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p></blockquote><h4 id="虚拟机栈的生命周期"><a href="#虚拟机栈的生命周期" class="headerlink" title="虚拟机栈的生命周期"></a>虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="虚拟机堆的概念"><a href="#虚拟机堆的概念" class="headerlink" title="虚拟机堆的概念"></a>虚拟机堆的概念</h4><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MetaspaceSize：初始化元空间大小，控制发生<span class="hljs-built_in">GC</span><br>MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。<br></code></pre></td></tr></table></figure><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><ol><li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li>JVM 找到 App 的主程序入口，执行 main 方法</li><li>这个 main 中的第一条语句为 Student student &#x3D; new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li>执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li>执行 sayName()</li></ol><p><a href="https://blog.csdn.net/csdnliuxin123524/article/details/81303711">JVM原理最全、清晰、通俗讲解，五天40小时吐血整理_jvm原理讲解教程最全清晰通俗讲解-CSDN博客</a></p><p>jvm虚拟机位于操作系统的堆中，并且，程序员写好的类加载到虚拟机执行的过程是：当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader，</p><p><strong>java虚拟机的生命周期</strong>：声明周期起点是当一个java应用main函数启动时虚拟机也同时被启动，而只有当在虚拟机实例中的所有非守护进程都结束时，java虚拟机实例才结束生命。</p><p><strong>java虚拟机与main方法的关系</strong>：main函数就是一个java应用的入口，main函数被执行时，java虚拟机就启动了。启动了几个main函数就启动了几个java应用，同时也启动了几个java的虚拟机。</p><p>java的虚拟机种有两种线程，一种叫叫守护线程，一种叫非守护线程（也叫普通线程），main函数就是个非守护线程，虚拟机的gc就是一个守护线程。java的虚拟机中，只要有任何非守护线程还没有结束，java虚拟机的实例都不会退出，所以即使main函数这个非守护线程退出，但是由于在main函数中启动的匿名线程也是非守护线程，它还没有结束，所以jvm没办法退出</p><p>虚拟机的gc（垃圾回收机制）就是一个典型的守护线程。</p><p><img src="https://s2.loli.net/2024/12/16/Vc3OL6JyM5qvz8T.png" alt="fdb281da8c98cc1240281d4520bc947f"></p><h2 id="1-JVM如何将-class字节码文件转化为对应机器的机器码"><a href="#1-JVM如何将-class字节码文件转化为对应机器的机器码" class="headerlink" title="1.JVM如何将.class字节码文件转化为对应机器的机器码"></a>1.JVM如何将.class字节码文件转化为对应机器的机器码</h2><p><a href="https://javaguide.cn/java/jvm/jvm-intro.html">大白话带你认识 JVM | JavaGuide</a></p><p><img src="https://s2.loli.net/2024/12/15/2SNXkfbxFtVypJ7.webp" alt="c602f57ea9297f50bbc265f1821d6263"></p><p><a href="https://www.doc200.com/java-interview/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9FJVM%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%EF%BC%9F.html">8. 什么是Java字节码？JVM如何将字节码转换为机器代码？ | 胖虎Docs</a></p><p>JVM将字节码转换为机器代码的过程主要依赖于其执行引擎。执行引擎负责解释和执行字节码，并将其转换为底层的机器代码，以便在物理硬件上执行。这个过程分为两个主要部分：解释执行和即时编译（JIT）。</p><h4 id="1-解释执行"><a href="#1-解释执行" class="headerlink" title="1. 解释执行"></a>1. 解释执行</h4><p>解释器是JVM的一个组件，它逐行解释字节码，并将其转换为对应的机器码指令，然后在处理器上执行。</p><p>工作原理</p><ul><li>JVM启动时，解释器开始工作，读取字节码指令，并解释成相应的机器码指令。</li><li>每条字节码指令都通过解释器进行解释，然后立即执行。这种方式简单直接，但对于频繁执行的代码（如循环体）效率较低。</li></ul><p>优点</p><ul><li>启动快，解释器立即可以开始执行字节码。</li><li>对于短期任务，解释器可以快速响应。</li></ul><p>缺点</p><ul><li>对于重复执行的代码，解释效率较低，因为每次循环都要重新解释相同的字节码。</li></ul><h4 id="2-即时编译"><a href="#2-即时编译" class="headerlink" title="2. 即时编译"></a>2. 即时编译</h4><p>为了提升程序的运行效率，JVM引入了JIT编译器。JIT编译器在程序运行时将热点代码（频繁执行的代码）编译为本地机器码，并将其缓存起来，以避免重复解释相同的字节码。</p><p>工作原理</p><ul><li>JVM在解释执行字节码的过程中，识别出哪些方法或代码块被频繁执行，称为“热点代码”。</li><li>JIT编译器将这些热点代码一次性编译为平台相关的机器码，存储在内存中。</li><li>当热点代码再次被执行时，JVM直接使用编译后的机器码，而不是通过解释器逐行解释，从而大幅提升执行效率。</li></ul><p>优点</p><ul><li>提升性能：JIT编译后的代码直接以机器码形式执行，性能接近于本地编译的程序。</li><li>逐渐优化：JIT编译器可以随着程序的运行，动态调整和优化编译策略。</li></ul><p>缺点</p><ul><li>编译开销：JIT编译会占用一些系统资源，在程序启动的初期可能导致响应变慢。</li><li>内存占用：编译后的机器码需要在内存中保存。</li></ul><h3 id="JVM的执行模式"><a href="#JVM的执行模式" class="headerlink" title="JVM的执行模式"></a>JVM的执行模式</h3><p>JVM在实际运行过程中，可能会采用解释执行和JIT编译的混合模式。在程序刚启动时，JVM可能更多依赖解释器，而当程序运行时间较长、热点代码较多时，JIT编译器将逐步接管更多的工作，从而提升整体运行效率。</p><h3 id="1-1-什么是Just-In-Time-JIT-编译器？"><a href="#1-1-什么是Just-In-Time-JIT-编译器？" class="headerlink" title="1.1 什么是Just-In-Time (JIT) 编译器？"></a>1.1 什么是Just-In-Time (JIT) 编译器？</h3><p><a href="https://blog.csdn.net/Genmer/article/details/119355224">关于Java的JIT(即时编译器)知识整理_java jit-CSDN博客</a></p><p>解释执行：解释执行是采用匹配执行解释器（解释器是个黑盒，通常也有编译器的组成部分）内部已经编译好的机器码，不是生成新的机器码（也有说法是逐条翻译成机器码？）。 - 由于逐条翻译，程序启动快，但是执行效率不高。</p><p>编译执行：运行期间，通过将字节码编译成对应的新的机器码（会将其缓存起来，通过参数-XX:ReservedCodeCacheSize），然后执行。 - 需要先编译出新的机器指令，所以程序启动较慢，但是执行效率高（因为执行的是机器指令）。</p><p>后来因为解释执行必然比执行编译好的机器指令的执行效率低，所以引入JIT（即时编译器）。在执行时，JIT会把翻译过的机器码保存起来，已备下次使用，因此从理论上来说，采用JIT技术能够在执行效率上，接近曾经纯编译技术。</p><p><strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行</strong>；当程序运行后，随着时间的推移，<strong>编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率</strong>。解释执行可以节约内存，而编译执行可以提升效率。</p><p><a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java即时编译器原理解析及实践 - 美团技术团队</a></p><p><img src="https://s2.loli.net/2024/12/16/ztKTYcNZlQoOGVg.png" alt="ba83857ecf9f344e4972fd551c4973d653952"></p><p><a href="https://javabetter.cn/jvm/jit.html">10 张手绘图 8000 字深入理解 JIT（即时编译器） | 二哥的Java进阶之路</a></p><p><a href="https://www.cnblogs.com/dzhou/p/9549839.html">什么是JIT，写的很好 - ddzh2020 - 博客园</a></p><h2 id="2-GC垃圾回收算法"><a href="#2-GC垃圾回收算法" class="headerlink" title="2.GC垃圾回收算法"></a>2.GC垃圾回收算法</h2><p>暂时略过</p><p><a href="https://blog.csdn.net/Pireley/article/details/134315943">Java进阶（垃圾回收GC）——理论篇：JVM内存模型 &amp; 垃圾回收定位清除算法 &amp; JVM中的垃圾回收器_java的内存模型以及gc算法-CSDN博客</a></p><h1 id="JVM如何与操作系统交互？"><a href="#JVM如何与操作系统交互？" class="headerlink" title="JVM如何与操作系统交互？"></a>JVM如何与操作系统交互？</h1><h2 id="1-什么是JNI"><a href="#1-什么是JNI" class="headerlink" title="1.什么是JNI?"></a>1.什么是JNI?</h2><p>JNI（Java Native Interface，Java本地接口）是 Java 提供的一种接口，允许 Java 程序调用本地（Native）代码或被本地代码调用。所谓本地代码通常是用 C 或 C++ 等语言编写的，并直接与底层硬件或操作系统交互。</p><h2 id="2-JNI工作原理？"><a href="#2-JNI工作原理？" class="headerlink" title="2.JNI工作原理？"></a>2.JNI工作原理？</h2><img src="https://s2.loli.net/2024/12/19/RfgdDQ4ilBIpA8O.jpg" alt="4403ab758e8ee449292962c2ec050ba6" style="zoom:50%;" /><h3 id="Java-调用-Native-代码"><a href="#Java-调用-Native-代码" class="headerlink" title="Java 调用 Native 代码"></a><strong>Java 调用 Native 代码</strong></h3><h4 id="为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？"><a href="#为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？" class="headerlink" title="为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？"></a>为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？</h4><p>这也就是JNI层的表现形式，中间的<strong>JNI层其实也是C++代码，它的作用就是桥梁，在这个C++代码中我们可以调用Java层代码也可以调用Native层的C++代码(天然可以，都是C++)<strong>。由于这里特殊的C++代码，可以把俩种混调用(Java和C++)，所以</strong>JNI有它自己的类型</strong>。例如：</p><ul><li><code>int</code> → <code>jint</code></li><li><code>boolean</code> → <code>jboolean</code></li></ul><p><img src="https://s2.loli.net/2024/12/19/ZSuBchRUQf8GF4O.jpg" alt="3fbc8cdc00c9070bffc0f094ae7792e3"></p><h4 id="本地实现函数的命名规则"><a href="#本地实现函数的命名规则" class="headerlink" title="本地实现函数的命名规则"></a>本地实现函数的命名规则</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- 前缀“Java_”。</span><br><span class="hljs-deletion">- 类的全名。</span><br><span class="hljs-deletion">- 下划线分隔符“_”。</span><br><span class="hljs-deletion">- 方法名字。</span><br><span class="hljs-deletion">- 有方法重载的情况时，还会有两个下划线（“__”），后面跟着参数描述符。</span><br></code></pre></td></tr></table></figure><p>假设 Java 类 <code>com.example.MyClass</code> 中有如下的本地方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>对应的本地方法 C 实现会是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JNIEXPORT </span>void <span class="hljs-keyword">JNICALL </span><span class="hljs-keyword">Java_com_example_MyClass_doSomething(JNIEnv </span>*, <span class="hljs-keyword">jobject);</span><br></code></pre></td></tr></table></figure><p>这样，通过 JNI 约定的命名规则，虚拟机可以根据 Java 方法的名称和参数生成与之匹配的本地方法名称，从而成功调用 C&#x2F;C++ 实现的本地方法。</p><h4 id="类加载器与本地库的关系"><a href="#类加载器与本地库的关系" class="headerlink" title="类加载器与本地库的关系"></a><strong>类加载器与本地库的关系</strong></h4><h5 id="1-本地库绑定到类加载器"><a href="#1-本地库绑定到类加载器" class="headerlink" title="(1) 本地库绑定到类加载器"></a><strong>(1) 本地库绑定到类加载器</strong></h5><ul><li>当一个类调用 <code>System.loadLibrary</code> 或 <code>System.load</code> 加载本地库时，该本地库会被绑定到加载该类的类加载器。</li><li>JVM 会确保一个本地库在同一个类加载器中只加载一次。</li><li>如果两个不同的类加载器加载同一个本地库，会导致冲突或错误。</li></ul><h5 id="2-本地方法的作用域"><a href="#2-本地方法的作用域" class="headerlink" title="(2) 本地方法的作用域"></a><strong>(2) 本地方法的作用域</strong></h5><ul><li>本地库中的方法仅在加载该库的类加载器和其加载的类中可用。</li><li>如果不同类加载器的类需要共享同一个本地库，则需要注意：<ul><li>本地库必须显式加载一次，并由共享的类加载器负责。</li><li>否则可能引发 <code>UnsatisfiedLinkError</code>。</li></ul></li></ul><p><strong>(3) 自定义类加载器的影响</strong></p><p>如果使用自定义类加载器加载一个类，并在该类中调用本地方法：</p><ul><li>自定义类加载器的作用域会限制本地库的使用。</li><li>需要确保本地库文件在正确的路径中，或者显式调用 <code>System.load</code> 指定绝对路径。</li></ul><h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><h5 id="类加载器与本地库的关联"><a href="#类加载器与本地库的关联" class="headerlink" title="类加载器与本地库的关联"></a>类加载器与本地库的关联</h5><p>类加载器在加载 Java 类的字节码（<code>.class</code> 文件）如果发现：</p><ul><li><p><strong>显式关联：</strong> 使用 <code>System.loadLibrary()</code> 或 <code>System.load()</code> 函数显式加载本地库。</p><p>例如，如果 Java 类 <code>MyClass</code> 需要调用一个本地方法 <code>nativeMethod()</code>，则在 <code>static</code> 块或类初始化过程中，可能会显式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;mylibrary&quot;</span>);  <span class="hljs-comment">// 显式加载名为 &quot;mylibrary&quot; 的本地库</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>System.loadLibrary(&quot;mylibrary&quot;)</code> 会将名为 <code>&quot;mylibrary&quot;</code> 的本地库与 <code>MyClass</code> 关联。这时，类加载器就会知道需要加载哪个本地库。</p></li><li><p><strong>隐式关联：</strong> 本地库的加载通常在第一次调用本地方法时自动发生。此时，JVM 会在类加载器关联的路径中搜索本地库，并加载适当的本地库。</p><p>例如，当第一次调用 <code>nativeMethod()</code> 时，JVM 会查找并加载该方法对应的本地库。类加载器会使用它的 <code>nativeLibrary</code> 搜索路径来找到相应的本地库。</p></li></ul><h5 id="类加载器如何与本地库关联"><a href="#类加载器如何与本地库关联" class="headerlink" title="类加载器如何与本地库关联"></a>类加载器如何与本地库关联</h5><p>加载器会维护一个本地库搜索路径，来查找它关联的本地库。这个路径通常是在启动 Java 程序时通过环境变量、Java 参数或类加载器配置进行设置的。类加载器的本地库搜索路径包括：</p><p><strong>系统路径：</strong> 默认情况下，JVM 会在操作系统的标准路径（如 <code>PATH</code> 环境变量中的路径，Windows 上的 <code>.dll</code> 文件路径，Unix&#x2F;Linux 上的 <code>.so</code> 文件路径）中查找本地库。</p><p><strong>指定路径：</strong> 当调用 <code>System.loadLibrary()</code> 时，本地库路径可能会通过 JVM 参数传递（例如 <code>-Djava.library.path</code>）。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">java -Djava.<span class="hljs-keyword">library</span>.path=/path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">library</span> MyClass<br></code></pre></td></tr></table></figure><p>在这个例子中，JVM 会使用 <code>-Djava.library.path</code> 参数指定的路径来搜索本地库。</p><p><strong>类加载器路径：</strong> 每个类加载器（比如 <code>AppClassLoader</code> 或自定义的类加载器）也可能有自己独立的路径来加载本地库。这个路径由类加载器的实现决定。</p><h5 id="本地库加载的时机"><a href="#本地库加载的时机" class="headerlink" title="本地库加载的时机"></a>本地库加载的时机</h5><p>本地库的加载通常发生在第一次调用本地方法时，即在 <strong>链接本地方法时</strong>。这个过程分为几个步骤：</p><ol><li><strong>类加载：</strong> 当 JVM 加载包含本地方法的类时，它会检查该类是否包含 <code>native</code> 方法。如果包含，JVM 就会在后续的调用中解析这个本地方法。</li><li><strong>本地方法调用：</strong> 当 Java 代码首次调用 <code>native</code> 方法时，JVM 会尝试加载与该方法相关联的本地库。</li><li><strong>本地库加载：</strong> JVM 会根据类加载器的配置，搜索本地库。如果找到相应的本地库，JVM 就会将本地方法与本地库中的实现绑定，并建立关联。</li><li><strong>链接成功：</strong> 一旦本地方法被链接，JVM 会创建内部的数据结构（如函数指针或本地方法的映射表），使得后续的调用可以直接跳转到本地库中的对应函数。</li></ol><h3 id="Native-代码调用-Java"><a href="#Native-代码调用-Java" class="headerlink" title="Native 代码调用 Java"></a><strong>Native 代码调用 Java</strong></h3><h4 id="JNIEnv接口指针"><a href="#JNIEnv接口指针" class="headerlink" title="JNIEnv接口指针"></a>JNIEnv接口指针</h4><p>本地代码通过JNIEnv接口指针里暴露的方法来使用虚拟机的功能。</p><p>JNIEnv是一个指向本地线程数据的接口指针，这个指针里面包含了一个指向函数表的指针。每一个接口函数在这表中都有一个 预定义的偏移位置。JNIEnv很像一个C++虚函数表或者Microsoft COM接口。</p><p><img src="https://s2.loli.net/2024/12/19/ZtgFubyJGQTnYMv.png" alt="jnienv"></p><h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>像int、char等这样的基本数据类型，在本地代码和JVM之间进行复制传递，而对象是引用传递的。每一个引用都包含一个指向JVM 中相应的对象的指针，但本地代码不能直接使用这个指针，必须通过引用来间接使用。<br>比起传递直接指针来说，传递引用可以让VM更灵活地管理对象。</p><h5 id="局部引用与全局引用"><a href="#局部引用与全局引用" class="headerlink" title="局部引用与全局引用"></a>局部引用与全局引用</h5><p>JNI可以为本地代码创建两种对象引用：局部引用和全局引用。局部引用的有效期是本地方法的调用期间，调用完成后，局部引用 会被JVM自动铲除。而全局引用，除非显示释放它，否则将一直存在。<br>JVM中的对象作为参数传递给本地方法时，用的是局部引用。大部分的JNI函数返回局部引用。JNI允许程序员从局部引用创建一个 全局引用。接受对象作为参数的JNI函数既支持全局引用也支持局部引用。本地方法执行完毕后，向JVM返回结果时，它可能向JVM 返回局部引用，也可能返回全局引用。<br>局部引用只在创建它的线程内部有效。本地代码不能跨线程传递和使用局部引用。<br>JNI中的NULL引用指向JVM中的null对象。对一个全局引用或者局部引用来说，只要它的值不是NULL，它就不会指向一个null对象。</p><h5 id="局部引用的实现"><a href="#局部引用的实现" class="headerlink" title="局部引用的实现"></a>局部引用的实现</h5><p>一个对象从JVM传递给本地方法时，就把控制权移交了过去，JVM会为每一个对象的传递创建一条记录，一条记录就是一个本地代码 中的引用和JVM中的对象的一个映射。记录中的对象不会被GC回收。所有传递到本地代码中的对象和从JNI函数返回的对象都被自动 地添加到映射表中。当本地方法返回时，VM会删除这些映射，允许GC回收记录中的数据。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用所指向的对象允许JVM回收，当对象被回收以后，弱引用也会被清除。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/Delilah_java/article/details/119778422">一篇JVM详细图解，坚持看完！带你真正搞懂Java虚拟机！_jvm图解-CSDN博客</a></p><p><a href="https://blog.csdn.net/createchance/article/details/53783490">Java Native Interface(JNI)从零开始详细教程_java jni-CSDN博客</a></p><p><a href="https://luori366.github.io/JNI_doc/jni_design_theory.html">JNI的作用与工作原理 | JNI_doc</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语法概览</title>
    <link href="/2022/08/15/JavaScript%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <url>/2022/08/15/JavaScript%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文仅是由于自己经常多语言开发，对于一些语言时常不用感到陌生或者使用中同其他语言用法混淆，故作此文，仅为自己提供一个JavaScript语言使用的知识体系。</p></blockquote><h1 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>ECMAScript是JavaScript的规格或标准，而JavaScript则是ECMAScript标准的一种实现</strong>。 这种关系有点类似于英语和美语的关系，两者都是同一种语言的两种变体</p><ul><li>ECMAScript中的一切（变量、函数名和操作符）都区分大小写</li><li>标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：❏ 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第3章讨论了5种基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的.</p><p>ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用var操作符（注意var是一个关键字），后跟变量名（即一个标识符）【未经过初始化的变量，会保存一个特殊的值——undefined】</p><p>用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    message=<span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// 全局变量</span><br>&#125;<br><span class="hljs-title function_">test</span>();<br><span class="hljs-title function_">alert</span>(message); <span class="hljs-comment">// &quot;hi&quot;</span><br></code></pre></td></tr></table></figure><p>可以使用一条语句定义多个变量，只要像下面这样把每个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> message=<span class="hljs-string">&quot;hi&quot;</span>,<br>    found=<span class="hljs-literal">false</span>,<br>    age=<span class="hljs-number">29</span>;<br></code></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object, Object本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一</p><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined</p><p>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回”object”的原因【实际上，undefined值是派生自null值的】</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是for-in语句的语法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">for (<span class="hljs-keyword">property</span><span class="hljs-title"> </span><span class="hljs-keyword">in</span> expression) statement<br></code></pre></td></tr></table></figure><p>使用label语句可以在代码中添加标签，以便将来使用。以下是label语句的语法：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">label:</span> statement<br></code></pre></td></tr></table></figure><p>with语句的作用是将代码的作用域设置到一个特定的对象中。with语句的语法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">with</span> (expression) <span class="hljs-keyword">statement</span>;<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>ECMAScript中的函数使用function关键字来声明，后跟一组参数以及函数体。函数的基本语法如下所示：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span><span class="hljs-params">(arg0, arg1, <span class="hljs-rest_arg">..., argN</span>)</span> &#123;<br>    statements<br>&#125;<br></code></pre></td></tr></table></figure><p>ECMAScript中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值</p><p>ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型[原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话]</p><p>关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但又没有初始化一样</p><p>ECMAScript函数不能像传统意义上那样实现重载,如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数</p><h3 id="执行环境与作用域"><a href="#执行环境与作用域" class="headerlink" title="执行环境与作用域"></a>执行环境与作用域</h3><p>JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码块都有自己的作用域（如果用ECMAScript的话来讲，就是它们自己的执行环境</p><p><img src="https://s2.loli.net/2024/10/02/MKrtpgRsTC7j85I.jpg" alt="R-C"></p><h4 id="1-执行环境（Execution-Context）"><a href="#1-执行环境（Execution-Context）" class="headerlink" title="1. 执行环境（Execution Context）"></a>1. 执行环境（Execution Context）</h4><p>执行环境是 JavaScript 中代码执行的环境，它包含了代码执行所需的各种信息。每当 JavaScript 执行一段代码时，都会创建一个执行环境。执行环境有三种主要类型：</p><ul><li><p><strong>全局执行环境</strong>：这是代码执行的默认环境。当 JavaScript 引擎启动时，会创建全局执行环境。在浏览器中，全局执行环境是 <code>window</code> 对象；在 Node.js 中，全局执行环境是 <code>global</code> 对象。</p></li><li><p><strong>函数执行环境</strong>：每当一个函数被调用时，都会创建一个新的执行环境。函数执行环境会包含函数的参数、变量、<code>this</code> 值等信息。</p></li><li><p><strong>Eval 执行环境</strong>：如果在 <code>eval</code> 函数中执行代码，则会创建一个特定的执行环境。</p><p><img src="https://s2.loli.net/2024/10/02/7FfLywbVO5mXZ2l.png" alt="R-C"></p></li></ul><h4 id="执行环境的组成部分"><a href="#执行环境的组成部分" class="headerlink" title="执行环境的组成部分"></a>执行环境的组成部分</h4><ul><li><strong>变量环境（Variable Environment）</strong>：用于存储变量和函数声明的环境。</li><li><strong>作用域链（Scope Chain）</strong>：用于访问当前执行环境及其外部环境的链式结构。</li><li><strong><code>this</code> 绑定</strong>：指向当前执行环境的上下文对象。</li></ul><h4 id="2-作用域（Scope）"><a href="#2-作用域（Scope）" class="headerlink" title="2. 作用域（Scope）"></a>2. 作用域（Scope）</h4><p>作用域是代码中可访问变量的区域。JavaScript 的作用域主要分为两种：</p><ul><li><p><strong>全局作用域</strong>：在代码的任何地方都可以访问的作用域。全局作用域的变量通常是附加到全局对象（如 <code>window</code>）上的属性。</p></li><li><p><strong>局部作用域</strong>：在函数内部定义的作用域，仅在该函数内部有效。每个函数都有自己的作用域，函数内部定义的变量在函数外部无法访问。</p></li></ul><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链是一个有序的作用域集合，用于决定当前执行上下文中变量的访问顺序。当访问一个变量时，JavaScript 引擎会首先在当前作用域中查找，如果未找到，则会沿着作用域链向外查找，直到找到该变量或到达全局作用域。</p><h4 id="3-执行环境与作用域的关系"><a href="#3-执行环境与作用域的关系" class="headerlink" title="3. 执行环境与作用域的关系"></a>3. 执行环境与作用域的关系</h4><p>执行环境和作用域是密切相关的。在每个执行环境中，都有一个与之关联的作用域链。当函数被调用时，JavaScript 会创建一个新的执行环境，并为该环境建立一个作用域链，以便能够访问外部变量。</p><h4 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h4><p>以下是一个简单的示例，展示了执行环境和作用域的概念：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;I am a global variable&quot;</span>; <span class="hljs-comment">// 全局变量</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&quot;I am an outer variable&quot;</span>; <span class="hljs-comment">// 外部函数变量</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> innerVar = <span class="hljs-string">&quot;I am an inner variable&quot;</span>; <span class="hljs-comment">// 内部函数变量</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// 可以访问 innerVar</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 可以访问 outerVar</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 可以访问 globalVar</span><br>    &#125;<br><br>    <span class="hljs-title function_">innerFunction</span>();<br>&#125;<br><br><span class="hljs-title function_">outerFunction</span>();<br><br><span class="hljs-comment">// 尝试访问局部变量</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// 报错: outerVar is not defined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// 报错: innerVar is not defined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// 输出: I am a global variable</span><br></code></pre></td></tr></table></figure><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li><code>globalVar</code> 是一个全局变量，可以在任何地方访问。</li><li><code>outerFunction</code> 定义了一个局部变量 <code>outerVar</code>，只能在其内部访问。</li><li><code>innerFunction</code> 定义了自己的局部变量 <code>innerVar</code>，只能在其内部访问，但它可以访问 <code>outerVar</code> 和 <code>globalVar</code>。</li><li>当尝试在全局作用域中访问 <code>outerVar</code> 和 <code>innerVar</code> 时，都会导致错误，因为它们是局部变量，无法在外部访问。</li></ol><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法是这样的。【关于函数声明，它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">arg0, arg1, arg2</span>) &#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;。<br></code></pre></td></tr></table></figure><p>第二种创建函数的方式是使用<strong>函数表达式</strong>。函数表达式有几种不同的语法形式。下面是最常见的一种形式。【这种情况下创建的函数叫做匿名函数】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> functionName=<span class="hljs-keyword">function</span>(<span class="hljs-params">arg0, arg1, arg2</span>)&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-函数声明与函数表达式的关键区别"><a href="#1-函数声明与函数表达式的关键区别" class="headerlink" title="1. 函数声明与函数表达式的关键区别"></a>1. 函数声明与函数表达式的关键区别</h4><table><thead><tr><th>特性</th><th>函数声明</th><th>函数表达式</th></tr></thead><tbody><tr><td>定义方式</td><td><code>function functionName() &#123;&#125;</code></td><td><code>const functionName = function() &#123;&#125;</code></td></tr><tr><td>提升</td><td>会被提升</td><td>不会被提升</td></tr><tr><td>调用顺序</td><td>可以在声明之前调用</td><td>必须在赋值之后调用</td></tr><tr><td>可命名</td><td>必须是命名的</td><td>可以是匿名的或命名的</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数声明示例</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">declaredFunction</span>()); <span class="hljs-comment">// 输出: &quot;I&#x27;m a declared function!&quot;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">declaredFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m a declared function!&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数表达式示例</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">exprFunction</span>()); <span class="hljs-comment">// 报错: exprFunction is not a function</span><br><br><span class="hljs-keyword">var</span> exprFunction = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m an expression function!&quot;</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>好的，下面我将分别解释这三点内容，帮助你更好地理解 JavaScript 中的匿名函数、闭包、作用域以及私有成员的概念。</p><h4 id="2-匿名函数和闭包"><a href="#2-匿名函数和闭包" class="headerlink" title="2.匿名函数和闭包"></a>2.匿名函数和闭包</h4><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>匿名函数是没有名字的函数，通常用于临时的、一次性的操作。它可以直接作为参数传递给其他函数，或在定义时立即执行。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is an anonymous function!&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个匿名函数作为 <code>setTimeout</code> 的参数。</p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>闭包是指一个函数（内层函数）可以“记住”并访问其外部作用域中的变量，即使在外部函数已经返回的情况下。闭包通常在创建匿名函数时使用，用于实现数据封装和私有变量。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> outerVariable = <span class="hljs-string">&quot;I&#x27;m from outer function!&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVariable); <span class="hljs-comment">// 访问外部函数的变量</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> inner = <span class="hljs-title function_">outerFunction</span>();<br><span class="hljs-title function_">inner</span>(); <span class="hljs-comment">// 输出: &quot;I&#x27;m from outer function!&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>innerFunction</code> 是一个闭包，它能够访问 <code>outerFunction</code> 中的 <code>outerVariable</code>。</p><h4 id="3-JavaScript-没有块级作用域的概念"><a href="#3-JavaScript-没有块级作用域的概念" class="headerlink" title="3. JavaScript 没有块级作用域的概念"></a>3. JavaScript 没有块级作用域的概念</h4><p>JavaScript 主要使用函数作用域而非块级作用域。传统的块（如 <code>if</code>、<code>for</code> 等）中的变量实际上是在包含的函数中创建的，而不是在块内部。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 使用 var 声明</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出: 10，因为 x 在函数作用域中被提升</span><br></code></pre></td></tr></table></figure><p>在这个例子中，变量 <code>x</code> 被声明在 <code>if</code> 块内，但它实际上在包含它的函数作用域中有效。使用 <code>var</code> 声明的变量会被提升，并且不具有块级作用域。</p><p><strong>ES6 引入的块级作用域</strong>：<br>从 ES6 开始，JavaScript 引入了 <code>let</code> 和 <code>const</code>，这两个关键字可以在块级作用域内声明变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>; <span class="hljs-comment">// 使用 let 声明</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 报错: y is not defined，因为 y 只在 if 块内有效</span><br></code></pre></td></tr></table></figure><p>在这个例子中，使用 <code>let</code> 声明的变量 <code>y</code> 只在 <code>if</code> 块内部有效，外部无法访问。</p><h4 id="4-JavaScript-中没有私有成员的概念"><a href="#4-JavaScript-中没有私有成员的概念" class="headerlink" title="4. JavaScript 中没有私有成员的概念"></a>4. JavaScript 中没有私有成员的概念</h4><p>JavaScript 对象的属性默认是公有的，即在对象外部可以访问和修改。然而，JavaScript 允许通过闭包的方式模拟私有变量的概念。</p><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-comment">// 私有变量</span><br>    <span class="hljs-keyword">let</span> age = <span class="hljs-number">0</span>; <span class="hljs-comment">// 通过闭包实现私有变量</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 公有属性</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> age; <span class="hljs-comment">// 通过方法访问私有变量</span><br>    &#125;;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">newAge</span>) &#123;<br>        age = newAge; <span class="hljs-comment">// 通过方法修改私有变量</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">getAge</span>()); <span class="hljs-comment">// 输出: 0</span><br>person.<span class="hljs-title function_">setAge</span>(<span class="hljs-number">30</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">getAge</span>()); <span class="hljs-comment">// 输出: 30</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出: undefined，无法访问私有变量</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>age</code> 是一个私有变量，它不能在 <code>Person</code> 对象外部直接访问。我们通过公有方法 <code>getAge</code> 和 <code>setAge</code> 来访问和修改这个私有变量。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，<strong>引用类型是一种数据结构，用于将数据和功能组织在一起</strong>。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p><p>对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p><p>对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：</p><ul><li>引用类型与传统面向对象程序设计中的类相似，但实现不同；</li><li>Object是一个基础类型，其他所有类型都从Object继承了基本的行为；</li><li>Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；</li><li>Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；</li><li>Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；</li><li>RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。</li></ul><p><strong>函数实际上是Function类型的实例，因此函数也是对象</strong>；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是它们共同的特征：</p><ul><li>每个包装类型都映射到同名的基本类型；</li><li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；</li><li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</li></ul><p>在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。</p><h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><p>ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说<strong>对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。</strong>正因为这样（以及其他将要讨论的原因），我们可以<strong>把ECMAScript的对象想象成散列表</strong>：无非就是一组名值对，其中值可以是数据或函数。每个对象都是基于一个引用类型创建的，这个引用类型</p><p>创建自定义对象方法：</p><p>1.创建一个Object的实例，然后再为它添加属性和方法</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 创建一个空的Object实例<br>var person <span class="hljs-operator">=</span> new Object()<span class="hljs-comment">;</span><br><br>// 添加属性<br>person.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Nicholas&quot;</span><span class="hljs-comment">;</span><br>person.age <span class="hljs-operator">=</span> <span class="hljs-number">29</span><span class="hljs-comment">;</span><br>person.job <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Software Engineer&quot;</span><span class="hljs-comment">;</span><br><br>// 添加方法<br>person.sayName <span class="hljs-operator">=</span> function() &#123;<br>    alert(this.name)<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br><br>// 调用方法<br>person.sayName()<span class="hljs-comment">;  // 会弹出 &quot;</span><br></code></pre></td></tr></table></figure><p>2.<strong>对象字面量</strong>【首选方式】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person=&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br><br><br>    <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>3.虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p><p>假设我们需要创建不同的“人”对象，每个人都有 <code>name</code>、<code>age</code> 和 <code>job</code> 属性，并且拥有 <code>sayName</code> 方法。使用工厂模式来简化对象创建的过程，可以这样实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-keyword">var</span> person = &#123;&#125;;<br>    person.<span class="hljs-property">name</span> = name;<br>    person.<span class="hljs-property">age</span> = age;<br>    person.<span class="hljs-property">job</span> = job;<br>    person.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> person;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><br>person1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br>person2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// 输出 &quot;Greg&quot;</span><br><br></code></pre></td></tr></table></figure><p>4.在使用工厂模式时，每次创建的对象是相互独立的，并不会共享同一个原型上的方法，因此对于<strong>方法的复用</strong>来说，工厂模式效率不高。如果有大量对象需要创建并且共享方法，使用构造函数模式或 ES6 的 <code>class</code> 会更合适。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-comment">// 为新创建的对象添加 name 属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;    <span class="hljs-comment">// 为新创建的对象添加 age 属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;    <span class="hljs-comment">// 为新创建的对象添加 job 属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 为新创建的对象添加 sayName 方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用构造函数创建新对象</span><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><br><span class="hljs-comment">// 调用对象的方法</span><br>person1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br>person2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// 输出 &quot;Greg&quot;</span><br><br><br></code></pre></td></tr></table></figure><p>5.为了解决构造函数模式中方法重复的问题，可以使用 JavaScript 的<strong>原型（prototype）</strong>机制。通过将方法定义在构造函数的原型上，所有实例可以共享这些方法，而不需要为每个实例创建单独的副本。【我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;<br>&#125;<br><br><span class="hljs-comment">// 将方法定义在原型上，以便所有实例共享</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><br>person1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// 输出 &quot;Nicholas&quot;</span><br>person2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// 输出 &quot;Greg&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>在JavaScript中，属性类型（Property Types）指的是对象属性的特性或行为控制方式。每个属性不仅仅是一个简单的键值对，它还包含了一些元数据，用来定义这个属性的行为。这些元数据包括属性的可配置性、可枚举性、可写性等。【属性类型与对象的关系可以类比为<strong>对象是房子，而属性类型决定了房子里的物品如何使用</strong>。】</p><p>JavaScript对象的属性有两种主要类型：</p><ol><li><strong>数据属性（Data Property）</strong></li><li><strong>访问器属性（Accessor Property）</strong></li></ol><h4 id="1-数据属性（Data-Property）"><a href="#1-数据属性（Data-Property）" class="headerlink" title="1. 数据属性（Data Property）"></a>1. <strong>数据属性（Data Property）</strong></h4><p>数据属性是最常见的一种属性类型，它直接包含值。数据属性有四个特性来控制它的行为：</p><ul><li>**[[Configurable]]**：表示该属性是否可以通过<code>delete</code>删除，或者是否可以修改其特性（默认值是<code>true</code>）。</li><li>**[[Enumerable]]**：表示该属性是否可以通过<code>for...in</code>循环枚举（默认值是<code>true</code>）。</li><li>**[[Writable]]**：表示该属性的值是否可以被修改（默认值是<code>true</code>）。</li><li>**[[Value]]**：属性的实际值，默认是<code>undefined</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>  <span class="hljs-comment">// 这是一个数据属性</span><br>&#125;;<br><br><span class="hljs-comment">// 可以通过Object.defineProperty修改其特性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不允许删除属性</span><br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 允许通过for...in枚举</span><br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,     <span class="hljs-comment">// 不允许修改值</span><br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>    <span class="hljs-comment">// 属性的值</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// &quot;Nicholas&quot;</span><br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;      <span class="hljs-comment">// 修改无效，因为writable为false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 仍然是 &quot;Nicholas&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="2-访问器属性（Accessor-Property）"><a href="#2-访问器属性（Accessor-Property）" class="headerlink" title="2. 访问器属性（Accessor Property）"></a>2. <strong>访问器属性（Accessor Property）</strong></h4><p>访问器属性不包含实际的值，而是通过getter和setter函数来读取和写入值。这些函数在访问属性时会自动执行。访问器属性有四个特性：</p><ul><li>**[[Configurable]]**：表示是否可以通过<code>delete</code>删除，或者是否可以修改其特性（默认值是<code>true</code>）。</li><li>**[[Enumerable]]**：表示该属性是否可以通过<code>for...in</code>循环枚举（默认值是<code>true</code>）。</li><li>**[[Get]]**：读取属性时调用的函数。如果未定义，读取属性将返回<code>undefined</code>。</li><li>**[[Set]]**：写入属性时调用的函数。如果未定义，属性不能被写入值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">_age</span>: <span class="hljs-number">25</span>,  <span class="hljs-comment">// 私有属性，只能通过getter和setter访问</span><br><br>    <span class="hljs-comment">// 定义getter，访问age时调用</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">age</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span>;<br>    &#125;,<br><br>    <span class="hljs-comment">// 定义setter，修改age时调用</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">newValue</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newValue &gt; <span class="hljs-number">0</span> &amp;&amp; newValue &lt; <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_age</span> = newValue;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Invalid age&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 访问age属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 25</span><br><br><span class="hljs-comment">// 修改age属性</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 30</span><br><br><span class="hljs-comment">// 设置无效的age</span><br>person.<span class="hljs-property">age</span> = -<span class="hljs-number">5</span>;          <span class="hljs-comment">// 输出 &quot;Invalid age&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="数据属性与访问器属性的区别"><a href="#数据属性与访问器属性的区别" class="headerlink" title="数据属性与访问器属性的区别"></a><strong>数据属性与访问器属性的区别</strong></h4><ul><li><strong>数据属性</strong>直接存储值，可以通过简单的赋值和读取操作来使用。</li><li><strong>访问器属性</strong>依赖于getter和setter方法，在读取和写入时可以执行特定的逻辑，而不是直接存储值。</li></ul><p><strong>其他</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用Object.getOwnPropertyDescriptor()来查看属性的详细特性信息：</span><br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(person, <span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor);<br><span class="hljs-comment">// 输出: &#123; value: &#x27;Nicholas&#x27;, writable: true, enumerable: true, configurable: true &#125;</span><br><span class="hljs-comment">//--------------------------------------------------------</span><br><br><span class="hljs-comment">//使用Object.defineProperty()或Object.defineProperties()来定义或修改属性的特性：</span><br><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-comment">// 定义一个新属性name，且不可修改</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// &quot;Nicholas&quot;</span><br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;      <span class="hljs-comment">// 修改无效，因为writable为false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 仍然是 &quot;Nicholas&quot;</span><br><br><span class="hljs-comment">//定义了一个Object.definePro-perties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应</span><br><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-comment">// 使用 Object.defineProperties() 同时定义多个属性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(person, &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">age</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-number">29</span>,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 访问属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// &quot;Nicholas&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>);   <span class="hljs-comment">// 29</span><br><span class="hljs-comment">// 尝试修改 job 属性</span><br>person.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Doctor&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">job</span>);   <span class="hljs-comment">// 仍然是 &quot;Software Engineer&quot;，因为writable为false</span><br></code></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的</p><p><strong>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性</strong>，<strong>这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。</strong>就拿前面的例子来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性____proto____，而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p><p><strong>允许对象通过原型属性访问其他对象的属性和方法。每个对象都有一个原型对象</strong>（通过 <code>__proto__</code> 或 <code>prototype</code>），而这个原型对象本身也有自己的原型对象，这样就形成了一个链式结构，称为原型链。【想象你去一家餐厅点餐，但当天这家店某些食材缺货，店员告诉你，他们的合作伙伴餐厅有这些食材。如果合作伙伴餐厅也没有，再找它的合作伙伴。这个过程类似于在 JavaScript 中通过原型链查找属性或方法。】</p><p><img src="https://s2.loli.net/2024/10/02/vVZGu3nPmbH9cYB.jpg" alt="OIP-C"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 基础构造函数 Person</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 在 Person 的原型上添加方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-comment">// 继承构造函数 Developer</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Developer</span>(<span class="hljs-params">name, age, language</span>) &#123;<br>    <span class="hljs-comment">// 调用 Person 构造函数，初始化 name 和 age</span><br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);  <span class="hljs-comment">// 绑定 this 到 Developer 的实例</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">language</span> = language;        <span class="hljs-comment">// 添加特有属性 language</span><br>&#125;<br><br><span class="hljs-comment">// 通过原型链实现继承</span><br><span class="hljs-title class_">Developer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// 设置 Developer.prototype 的构造函数指向 Developer</span><br><span class="hljs-title class_">Developer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Developer</span>;<br><br><span class="hljs-comment">// 在 Developer 的原型上添加方法</span><br><span class="hljs-title class_">Developer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayLanguage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;I program in &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">language</span>);<br>&#125;;<br><br><span class="hljs-comment">// 创建 Developer 实例</span><br><span class="hljs-keyword">var</span> dev1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Developer</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>);<br><span class="hljs-keyword">var</span> dev2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Developer</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;Python&#x27;</span>);<br><br><span class="hljs-comment">// 调用方法</span><br>dev1.<span class="hljs-title function_">sayHello</span>();      <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br>dev1.<span class="hljs-title function_">sayLanguage</span>();   <span class="hljs-comment">// 输出: I program in JavaScript</span><br><br>dev2.<span class="hljs-title function_">sayHello</span>();      <span class="hljs-comment">// 输出: Hello, my name is Bob</span><br>dev2.<span class="hljs-title function_">sayLanguage</span>();   <span class="hljs-comment">// 输出: I program in Python</span><br><br></code></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>ECMAScript是JavaScript的核心，但如果要在Web中使用JavaScript，那么BOM（浏览器对象模型）则无疑才是真正的核心。BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关</p><p>浏览器对象模型（BOM）以window对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。BOM的组成部分有 ：</p><ul><li>在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames集合中，可以通过位置或通过名称来访问。</li><li>有一些窗口指针，可以用来引用其他框架，包括父框架。</li><li>top对象始终指向最外围的框架，也就是整个浏览器窗口。</li><li>parent对象表示包含当前框架的框架，而self对象则回指window。</li><li>使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。</li><li>调用replace()方法可以导航到一个新URL，同时该URL会替换浏览器历史记录中当前显示的页面。</li><li>navigator对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。</li></ul><p>BOM中还有两个对象：screen和history，但它们的功能有限。screen对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>BOM Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 使用 window 对象</span></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Welcome to the JavaScript BOM!&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 使用 document 对象</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Document Title: &quot;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&quot;New Title&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> paragraph = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;p&quot;</span>);</span><br><span class="language-javascript">        paragraph.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;This is a new paragraph added to the document.&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(paragraph);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 使用 navigator 对象</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Browser Name: &quot;</span> + navigator.<span class="hljs-property">appName</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Browser Version: &quot;</span> + navigator.<span class="hljs-property">appVersion</span>);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-comment">// 使用 screen 对象</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Screen Width: &quot;</span> + screen.<span class="hljs-property">width</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Screen Height: &quot;</span> + screen.<span class="hljs-property">height</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 使用 location 对象</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Current URL: &quot;</span> + location.<span class="hljs-property">href</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// location.href = &quot;https://www.example.com&quot;; // 重定向示例</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分</p><p>DOM是语言中立的API，用于访问和操作HTML和XML文档。DOM1级将HTML和XML文档形象地看作一个层次化的节点树，可以使用JavaScript来操作这个节点树，进而改变底层文档的外观和结构。</p><p>DOM由各种节点构成，简要总结如下。</p><ul><li>最基本的节点类型是Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node。</li><li>Document类型表示整个文档，是一组分层节点的根节点。在JavaScript中，document对象是Document的一个实例。使用document对象，有很多种方式可以查询和取得节点。</li><li>Element节点表示文档中的所有HTML或XML元素，可以用来操作这些元素的内容和特性。</li><li>另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA区域和文档片段。</li></ul><p>访问DOM的操作在多数情况下都很直观，不过在处理<script>和<style>元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用innerHTML时，以及在创建新元素时的一些问题。理解DOM的关键，就是理解DOM对性能的影响。DOM操作往往是JavaScript程序中开销最大的部分，而因访问NodeList导致的问题为最多。NodeList对象都是“动态的”，这就意味着每次访问NodeList对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少DOM操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.highlight</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Hello, DOM!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;changeColorBtn&quot;</span>&gt;</span>Change Color<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addParagraphBtn&quot;</span>&gt;</span>Add Paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 选择节点</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> titleElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> contentDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;content&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 修改节点内容</span></span><br><span class="language-javascript">        titleElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;Welcome to the DOM!&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 添加点击事件以更改颜色</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;changeColorBtn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            titleElement.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 添加段落</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;addParagraphBtn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> newParagraph = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="language-javascript">            newParagraph.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;This is a new paragraph added to the content.&quot;</span>;</span><br><span class="language-javascript">            contentDiv.<span class="hljs-title function_">appendChild</span>(newParagraph);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>JavaScript 的事件是用户与网页交互的基础，可以触发各种行为。例如，用户的点击、键盘输入、鼠标移动等都会引发相应的事件。事件处理是构建交互式网页的重要部分，能够让网页响应用户的行为。</p><h3 id="1-事件的基本概念"><a href="#1-事件的基本概念" class="headerlink" title="1. 事件的基本概念"></a>1. 事件的基本概念</h3><ul><li><strong>事件</strong>：用户与浏览器的交互，例如点击按钮、移动鼠标、按下键盘等。</li><li><strong>事件处理</strong>：通过 JavaScript 编写的代码，以响应特定事件。</li></ul><h3 id="2-常见的事件类型"><a href="#2-常见的事件类型" class="headerlink" title="2. 常见的事件类型"></a>2. 常见的事件类型</h3><table><thead><tr><th><strong>事件类型</strong></th><th><strong>事件名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>鼠标事件</strong></td><td><code>click</code></td><td>单击鼠标。</td></tr><tr><td></td><td><code>dblclick</code></td><td>双击鼠标。</td></tr><tr><td></td><td><code>mouseover</code></td><td>鼠标指针移到元素上。</td></tr><tr><td></td><td><code>mouseout</code></td><td>鼠标指针移出元素。</td></tr><tr><td><strong>键盘事件</strong></td><td><code>keydown</code></td><td>按下键盘键。</td></tr><tr><td></td><td><code>keyup</code></td><td>释放键盘键。</td></tr><tr><td></td><td><code>keypress</code></td><td>在按下键盘键并保持时触发（已不推荐使用）。</td></tr><tr><td><strong>表单事件</strong></td><td><code>submit</code></td><td>表单提交时触发。</td></tr><tr><td></td><td><code>change</code></td><td>输入字段的值变化时触发。</td></tr><tr><td></td><td><code>focus</code></td><td>输入字段获得焦点时触发。</td></tr><tr><td></td><td><code>blur</code></td><td>输入字段失去焦点时触发。</td></tr><tr><td><strong>文档和窗口事件</strong></td><td><code>load</code></td><td>文档或窗口加载完成时触发。</td></tr><tr><td></td><td><code>resize</code></td><td>窗口大小改变时触发。</td></tr><tr><td></td><td><code>scroll</code></td><td>页面滚动时触发。</td></tr></tbody></table><h3 id="3-事件的注册与处理"><a href="#3-事件的注册与处理" class="headerlink" title="3. 事件的注册与处理"></a>3. 事件的注册与处理</h3><p>事件可以通过不同的方式进行注册，最常用的方法有以下几种：</p><ol><li><p><strong>HTML 属性</strong>：<br>在 HTML 元素中直接使用事件属性。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Button clicked!&#x27;)&quot;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>DOM 方法</strong>：<br>使用 JavaScript 的 <code>addEventListener()</code> 方法来注册事件处理程序。此方法更灵活，可以注册多个事件处理程序，并支持事件捕获和冒泡。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>内联事件处理器</strong>：<br>在 HTML 中使用 <code>on</code> 前缀的属性，例如 <code>onclick</code>、<code>onmouseover</code> 等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myButton&quot;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="4. 事件对象"></a>4. 事件对象</h3><p>每当事件被触发时，都会生成一个事件对象，包含有关事件的详细信息。常见的属性和方法包括：</p><ul><li><strong>event.type</strong>：事件的类型（例如 <code>click</code>）。</li><li><strong>event.target</strong>：事件的目标元素。</li><li>**event.preventDefault()**：阻止默认事件的发生（例如，阻止表单提交）。</li><li>**event.stopPropagation()**：停止事件的传播。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JavaScript Events<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myButton&quot;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myInput&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Type something...&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 鼠标事件</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>);</span><br><span class="language-javascript">        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked! Event type: &#x27;</span> + event.<span class="hljs-property">type</span>);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 键盘事件</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myInput&#x27;</span>);</span><br><span class="language-javascript">        input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Key pressed: &#x27;</span> + event.<span class="hljs-property">key</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Enter&#x27;</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;You pressed Enter!&#x27;</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-事件冒泡与捕获"><a href="#5-事件冒泡与捕获" class="headerlink" title="5. 事件冒泡与捕获"></a>5. 事件冒泡与捕获</h3><ul><li><strong>事件冒泡</strong>：事件从目标元素开始，逐层向上传播到文档根节点。</li><li><strong>事件捕获</strong>：事件从文档根节点开始，逐层向下传播到目标元素。</li></ul><p>使用 <code>addEventListener()</code> 方法时，可以通过第三个参数指定事件的捕获或冒泡行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 捕获</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 冒泡（默认）</span><br></code></pre></td></tr></table></figure><h3 id="6-事件委托"><a href="#6-事件委托" class="headerlink" title="6. 事件委托"></a>6. 事件委托</h3><p>事件委托是一种高效的事件处理技术，允许在父元素上注册事件处理程序，子元素的事件会自动冒泡到父元素，从而简化事件处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myList&#x27;</span>);<br>list.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;List item clicked: &#x27;</span> + event.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>XML（可扩展标记语言，eXtensible Markup Language）是一种用于描述数据的标记语言，它提供了一种结构化的方式来存储和传输数据。XML 的设计旨在简化数据的共享和传输，使其能够在不同的系统和平台之间无缝交互。</p><h3 id="1-XML-的基本特性"><a href="#1-XML-的基本特性" class="headerlink" title="1. XML 的基本特性"></a>1. XML 的基本特性</h3><ul><li><strong>可扩展性</strong>：XML 允许用户自定义标签，以适应不同的数据需求。</li><li><strong>自描述性</strong>：数据结构由标签定义，具有较强的自描述性，便于理解。</li><li><strong>平台独立性</strong>：XML 是一种纯文本格式，可以在不同的操作系统和应用程序中使用。</li><li><strong>可读性</strong>：XML 文件是人类可读的，方便调试和编辑。</li></ul><h3 id="2-XML-的结构"><a href="#2-XML-的结构" class="headerlink" title="2. XML 的结构"></a>2. XML 的结构</h3><p>XML 文档由一系列嵌套的元素构成，每个元素都有开始标签和结束标签。以下是一个简单的 XML 示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>：XML 声明，指明文档的版本和编码。</li><li><code>&lt;note&gt;</code>：根元素，表示整个 XML 文档的开始。</li><li><code>&lt;to&gt;</code>, <code>&lt;from&gt;</code>, <code>&lt;heading&gt;</code>, <code>&lt;body&gt;</code>：子元素，包含具体的数据内容。</li></ul><h3 id="3-XML-的应用场景"><a href="#3-XML-的应用场景" class="headerlink" title="3. XML 的应用场景"></a>3. XML 的应用场景</h3><ul><li><strong>数据交换</strong>：在不同系统之间传输数据，如在 Web 服务中。</li><li><strong>配置文件</strong>：用于应用程序的配置文件，例如 Spring 框架的配置。</li><li><strong>文档存储</strong>：存储文档内容，如 RSS 提要、SVG 图形等。</li><li><strong>数据持久化</strong>：用于数据库之外的数据存储。</li></ul><h3 id="4-解析-XML"><a href="#4-解析-XML" class="headerlink" title="4. 解析 XML"></a>4. 解析 XML</h3><p>在 JavaScript 中，可以使用 <code>DOMParser</code> 将 XML 字符串解析为 DOM 对象，也可以使用 <code>XMLHttpRequest</code> 或 <code>fetch</code> API 来加载外部的 XML 文件并进行解析。</p><h4 id="示例代码（解析-XML-字符串）"><a href="#示例代码（解析-XML-字符串）" class="headerlink" title="示例代码（解析 XML 字符串）"></a>示例代码（解析 XML 字符串）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xmlString = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-string">&lt;note&gt;</span><br><span class="hljs-string">    &lt;to&gt;Tove&lt;/to&gt;</span><br><span class="hljs-string">    &lt;from&gt;Jani&lt;/from&gt;</span><br><span class="hljs-string">    &lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="hljs-string">    &lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;</span><br><span class="hljs-string">&lt;/note&gt;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMParser</span>();<br><span class="hljs-keyword">var</span> xmlDoc = parser.<span class="hljs-title function_">parseFromString</span>(xmlString, <span class="hljs-string">&quot;application/xml&quot;</span>);<br><br><span class="hljs-comment">// 访问 XML 数据</span><br><span class="hljs-keyword">var</span> to = xmlDoc.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;to&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">textContent</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to); <span class="hljs-comment">// 输出 &quot;Tove&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>AJAX（Asynchronous JavaScript and XML）是一种用于创建快速动态网页的技术。通过在后台与服务器进行异步通信，AJAX 使得网页能够更新部分内容而无需重新加载整个页面，从而提高用户体验和性能。</p><h3 id="1-AJAX-的基本概念"><a href="#1-AJAX-的基本概念" class="headerlink" title="1. AJAX 的基本概念"></a>1. AJAX 的基本概念</h3><ul><li><strong>异步</strong>：AJAX 允许网页在不干扰用户交互的情况下进行数据加载。用户可以继续与页面互动，而数据请求在后台进行。</li><li><strong>JavaScript</strong>：使用 JavaScript 进行数据处理和更新网页内容。</li><li><strong>XML</strong>：虽然最初设计时使用 XML 作为数据格式，但如今 AJAX 可以处理多种格式，包括 JSON、HTML 和纯文本。</li></ul><h3 id="2-AJAX-的工作原理"><a href="#2-AJAX-的工作原理" class="headerlink" title="2. AJAX 的工作原理"></a>2. AJAX 的工作原理</h3><p>AJAX 的工作流程通常包括以下几个步骤：</p><ol><li><strong>创建 XMLHttpRequest 对象</strong>：这是 AJAX 通信的基础。</li><li><strong>配置请求</strong>：使用 <code>open</code> 方法配置请求类型（GET、POST 等）和 URL。</li><li><strong>发送请求</strong>：调用 <code>send</code> 方法向服务器发送请求。</li><li><strong>处理响应</strong>：使用 <code>onreadystatechange</code> 事件处理响应，解析数据并更新网页内容。</li></ol><h3 id="3-AJAX-示例"><a href="#3-AJAX-示例" class="headerlink" title="3. AJAX 示例"></a>3. AJAX 示例</h3><p>以下是一个使用 AJAX 从服务器获取 JSON 数据并更新网页内容的示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>AJAX Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadData</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// 配置请求</span></span><br><span class="language-javascript">            xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>, <span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// 设置响应处理</span></span><br><span class="language-javascript">            xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-comment">// 解析 JSON 数据</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">var</span> posts = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>);</span><br><span class="language-javascript">                    <span class="hljs-keyword">var</span> output = <span class="hljs-string">&#x27;&lt;ul&gt;&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">                    <span class="hljs-comment">// 更新网页内容</span></span><br><span class="language-javascript">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; posts.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">                        output += <span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span> + posts[i].<span class="hljs-property">title</span> + <span class="hljs-string">&#x27;&lt;/li&gt;&#x27;</span>;</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                    output += <span class="hljs-string">&#x27;&lt;/ul&gt;&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">                    <span class="hljs-comment">// 将内容插入到网页中</span></span><br><span class="language-javascript">                    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>).<span class="hljs-property">innerHTML</span> = output;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// 发送请求</span></span><br><span class="language-javascript">            xhr.<span class="hljs-title function_">send</span>();</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>AJAX Example<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;loadData()&quot;</span>&gt;</span>Load Posts<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h4><ul><li><strong>创建 XMLHttpRequest 对象</strong>：使用 <code>new XMLHttpRequest()</code> 创建请求对象。</li><li><strong>配置请求</strong>：使用 <code>open</code> 方法配置请求类型和目标 URL。</li><li><strong>设置响应处理</strong>：通过 <code>onreadystatechange</code> 事件处理请求的不同状态。状态 4 表示请求完成，状态 200 表示请求成功。</li><li><strong>解析 JSON 数据</strong>：使用 <code>JSON.parse()</code> 解析服务器返回的 JSON 数据。</li><li><strong>更新网页内容</strong>：通过 DOM 操作将数据插入到页面中。</li></ul><h3 id="4-AJAX-与-Fetch-API"><a href="#4-AJAX-与-Fetch-API" class="headerlink" title="4. AJAX 与 Fetch API"></a>4. AJAX 与 Fetch API</h3><p>随着现代浏览器的发展，Fetch API 提供了一种更简洁的方式来进行 AJAX 请求。Fetch API 返回一个 Promise，使得异步请求的处理更加优雅。以下是使用 Fetch API 的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response was not ok&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>        &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">posts</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> output = <span class="hljs-string">&#x27;&lt;ul&gt;&#x27;</span>;<br>            posts.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> &#123;<br>                output += <span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span> + post.<span class="hljs-property">title</span> + <span class="hljs-string">&#x27;&lt;/li&gt;&#x27;</span>;<br>            &#125;);<br>            output += <span class="hljs-string">&#x27;&lt;/ul&gt;&#x27;</span>;<br>            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>).<span class="hljs-property">innerHTML</span> = output;<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;There was a problem with the fetch operation:&#x27;</span>, error));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>编程语言</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
