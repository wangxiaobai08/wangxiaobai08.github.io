<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>unicorn原理浅析</title>
    <link href="/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="unicorn是什么？"><a href="#unicorn是什么？" class="headerlink" title="unicorn是什么？"></a>unicorn是什么？</h1><p><strong>Unicorn</strong> 是一个基于 QEMU 的轻量级 CPU 仿真框架，用于模拟多种架构（如 ARM、x86、MIPS 等）的指令执行和状态变化。其本质是通过 <strong>动态二进制翻译</strong> (Dynamic Binary Translation) 将目标架构的指令翻译为宿主架构可执行代码，并在宿主机运行。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ul><li><strong>多架构支持</strong>：支持 ARM、x86、MIPS 等主流架构及模式（如 ARM&#x2F;Thumb）。</li><li><strong>指令仿真</strong>：精准模拟 CPU 指令行为（如跳转、寄存器操作、内存访问等）。</li><li><strong>内存与寄存器仿真</strong>：用户可自定义虚拟内存布局及操作寄存器。</li><li><strong>钩子机制</strong>：支持拦截指令、内存访问等，便于监控和调试。</li></ul><h3 id="本质特点"><a href="#本质特点" class="headerlink" title="本质特点"></a><strong>本质特点</strong></h3><ul><li><strong>动态翻译</strong>：基于 QEMU 的 TCG 技术，直接在宿主机运行目标指令，高效快捷。</li><li><strong>模块化</strong>：仅关注 CPU 指令仿真，易用、灵活，适合安全研究、逆向工程和嵌入式开发。</li></ul><h1 id="ARM64的体系架构"><a href="#ARM64的体系架构" class="headerlink" title="ARM64的体系架构"></a>ARM64的体系架构</h1><p>见上篇文章：ARM64架构</p><h1 id="unicorn怎么运行起来的？"><a href="#unicorn怎么运行起来的？" class="headerlink" title="unicorn怎么运行起来的？"></a>unicorn怎么运行起来的？</h1><p>CPU的运行，本质上就是：从内存中读取指令，并运行指令（包括输出结果，到对应内存地址或寄存器）</p><p>Unicorn要模拟的是CPU的运行。所以也就（只）是，把代码放到对应的地址上，Unicorn开始运行，去对应地址：<strong>读取指令</strong>，（解析并）<strong>执行指令</strong>，而解析和运行该指令的结果，往往是，本身就是，写入计算后的结果到对应的寄存器或内存而已。</p><p>而在指令执行期间的所需要的其他内容，比如后续会涉及到的函数参数、Stack栈、Heap堆等等，则都是为了：确保Unicorn模拟CPU的结果，和真实的代码执行的结果，要（完全）一致，才有价值，才能真正得到的希望的输出的结果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">指令<span class="hljs-operator">=</span>instruction <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 代码<span class="hljs-operator">=</span>code <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 操作码<span class="hljs-operator">=</span>opcode <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 二进制(数据) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> binary (data)<br></code></pre></td></tr></table></figure><h2 id="怎么模拟出内存等结构的？"><a href="#怎么模拟出内存等结构的？" class="headerlink" title="怎么模拟出内存等结构的？"></a>怎么模拟出内存等结构的？</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p><img src="https://s2.loli.net/2024/12/17/kpMjRTFBOX3Qv2V.png" alt="image-20241217103506135"></p><p>一个常见的内存布局如下：</p><table><thead><tr><th><strong>内存区域</strong></th><th><strong>起始地址</strong></th><th><strong>大小</strong></th><th><strong>权限</strong></th></tr></thead><tbody><tr><td>代码段</td><td><code>0x40000</code></td><td>2 MB</td><td>可读可执行（RX）</td></tr><tr><td>数据段</td><td><code>0x42000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆区</td><td><code>0x60000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆栈段</td><td><code>0x7FFF0000</code></td><td>1 MB（向下增长）</td><td>可读可写（RW）</td></tr></tbody></table><p><strong>代码段</strong>：</p><ul><li>通常映射在较低的地址区域，如 <code>0x40000</code>，用来存储程序的指令。</li><li>设置为可读可执行权限（<code>UC_PROT_READ | UC_PROT_EXEC</code>）。</li></ul><p><strong>数据段</strong>：</p><ul><li>紧邻代码段，用来存储全局变量、静态变量等。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>堆区</strong>：</p><ul><li>用于动态分配内存，可以根据程序运行时的需求调整大小。</li><li>通过自定义的内存管理器或直接扩展区域实现。</li></ul><p><strong>堆栈段</strong>：</p><ul><li>通常放在高地址区域（如 <code>0x7FFF0000</code>），并从高地址向低地址增长。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>Unicorn 的内存设置是它自己模拟的，而不是由操作系统直接管理的</strong>。Unicorn 作为一个用户态的 CPU 仿真框架，模拟了目标架构的 CPU 和内存系统。Unicorn 将内存的虚拟地址（如 <code>0x40000</code> 或 <code>0x7FFF0000</code>）完全作为目标架构的地址模拟，与主机的虚拟地址无关。主机操作系统只负责分配 Unicorn 运行本身需要的资源（如 CPU 时间和主机内存），但不会干涉 Unicorn 模拟的内存布局。</p><p>值得注意的是：</p><p>Unicorn 本身并不会主动区分“特殊用途”地址和“普通地址”，但它的执行逻辑可能依赖用户分配的地址。但如果你在 <code>0x0 - 0xFFFF</code> 范围内映射代码或数据，可能会导致以下问题：</p><ol><li><strong>Unicorn 的初始化数据</strong>：某些架构可能会默认初始化特定的寄存器或内存区域到低地址，用户手动操作的地址可能与这些区域冲突。</li><li><strong>调试和兼容性问题</strong>：许多调试工具或调试器（如 GDB）默认会将低地址区域视为不可用的保留空间。如果代码被放置在低地址区域，调试时可能导致断点设置失败或程序崩溃。</li></ol><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>写入内容（代码，数据）到内存中之前，要注意先确认<code>字节序</code>&#x3D;<code>endian</code>是<code>大端</code>还是<code>小端</code></p><p>ARM中，默认是<code>小端</code>&#x3D;<code>UC_MODE_LITTLE_ENDIAN</code></p><p>除非特殊需要，才会设置为<code>大端</code>&#x3D;<code>UC_MODE_BIG_ENDIAN</code></p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><table><thead><tr><th><strong>部分</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>(1) 动态二进制翻译（Dynamic Binary Translation）</strong></td><td></td></tr><tr><td><strong>翻译机制</strong></td><td>- 通过 QEMU 的 TCG（Tiny Code Generator）实现动态翻译。- 将目标架构的指令翻译为宿主架构的中间表示（IR, Intermediate Representation）。- 翻译后的代码缓存在 <strong>Translation Block Cache (TLB)</strong> 中。</td></tr><tr><td><strong>执行流程</strong></td><td>1. 解析目标架构指令。2. 使用 TCG 将指令翻译为宿主架构的中间代码（IR）。3. 中间代码再翻译为宿主机的原生机器指令，并直接运行。</td></tr><tr><td><strong>性能特点</strong></td><td>- 比解释型模拟（如 Bochs）快得多。- 动态翻译存在一定开销，但重复执行时利用 TLB 提升效率。</td></tr><tr><td><strong>(2) 指令的分发与仿真</strong></td><td></td></tr><tr><td><strong>指令获取</strong></td><td>- 从当前 <strong>PC（Program Counter）</strong> 所指向的地址读取目标内存中的指令。- 内存管理由 Unicorn 的虚拟内存模型负责，需通过 <strong><code>uc_mem_map</code></strong> 等接口预先映射内存。</td></tr><tr><td><strong>指令解析与翻译</strong></td><td>- 根据架构解码指令，提取操作码和操作数。示例：- <strong>ARM</strong>：解析指令类型（如分支 <code>BL</code>、数据处理 <code>ADD</code>、内存访问 <code>LDR</code>）。- <strong>x86</strong>：解析指令（如 <code>MOV</code>、<code>CALL</code>、<code>JMP</code>）。</td></tr><tr><td><strong>指令执行</strong></td><td>- 将解析的指令翻译为宿主机代码并执行。- 例如模拟内存访问、条件跳转、异常处理等。</td></tr><tr><td><strong>状态更新</strong></td><td>- 根据指令执行结果更新模拟状态（寄存器、内存等）。</td></tr><tr><td><strong>(3) 内存与寄存器仿真</strong></td><td></td></tr><tr><td><strong>内存仿真</strong></td><td>- Unicorn 使用虚拟内存模型模拟目标架构内存。- 用户通过 <strong><code>uc_mem_map</code></strong> 定义虚拟内存布局。- 所有内存访问都经 Unicorn 的内存管理层检查。</td></tr><tr><td><strong>寄存器仿真</strong></td><td>- 不同架构有各自的寄存器模型：    - <strong>x86</strong>：<code>EIP</code>、<code>ESP</code> 等。    - <strong>ARM</strong>：<code>R0-R15</code>、<code>PC</code>、<code>LR</code> 等。- 用户通过 <strong><code>uc_reg_read</code></strong> 和 <strong><code>uc_reg_write</code></strong> 接口操作寄存器。</td></tr><tr><td><strong>(4) 钩子机制（Hooking Mechanism）</strong></td><td></td></tr><tr><td><strong>代码钩子</strong></td><td>- 拦截特定指令或地址范围的执行。</td></tr><tr><td><strong>内存钩子</strong></td><td>- 拦截内存读写访问，用于监控或修改操作。</td></tr><tr><td><strong>异常钩子</strong></td><td>- 捕获未定义指令、未映射内存访问等异常。</td></tr><tr><td><strong>(5) 架构和模式切换</strong></td><td></td></tr><tr><td><strong>支持的架构</strong></td><td><strong>x86、x86_64、ARM、ARM64、MIPS、SPARC、PowerPC</strong></td></tr><tr><td><strong>模式切换</strong></td><td>- <strong>x86</strong>：支持 32 位和 64 位模式切换。- <strong>ARM</strong>：支持 ARM 模式和 Thumb 模式切换（通过 <code>BLX</code> 等指令）。- 用户初始化时通过 <code>Uc(UC_ARCH_ARM, UC_MODE_THUMB)</code> 指定模式，模拟中可根据指令动态切换。</td></tr></tbody></table><h1 id="unicorn使用的基本思想？"><a href="#unicorn使用的基本思想？" class="headerlink" title="unicorn使用的基本思想？"></a>unicorn使用的基本思想？</h1><h2 id="运行前初始化"><a href="#运行前初始化" class="headerlink" title="运行前初始化"></a>运行前初始化</h2><p>主要是对内存布局，比如：堆，栈等一些设置，注意对需要模拟的函数参数<strong>提前写入寄存器</strong>，其他一些特殊情况中，要给特定内存地址写入特定地址，供后续代码模拟时调用。</p><h2 id="运行中Hook"><a href="#运行中Hook" class="headerlink" title="运行中Hook"></a>运行中Hook</h2><p>开始运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mu.emu_start(ADDRESS, ADDRESS + <span class="hljs-built_in">len</span>(ARM_CODE))<br></code></pre></td></tr></table></figure><ul><li>ADDRESS：最开始映射的代码的最初位置</li><li>ADDRESS + len(ARM_CODE)：映射的代码起始位置，加上对应代码长度后的，结束位置</li></ul><blockquote><p>为了用Unicorn模拟代码运行，调试出我们希望搞懂的函数的逻辑，往往期间需要很多额外的调试内容</p></blockquote><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>Unicorn模拟期间，常需要去搞懂底层正在发生的细节，查看对应的寄存器、内存的值等等，此时，就可以用到Unicorn所提供的机制：hook。</p><p>其中比较常用的一些hook是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">- hook代码<br>- hook特定指令<br>- hook内存<br>- hook异常<br>- hook其他<br></code></pre></td></tr></table></figure><p>关于Unicorn支持的hook的全部种类是：</p><p>指令执行类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_INTR`<br>- `UC_HOOK_INSN`<br>- `UC_HOOK_CODE`<br>- `UC_HOOK_BLOCK`<br></code></pre></td></tr></table></figure><p>内存访问类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_PROT`<br>- `UC_HOOK_MEM_WRITE_PROT`<br>- `UC_HOOK_MEM_FETCH_PROT`<br>- `UC_HOOK_MEM_READ`<br>- `UC_HOOK_MEM_WRITE`<br>- `UC_HOOK_MEM_FETCH`<br>- `UC_HOOK_MEM_READ_AFTER`<br></code></pre></td></tr></table></figure><p>异常处理类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_UNMAPPED`<br>- `UC_HOOK_MEM_WRITE_UNMAPPED`<br>- `UC_HOOK_MEM_FETCH_UNMAPPED`<br>- `UC_HOOK_INSN_INVALID`<br></code></pre></td></tr></table></figure><p>其他</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_EDGE_GENERATED`<br>- `UC_HOOK_TCG_OPCODE`<br></code></pre></td></tr></table></figure><p>Hook的设置，在运行中逐指令进行对比，当符合设置的内容时，触发钩子函数进行处理</p><h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>引入外部的反汇编器disassembler，比如<code>Capstone</code>，自己去把二进制翻译为对应指令</p><h2 id="运行后获取结果"><a href="#运行后获取结果" class="headerlink" title="运行后获取结果"></a>运行后获取结果</h2><h3 id="停止运行"><a href="#停止运行" class="headerlink" title="停止运行"></a>停止运行</h3><p>对于Unicorn来说，就是模拟CPU运行，模拟去读取指令和运行指令而已。</p><p>所以，换句话说，如果你的给code代码的地址空间写入了代码后，如果没有额外的跳转等复杂逻辑，则：</p><ul><li><strong>Unicorn会一直运行下去</strong></li></ul><p>如果没有合适的触发时机，去让其停下来，那就变成了死循环，永远不结束了。</p><p>而我们的目标是：模拟代码，尤其是函数的逻辑，希望代码运行完毕，输出结果的。</p><p>所以，此处往往选择一个合适的时机去触发其让Unicorn停下来。</p><p>这个时机，一般都是：<code>ret</code>指令，即，当发现正在运行的指令是<code>ret</code>指令，则就会调用<code>emu_stop</code>去停下来。</p><p><strong>在<code>hook_code</code>中，借助<code>Capstone</code>反编译出当前指令，其中<code>mnemonic</code>就是指令名称，当发现是<code>ret</code>指令时</strong></p><p>注：对于arm64e来说，还有更多的PAC相关ret指令：<code>retaa</code>、<code>retab</code>等，所以此处用<code>re</code>正则去判断指令名称是否匹配，而不是直接判断和<code>ret</code>是否相等。</p><p>就去调用<code>emu_stop()</code>去停止Unicorn的继续运行。</p><p><strong>这里也是借助Hook进行的</strong></p><h3 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h3><p>通过读取寄存器中的值来获取结果</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://book.crifan.org/books/cpu_emulator_unicorn/website/how_use/background/core_logic/cpu_logic.html">CPU的核心逻辑 · CPU模拟利器：Unicorn</a></p>]]></content>
    
    
    <categories>
      
      <category>符号/模拟执行</category>
      
      <category>unicorn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angr原理浅析</title>
    <link href="/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p><strong>约束条件（Constraints）</strong> 是对问题求解空间的限制或规定，它规定了哪些解是允许的，哪些解是不允许的。在数学、计算机科学、逻辑学等领域，约束条件通常用于描述某个问题的限制条件，目的是让我们能够从所有可能的解中筛选出符合特定规则或要求的解。</p><p>在数学中，约束条件通常是一些方程或不等式，定义了一个问题的解集。例如，约束条件 <code>x + y ≤ 10</code> 就表示在求解时，变量 <code>x</code> 和 <code>y</code> 的和不能超过 10。</p><p>在计算机科学，约束条件常常是对程序状态的描述，表示程序在某一时刻满足的条件或限制。例如，假设有一个条件 <code>if (x &lt; 10)</code>，那么在程序的执行过程中，<code>x &lt; 10</code> 就是一个约束条件。</p><h2 id="什么是Z3"><a href="#什么是Z3" class="headerlink" title="什么是Z3"></a>什么是Z3</h2><p><a href="https://github.com/Z3Prover/z3">Z3 solver</a> 是由微软开发的 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），用于检查逻辑表达式的可满足性，并可以找到一组约束中的其中一个可行解（无法找出所有的可行解）。</p><p>不深入研究的话，这里可以简单理解为：<strong>解方程</strong>，当然他还有很多应用场景比如：</p><ul><li><strong>布尔逻辑</strong>：可以处理布尔表达式，求解SAT（布尔可满足性）问题。</li><li><strong>线性算术</strong>：能够处理整数和实数的线性约束。</li><li><strong>非线性算术</strong>：支持非线性算术运算的求解。</li><li><strong>数组、集合、图结构</strong>：支持复杂的数据结构。</li><li><strong>符号执行</strong>：结合符号执行技术，Z3能对程序的执行路径进行分析和求解。</li><li><strong>程序验证</strong>：通过将程序的行为转化为约束，Z3可以帮助验证程序是否满足特定的安全性或功能性要求。</li><li><strong>自动化定理证明</strong>：Z3可以用来证明数学定理或逻辑公式的有效性。</li></ul><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> Solver, Real, sat<br><br><span class="hljs-comment"># 创建符号变量 x</span><br>x = Real(<span class="hljs-string">&#x27;x&#x27;</span>)<br><br><span class="hljs-comment"># 创建方程：x^2 - 3x + 2 = 0</span><br>equation = x**<span class="hljs-number">2</span> - <span class="hljs-number">3</span>*x + <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 创建一个求解器</span><br>solver = Solver()<br><br><span class="hljs-comment"># 将方程添加到求解器</span><br>solver.add(equation)<br><br><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">if</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方程无解&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/5rTdVqvCSa6zQtP.png" alt="image-20241219153257642" style="zoom:50%;" /></p><p>而不是：x &#x3D; 1和x &#x3D; 2</p><p>这是因为Z3 在求解方程时，默认情况下只返回第一个找到的解。这是因为 Z3 是一个 <strong>满足性求解器</strong>（Satisfiability Solver），它的目标是检查约束是否可满足，并返回其中一个满足约束的解，而不是所有可能的解。</p><p>通过进一步添加约束条件可以得到所有解（即排除已经找到的解）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">while</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 排除当前解，继续寻找下一个解</span><br>    solver.add(x != model[x])<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/mJYOACvKk2acpsj.png" alt="image-20241219153642676" style="zoom:50%;" /></p><h1 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h1><h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><img src="https://s2.loli.net/2024/12/19/u3ez9CtglaXyJNk.png" alt="220430bodvqhbod4pty8zv"></p><p>符号执行是一种程序分析技术，它通过将程序中的某些变量替换为符号变量（而不是具体值），来模拟程序的执行。符号变量代表任意值，并通过符号计算来追踪程序的执行路径和计算结果。与传统的测试方法不同，它并不是通过具体的输入值来执行程序，而是通过符号表示的输入值来执行程序，并尝试探索程序中所有可能的执行路径。</p><h3 id="符号执行流程"><a href="#符号执行流程" class="headerlink" title="符号执行流程"></a>符号执行流程</h3><p><strong>符号变量</strong>： 在符号执行中，输入变量（例如函数参数、内存内容等）被替换为符号变量（symbolic variables），这些符号变量表示可以取任意值。与传统的实际值（如整数、字符串）不同，符号变量没有固定的值，而是代表一个值的集合或范围。</p><p><strong>路径探索</strong>： 符号执行通过模拟程序的控制流来探索不同的路径。每当程序遇到条件判断（例如 <code>if</code> 语句）时，它会根据符号变量的约束来分裂路径。符号执行引擎会为每条路径维护一组条件约束，表示该路径的执行条件。</p><p><strong>约束收集与求解</strong>： 在执行过程中，每当遇到条件判断时（例如 <code>if</code> 语句），符号执行引擎会根据条件生成约束（例如 <code>x &lt; 10</code> 或 <code>x &gt;= 10</code>）。这些约束随着路径的推进被累积。最后，使用约束求解器（如 Z3）来检查是否存在解，即判断某条路径是否可行。如果求解器找到了满足这些约束的具体输入值，那么符号执行就能沿着这条路径继续模拟执行。</p><h2 id="什么是angr"><a href="#什么是angr" class="headerlink" title="什么是angr?"></a>什么是angr?</h2><p><strong>angr</strong> 是一个基于 Python 的 <strong>二进制分析框架</strong>，专门用于分析二进制程序。它提供了一个强大的工具集，用于执行分析任务，如符号执行（Symbolic Execution）、路径探索（Path Exploration）、漏洞挖掘、逆向工程、静态分析等。</p><h2 id="angr的工作原理？"><a href="#angr的工作原理？" class="headerlink" title="angr的工作原理？"></a>angr的工作原理？</h2><ol><li><strong>加载二进制</strong>：<ul><li>使用 angr 加载目标二进制文件（例如 ELF、PE 格式的可执行文件）。</li></ul></li><li><strong>符号执行与路径探索</strong>：<ul><li>angr 会在二进制程序的某些地方插入符号（symbolic variables），并从程序入口点（例如 <code>main</code> 函数）开始执行。每执行一步，angr 会模拟程序的行为并生成新的约束条件。</li></ul></li><li><strong>生成约束</strong>：<ul><li>在符号执行过程中，程序的条件分支会根据符号变量的取值生成约束（例如：<code>x &lt; 10</code>）。这些约束会被加入到当前路径的状态中。</li></ul></li><li><strong>路径分裂</strong>：<ul><li>当遇到条件分支时，angr 会将程序的执行路径分裂成多个子路径。例如，<code>if (x &lt; 10)</code> 会导致两个路径，一个路径满足 <code>x &lt; 10</code>，另一个路径满足 <code>x &gt;= 10</code>。</li></ul></li><li><strong>求解与回溯</strong>：<ul><li>每条路径都会产生约束，angr 会通过求解器（如 Z3）来判断某条路径是否可行。如果路径不可行，angr 会将其丢弃。如果路径可行，它将继续沿着该路径执行，直到达到目标或出现漏洞。</li></ul></li></ol><p>可以看出同unicorn只能走一个分支相比，angr在运行的过程中，从给定的一个state(程序状态，程序的寄存器值，内存的不同都可以作为程序状态的不同)开始执行，每个state维护着一个约束条件的集合(比如i&lt;10,i!&#x3D;0)，通过收集约束，进行遍历，最终angr理论上可以遍历到程序的所有可能控制流，当angr运行到目标状态时，就可以调用求解器(z3等)对一路上收集到的约束进行求解，最终得到某个符号能够到达当前状态的值。</p><p><img src="https://s2.loli.net/2024/12/19/pwKVfMPCjUbX95v.jpg" alt="215918bnzmvv6wzoqingwv"></p><p>值得注意的是：同传统的静态符号执行(unicorn引擎)相比，<strong>angr使用的是混合执行技术，合并了静态符号执行，和动态具体执行两种技术</strong></p><p>动态符号执行（concolic execution）维持了两个状态。一种是实际变量的状态，另一种是符号化的状态。实际状态将随机生成值映射到变量中，而符号化状态将变量进行符号化。concolic首先将实际状态运行，并收集实际运行时该路径的变量符号化的约束式，i求解。并将约束式取反，获取另一条路径的约束式并求解。过程不断重复，知道路径被探索完，或者达到用户设置的限制。</p><p>具体的例子可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 路径1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 路径2</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      <span class="hljs-comment">// 路径3</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="动态执行过程"><a href="#动态执行过程" class="headerlink" title="动态执行过程"></a>动态执行过程</h3><ol><li><strong>实际状态</strong>：随机初始化输入，例如 <code>x = 15</code>。</li><li><strong>符号化状态</strong>：将 <code>x</code> 表示为符号变量 <code>X</code>。</li></ol><hr><h4 id="步骤1：运行实际状态并收集约束"><a href="#步骤1：运行实际状态并收集约束" class="headerlink" title="步骤1：运行实际状态并收集约束"></a><strong>步骤1：运行实际状态并收集约束</strong></h4><ol><li><p><strong>实际运行</strong>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">15</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>1</code>，对应<strong>路径1</strong>。</p></li><li><p><strong>符号化执行</strong>：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt; <span class="hljs-number">10</span>  (路径<span class="hljs-number">1</span>)<br>X &lt; <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>将这些条件存入符号约束集。</p></li></ol><hr><h4 id="步骤2：生成新路径（约束取反）"><a href="#步骤2：生成新路径（约束取反）" class="headerlink" title="步骤2：生成新路径（约束取反）"></a><strong>步骤2：生成新路径（约束取反）</strong></h4><ol><li><p>从约束集中取反条件：</p><p>原路径约束为 <code>X &gt; 10 &amp;&amp; X &lt; 20</code>。</p><p>取反约束为 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>即：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span> || X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择其中一条路径：<code>X &lt;= 10</code>**。</p><p>求解约束 <code>X &lt;= 10</code>，求解器可能返回 <code>X = 5</code>。</p></li></ol><hr><h4 id="步骤3：探索新路径"><a href="#步骤3：探索新路径" class="headerlink" title="步骤3：探索新路径"></a><strong>步骤3：探索新路径</strong></h4><ol><li><p>使用新值 <code>x = 5</code> 实际运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">5</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &gt; <span class="hljs-number">10</span>) &#123;           // 条件不成立<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>3</code>，对应<strong>路径3</strong>。</p></li><li><p>收集符号化约束：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span>  (路径<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="步骤4：继续探索未覆盖的路径"><a href="#步骤4：继续探索未覆盖的路径" class="headerlink" title="步骤4：继续探索未覆盖的路径"></a><strong>步骤4：继续探索未覆盖的路径</strong></h4><ol><li><p>再次从约束集中取反条件：</p><p>已探索的路径约束为：</p><p>​     路径1：<code>X &gt; 10 &amp;&amp; X &lt; 20</code></p><p>​     路径3：<code>X &lt;= 10</code></p><p>合并取反条件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>) &amp;&amp; !(X &lt;= <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>简化后为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择路径：<code>X &gt;= 20</code>**。</p><p>求解约束 <code>X &gt;= 20</code>，求解器可能返回 <code>X = 25</code>。</p></li><li><p>使用新值 <code>x = 25</code> 实际运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>执行路径为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件不成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>2</code>，对应<strong>路径2</strong>。</p></li></ol><hr><h4 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a><strong>终止条件</strong></h4><p>动态符号执行会重复上述过程：</p><ol><li>实际运行一个具体值。</li><li>收集符号化约束。</li><li>取反约束生成新路径。</li><li>继续探索未覆盖的路径。</li></ol><p>直到：</p><ul><li><strong>所有路径都被探索</strong>：程序的逻辑分支全部覆盖。</li><li><strong>达到用户设定的限制</strong>：例如最大路径数量、最大求解时间等。</li></ul><h2 id="angr的不足"><a href="#angr的不足" class="headerlink" title="angr的不足"></a>angr的不足</h2><h3 id="未约束导致路径爆炸"><a href="#未约束导致路径爆炸" class="headerlink" title="未约束导致路径爆炸"></a>未约束导致路径爆炸</h3><p>在符号执行中，如果函数的输入变量或状态没有被有效约束（即没有设定足够的条件），Angr 等工具会把这些变量当作符号值进行推理和执行。而未约束的变量可能会导致两方面的问题：</p><ol><li><strong>不确定的输入</strong>： 如果输入没有约束（例如，函数的参数没有指定具体的值或者范围），那么每次执行到某个条件判断时，就会有多个可能的选择。例如，假设你有一个函数，其中某个参数 <code>x</code> 的值没有明确的限制，那么在 <code>if</code> 语句中对 <code>x</code> 的判断就可能导致多个分支，每个分支都有不同的路径。</li><li><strong>无限循环</strong>： 当未约束的变量影响到循环条件时，符号执行就无法准确预测循环何时结束，因为它并不知道循环的终止条件何时成立。例如，某个循环的退出条件可能是 <code>x == 0</code>，但 <code>x</code> 是一个未约束的符号变量，Angr 并不知道 <code>x</code> 什么时候会变为 0。因此，符号执行引擎就可能会一直在这个循环中进行模拟，导致路径在循环内无限增长。</li></ol><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">void foo(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果我们给定一个具体的值，例如 <code>x = 10</code>，程序会在 10 次迭代后退出。</li><li>但是如果 <code>x</code> 是一个未约束的符号变量（例如，Angr 看到 <code>x</code> 是一个符号值），它就不能确定 <code>x</code> 会在什么时候达到 0，或者是否有可能永远不为 0。</li></ul><p>在符号执行中，Angr 会尝试探索所有可能的路径。在这种情况下，由于 <code>x</code> 没有约束，符号执行引擎无法推断出 <code>x</code> 何时会变为 0，因此它可能会认为该循环将永远执行下去，导致<strong>路径爆炸</strong>。</p><h4 id="路径爆炸与无限循环的关系"><a href="#路径爆炸与无限循环的关系" class="headerlink" title="路径爆炸与无限循环的关系"></a><strong>路径爆炸与无限循环的关系</strong></h4><p>路径爆炸指的是，随着未约束变量的增加，符号执行的路径数量呈指数级增长，导致无法有效地探索所有路径。无限循环是路径爆炸的一种特殊情况，通常发生在没有足够约束的情况下，符号执行无法判断循环是否终止，从而导致执行路径无法终止。</p><p>例如，当未约束的循环变量 <code>x</code> 不断变化，且影响循环的终止条件时，Angr 可能会不断生成新的路径，每个路径代表不同的 <code>x</code> 值和不同的循环迭代次数，最终导致路径数量迅速膨胀，系统无法有效处理这些路径，从而导致“卡死”。</p><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> func(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x = x - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>x</code> 没有任何约束，Angr 会将其视为符号变量，可能会生成多条路径来探索 <code>x</code> 可能的值。每条路径都会尝试模拟 <code>x</code> 在每次循环中的变化，直到达到退出条件 <code>x &lt;= 0</code>。</p><p>在符号执行的过程中，Angr 会对每次 <code>x = x - 1</code> 做出决策，并生成新的路径。</p><p>如果没有足够的约束（例如，限制 <code>x</code> 的值或设置循环的最大迭代次数），Angr 可能会生成大量的路径来模拟不同的 <code>x</code> 值和循环次数，导致路径数目激增，甚至无法终止。</p><h3 id="误报"><a href="#误报" class="headerlink" title="误报"></a>误报</h3><p>事实上angr是基于符号执行来遍历程序的所有路径，它是否能遍历所有路径其实取决于其约束求解引擎是否强大，这里采用的是z3<br>当它能明确发现这个条件是无法满足的时候就不会走向这个路径，我们可以称之为虚假控制流。<br>但是如果程序本身的逻辑中存在一个条件是非常难以满足的，或者说超出了约束求解引擎的能力，那么则有可能到达不了这个路径，就会被误标记为虚假的控制流，实际中是很少出现的。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">[动若脱兔:深入浅出angr--初步理解符号执行以及angr架构 - 0xJDchen - 博客园](https://www.cnblogs.com/0xJDchen/p/9291335.html)<br><br>[利用angr去除混淆的优势，不足与实践 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1484714-1-1.html)<br><br>[angr_ctf——从0学习angr（一）：angr简介与核心概念 - Uiharu - 博客园](https://www.cnblogs.com/level5uiharu/p/16925991.html)<br><br>[angr - CTF Wiki](https://ctf-wiki.org/reverse/tools/simulate-execution/angr/)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>符号/模拟执行</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识JVM</title>
    <link href="/2024/12/19/%E5%88%9D%E8%AF%86JVM/"/>
    <url>/2024/12/19/%E5%88%9D%E8%AF%86JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。java语言跨平台的秘密</p><h1 id="Java如何被JVM所运行？"><a href="#Java如何被JVM所运行？" class="headerlink" title="Java如何被JVM所运行？"></a>Java如何被JVM所运行？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">Java 源文件 --&gt; 编译器 --&gt; .<span class="hljs-keyword">class</span>字节码文件--&gt; 类加载器--&gt;JVM<br></code></pre></td></tr></table></figure><h2 id="1-什么是-class字节码文件？"><a href="#1-什么是-class字节码文件？" class="headerlink" title="1.什么是.class字节码文件？"></a>1.什么是.class字节码文件？</h2><p>在 Java 中，JVM 可以理解的代码叫作字节码，也就是 .class 文件，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，并且保留了解释型语言可移植的特点，而通过即时编译器（JIT）又有编译型语言执行效率高的特点。所以 Java 程序运行时比较高效，同时 Java 通过字节码文件和虚拟机之间的关系，实现了平台无关性，一次编译，各平台都可运行。</p><p><a href="https://www.cnblogs.com/code-duck/p/13568004.html#%E4%BA%8C-class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">Class文件结构（详细解读） - codeduck - 博客园</a></p><h3 id="1-1-class文件与java源代码中的class类有什么联系和区别？"><a href="#1-1-class文件与java源代码中的class类有什么联系和区别？" class="headerlink" title="1.1 .class文件与java源代码中的class类有什么联系和区别？"></a>1.1 .class文件与java源代码中的class类有什么联系和区别？</h3><h2 id="2-怎么编译成-class字节码文件？"><a href="#2-怎么编译成-class字节码文件？" class="headerlink" title="2.怎么编译成.class字节码文件？"></a>2.怎么编译成.class字节码文件？</h2><p><a href="https://blog.csdn.net/weixin_44688973/article/details/125757836">Java文件是怎么编译成Class文件的_java编译成class-CSDN博客</a></p><p>答：编译原理相关，暂时略过</p><h2 id="3-类加载器工作原理"><a href="#3-类加载器工作原理" class="headerlink" title="3.类加载器工作原理"></a>3.类加载器工作原理</h2><h3 id="3-1-什么是双亲委派机制"><a href="#3-1-什么是双亲委派机制" class="headerlink" title="3.1 什么是双亲委派机制"></a>3.1 什么是双亲委派机制</h3><p>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器。（类加载器之间的父子关系不是以继承的关系实现，而是使用组合关系来复用父加载器的代码）</p><p><img src="https://s2.loli.net/2024/10/04/Klyv9UDehVc4uNT.webp" alt="双亲委派机制"></p><p>如果类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层级的类加载器都是如此，因此所有请求最终都会被传到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。因此，加载过程可以看成自底向上检查类是否已经加载，然后自顶向下加载类。整个过程就是一个递归的过程</p><p>整个过程：</p><ol><li><strong>自定义类加载器</strong>收到类加载请求，首先检查缓存是否已经加载该类。</li><li>如果未找到，则将请求<strong>委派给父类加载器</strong>，父类加载器首先会检查自己是否已经加载过该类（调用 <code>findLoadedClass()</code>）。如果找到，则返回该类，类加载过程结束。如果找不到，则继续将请求委派给其父类加载器</li><li>逐层向上，直到最顶层的<strong>启动类加载器（Bootstrap ClassLoader）</strong>。</li><li><strong>启动类加载器</strong>检查核心类库，能加载则返回，若不能加载则返回 <code>null</code>，传递控制权回给下层加载器。它的<strong>子类加载器</strong>将获得加载类的机会，并且尝试自己去加载该类。加载成功，则类加载过程结束。如果它也无法加载，则返回 <code>null</code>，传递控制权回给下层加载器</li><li>各层加载器依次返回，若父加载器未加载到类，则最底层的<strong>自定义类加载器</strong>通过 <code>findClass()</code> 方法尝试自己加载该类。</li><li>成功加载后，类会被缓存，加载过程结束。如果所有加载器都未能加载，抛出 <code>ClassNotFoundException</code>。</li></ol><p><img src="https://s2.loli.net/2024/10/04/C1XeMY9PkpbfL5F.png" alt="双亲委派"></p><p>双亲委派模型的优点：</p><ol><li><p>使用双亲委派模型来组织类加载器之间的关系，Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p></li><li><p>避免类的重复加载，当父类加载器已经加载了该类时，子类加载器就没必要再加载一次。</p></li><li><p>解决各个类加载器的基础类的统一问题，越基础的类由越上层的加载器进行加载。避免Java核心API中的类被随意替换，规避风险，防止核心API库被随意篡改。</p></li></ol><blockquote><p>例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的 Java 类，可以正常编译，但是永远无法被加载运行。</p></blockquote><h1 id="JVM的组成与运行原理？"><a href="#JVM的组成与运行原理？" class="headerlink" title="JVM的组成与运行原理？"></a>JVM的组成与运行原理？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">.<span class="hljs-keyword">class</span>字节码文件 --&gt; JVM --&gt; 机器码<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/15/zQjNwtq1Ef2UKv3.png" alt="1"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="本地方法栈和程序计数器"><a href="#本地方法栈和程序计数器" class="headerlink" title="本地方法栈和程序计数器"></a>本地方法栈和程序计数器</h3><p>native 修饰的方法就是本地方法，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区（method area）</strong>只是 <strong>JVM 规范</strong>中定义的一个概念，用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="虚拟机栈和虚拟机堆"><a href="#虚拟机栈和虚拟机堆" class="headerlink" title="虚拟机栈和虚拟机堆"></a>虚拟机栈和虚拟机堆</h3><blockquote><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p></blockquote><h4 id="虚拟机栈的生命周期"><a href="#虚拟机栈的生命周期" class="headerlink" title="虚拟机栈的生命周期"></a>虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="虚拟机堆的概念"><a href="#虚拟机堆的概念" class="headerlink" title="虚拟机堆的概念"></a>虚拟机堆的概念</h4><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MetaspaceSize：初始化元空间大小，控制发生<span class="hljs-built_in">GC</span><br>MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。<br></code></pre></td></tr></table></figure><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><ol><li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li>JVM 找到 App 的主程序入口，执行 main 方法</li><li>这个 main 中的第一条语句为 Student student &#x3D; new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li>执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li>执行 sayName()</li></ol><p><a href="https://blog.csdn.net/csdnliuxin123524/article/details/81303711">JVM原理最全、清晰、通俗讲解，五天40小时吐血整理_jvm原理讲解教程最全清晰通俗讲解-CSDN博客</a></p><p>jvm虚拟机位于操作系统的堆中，并且，程序员写好的类加载到虚拟机执行的过程是：当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader，</p><p><strong>java虚拟机的生命周期</strong>：声明周期起点是当一个java应用main函数启动时虚拟机也同时被启动，而只有当在虚拟机实例中的所有非守护进程都结束时，java虚拟机实例才结束生命。</p><p><strong>java虚拟机与main方法的关系</strong>：main函数就是一个java应用的入口，main函数被执行时，java虚拟机就启动了。启动了几个main函数就启动了几个java应用，同时也启动了几个java的虚拟机。</p><p>java的虚拟机种有两种线程，一种叫叫守护线程，一种叫非守护线程（也叫普通线程），main函数就是个非守护线程，虚拟机的gc就是一个守护线程。java的虚拟机中，只要有任何非守护线程还没有结束，java虚拟机的实例都不会退出，所以即使main函数这个非守护线程退出，但是由于在main函数中启动的匿名线程也是非守护线程，它还没有结束，所以jvm没办法退出</p><p>虚拟机的gc（垃圾回收机制）就是一个典型的守护线程。</p><p><img src="https://s2.loli.net/2024/12/16/Vc3OL6JyM5qvz8T.png" alt="fdb281da8c98cc1240281d4520bc947f"></p><h2 id="1-JVM如何将-class字节码文件转化为对应机器的机器码"><a href="#1-JVM如何将-class字节码文件转化为对应机器的机器码" class="headerlink" title="1.JVM如何将.class字节码文件转化为对应机器的机器码"></a>1.JVM如何将.class字节码文件转化为对应机器的机器码</h2><p><a href="https://javaguide.cn/java/jvm/jvm-intro.html">大白话带你认识 JVM | JavaGuide</a></p><p><img src="https://s2.loli.net/2024/12/15/2SNXkfbxFtVypJ7.webp" alt="c602f57ea9297f50bbc265f1821d6263"></p><p><a href="https://www.doc200.com/java-interview/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9FJVM%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%EF%BC%9F.html">8. 什么是Java字节码？JVM如何将字节码转换为机器代码？ | 胖虎Docs</a></p><p>JVM将字节码转换为机器代码的过程主要依赖于其执行引擎。执行引擎负责解释和执行字节码，并将其转换为底层的机器代码，以便在物理硬件上执行。这个过程分为两个主要部分：解释执行和即时编译（JIT）。</p><h4 id="1-解释执行"><a href="#1-解释执行" class="headerlink" title="1. 解释执行"></a>1. 解释执行</h4><p>解释器是JVM的一个组件，它逐行解释字节码，并将其转换为对应的机器码指令，然后在处理器上执行。</p><p>工作原理</p><ul><li>JVM启动时，解释器开始工作，读取字节码指令，并解释成相应的机器码指令。</li><li>每条字节码指令都通过解释器进行解释，然后立即执行。这种方式简单直接，但对于频繁执行的代码（如循环体）效率较低。</li></ul><p>优点</p><ul><li>启动快，解释器立即可以开始执行字节码。</li><li>对于短期任务，解释器可以快速响应。</li></ul><p>缺点</p><ul><li>对于重复执行的代码，解释效率较低，因为每次循环都要重新解释相同的字节码。</li></ul><h4 id="2-即时编译"><a href="#2-即时编译" class="headerlink" title="2. 即时编译"></a>2. 即时编译</h4><p>为了提升程序的运行效率，JVM引入了JIT编译器。JIT编译器在程序运行时将热点代码（频繁执行的代码）编译为本地机器码，并将其缓存起来，以避免重复解释相同的字节码。</p><p>工作原理</p><ul><li>JVM在解释执行字节码的过程中，识别出哪些方法或代码块被频繁执行，称为“热点代码”。</li><li>JIT编译器将这些热点代码一次性编译为平台相关的机器码，存储在内存中。</li><li>当热点代码再次被执行时，JVM直接使用编译后的机器码，而不是通过解释器逐行解释，从而大幅提升执行效率。</li></ul><p>优点</p><ul><li>提升性能：JIT编译后的代码直接以机器码形式执行，性能接近于本地编译的程序。</li><li>逐渐优化：JIT编译器可以随着程序的运行，动态调整和优化编译策略。</li></ul><p>缺点</p><ul><li>编译开销：JIT编译会占用一些系统资源，在程序启动的初期可能导致响应变慢。</li><li>内存占用：编译后的机器码需要在内存中保存。</li></ul><h3 id="JVM的执行模式"><a href="#JVM的执行模式" class="headerlink" title="JVM的执行模式"></a>JVM的执行模式</h3><p>JVM在实际运行过程中，可能会采用解释执行和JIT编译的混合模式。在程序刚启动时，JVM可能更多依赖解释器，而当程序运行时间较长、热点代码较多时，JIT编译器将逐步接管更多的工作，从而提升整体运行效率。</p><h3 id="1-1-什么是Just-In-Time-JIT-编译器？"><a href="#1-1-什么是Just-In-Time-JIT-编译器？" class="headerlink" title="1.1 什么是Just-In-Time (JIT) 编译器？"></a>1.1 什么是Just-In-Time (JIT) 编译器？</h3><p><a href="https://blog.csdn.net/Genmer/article/details/119355224">关于Java的JIT(即时编译器)知识整理_java jit-CSDN博客</a></p><p>解释执行：解释执行是采用匹配执行解释器（解释器是个黑盒，通常也有编译器的组成部分）内部已经编译好的机器码，不是生成新的机器码（也有说法是逐条翻译成机器码？）。 - 由于逐条翻译，程序启动快，但是执行效率不高。</p><p>编译执行：运行期间，通过将字节码编译成对应的新的机器码（会将其缓存起来，通过参数-XX:ReservedCodeCacheSize），然后执行。 - 需要先编译出新的机器指令，所以程序启动较慢，但是执行效率高（因为执行的是机器指令）。</p><p>后来因为解释执行必然比执行编译好的机器指令的执行效率低，所以引入JIT（即时编译器）。在执行时，JIT会把翻译过的机器码保存起来，已备下次使用，因此从理论上来说，采用JIT技术能够在执行效率上，接近曾经纯编译技术。</p><p><strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行</strong>；当程序运行后，随着时间的推移，<strong>编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率</strong>。解释执行可以节约内存，而编译执行可以提升效率。</p><p><a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java即时编译器原理解析及实践 - 美团技术团队</a></p><p><img src="https://s2.loli.net/2024/12/16/ztKTYcNZlQoOGVg.png" alt="ba83857ecf9f344e4972fd551c4973d653952"></p><h2 id="2-GC垃圾回收算法"><a href="#2-GC垃圾回收算法" class="headerlink" title="2.GC垃圾回收算法"></a>2.GC垃圾回收算法</h2><p>暂时略过</p><p><a href="https://blog.csdn.net/Pireley/article/details/134315943">Java进阶（垃圾回收GC）——理论篇：JVM内存模型 &amp; 垃圾回收定位清除算法 &amp; JVM中的垃圾回收器_java的内存模型以及gc算法-CSDN博客</a></p><h1 id="JVM如何与操作系统交互？"><a href="#JVM如何与操作系统交互？" class="headerlink" title="JVM如何与操作系统交互？"></a>JVM如何与操作系统交互？</h1><h2 id="1-什么是JNI"><a href="#1-什么是JNI" class="headerlink" title="1.什么是JNI?"></a>1.什么是JNI?</h2><p>JNI（Java Native Interface，Java本地接口）是 Java 提供的一种接口，允许 Java 程序调用本地（Native）代码或被本地代码调用。所谓本地代码通常是用 C 或 C++ 等语言编写的，并直接与底层硬件或操作系统交互。</p><h2 id="2-JNI工作原理？"><a href="#2-JNI工作原理？" class="headerlink" title="2.JNI工作原理？"></a>2.JNI工作原理？</h2><img src="https://s2.loli.net/2024/12/19/RfgdDQ4ilBIpA8O.jpg" alt="4403ab758e8ee449292962c2ec050ba6" style="zoom:50%;" /><h3 id="Java-调用-Native-代码"><a href="#Java-调用-Native-代码" class="headerlink" title="Java 调用 Native 代码"></a><strong>Java 调用 Native 代码</strong></h3><h4 id="为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？"><a href="#为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？" class="headerlink" title="为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？"></a>为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？</h4><p>这也就是JNI层的表现形式，中间的<strong>JNI层其实也是C++代码，它的作用就是桥梁，在这个C++代码中我们可以调用Java层代码也可以调用Native层的C++代码(天然可以，都是C++)<strong>。由于这里特殊的C++代码，可以把俩种混调用(Java和C++)，所以</strong>JNI有它自己的类型</strong>。例如：</p><ul><li><code>int</code> → <code>jint</code></li><li><code>boolean</code> → <code>jboolean</code></li></ul><p><img src="https://s2.loli.net/2024/12/19/ZSuBchRUQf8GF4O.jpg" alt="3fbc8cdc00c9070bffc0f094ae7792e3"></p><h4 id="本地实现函数的命名规则"><a href="#本地实现函数的命名规则" class="headerlink" title="本地实现函数的命名规则"></a>本地实现函数的命名规则</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- 前缀“Java_”。</span><br><span class="hljs-deletion">- 类的全名。</span><br><span class="hljs-deletion">- 下划线分隔符“_”。</span><br><span class="hljs-deletion">- 方法名字。</span><br><span class="hljs-deletion">- 有方法重载的情况时，还会有两个下划线（“__”），后面跟着参数描述符。</span><br></code></pre></td></tr></table></figure><p>假设 Java 类 <code>com.example.MyClass</code> 中有如下的本地方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>对应的本地方法 C 实现会是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JNIEXPORT </span>void <span class="hljs-keyword">JNICALL </span><span class="hljs-keyword">Java_com_example_MyClass_doSomething(JNIEnv </span>*, <span class="hljs-keyword">jobject);</span><br></code></pre></td></tr></table></figure><p>这样，通过 JNI 约定的命名规则，虚拟机可以根据 Java 方法的名称和参数生成与之匹配的本地方法名称，从而成功调用 C&#x2F;C++ 实现的本地方法。</p><h4 id="类加载器与本地库的关系"><a href="#类加载器与本地库的关系" class="headerlink" title="类加载器与本地库的关系"></a><strong>类加载器与本地库的关系</strong></h4><h5 id="1-本地库绑定到类加载器"><a href="#1-本地库绑定到类加载器" class="headerlink" title="(1) 本地库绑定到类加载器"></a><strong>(1) 本地库绑定到类加载器</strong></h5><ul><li>当一个类调用 <code>System.loadLibrary</code> 或 <code>System.load</code> 加载本地库时，该本地库会被绑定到加载该类的类加载器。</li><li>JVM 会确保一个本地库在同一个类加载器中只加载一次。</li><li>如果两个不同的类加载器加载同一个本地库，会导致冲突或错误。</li></ul><h5 id="2-本地方法的作用域"><a href="#2-本地方法的作用域" class="headerlink" title="(2) 本地方法的作用域"></a><strong>(2) 本地方法的作用域</strong></h5><ul><li>本地库中的方法仅在加载该库的类加载器和其加载的类中可用。</li><li>如果不同类加载器的类需要共享同一个本地库，则需要注意：<ul><li>本地库必须显式加载一次，并由共享的类加载器负责。</li><li>否则可能引发 <code>UnsatisfiedLinkError</code>。</li></ul></li></ul><p><strong>(3) 自定义类加载器的影响</strong></p><p>如果使用自定义类加载器加载一个类，并在该类中调用本地方法：</p><ul><li>自定义类加载器的作用域会限制本地库的使用。</li><li>需要确保本地库文件在正确的路径中，或者显式调用 <code>System.load</code> 指定绝对路径。</li></ul><h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><h5 id="类加载器与本地库的关联"><a href="#类加载器与本地库的关联" class="headerlink" title="类加载器与本地库的关联"></a>类加载器与本地库的关联</h5><p>类加载器在加载 Java 类的字节码（<code>.class</code> 文件）如果发现：</p><ul><li><p><strong>显式关联：</strong> 使用 <code>System.loadLibrary()</code> 或 <code>System.load()</code> 函数显式加载本地库。</p><p>例如，如果 Java 类 <code>MyClass</code> 需要调用一个本地方法 <code>nativeMethod()</code>，则在 <code>static</code> 块或类初始化过程中，可能会显式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;mylibrary&quot;</span>);  <span class="hljs-comment">// 显式加载名为 &quot;mylibrary&quot; 的本地库</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>System.loadLibrary(&quot;mylibrary&quot;)</code> 会将名为 <code>&quot;mylibrary&quot;</code> 的本地库与 <code>MyClass</code> 关联。这时，类加载器就会知道需要加载哪个本地库。</p></li><li><p><strong>隐式关联：</strong> 本地库的加载通常在第一次调用本地方法时自动发生。此时，JVM 会在类加载器关联的路径中搜索本地库，并加载适当的本地库。</p><p>例如，当第一次调用 <code>nativeMethod()</code> 时，JVM 会查找并加载该方法对应的本地库。类加载器会使用它的 <code>nativeLibrary</code> 搜索路径来找到相应的本地库。</p></li></ul><h5 id="类加载器如何与本地库关联"><a href="#类加载器如何与本地库关联" class="headerlink" title="类加载器如何与本地库关联"></a>类加载器如何与本地库关联</h5><p>加载器会维护一个本地库搜索路径，来查找它关联的本地库。这个路径通常是在启动 Java 程序时通过环境变量、Java 参数或类加载器配置进行设置的。类加载器的本地库搜索路径包括：</p><p><strong>系统路径：</strong> 默认情况下，JVM 会在操作系统的标准路径（如 <code>PATH</code> 环境变量中的路径，Windows 上的 <code>.dll</code> 文件路径，Unix&#x2F;Linux 上的 <code>.so</code> 文件路径）中查找本地库。</p><p><strong>指定路径：</strong> 当调用 <code>System.loadLibrary()</code> 时，本地库路径可能会通过 JVM 参数传递（例如 <code>-Djava.library.path</code>）。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">java -Djava.<span class="hljs-keyword">library</span>.path=/path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">library</span> MyClass<br></code></pre></td></tr></table></figure><p>在这个例子中，JVM 会使用 <code>-Djava.library.path</code> 参数指定的路径来搜索本地库。</p><p><strong>类加载器路径：</strong> 每个类加载器（比如 <code>AppClassLoader</code> 或自定义的类加载器）也可能有自己独立的路径来加载本地库。这个路径由类加载器的实现决定。</p><h5 id="本地库加载的时机"><a href="#本地库加载的时机" class="headerlink" title="本地库加载的时机"></a>本地库加载的时机</h5><p>本地库的加载通常发生在第一次调用本地方法时，即在 <strong>链接本地方法时</strong>。这个过程分为几个步骤：</p><ol><li><strong>类加载：</strong> 当 JVM 加载包含本地方法的类时，它会检查该类是否包含 <code>native</code> 方法。如果包含，JVM 就会在后续的调用中解析这个本地方法。</li><li><strong>本地方法调用：</strong> 当 Java 代码首次调用 <code>native</code> 方法时，JVM 会尝试加载与该方法相关联的本地库。</li><li><strong>本地库加载：</strong> JVM 会根据类加载器的配置，搜索本地库。如果找到相应的本地库，JVM 就会将本地方法与本地库中的实现绑定，并建立关联。</li><li><strong>链接成功：</strong> 一旦本地方法被链接，JVM 会创建内部的数据结构（如函数指针或本地方法的映射表），使得后续的调用可以直接跳转到本地库中的对应函数。</li></ol><h3 id="Native-代码调用-Java"><a href="#Native-代码调用-Java" class="headerlink" title="Native 代码调用 Java"></a><strong>Native 代码调用 Java</strong></h3><h4 id="JNIEnv接口指针"><a href="#JNIEnv接口指针" class="headerlink" title="JNIEnv接口指针"></a>JNIEnv接口指针</h4><p>本地代码通过JNIEnv接口指针里暴露的方法来使用虚拟机的功能。</p><p>JNIEnv是一个指向本地线程数据的接口指针，这个指针里面包含了一个指向函数表的指针。每一个接口函数在这表中都有一个 预定义的偏移位置。JNIEnv很像一个C++虚函数表或者Microsoft COM接口。</p><p><img src="https://s2.loli.net/2024/12/19/ZtgFubyJGQTnYMv.png" alt="jnienv"></p><h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>像int、char等这样的基本数据类型，在本地代码和JVM之间进行复制传递，而对象是引用传递的。每一个引用都包含一个指向JVM 中相应的对象的指针，但本地代码不能直接使用这个指针，必须通过引用来间接使用。<br>比起传递直接指针来说，传递引用可以让VM更灵活地管理对象。</p><h5 id="局部引用与全局引用"><a href="#局部引用与全局引用" class="headerlink" title="局部引用与全局引用"></a>局部引用与全局引用</h5><p>JNI可以为本地代码创建两种对象引用：局部引用和全局引用。局部引用的有效期是本地方法的调用期间，调用完成后，局部引用 会被JVM自动铲除。而全局引用，除非显示释放它，否则将一直存在。<br>JVM中的对象作为参数传递给本地方法时，用的是局部引用。大部分的JNI函数返回局部引用。JNI允许程序员从局部引用创建一个 全局引用。接受对象作为参数的JNI函数既支持全局引用也支持局部引用。本地方法执行完毕后，向JVM返回结果时，它可能向JVM 返回局部引用，也可能返回全局引用。<br>局部引用只在创建它的线程内部有效。本地代码不能跨线程传递和使用局部引用。<br>JNI中的NULL引用指向JVM中的null对象。对一个全局引用或者局部引用来说，只要它的值不是NULL，它就不会指向一个null对象。</p><h5 id="局部引用的实现"><a href="#局部引用的实现" class="headerlink" title="局部引用的实现"></a>局部引用的实现</h5><p>一个对象从JVM传递给本地方法时，就把控制权移交了过去，JVM会为每一个对象的传递创建一条记录，一条记录就是一个本地代码 中的引用和JVM中的对象的一个映射。记录中的对象不会被GC回收。所有传递到本地代码中的对象和从JNI函数返回的对象都被自动 地添加到映射表中。当本地方法返回时，VM会删除这些映射，允许GC回收记录中的数据。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用所指向的对象允许JVM回收，当对象被回收以后，弱引用也会被清除。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/Delilah_java/article/details/119778422">一篇JVM详细图解，坚持看完！带你真正搞懂Java虚拟机！_jvm图解-CSDN博客</a></p><p><a href="https://blog.csdn.net/createchance/article/details/53783490">Java Native Interface(JNI)从零开始详细教程_java jni-CSDN博客</a></p><p><a href="https://luori366.github.io/JNI_doc/jni_design_theory.html">JNI的作用与工作原理 | JNI_doc</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
