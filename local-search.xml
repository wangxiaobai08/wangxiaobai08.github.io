<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2</title>
    <link href="/2024/12/18/2/"/>
    <url>/2024/12/18/2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学</title>
    <link href="/2024/12/18/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <url>/2024/12/18/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p><img src="https://s21.ax1x.com/2024/09/28/pA1VbIH.jpg" alt="1"></p><p>简化版：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1VLid.png" alt="2"></p><h1 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h1><blockquote><p>机密性是指向无权访问数据者隐藏真实数据，而加密可以实现这一目标。发明密码学的初衷就是加密，加密也是早期的密码学家最关心的技术，他们经常会问自己：“如何才能向观察者隐藏我们的对话内容？”</p></blockquote><p>对称加密算法是一种加密方法，使用相同的密钥进行数据的加密和解密。发送方和接收方必须共享同一个密钥，以便于对数据进行加密和解密。对称加密算法通常速度较快，适用于大数据量的加密。这其中又因为应用场景不同又分为分块加密和流加密。</p><p>分组加密将数据分为固定大小的块逐块加密，适合大数据量，如文件加密；流加密则逐字节加密，适合实时数据传输，如音视频流。分组加密速度较慢，流加密较快，但流加密在错误传播时影响更大。</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1Vjzt.png" alt="image-20240928180400857"></p><h2 id="分组密码算法-Block-cipher"><a href="#分组密码算法-Block-cipher" class="headerlink" title="分组密码算法(Block cipher)"></a>分组密码算法(Block cipher)</h2><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>AES加密算法.pdf   <a href="https://www.alipan.com/s/nZN1ABDPfGf">https://www.alipan.com/s/nZN1ABDPfGf</a> 提取码: sw76 </p><h3 id="TEA算法"><a href="#TEA算法" class="headerlink" title="TEA算法"></a>TEA算法</h3><p>TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的。</p><p>TEA 算法使用 64 位的明文分组和 128 位的密钥，它使用 Feistel 分组加密框架，建议的迭代次数为 32 轮。该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ&#x3D;「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）。</p><p>之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Encrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    <span class="hljs-comment">//总共加密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        sum += delta;<br>        x += ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        y += ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Decrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    sum = delta &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">//注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br>    <span class="hljs-comment">//总共加密32轮 那么反序也解密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        <span class="hljs-comment">// 先将y解开 然后参与运算在解x</span><br>        y -= ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>        x -= ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        sum -= delta;<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> Data[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">//明文，必须是8字节的倍数，不够需要程序补全，参考base64方法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;待加密的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);  <br><br>    <span class="hljs-type">long</span> key[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;   <span class="hljs-comment">//密钥随便</span><br><br>    <span class="hljs-comment">//Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.</span><br>    Encrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;加密后的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);<br>    Decrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密后的数值：%d %d\&quot;,Data[0],Data[1]);</span><br><span class="hljs-string">    system(&quot;</span>pause<span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h5 id="逆向练习："><a href="#逆向练习：" class="headerlink" title="逆向练习："></a>逆向练习：</h5><p>题目来源：攻防世界(easy-app)</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1VXRI.png" alt="image-20240925190902367"></p><h2 id="流密码算法-Stream-cipher"><a href="#流密码算法-Stream-cipher" class="headerlink" title="流密码算法(Stream cipher)"></a>流密码算法(Stream cipher)</h2><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><h1 id="非对称密码算法"><a href="#非对称密码算法" class="headerlink" title="非对称密码算法"></a><strong>非对称密码算法</strong></h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>对称加密(公钥密码算法)的安全性依赖于密钥的保密性和算法的强度。如果密钥被泄露，攻击者可以轻易解密数据。因此，在实际应用中，密钥管理和分发是对称加密的关键挑战之一。而通过使用密钥交换协议，通信双方可以安全地获得一个对称密钥，而敌手却无法知道这个对称密钥。</p><p>非对称密码算法使用一对密钥进行加密和解密，通常包括公钥和私钥。公钥可以公开，任何人都可以使用它加密数据；而私钥则必须保密，仅由拥有者使用来解密数据。</p><p><strong>主要特性</strong>：</p><ol><li><strong>密钥对</strong>：每个用户拥有一对密钥，公钥用于加密，私钥用于解密。</li><li><strong>安全性</strong>：即使公钥被公开，私钥的保密性仍能确保加密数据的安全性。</li><li><strong>身份验证</strong>：可用于数字签名，通过私钥签名的数据可以用公钥验证，确保信息来源和完整性。</li></ol><p><img src="https://s21.ax1x.com/2024/09/28/pA1VxQP.png" alt="image-20240928180525589"></p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>RSA加密算法.pdf <a href="https://www.alipan.com/s/tpBA521QB9q">https://www.alipan.com/s/tpBA521QB9q</a> 提取码: k9b2 </p><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-comment">// 计算最大公约数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// 求模反元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">modInverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt; m; x++) &#123;<br>        <span class="hljs-keyword">if</span> ((a * x) % m == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 快速幂算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">power</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    x = x % p;<br>    <span class="hljs-keyword">while</span> (y &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) <br>            res = (res * x) % p;<br>        y = y &gt;&gt; <span class="hljs-number">1</span>;<br>        x = (x * x) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// RSA加密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(m, e, n);<br>&#125;<br><br><span class="hljs-comment">// RSA解密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_decrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(c, d, n);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">61</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> q = <span class="hljs-number">53</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> n = p * q; <span class="hljs-comment">// 计算n</span><br>    <span class="hljs-type">int</span> phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算φ(n)</span><br>    <br>    <span class="hljs-type">int</span> e = <span class="hljs-number">17</span>; <span class="hljs-comment">// 选择公钥</span><br>    <span class="hljs-keyword">while</span> (gcd(e, phi) != <span class="hljs-number">1</span>) &#123;<br>        e++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> d = modInverse(e, phi); <span class="hljs-comment">// 计算私钥</span><br>    <br>    <span class="hljs-type">int</span> m = <span class="hljs-number">65</span>; <span class="hljs-comment">// 明文</span><br>    <span class="hljs-type">int</span> c = rsa_encrypt(m, e, n); <span class="hljs-comment">// 加密</span><br>    <span class="hljs-type">int</span> decrypted = rsa_decrypt(c, d, n); <span class="hljs-comment">// 解密</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;明文: %d\n&quot;</span>, m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;密文: %d\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密: %d\n&quot;</span>, decrypted);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>简单地说，数字签名的作用类似于现实生活中在支票和合同上的签名。当然数字签名是一种密码学技术，相比手写签名，它提供了更多的安全保证。当数字签名应用在各种各样的协议中时，它会让这些协议具有更加强大的功能</p><p>我们知道数字签名与现实生活中的签名非常相似。该密码学原语是在直观上很容易理解的密码原语之一。</p><ul><li>只有签名者本人可以对任意消息生成签名。</li><li>任何人都可以验证签名者对消息的签名。</li></ul><p><strong>在非对称密码领域，我们很容易想到数字签名的这种非对称性实现方式。</strong></p><p>签名方案通常由3种不同的算法组成。</p><ul><li>密钥对生成算法：签名者使用该算法生成新的私钥和公钥（公钥可以共享出去）。</li><li>签名算法：该算法以私钥和消息为输入，输出消息的签名。</li><li>验证算法：该算法以公钥、消息以及消息的签名为输入，输出验证结果（通过或不通过）。</li></ul><p>有时我们也将私钥称为签名密钥，将公钥称为验证密钥。上述3种算法的原理如图7.1所示。</p><p><img src="https://s2.loli.net/2024/12/18/9vMmelxptT35azP.png" alt="image-20240928211112408"></p><p>那么为什么数字签名应用如此广泛呢？这是因为数字签名可以用于验证消息的来源以及完整性。</p><ul><li>来源：如果这个消息中包含某个人的签名，那么说明该消息源于这个人。</li><li>完整性：如果有人篡改了消息，签名就会失效。</li></ul><h3 id="数字证书-公钥的数字签名"><a href="#数字证书-公钥的数字签名" class="headerlink" title="数字证书(公钥的数字签名)"></a>数字证书(公钥的数字签名)</h3><p>数字证书也称为身份证书和<a href="https://zhida.zhihu.com/search?content_id=222777750&content_type=Article&match_order=1&q=%E5%85%AC%E9%92%A5%E8%AF%81%E4%B9%A6&zhida_source=entity">公钥证书</a>，是一种利用公钥基础设施(PKI)并使个人和企业能够通过互联网安全地共享数据的电子密码。</p><p>在信任可传递的假设下，数字签名将变得更加强大。简而言之，如果你相信我，而我相信Alice，那么你就可以相信Alice。信任的传递性使得系统中的信任关系得到极大地扩展。想象一下，假设我们信任某些权威机构及其验证密钥。那么，假设该权威机构对某些消息进行签名，比如Charles或者David的公钥信息等，我们就可以选择相信这个签名与消息的映射关系！这种映射称为公钥基础设施(Public Key Infrastructure，PKI)。例如，当我们尝试与Charles进行密钥交换，且他声称自己的公钥是3848时，可以通过检查我们信任的权威机构是否对类似“Charles的公钥是3848…”的消息进行签名来验证Charles的公钥的真实性。</p><p>PKI在实践中的一个应用是Web PKI。浏览器每天都通过Web PKI对我们与网站的密钥交换过程进行认证。Web PKI可以简化如下（见图7.3）过程：当我们下载浏览器时，它附带了一些内置在浏览器中的验证密钥。此验证密钥与一个权威机构相关联，该机构负责对成千上万个网站的公钥进行签名，以便网络用户可以信任这些公钥，而不必知道权威机构的存在。而用户不能观察到的是，这些网站在获得它们公钥的签名之前，必须向权威机构证明它们确实拥有自己所声称的域名。（事实上，浏览器信任许多权威机构而不仅只有一个。）</p><p><img src="https://s2.loli.net/2024/12/18/kUbWm1H7R6QrIux.png" alt="image-20240928212930338"></p><h1 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a><strong>摘要算法</strong></h1><h2 id="密码原语-基础知识"><a href="#密码原语-基础知识" class="headerlink" title="密码原语(基础知识)"></a>密码原语(基础知识)</h2><p>哈希函数(Hash Function)，它可以给任何数据生成一个全局唯一的标识符。哈希函数在密码学中随处可见！非正式地说，哈希函数以任意值为输入，并输出一个唯一的字节串。给定相同的输入，哈希函数总是产生相同的字节串。这可能看起来没什么，但在密码学中，许多算法都是基于哈希函数构造的。哈希函数的输出通常被称为摘要(Digest)或哈希值(Hash)</p><p>哈希函数的三种安全属性的表格及其简要介绍：</p><table><thead><tr><th>属性</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>抗第一原像性</td><td>给定哈希值，无法找到一个输入值，使得该输入值的哈希值等于该给定哈希值。</td><td>这确保了即使攻击者知道哈希值，也不能轻易反推原始输入。</td></tr><tr><td>抗第二原像性</td><td>给定输入值，无法找到另一个不同的输入值，使得两个输入的哈希值相同。</td><td>这保证了不同输入产生相同哈希值的概率极低，有效抵御替换攻击。</td></tr><tr><td>抗碰撞性</td><td>任何两个不同的输入值，几乎不可能产生相同的哈希值。</td><td>这使得攻击者无法找到两个不同的输入使它们的哈希值相同。</td></tr></tbody></table><p>主要应用场景：</p><table><thead><tr><th>应用场景</th><th>描述</th></tr></thead><tbody><tr><td>数据完整性验证</td><td>检查数据在传输或存储过程中的完整性，确保未被篡改。</td></tr><tr><td>密码存储</td><td>将用户密码哈希后存储，防止直接获取明文密码。</td></tr><tr><td>数字签名</td><td>生成数字签名的摘要，确保签名的数据未被篡改并提供身份验证。</td></tr><tr><td>文件完整性校验</td><td>在软件分发时，通过哈希值验证下载文件的完整性，防止恶意篡改。</td></tr><tr><td>区块链技术</td><td>用于生成区块的哈希值，确保区块链中的数据不可篡改和一致性。</td></tr><tr><td>身份认证</td><td>在安全协议中，确保用户身份的验证，防止伪造身份。</td></tr><tr><td>网络协议安全</td><td>在SSL&#x2F;TLS等协议中用于数据传输的安全性和完整性校验。</td></tr><tr><td>防止重放攻击</td><td>确保每次通信都有唯一的哈希值，防止旧通信内容被重放。</td></tr><tr><td>电子邮件安全</td><td>用于生成邮件的哈希值，确保邮件内容未被篡改。</td></tr><tr><td>代码签名</td><td>验证软件代码的完整性和来源，确保软件未被篡改。</td></tr></tbody></table><h2 id="消息摘要算法-Message-Digest"><a href="#消息摘要算法-Message-Digest" class="headerlink" title="消息摘要算法(Message Digest)"></a>消息摘要算法(Message Digest)</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><h4 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： MD5（Message-Digest Algorithm 5）是一种广泛使用的哈希函数，它产生一个128位（16字节）的哈希值，通常以32位十六进制数字表示。</p><p><strong>主要特性</strong>：</p><ul><li><strong>输出固定长度</strong>：无论输入数据大小如何，MD5总是生成128位的哈希值。</li><li><strong>快速计算</strong>：MD5的计算速度相对较快，适合处理大量数据。</li><li><strong>抗碰撞性</strong>：理论上，MD5应保证不同输入不产生相同的哈希值（尽管实际应用中存在漏洞）。</li><li><strong>广泛应用</strong>：MD5曾被广泛用于数据完整性校验、数字签名和密码存储等场景。</li></ul><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块"><a href="#数据填充和分块" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>对待加密的文件或者字符串的处理是将一个字符串分割成每512位为一个分组(小到KB大到GB都是如此划分)，形如N*512+R，这里的R是余下的位数。这个R分为几种情况：</p><ul><li>当R&#x3D;0时，实际上不需要单独“补上一个512位的分组”，因为接下来的填充和长度信息添加会自动形成一个完整的分组。</li><li>当R&lt;448时，需要在消息后面添加一个<code>1</code>，然后添加足够多的<code>0</code>，直到消息长度达到448位。之后，添加64位的长度信息（即原始消息的长度，以位为单位，低位在前）。</li><li>当R&gt;448时，确实需要添加足够的<code>0</code>（加上那个初始的<code>1</code>）来填满当前分组（即达到512位），然后在下一个分组中继续添加64位的长度信息(下一个分组的前64位)。但请注意，这里不是“再补上一个512位的分组”，而是说长度信息会放在一个新的分组中（如果原始消息加上填充的<code>1</code>和<code>0</code>不足以填满一个完整的分组，则可能看起来像是“再补”了一个分组，但实际上只是长度信息占据了一个分组的前部分）。</li></ul><p>这里的最后长度的填充一般在输出的前一刻执行。前面的分块后就可以执行后续操作了。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">Md5Finalise</span>  <br><span class="hljs-params">(  </span><br><span class="hljs-params">    Md5Context*         Context,        <span class="hljs-comment">// [in out] 指向MD5上下文的指针，该上下文将被修改以完成哈希计算。  </span></span><br><span class="hljs-params">    MD5_HASH*           Digest          <span class="hljs-comment">// [out] 用于接收最终哈希值的缓冲区。  </span></span><br><span class="hljs-params">)</span>  <br>&#123;  <br>    <span class="hljs-type">uint32_t</span>    used;     <span class="hljs-comment">// 用于存储缓冲区中已使用字节的数量。  </span><br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;     <span class="hljs-comment">// 用于存储缓冲区中剩余空闲字节的数量。  </span><br>  <br>    <span class="hljs-comment">// 计算缓冲区中已使用的字节数。  </span><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;  <br>  <br>    <span class="hljs-comment">// 在缓冲区的当前位置添加一个0x80字节作为填充的开始。  </span><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;  <br>  <br>    <span class="hljs-comment">// 计算填充0x80字节后剩余的空闲空间。  </span><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;  <br>  <br>    <span class="hljs-comment">// 如果剩余的空闲空间不足以存放64位长度信息，则进行填充、变换，并重置used和free。  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );  <br>        <span class="hljs-comment">//压缩循环函数(暂时不要管)</span><br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br>        used = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 在剩余空间中填充0，直到距离缓冲区末尾剩下8个字节用于存放长度信息。  </span><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );  <br>  <br>    <span class="hljs-comment">// 将消息长度（以位为单位）左移3位（这不是标准MD5），并存储到缓冲区末尾。  </span><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;  <br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );  <br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );  <br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );  <br>  <br>    <span class="hljs-comment">// 对填充后的缓冲区进行最后的变换，得到最终的哈希值。  </span><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br></code></pre></td></tr></table></figure><h5 id="链接变量初始化"><a href="#链接变量初始化" class="headerlink" title="链接变量初始化"></a>链接变量初始化</h5><p>初始化一个128-bit 的 MD 缓冲区，初始记为CV0，可以表示成4个32-bit 寄存器（A, B, C, D），后续的迭代始终在 MD 缓冲区进行，最后一步的128-bit 输出即为MD5算法的结果。</p><p>MD5有四个32位的被称作链接变量的整数参数，这是个参数我们定义为A、B、C、D其取值为：A&#x3D;0x01234567，B&#x3D;0x89abcdef，C&#x3D;0xfedcba98，D&#x3D;0x76543210。但考虑到内存数据存储大小端的问题我们将其赋值为：A&#x3D;0x67452301，B&#x3D;0xefcdab89，C&#x3D;0x98badcfe，D&#x3D;0x10325476。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span>     lo;<br>    <span class="hljs-type">uint32_t</span>     hi;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint8_t</span>      buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">uint32_t</span>     block[<span class="hljs-number">16</span>];<br>&#125; Md5Context;<br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;a = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;b = <span class="hljs-number">0xefcdab89</span>;<br>    Context-&gt;c = <span class="hljs-number">0x98badcfe</span>;<br>    Context-&gt;d = <span class="hljs-number">0x10325476</span>;<br><br>    Context-&gt;lo = <span class="hljs-number">0</span>;<br>    Context-&gt;hi = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="压缩循环"><a href="#压缩循环" class="headerlink" title="压缩循环"></a>压缩循环</h5><p>MD5算法规定了四个非线性操作函数（&amp;是与，|是或，~是非，^是异或）</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define F( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">z</span>) ^ ((<span class="hljs-name">x</span>) &amp; ((<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>))) )<br>#define G( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">z</span>) &amp; ((<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>))) )<br>#define H( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>) )<br>#define I( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">x</span>) | ~(<span class="hljs-name">z</span>)) )<br></code></pre></td></tr></table></figure><p>这些函数设计思想的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。</p><p>利用上面的四种操作，生成四个重要的计算函数。首先我们声明四个中间变量a,b,c,d，赋值：a &#x3D; A, b &#x3D; B, c &#x3D; C, d &#x3D; D。然后定义这四个计算函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br></code></pre></td></tr></table></figure><p>其中M[j]表示消息的第j个子分组（从0到15），&lt;&lt;表示循环左移s，常数ti是4294967296*abs(sin(i))的整数部分，i取值从1到64，单位是弧度。</p><p>定义好上述的四个计算函数后，就可以实现MD5的真正循环计算了。<strong>这个循环的循环次数为512位分组的个数</strong>。</p><blockquote><p>压缩函数每次都从CV（即上文提到的 128-bit 缓冲区）输入128位，从之前分好的消息分组中按顺序输入512位，完成4轮循环后，得到该轮压缩的128位结果，加到原来的缓冲区中，然后用下一分组继续上述步骤。（<strong>说具体一点，就是函数每次都从缓冲区(A, B, C, D)拿到四个数a, b, c, d，然后对于a, b, c, d进行压缩循环操作，把最后得到的结果a, b, c, d加到原来的(A, B, C, D)中，下一次函数执行再从(A, B, C, D)中拿数据</strong>）</p></blockquote><p>每次循环执行64次计算，上述4个函数每个16次.</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span>*<br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*     ctx,</span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*     data,</span><br><span class="hljs-params">        <span class="hljs-type">uintmax_t</span>       size</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span>*     ptr;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint32_t</span>     saved_a;<br>    <span class="hljs-type">uint32_t</span>     saved_b;<br>    <span class="hljs-type">uint32_t</span>     saved_c;<br>    <span class="hljs-type">uint32_t</span>     saved_d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> GET(n) (ctx-&gt;block[(n)])</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(n) (ctx-&gt;block[(n)] =             \</span><br><span class="hljs-meta">            ((uint32_t)ptr[(n)*4 + 0] &lt;&lt; 0 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 1] &lt;&lt; 8 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 2] &lt;&lt; 16)      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 3] &lt;&lt; 24) )</span><br><br>    ptr = (<span class="hljs-type">uint8_t</span>*)data;<br><br>    a = ctx-&gt;a;<br>    b = ctx-&gt;b;<br>    c = ctx-&gt;c;<br>    d = ctx-&gt;d;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        saved_a = a;<br>        saved_b = b;<br>        saved_c = c;<br>        saved_d = d;<br><br>        <span class="hljs-comment">// Round 1</span><br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xd76aa478</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xe8c7b756</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x242070db</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xc1bdceee</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf57c0faf</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">5</span>),  <span class="hljs-number">0x4787c62a</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa8304613</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xfd469501</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">8</span> ),  <span class="hljs-number">0x698098d8</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">9</span> ),  <span class="hljs-number">0x8b44f7af</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">10</span> ), <span class="hljs-number">0xffff5bb1</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">11</span> ), <span class="hljs-number">0x895cd7be</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">12</span> ), <span class="hljs-number">0x6b901122</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">13</span> ), <span class="hljs-number">0xfd987193</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">14</span> ), <span class="hljs-number">0xa679438e</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">15</span> ), <span class="hljs-number">0x49b40821</span>, <span class="hljs-number">22</span> )<br><br>        <span class="hljs-comment">// Round 2</span><br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xf61e2562</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xc040b340</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x265e5a51</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xe9b6c7aa</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xd62f105d</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0x02441453</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xd8a1e681</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xe7d3fbc8</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0x21e1cde6</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xc33707d6</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xf4d50d87</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x455a14ed</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0xa9e3e905</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xfcefa3f8</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x676f02d9</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x8d2a4c8a</span>, <span class="hljs-number">20</span> )<br><br>        <span class="hljs-comment">// Round 3</span><br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfffa3942</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x8771f681</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x6d9d6122</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xfde5380c</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xa4beea44</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0x4bdecfa9</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xf6bb4b60</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xbebfbc70</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x289b7ec6</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xeaa127fa</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xd4ef3085</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0x04881d05</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xd9d4d039</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0xe6db99e5</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0x1fa27cf8</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xc4ac5665</span>, <span class="hljs-number">23</span> )<br><br>        <span class="hljs-comment">// Round 4</span><br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xf4292244</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x432aff97</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xab9423a7</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfc93a039</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x655b59c3</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0x8f0ccc92</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xffeff47d</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0x85845dd1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x6fa87e4f</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xfe2ce6e0</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa3014314</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x4e0811a1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf7537e82</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0xbd3af235</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x2ad7d2bb</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xeb86d391</span>, <span class="hljs-number">21</span> )<br><br>        a += saved_a;<br>        b += saved_b;<br>        c += saved_c;<br>        d += saved_d;<br><br>        ptr += <span class="hljs-number">64</span>;<br>    &#125; <span class="hljs-keyword">while</span>( size -= <span class="hljs-number">64</span> );<br><br>    ctx-&gt;a = a;<br>    ctx-&gt;b = b;<br>    ctx-&gt;c = c;<br>    ctx-&gt;d = d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> GET</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> SET</span><br><br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*         Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    saved_lo;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    saved_lo = Context-&gt;lo;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;lo = (saved_lo + BufferSize) &amp; <span class="hljs-number">0x1fffffff</span>) &lt; saved_lo )<br>    &#123;<br>        Context-&gt;hi++;<br>    &#125;<br>    Context-&gt;hi += (<span class="hljs-type">uint32_t</span>)( BufferSize &gt;&gt; <span class="hljs-number">29</span> );<br><br>    used = saved_lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    <span class="hljs-keyword">if</span>( used )<br>    &#123;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>        <span class="hljs-keyword">if</span>( BufferSize &lt; <span class="hljs-built_in">free</span> )<br>        &#123;<br>            <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, BufferSize );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, <span class="hljs-built_in">free</span> );<br>        Buffer = (<span class="hljs-type">uint8_t</span>*)Buffer + <span class="hljs-built_in">free</span>;<br>        BufferSize -= <span class="hljs-built_in">free</span>;<br>        TransformFunction(Context, Context-&gt;buffer, <span class="hljs-number">64</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( BufferSize &gt;= <span class="hljs-number">64</span> )<br>    &#123;<br>        Buffer = TransformFunction( Context, Buffer, BufferSize &amp; ~(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-number">0x3f</span> );<br>        BufferSize &amp;= <span class="hljs-number">0x3f</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( Context-&gt;buffer, Buffer, BufferSize );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h5><p>处理完所有的512位的分组后，得到一组新的A,B,C,D的值，将这些值按ABCD的顺序级联，就得到了想要的MD5散列值。当然，输出依然要考虑内存存储的大小端问题。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Finalise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        MD5_HASH*           Digest          <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;<br><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );<br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>        used = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );<br><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;<br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );<br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );<br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );<br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );<br><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>    <br>    <br>    <span class="hljs-comment">//-----------结果输出-----------------</span><br><br>    Digest-&gt;bytes[<span class="hljs-number">0</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a );<br>    Digest-&gt;bytes[<span class="hljs-number">1</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">2</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">3</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">4</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b );<br>    Digest-&gt;bytes[<span class="hljs-number">5</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">6</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">7</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">8</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c );<br>    Digest-&gt;bytes[<span class="hljs-number">9</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">10</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">11</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">12</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d );<br>    Digest-&gt;bytes[<span class="hljs-number">13</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">14</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">15</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">24</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h3><p><a href="https://www.cnblogs.com/myseries/p/11581170.html">MD5算法+盐Salt - myseries - 博客园 (cnblogs.com)</a></p><p><strong>概念</strong>： MD5加盐是指在计算MD5哈希值时，向原始数据中添加一个随机的字符串（称为“盐”），以增强哈希值的安全性。盐的主要目的是防止使用预计算的哈希值（如彩虹表）进行攻击。(MD5加盐常用于密码存储、用户认证等需要保护敏感数据的场合)</p><p><strong>工作原理</strong>：</p><ol><li><strong>生成盐</strong>：为每个用户或数据生成一个随机字符串，通常长度在8至16字节之间。</li><li><strong>组合数据</strong>：将盐与原始数据（如密码）结合。可以是简单的拼接，或采用更复杂的方式。</li><li><strong>计算哈希</strong>：使用MD5算法计算组合后的数据的哈希值。</li></ol><h2 id="安全散列算法-Secure-Hash-Algorithm"><a href="#安全散列算法-Secure-Hash-Algorithm" class="headerlink" title="安全散列算法(Secure Hash Algorithm)"></a>安全散列算法(Secure Hash Algorithm)</h2><p>哈希函数的概念最早出现在计算机科学中，主要用于数据结构（如哈希表）和简单的完整性校验</p><h3 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h3><h4 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-1（Secure Hash Algorithm 1）是一种广泛使用的加密哈希函数，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于1995年。SHA-1生成一个160位（20字节）的哈希值，通常以40位十六进制数表示。(SHA-1已不再安全)</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出固定长度</strong>：无论输入数据的大小，SHA-1总是生成160位的哈希值。</li><li><strong>快速计算</strong>：SHA-1计算速度较快，适合处理大数据量。</li><li><strong>抗碰撞性</strong>：SHA-1设计上应保证不同输入产生不同哈希值，但随着研究的深入，已被发现存在碰撞漏洞。</li></ol><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块-1"><a href="#数据填充和分块-1" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>将512位的明文分组划分为16个子明文分组，每个子明文分组为32位。</p><p>其中分块与填充同MD5相同不多赘述</p><h5 id="初始化MD-Buffer"><a href="#初始化MD-Buffer" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-comment">// SHA1 initialisation constants</span><br>    Context-&gt;State[<span class="hljs-number">0</span>] = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;State[<span class="hljs-number">1</span>] = <span class="hljs-number">0xEFCDAB89</span>;<br>    Context-&gt;State[<span class="hljs-number">2</span>] = <span class="hljs-number">0x98BADCFE</span>;<br>    Context-&gt;State[<span class="hljs-number">3</span>] = <span class="hljs-number">0x10325476</span>;<br>    Context-&gt;State[<span class="hljs-number">4</span>] = <span class="hljs-number">0xC3D2E1F0</span>;<br>    Context-&gt;Count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    Context-&gt;Count[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="16份子明文分组扩展为80份"><a href="#16份子明文分组扩展为80份" class="headerlink" title="16份子明文分组扩展为80份"></a>16份子明文分组扩展为80份</h5><p>扩充的方法:</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1Z9eS.png" alt="image-20240919202000585"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> blk(i) (block-&gt;l[i&amp;15] = rol(block-&gt;l[(i+13)&amp;15] ^ block-&gt;l[(i+8)&amp;15] ^ block-&gt;l[(i+2)&amp;15] ^ block-&gt;l[i&amp;15],1))</span><br><span class="hljs-comment">//rol函数用于循环左移:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rol(value, bits) (((value) <span class="hljs-string">&lt;&lt; (bits)) | ((value) &gt;</span>&gt; (32 - (bits))))</span><br></code></pre></td></tr></table></figure><h5 id="80份子明文分组进行4轮运算"><a href="#80份子明文分组进行4轮运算" class="headerlink" title="80份子明文分组进行4轮运算"></a>80份子明文分组进行4轮运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1ZSL8.png" alt="image-20240919203025400"></p><p>其中k为固定值：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1eT4H.png" alt="2"></p><p>f函数为(之所以称为四轮运算的原因)：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1eb8A.png" alt="1111"></p><h5 id="链接变量与初始链接变量进行求和运算"><a href="#链接变量与初始链接变量进行求和运算" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1eqgI.png" alt="image-20240919203559058"></p><p>这里的Ho就是初始化的5个常量</p><p>注意这里的”+”是指:</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mSUg.png" alt="image-20240919203941364"></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            state[<span class="hljs-number">5</span>],</span><br><span class="hljs-params">        <span class="hljs-type">uint8_t</span> <span class="hljs-type">const</span>       buffer[<span class="hljs-number">64</span>]</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>            a;<br>    <span class="hljs-type">uint32_t</span>            b;<br>    <span class="hljs-type">uint32_t</span>            c;<br>    <span class="hljs-type">uint32_t</span>            d;<br>    <span class="hljs-type">uint32_t</span>            e;<br>    <span class="hljs-type">uint8_t</span>             workspace[<span class="hljs-number">64</span>];<br>    CHAR64LONG16*       block = (CHAR64LONG16*) workspace;<br><br>    Load128BitsAsWords( block-&gt;l, buffer );<br><br>    <span class="hljs-comment">// Copy context-&gt;state[] to working vars</span><br>    a = state[<span class="hljs-number">0</span>];<br>    b = state[<span class="hljs-number">1</span>];<br>    c = state[<span class="hljs-number">2</span>];<br>    d = state[<span class="hljs-number">3</span>];<br>    e = state[<span class="hljs-number">4</span>];<br><br>    <span class="hljs-comment">// 4 rounds of 20 operations each. Loop unrolled.</span><br>    R0(a,b,c,d,e, <span class="hljs-number">0</span>); R0(e,a,b,c,d, <span class="hljs-number">1</span>); R0(d,e,a,b,c, <span class="hljs-number">2</span>); R0(c,d,e,a,b, <span class="hljs-number">3</span>);<br>    R0(b,c,d,e,a, <span class="hljs-number">4</span>); R0(a,b,c,d,e, <span class="hljs-number">5</span>); R0(e,a,b,c,d, <span class="hljs-number">6</span>); R0(d,e,a,b,c, <span class="hljs-number">7</span>);<br>    R0(c,d,e,a,b, <span class="hljs-number">8</span>); R0(b,c,d,e,a, <span class="hljs-number">9</span>); R0(a,b,c,d,e,<span class="hljs-number">10</span>); R0(e,a,b,c,d,<span class="hljs-number">11</span>);<br>    R0(d,e,a,b,c,<span class="hljs-number">12</span>); R0(c,d,e,a,b,<span class="hljs-number">13</span>); R0(b,c,d,e,a,<span class="hljs-number">14</span>); R0(a,b,c,d,e,<span class="hljs-number">15</span>);<br>    R1(e,a,b,c,d,<span class="hljs-number">16</span>); R1(d,e,a,b,c,<span class="hljs-number">17</span>); R1(c,d,e,a,b,<span class="hljs-number">18</span>); R1(b,c,d,e,a,<span class="hljs-number">19</span>);<br>    R2(a,b,c,d,e,<span class="hljs-number">20</span>); R2(e,a,b,c,d,<span class="hljs-number">21</span>); R2(d,e,a,b,c,<span class="hljs-number">22</span>); R2(c,d,e,a,b,<span class="hljs-number">23</span>);<br>    R2(b,c,d,e,a,<span class="hljs-number">24</span>); R2(a,b,c,d,e,<span class="hljs-number">25</span>); R2(e,a,b,c,d,<span class="hljs-number">26</span>); R2(d,e,a,b,c,<span class="hljs-number">27</span>);<br>    R2(c,d,e,a,b,<span class="hljs-number">28</span>); R2(b,c,d,e,a,<span class="hljs-number">29</span>); R2(a,b,c,d,e,<span class="hljs-number">30</span>); R2(e,a,b,c,d,<span class="hljs-number">31</span>);<br>    R2(d,e,a,b,c,<span class="hljs-number">32</span>); R2(c,d,e,a,b,<span class="hljs-number">33</span>); R2(b,c,d,e,a,<span class="hljs-number">34</span>); R2(a,b,c,d,e,<span class="hljs-number">35</span>);<br>    R2(e,a,b,c,d,<span class="hljs-number">36</span>); R2(d,e,a,b,c,<span class="hljs-number">37</span>); R2(c,d,e,a,b,<span class="hljs-number">38</span>); R2(b,c,d,e,a,<span class="hljs-number">39</span>);<br>    R3(a,b,c,d,e,<span class="hljs-number">40</span>); R3(e,a,b,c,d,<span class="hljs-number">41</span>); R3(d,e,a,b,c,<span class="hljs-number">42</span>); R3(c,d,e,a,b,<span class="hljs-number">43</span>);<br>    R3(b,c,d,e,a,<span class="hljs-number">44</span>); R3(a,b,c,d,e,<span class="hljs-number">45</span>); R3(e,a,b,c,d,<span class="hljs-number">46</span>); R3(d,e,a,b,c,<span class="hljs-number">47</span>);<br>    R3(c,d,e,a,b,<span class="hljs-number">48</span>); R3(b,c,d,e,a,<span class="hljs-number">49</span>); R3(a,b,c,d,e,<span class="hljs-number">50</span>); R3(e,a,b,c,d,<span class="hljs-number">51</span>);<br>    R3(d,e,a,b,c,<span class="hljs-number">52</span>); R3(c,d,e,a,b,<span class="hljs-number">53</span>); R3(b,c,d,e,a,<span class="hljs-number">54</span>); R3(a,b,c,d,e,<span class="hljs-number">55</span>);<br>    R3(e,a,b,c,d,<span class="hljs-number">56</span>); R3(d,e,a,b,c,<span class="hljs-number">57</span>); R3(c,d,e,a,b,<span class="hljs-number">58</span>); R3(b,c,d,e,a,<span class="hljs-number">59</span>);<br>    R4(a,b,c,d,e,<span class="hljs-number">60</span>); R4(e,a,b,c,d,<span class="hljs-number">61</span>); R4(d,e,a,b,c,<span class="hljs-number">62</span>); R4(c,d,e,a,b,<span class="hljs-number">63</span>);<br>    R4(b,c,d,e,a,<span class="hljs-number">64</span>); R4(a,b,c,d,e,<span class="hljs-number">65</span>); R4(e,a,b,c,d,<span class="hljs-number">66</span>); R4(d,e,a,b,c,<span class="hljs-number">67</span>);<br>    R4(c,d,e,a,b,<span class="hljs-number">68</span>); R4(b,c,d,e,a,<span class="hljs-number">69</span>); R4(a,b,c,d,e,<span class="hljs-number">70</span>); R4(e,a,b,c,d,<span class="hljs-number">71</span>);<br>    R4(d,e,a,b,c,<span class="hljs-number">72</span>); R4(c,d,e,a,b,<span class="hljs-number">73</span>); R4(b,c,d,e,a,<span class="hljs-number">74</span>); R4(a,b,c,d,e,<span class="hljs-number">75</span>);<br>    R4(e,a,b,c,d,<span class="hljs-number">76</span>); R4(d,e,a,b,c,<span class="hljs-number">77</span>); R4(c,d,e,a,b,<span class="hljs-number">78</span>); R4(b,c,d,e,a,<span class="hljs-number">79</span>);<br><br>    <span class="hljs-comment">// Add the working vars back into context.state[]</span><br>    state[<span class="hljs-number">0</span>] += a;<br>    state[<span class="hljs-number">1</span>] += b;<br>    state[<span class="hljs-number">2</span>] += c;<br>    state[<span class="hljs-number">3</span>] += d;<br>    state[<span class="hljs-number">4</span>] += e;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span>  <span class="hljs-type">const</span>*        Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    i;<br>    <span class="hljs-type">uint32_t</span>    j;<br><br>    j = (Context-&gt;Count[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">63</span>;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;Count[<span class="hljs-number">0</span>] += BufferSize &lt;&lt; <span class="hljs-number">3</span>) &lt; (BufferSize &lt;&lt; <span class="hljs-number">3</span>) )<br>    &#123;<br>        Context-&gt;Count[<span class="hljs-number">1</span>]++;<br>    &#125;<br><br>    Context-&gt;Count[<span class="hljs-number">1</span>] += (BufferSize &gt;&gt; <span class="hljs-number">29</span>);<br>    <span class="hljs-keyword">if</span>( (j + BufferSize) &gt; <span class="hljs-number">63</span> )<br>    &#123;<br>        i = <span class="hljs-number">64</span> - j;<br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], Buffer, i );<br>        TransformFunction(Context-&gt;State, Context-&gt;Buffer);<br>        <span class="hljs-keyword">for</span>( ; i + <span class="hljs-number">63</span> &lt; BufferSize; i += <span class="hljs-number">64</span> )<br>        &#123;<br>            TransformFunction(Context-&gt;State, (<span class="hljs-type">uint8_t</span>*)Buffer + i);<br>        &#125;<br>        j = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        i = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], &amp;((<span class="hljs-type">uint8_t</span>*)Buffer)[i], BufferSize - i );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="链接变量作为下一个明文分组的输入重复进行以上操作"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mp5Q.png" alt="image-20240919203902118"></p><p>代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pf">// Copy context-&gt;state[] <span class="hljs-keyword">to</span> working vars<br>  a = <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>];<br>  b = <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>];<br>  c = <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>];<br>  d = <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>];<br>  e = <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>];<br><br>  // <span class="hljs-number">4</span> rounds of <span class="hljs-number">20</span> operations each. Loop unrolled.<br>  ............<br>  .....<br>  .<br><br>  // Add the working vars back into context.<span class="hljs-keyword">state</span>[]<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>] += a;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>] += b;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>] += c;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>] += d;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>] += e;<br></code></pre></td></tr></table></figure><h5 id="最后5个链接变量里面的数据就是SHA1摘要"><a href="#最后5个链接变量里面的数据就是SHA1摘要" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>在所有数据块处理完成后，5个链接变量的最终值即为SHA1的摘要值。</p><h3 id="SHA2算法"><a href="#SHA2算法" class="headerlink" title="SHA2算法"></a>SHA2算法</h3><h4 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-2（Secure Hash Algorithm 2）是一组加密哈希函数的集合，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于2001年。SHA-2包含多个变种，主要有SHA-224、SHA-256、SHA-384、SHA-512等，输出的哈希值长度分别为224、256、384和512位。</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出长度可变</strong>：SHA-2支持多种输出长度，适应不同安全需求。</li><li><strong>增强的安全性</strong>：相较于SHA-1，SHA-2提供更强的抗碰撞性和抗预映像性，当前被认为是安全的哈希算法。</li><li><strong>广泛应用</strong>：被广泛用于数据完整性验证、数字签名、SSL&#x2F;TLS证书等领域。</li></ol><h4 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充与分组"><a href="#数据填充与分组" class="headerlink" title="数据填充与分组"></a>数据填充与分组</h5><p>同MD5 算法、SHA-1 算法，第一步还是要将数据填充为512 bits 的整数倍，也就是64字节的整数倍。这些n 段512bits(64字节)的数据会作为原始信息进行处理。</p><h5 id="初始化MD-Buffer-1"><a href="#初始化MD-Buffer-1" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha256Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha256Context*      Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;curlen = <span class="hljs-number">0</span>;<br>    Context-&gt;length = <span class="hljs-number">0</span>;<br>    Context-&gt;state[<span class="hljs-number">0</span>] = <span class="hljs-number">0x6A09E667</span>UL;<br>    Context-&gt;state[<span class="hljs-number">1</span>] = <span class="hljs-number">0xBB67AE85</span>UL;<br>    Context-&gt;state[<span class="hljs-number">2</span>] = <span class="hljs-number">0x3C6EF372</span>UL;<br>    Context-&gt;state[<span class="hljs-number">3</span>] = <span class="hljs-number">0xA54FF53A</span>UL;<br>    Context-&gt;state[<span class="hljs-number">4</span>] = <span class="hljs-number">0x510E527F</span>UL;<br>    Context-&gt;state[<span class="hljs-number">5</span>] = <span class="hljs-number">0x9B05688C</span>UL;<br>    Context-&gt;state[<span class="hljs-number">6</span>] = <span class="hljs-number">0x1F83D9AB</span>UL;<br>    Context-&gt;state[<span class="hljs-number">7</span>] = <span class="hljs-number">0x5BE0CD19</span>UL;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="将512bits数据（164字节）扩展为644字节"><a href="#将512bits数据（164字节）扩展为644字节" class="headerlink" title="将512bits数据（164字节）扩展为644字节"></a>将512bits数据（16<em>4字节）扩展为64</em>4字节</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mCCj.png" alt="image-20240919212319707"></p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mP8s.png" alt="image-20240919212345601"></p><h5 id="进入主循环，进行64次循环"><a href="#进入主循环，进行64次循环" class="headerlink" title="进入主循环，进行64次循环"></a>进入主循环，进行64次循环</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mi2n.png" alt="image-20240919212616394"></p><p><img src="https://s2.loli.net/2024/09/29/HyfBTmEteP3s1h6.png" alt="image-20240919213245654.png"></p><p>注意A、B、C、D 、E、F、G、H分别是上一段512bits 处理后留下来的8个整数(<strong>第一次运算的时候这8个数为固定的常数</strong>)。在对该512bits 数据运算前需要先把这8个整数临时存起来（作为下一组运算的初始值，一直到64 次循环彻底结束。）。</p><p><img src="https://s2.loli.net/2024/09/29/2MSCtv1HZTLQg4o.png" alt="image-20240919212718907.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ed7f15772e4ddc5d23f140f85027b53.gif" alt="W_t">表示一个32 bits(4个字节) 的输入数据(512bits 数据其中的32bits)，<img src="https://i-blog.csdnimg.cn/blog_migrate/23a5f8b290dde5116088d13bad292457.gif" alt="K_t"> 表示一个32bits 的常数(这个也是固定的)</p><p><img src="https://s2.loli.net/2024/09/29/21ld5pgQmVKWs3t.png" alt="image-20240919213306065.png"></p><h5 id="链接变量与初始链接变量进行求和运算-1"><a href="#链接变量与初始链接变量进行求和运算-1" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s2.loli.net/2024/09/29/xurShl8HjsMXFZN.png" alt="image-20240919213011417.png"></p><h5 id="链接变量作为下一个明文分组的输入重复进行以上操作-1"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作-1" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p><h5 id="最后5个链接变量里面的数据就是SHA1摘要-1"><a href="#最后5个链接变量里面的数据就是SHA1摘要-1" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>最后一段512bits 运算后得到最终的A、B、C、D、E，即为最终的160bits数，因为需要得到最后256bits(64 位16进制)的字符串，所以要将每个4字节的数转换成8位的16进制字符串。</p><hr><h2 id="消息认证码法-Message-Authentication-Code"><a href="#消息认证码法-Message-Authentication-Code" class="headerlink" title="消息认证码法(Message Authentication Code)"></a>消息认证码法(Message Authentication Code)</h2><p><img src="https://s2.loli.net/2024/09/29/PG2V5SeEJ4IvfxH.png" alt="image-20240919215256824"></p><p><strong>把哈希函数和密钥结合起来</strong>，将得到一个新的保护数据完整性的密码学原语——消息认证码(Message Authentication Code，MAC)。密钥是安全的基础：没有密钥就无法保证机密性，也无法实现认证性。虽然哈希函数可以为任意数据提供认证性或完整性，但它需要依赖于一个不可篡改的可信信道.</p><blockquote><p><em>比如：恶意用户可以修改cookie中的信息。若cookie中仅包含用户名及用户名的哈希值，则可以通过修改这些信息来模拟不同的用户</em></p><p><em>为了确保用户的cookie不被随意更改，我们可以使用上面提到的密码学原语。当用户第一次登录网站时，网站根据密钥和用户名生成一个认证标签，并让用户将用户名和认证标签存储在cookie中。由于不知道密钥，所以用户无法伪造其他用户名的有效认证标签。</em></p></blockquote><p>实现方式有：</p><table><thead><tr><th><strong>实现方式</strong></th><th><strong>原理</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>HMAC</strong></td><td>基于哈希函数与密钥结合，经过两次哈希生成认证码</td><td>简单易实现，支持多种哈希函数，安全性好</td><td>相较于其他方法，计算效率较低</td><td>网络协议（TLS、IPsec）、API认证、OAuth</td></tr><tr><td><strong>CMAC</strong></td><td>基于分组密码（如AES），通过分组加密生成认证码</td><td>适合硬件实现，安全性高</td><td>密钥管理相对复杂</td><td>无线通信协议（如IEEE 802.11i）、密码学库</td></tr><tr><td><strong>OMAC</strong></td><td>基于CMAC的简化版本，仅使用一个密钥</td><td>密钥管理简单，适合低资源场景</td><td>不适合并行计算</td><td>嵌入式系统</td></tr><tr><td><strong>PMAC</strong></td><td>通过块加密算法并行处理消息块生成认证码</td><td>支持并行处理，速度快</td><td>实现复杂度较高</td><td>高性能场景，如高速网络、数据加密存储</td></tr><tr><td><strong>GMAC</strong></td><td>基于Galois&#x2F;Counter Mode（GCM）模式生成认证码</td><td>高性能，支持并行处理</td><td>需要与加密模式结合使用</td><td>IPsec、TLS等加密协议</td></tr><tr><td><strong>Poly1305</strong></td><td>基于伪随机函数，通过模数运算生成认证码</td><td>轻量级设计，计算效率高</td><td>需要与ChaCha20等算法配合</td><td>嵌入式设备、高效加密协议（如TLS 1.3）</td></tr><tr><td><strong>CBC-MAC</strong></td><td>基于分组加密的CBC模式生成认证码</td><td>简单易实现</td><td>对变长消息不安全，容易受长度攻击</td><td>已被更安全的CMAC替代</td></tr></tbody></table><h3 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h3><h4 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>HMAC</strong>（基于哈希的消息认证码）是一种通过哈希函数生成消息认证码的算法。它的主要作用是验证消息的完整性和真实性，防止消息在传输过程中被篡改。HMAC 结合了加密哈希函数（如SHA-256或SHA-1）和一个密钥，生成一个固定长度的消息摘要。</p><h4 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://s2.loli.net/2024/09/29/p4hcDSjUk9e3YG2.png" alt="image-20240919214933334"><br>其中：<br>H 为密码Hash函数（如MD5或SHA-2），能够对明文进行分组循环压缩；<br>k 为密钥（secret key）；<br>m 为要认证的消息；<br>k’ 是从原始密钥 k 导出的另一个密钥（如果 k 短于散列函数的输入块大小，则向右填充零；如果比该块大小更长，则对 k 进行散列）<br>ipad 内部填充（0x5C5C5C…5C5C，一段十六进制常量）；<br>opad 外部填充（0x363636…3636，一段十六进制常量)<br><img src="https://s2.loli.net/2024/09/29/2XDcgNFAbvwBxmG.png" alt="R-C"></p><p>a) 在密钥k后面添加0，或者对密钥k用H（Hash函数）进行处理，创建一个字长为B的字符串（B为Hash函数的明文分组长度）；<br>b) 将上一步生成的B字长的字符串ipad做异或运算；<br>c)将数据流m填充至第二步的结果字符串中；<br>d)用H作用于第三步生成的数据流；<br>e)将第一步生成的B字长字符串与opad做异或运算；<br>f)再将第四步的结果填充进第五步的结果中；<br>g)用H作用于第六步生成的数据流，输出最终结果。</p><hr><h2 id="国密-SM3"><a href="#国密-SM3" class="headerlink" title="国密(SM3)"></a>国密(SM3)</h2><h3 id="简单介绍-5"><a href="#简单介绍-5" class="headerlink" title="简单介绍"></a>简单介绍</h3><p><strong>概述</strong>： SM3是一种由中国国家密码管理局设计的加密哈希函数，属于国密算法系列，发布于2010年。SM3主要用于确保数据完整性和身份验证，输出的哈希值长度为256位。(SM3广泛应用于电子商务、数字签名、区块链和信息安全等领域)</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出固定长度</strong>：无论输入数据大小，SM3总是生成256位的哈希值。</li><li><strong>安全性</strong>：SM3经过严格的安全评估，具有良好的抗碰撞性和抗预映像性，适合用于高安全性需求的场合。</li><li><strong>高效性</strong>：在硬件和软件实现上具有较高的效率，适合处理大规模数据。</li></ol><h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="消息填充"><a href="#消息填充" class="headerlink" title="消息填充"></a>消息填充</h4><p><img src="https://s2.loli.net/2024/09/29/wTA6OfE2Yb4lJ5H.png" alt="image-20240920102423212"></p><h4 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h4><p>SM3的迭代压缩步骤没有直接使用数据分组进行运算，而是使用这个步骤产生的132个消息字。（一个消息字的长度为32位&#x2F;4个字节&#x2F;8个16j进制数字）概括来说，先将一个512位数据分组划分为16个消息字，并且作为生成的132个消息字的前16个。再<strong>用这16个消息字递推生成剩余的116个消息字</strong>。</p><p>在最终得到的132个消息字中，前68个消息字构成数列 {W j {W_j}Wj}，后64个消息字构成数列 {W j ‘ {W_j^&#96;}Wj‘}，其中下标j从0开始计数。</p><p><img src="https://s2.loli.net/2024/09/29/SYcCjgi3HDQW2pN.png" alt="image-20240920102620139"></p><h4 id="迭代压缩"><a href="#迭代压缩" class="headerlink" title="迭代压缩"></a>迭代压缩</h4><p>这块结构和SHA系列算法也比较相似，由初始化向量然后对于每一个扩展后的消息进行处理，直到处理完最后一个分块。</p><p><img src="https://s2.loli.net/2024/09/29/xBK6a4djoQMH5tV.jpg" alt="f0adf403fda784ac40e30771876caede (1)"></p><h5 id="压缩函数-核心"><a href="#压缩函数-核心" class="headerlink" title="压缩函数(核心)"></a>压缩函数(核心)</h5><p><img src="https://s2.loli.net/2024/09/29/1Ao9rcevbuyjOtM.png" alt="image-20240920103047143"></p><p>其中初值IV被放在A、B、C、D、E、F、G、H八个<a href="https://www.zhihu.com/search?q=32%E4%BD%8D%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:129692191%7D">32位变量</a>中</p><p>压缩函数将这八个变量进行64轮相同的计算，一轮的计算过程如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/PH7kIDdAfOyKMSc.jpg" alt="748a9c1bcf39b12e4d868474649ff333"></p><p>最后，再将计算完成的A、B、C、D、E、F、G、H和原来的A、B、C、D、E、F、G、H分别进行异或，就是压缩函数的输出。这个输出再作为下一次调用压缩函数时的初值。依次类推，直到用完最后一组132个消息字为止。</p><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://s2.loli.net/2024/09/29/DafG4M9qZjzh1LC.png" alt="image-20240920103309918"></p><p>将得到的A、B、C、D、E、F、G、H八个变量拼接输出，就是SM3算法的输出。</p><h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="Base系列算法"><a href="#Base系列算法" class="headerlink" title="Base系列算法"></a>Base系列算法</h2><h3 id="Base16编码"><a href="#Base16编码" class="headerlink" title="Base16编码"></a>Base16编码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Base16（也称为Hexadecimal或Hex）是一种常见的编码方式，用于将二进制数据转换为可读的文本格式。它使用16个不同的字符来表示每4位二进制数。Base16编码使用的字符集包括<code>0-9</code>和<code>A-F</code>，其中<code>A-F</code>代表10到15的数字。这种编码方式通常用于计算机系统中表示二进制数据，并且非常适合于调试和数据展示。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据（通常是字节）准备好。</li><li><strong>分组处理</strong>：将每个字节（8位）分解为两个4位的部分。</li><li><strong>映射字符</strong>：使用Base16字符集将每个4位部分映射为一个Base16字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base16字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base16编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base16字符转换为对应的4位二进制值。</li><li><strong>合并处理</strong>：将这些4位二进制值重新组合成字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base16 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* hexChars = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 每个字节对应两个十六进制字符</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &gt;&gt; <span class="hljs-number">4</span>]);   <span class="hljs-comment">// 高四位</span><br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &amp; <span class="hljs-number">0x0F</span>]); <span class="hljs-comment">// 低四位</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base16 解码函数</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">decodeHexChar</span><span class="hljs-params">(<span class="hljs-type">char</span> hexChar)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;F&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid hex character&quot;</span>);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">length</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base16 input length&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> high = <span class="hljs-built_in">decodeHexChar</span>(input[i]);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> low = <span class="hljs-built_in">decodeHexChar</span>(input[i + <span class="hljs-number">1</span>]);<br>        output.<span class="hljs-built_in">push_back</span>((high &lt;&lt; <span class="hljs-number">4</span>) | low);  <span class="hljs-comment">// 高位和低位合并成一个字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase16</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase16</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base32编码"><a href="#Base32编码" class="headerlink" title="Base32编码"></a>Base32编码</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>Base32是一种编码方案，用于将二进制数据转换为可打印的文本格式。它使用32个不同的字符来表示每5位二进制数。Base32编码使用的字符集通常包括<code>A-Z</code>和<code>2-7</code>，这些字符在ASCII范围内都是可打印的。Base32通常用于需要对数据进行一定程度的可读性增强的场景，例如在URL中或在一些认证系统中。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好。</li><li><strong>分组处理</strong>：将数据分成每5位二进制的一组，每组对应一个Base32字符。</li><li><strong>映射字符</strong>：使用Base32字符集将每5位二进制数据映射为一个Base32字符。</li><li><strong>填充处理</strong>：如果数据长度不是5的倍数，使用<code>=</code>字符进行填充，以确保编码字符串的长度为8的倍数。</li><li><strong>输出结果</strong>：将所有映射得到的Base32字符和填充字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base32编码后的字符串，并去除可能存在的填充字符<code>=</code>。</li><li><strong>字符映射</strong>：将每个Base32字符转换为对应的5位二进制值。</li><li><strong>合并处理</strong>：将这些5位二进制值重新组合成字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE32_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;<br><br><span class="hljs-comment">// Base32 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 将缓冲区左移8位</span><br>        buffer |= c;   <span class="hljs-comment">// 将当前字节加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">5</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &gt;&gt; (bitsLeft - <span class="hljs-number">5</span>)) &amp; <span class="hljs-number">0x1F</span>]);  <span class="hljs-comment">// 取高5位</span><br>            bitsLeft -= <span class="hljs-number">5</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余位数不足5位的情况</span><br>    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &lt;&lt; (<span class="hljs-number">5</span> - bitsLeft)) &amp; <span class="hljs-number">0x1F</span>]);<br>        paddingCount = (<span class="hljs-number">8</span> - (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">8</span>)) % <span class="hljs-number">8</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 Base32 的 &quot;=&quot; 填充字符</span><br>    output.<span class="hljs-built_in">append</span>(paddingCount, <span class="hljs-string">&#x27;=&#x27;</span>);<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base32 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            paddingCount++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = BASE32_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base32 character&quot;</span>);<br>        &#125;<br><br>        buffer &lt;&lt;= <span class="hljs-number">5</span>;  <span class="hljs-comment">// 将缓冲区左移5位</span><br>        buffer |= index;  <span class="hljs-comment">// 将当前字符的值加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">5</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (bitsLeft - <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 取高8位</span><br>            bitsLeft -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase32</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase32</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base58-编码"><a href="#Base58-编码" class="headerlink" title="Base58 编码"></a>Base58 编码</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Base58是一种用于将二进制数据编码为可打印字符的方案，广泛应用于加密货币（如比特币地址）等领域。Base58编码通过去除Base64编码中的某些容易混淆的字符（如<code>0</code>、<code>O</code>、<code>I</code>、<code>l</code>），使编码结果更易于手动输入和读取。它使用58个可打印的ASCII字符，编码效率高，每4字节二进制数据编码为5个Base58字符。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>转换为整数</strong>：将二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：用58作为基数，将大整数逐步除以58，得到的余数用于索引Base58字符集，从而得到Base58字符。</li><li><strong>处理前导零</strong>：在编码结果前添加相应数量的Base58字符<code>1</code>，以保持与原始数据前导零的对应关系。</li><li><strong>输出结果</strong>：将所有映射得到的Base58字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base58编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base58字符转换为其在Base58字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个大整数。</li><li><strong>处理前导零</strong>：根据编码结果中的前导<code>1</code>的数量，将相应数量的前导零添加到解码结果中。</li><li><strong>转换为二进制数据</strong>：将大整数转换回二进制数据，得到原始数据。</li></ol><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE58_ALPHABET = <span class="hljs-string">&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span>;<br><br><span class="hljs-comment">// 辅助函数：将字节数组解释为大整数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">toBigInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(input.begin(), input.end())</span></span>;<br>    <span class="hljs-keyword">return</span> bigInt;<br>&#125;<br><br><span class="hljs-comment">// Base58 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; digits;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; bigInt = <span class="hljs-built_in">toBigInt</span>(input);<br><br>    <span class="hljs-comment">// 跳过前导的0字节</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte : bigInt) &#123;<br>        <span class="hljs-keyword">if</span> (byte == <span class="hljs-number">0</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将大整数转为Base58编码</span><br>    <span class="hljs-keyword">while</span> (!bigInt.<span class="hljs-built_in">empty</span>() &amp;&amp; *std::<span class="hljs-built_in">max_element</span>(bigInt.<span class="hljs-built_in">begin</span>(), bigInt.<span class="hljs-built_in">end</span>()) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = carry * <span class="hljs-number">256</span> + byte;<br>            byte = value / <span class="hljs-number">58</span>;<br>            carry = value % <span class="hljs-number">58</span>;<br>        &#125;<br>        digits.<span class="hljs-built_in">push_back</span>(carry);<br>    &#125;<br><br>    <span class="hljs-comment">// 将前导0字节编码为Base58的`1`字符</span><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;1&#x27;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 反转余数得到的Base58编码</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = digits.<span class="hljs-built_in">rbegin</span>(); it != digits.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += BASE58_ALPHABET[*it];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Base58 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-type">size_t</span> index = BASE58_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base58 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> carry = index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = byte * <span class="hljs-number">58</span> + carry;<br>            carry = value &gt;&gt; <span class="hljs-number">8</span>;<br>            byte = value &amp; <span class="hljs-number">0xFF</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (carry) &#123;<br>            bigInt.<span class="hljs-built_in">push_back</span>(carry &amp; <span class="hljs-number">0xFF</span>);<br>            carry &gt;&gt;= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理前导的&#x27;1&#x27;字符</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = bigInt.<span class="hljs-built_in">rbegin</span>(); it != bigInt.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(*it);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase58</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase58</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>Base64是一种广泛使用的编码方式，将二进制数据转换为可打印的ASCII字符。它常用于在需要将二进制数据嵌入到文本格式中时（如在电子邮件、URL、JSON等）。Base64将每3字节的二进制数据编码为4个ASCII字符，使得编码后的数据长度增加约33%。Base64字符集包括<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>、<code>+</code>、<code>/</code>和<code>=</code>（作为填充字符）。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每3字节（24位）的一组，如果数据长度不足3字节，则使用填充字符<code>=</code>进行填充，以确保处理的字节数为3的倍数。</li><li><strong>转换为6位组</strong>：将每组24位二进制数据分成4组6位的二进制数。</li><li><strong>映射字符</strong>：使用Base64字符集将每6位二进制数据映射为一个Base64字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base64字符和填充字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base64编码后的字符串，并去除填充字符<code>=</code>。</li><li><strong>字符映射</strong>：将每个Base64字符转换为对应的6位二进制值。</li><li><strong>组合处理</strong>：将这些6位二进制值重新组合成24位的二进制数据。</li><li><strong>分解字节</strong>：将24位二进制数据分解为3个字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE64_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;<br><br><span class="hljs-comment">// Base64 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output; <span class="hljs-comment">// 存储编码后的输出字符串</span><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于存储当前处理的字符值</span><br>    <span class="hljs-type">int</span> bits = <span class="hljs-number">-6</span>; <span class="hljs-comment">// 当前处理的位数，初始化为 -6，因为我们要填充 6 位的 Base64 字符</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b63 = <span class="hljs-number">0x3F</span>; <span class="hljs-comment">// 64 的二进制数（111111），用于获取 Base64 字符</span><br><br>    <span class="hljs-comment">// 遍历输入字符串的每一个字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        val = (val &lt;&lt; <span class="hljs-number">8</span>) + c; <span class="hljs-comment">// 将当前字符的 ASCII 值添加到 val 中，左移 8 位</span><br>        bits += <span class="hljs-number">8</span>; <span class="hljs-comment">// 增加已处理的位数</span><br><br>        <span class="hljs-comment">// 当处理的位数大于等于 0 时，进行编码</span><br>        <span class="hljs-keyword">while</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从 val 中提取出高 6 位，并查找对应的 Base64 字符</span><br>            output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[(val &gt;&gt; bits) &amp; b63]);<br>            bits -= <span class="hljs-number">6</span>; <span class="hljs-comment">// 每次处理 6 位，减少 bits 的值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位，如果还有剩余的 bits &gt; -6，则需要继续编码</span><br>    <span class="hljs-keyword">if</span> (bits &gt; <span class="hljs-number">-6</span>) &#123;<br>        <span class="hljs-comment">// 将剩余的位向左移动并提取对应的 Base64 字符</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[((val &lt;&lt; <span class="hljs-number">8</span>) &gt;&gt; (bits + <span class="hljs-number">8</span>)) &amp; b63]);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 output 的大小不是 4 的倍数，则添加 &#x27;=&#x27; 作为填充</span><br>    <span class="hljs-keyword">while</span> (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">4</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 添加填充字符 &#x27;=&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output; <span class="hljs-comment">// 返回编码后的 Base64 字符串</span><br>&#125;<br><br><br><span class="hljs-comment">// Base64 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>        T[BASE64_ALPHABET[i]] = i;<br>    &#125;<br><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>, bits = <span class="hljs-number">-8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        <span class="hljs-keyword">if</span> (T[c] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>        val = (val &lt;&lt; <span class="hljs-number">6</span>) + T[c];<br>        bits += <span class="hljs-number">6</span>;<br><br>        <span class="hljs-keyword">if</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">char</span>((val &gt;&gt; bits) &amp; <span class="hljs-number">0xFF</span>));<br>            bits -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase64</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    std::string decoded = <span class="hljs-built_in">decodeBase64</span>(encoded);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base85编码"><a href="#Base85编码" class="headerlink" title="Base85编码"></a>Base85编码</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>Base85是一种用于将二进制数据转换为可打印字符的编码方案。它通过使用85个不同的ASCII字符来表示每4字节（32位）的二进制数据。这种编码方式常用于需要将二进制数据嵌入文本中的场景，如在PDF文件中。相比于Base64，Base85编码能够以更高的效率将数据压缩成更短的字符串，因为每4字节的二进制数据在Base85中编码为5个字符。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每4字节（32位）的组，如果数据长度不足4字节，则进行填充。</li><li><strong>转换为整数</strong>：将每4字节的二进制数据转换为一个32位的整数。</li><li><strong>映射字符</strong>：将32位整数转换为5个Base85字符。具体来说，整数被逐步除以85，得到的余数对应Base85字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base85字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base85编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base85字符转换为Base85字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个32位的整数。</li><li><strong>分解字节</strong>：将32位整数转换回4字节（32位）的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE85_ALPHABET = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&amp;()*+-;&lt;=&gt;?@^_`&#123;|&#125;~&quot;</span>;<br><br><span class="hljs-comment">// Base85 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        buffer = buffer * <span class="hljs-number">256</span> + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(input[i]);<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>                buffer /= <span class="hljs-number">85</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">end</span>());<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        buffer &lt;&lt;= (<span class="hljs-number">4</span> - count) * <span class="hljs-number">8</span>;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>            buffer /= <span class="hljs-number">85</span>;<br>        &#125;<br>        output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">begin</span>() + count + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base85 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE85_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base85 character&quot;</span>);<br>        &#125;<br>        buffer = buffer * <span class="hljs-number">85</span> + pos;<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>            &#125;<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = count; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>            buffer = buffer * <span class="hljs-number">85</span> + <span class="hljs-number">84</span>;  <span class="hljs-comment">// 用最大值填充</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">4</span> - count; --j) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase85</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase85</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base91编码"><a href="#Base91编码" class="headerlink" title="Base91编码"></a>Base91编码</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>Base91是一种编码方案，用于将二进制数据转换为可打印的ASCII字符。它使用91个字符来表示每13位的二进制数据。Base91设计的目的是在保证编码效率的同时，提供更好的数据密度比Base64和Base85。Base91编码通常用于需要高数据密度的应用场景，例如某些压缩算法和数据传输协议。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每13位（即1.625字节）的组。由于13位并不整除8位字节，因此每个Base91编码块处理的字节数可能会有所不同。</li><li><strong>转换为整数</strong>：将每组13位的二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：将这个整数转换为Base91字符。整数会被逐步除以91，得到的余数对应Base91字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base91字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base91编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base91字符转换为Base91字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个13位的二进制整数。</li><li><strong>分解字节</strong>：将13位的二进制整数转换回原始的字节数据。这可能涉及到将整数拆分为多个字节（通常是2或3个字节）。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base91 字符集</span><br><span class="hljs-type">const</span> std::string BASE91_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span><br>                                    <span class="hljs-string">&quot;!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`&#123;|&#125;~\&quot;&quot;</span>;<br><br><span class="hljs-comment">// Base91 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer |= (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(c) &lt;&lt; bitsLeft);<br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-type">uint32_t</span> value = buffer &amp; <span class="hljs-number">8191</span>;  <span class="hljs-comment">// 取13位</span><br>            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">88</span>) &#123;                <span class="hljs-comment">// 处理特殊情况</span><br>                buffer &gt;&gt;= <span class="hljs-number">13</span>;<br>                bitsLeft -= <span class="hljs-number">13</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                value = buffer &amp; <span class="hljs-number">16383</span>;      <span class="hljs-comment">// 取14位</span><br>                buffer &gt;&gt;= <span class="hljs-number">14</span>;<br>                bitsLeft -= <span class="hljs-number">14</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value % <span class="hljs-number">91</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余不足13位的部分</span><br>    <span class="hljs-keyword">if</span> (bitsLeft) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer % <span class="hljs-number">91</span>]);<br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">7</span> || buffer &gt; <span class="hljs-number">90</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base91 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE91_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base91 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>            value = pos;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            value += pos * <span class="hljs-number">91</span>;<br>            buffer |= value &lt;&lt; bitsLeft;<br>            bitsLeft += (value &amp; <span class="hljs-number">8191</span>) &gt; <span class="hljs-number">88</span> ? <span class="hljs-number">13</span> : <span class="hljs-number">14</span>;<br><br>            <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>                output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);<br>                buffer &gt;&gt;= <span class="hljs-number">8</span>;<br>                bitsLeft -= <span class="hljs-number">8</span>;<br>            &#125;<br>            value = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位</span><br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(buffer | (value &lt;&lt; bitsLeft));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase91</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase91</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base100编码"><a href="#Base100编码" class="headerlink" title="Base100编码"></a>Base100编码</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>Base100是一种用于将二进制数据转换为可打印字符的编码方案。它使用100个不同的字符来表示每16位的二进制数据。这种编码方式在字符集选择上较为宽松，通常选择可打印的ASCII字符。Base100的设计旨在提供比Base64和Base85更高的数据密度，使得编码后的数据更为紧凑。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每16位（即2字节）的组。如果数据长度不足2字节，则进行填充。</li><li><strong>转换为整数</strong>：将每16位的二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：将这个整数转换为Base100字符。整数会被逐步除以100，得到的余数对应Base100字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base100字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base100编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base100字符转换为Base100字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个16位的二进制整数。</li><li><strong>分解字节</strong>：将16位的二进制整数转换回原始的字节数据，通常是2个字节（或1个字节的填充情况）。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base100 字符集 (ASCII 范围: 33-132)</span><br><span class="hljs-type">const</span> std::string BASE100_ALPHABET = <span class="hljs-string">&quot; !\&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;</span><br>                                     <span class="hljs-string">&quot;€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ&quot;</span>;<br><br><span class="hljs-comment">// Base100 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer = (buffer &lt;&lt; <span class="hljs-number">8</span>) | c;<br>        count++;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">2</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 填充一个字节</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base100 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 input length.&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> index1 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-type">int</span> index2 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i + <span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">if</span> (index1 == std::string::npos || index2 == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 character.&quot;</span>);<br>        &#125;<br><br>        buffer = index1 * <span class="hljs-number">100</span> + index2;<br>        output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 高字节</span><br>        output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);         <span class="hljs-comment">// 低字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase100</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase100</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/0yst3r-2046/p/11962942.html">Base系列编码浅析【base16 base32 base64 base85 base36 base 58 base91 base 92 base62】 - 0yst3r - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.equinox.chat/archives/45/">Base系列编码详解 - 二进制学习 (equinox.chat)</a></p><p><a href="https://blog.csdn.net/m0_62690279/article/details/123941239">常见加密算法总结-base系列部分_base加密-CSDN博客</a></p><p><a href="https://danielxuuuuu.github.io/2019/11/18/MD5%E7%AE%97%E6%B3%95%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84">MD5算法的C语言实现 · Daniel’s Studio (danielxuuuuu.github.io)</a></p><p><a href="https://www.cnblogs.com/foxclever/p/7668369.html">信息摘要算法之一：MD5算法解析及实现 - Moonan - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/450180396">RSA —— 经典的非对称加密算法 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/78913397">密码学基础：AES加密算法 - 知乎 (zhihu.com)</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二） - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>[RSA算法详解 - 飞翔的大熊 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA算法流程</a> 1 生成秘钥 选择两个不相等的质数p%2Cq 计算p%2Cq的乘积n 计算n的欧拉函数φ (n)%3D (p-1)*,根据上面的公式可以算出密文C 解密 接收方获取密文c，使用自己的私钥 (n%2Cd)依照如下公式解密 c^d%3Dm (mod n) c%2Cd%2Cn已知，可以算出明文m)</p><p><a href="https://blog.csdn.net/s2603898260/article/details/122389816">RSA 算法图解+数学证明_rsa算法流程图-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/98514678">AES加密算法流程介绍 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/TheSkyLee/article/details/108699243">一文彻底搞懂加密、数字签名和数字证书，看不懂你打我！-CSDN博客</a></p><p><a href="https://blog.csdn.net/xiao__1bai/article/details/123307059">解析 TEA 加密算法(C语言、python)：_tea加密-CSDN博客</a></p><p><a href="https://www.cnblogs.com/shelmean/p/14281332.html">RC4加密算法 - shelmean - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV1c34y1M7NW/?spm_id_from=333.999.0.0">HMAC | MAC | 基于哈希函数的消息认证码</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/19/hello-world/"/>
    <url>/2024/05/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
