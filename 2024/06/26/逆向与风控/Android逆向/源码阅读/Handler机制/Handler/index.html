

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="站在巨人的肩膀上： Android消息机制1-Handler(Java层) - Gityuan博客 | 袁辉辉的技术博客 Android消息机制3-Handler(实战) - Gityuan博客 | 袁辉辉的技术博客   先看一个普通的例子： 1234567891011121314151617181920212223242526protected void onCreate(Bundle sav">
<meta property="og:type" content="article">
<meta property="og:title" content="Handler原理">
<meta property="og:url" content="http://example.com/2024/06/26/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Android%E9%80%86%E5%90%91/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Handler%E6%9C%BA%E5%88%B6/Handler/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="站在巨人的肩膀上： Android消息机制1-Handler(Java层) - Gityuan博客 | 袁辉辉的技术博客 Android消息机制3-Handler(实战) - Gityuan博客 | 袁辉辉的技术博客   先看一个普通的例子： 1234567891011121314151617181920212223242526protected void onCreate(Bundle sav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/03/13/L5CiEXG1Mlet7Zo.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/13/ncpRTt6aBEZhN5e.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/13/4FMPVmwHZDjlyGB.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/14/RJfqbW5jXiu7Vcy.png">
<meta property="article:published_time" content="2024-06-26T04:25:14.000Z">
<meta property="article:modified_time" content="2025-04-27T06:58:58.340Z">
<meta property="article:author" content="Ling">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/03/13/L5CiEXG1Mlet7Zo.png">
  
  
  
  <title>Handler原理 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Handler原理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-26 12:25" pubdate>
          2024年6月26日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          55 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Handler原理</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>站在巨人的肩膀上：</p>
<p><a target="_blank" rel="noopener" href="https://gityuan.com/2015/12/26/handler-message-framework/">Android消息机制1-Handler(Java层) - Gityuan博客 | 袁辉辉的技术博客</a></p>
<p><a target="_blank" rel="noopener" href="https://gityuan.com/2016/01/01/handler-message-usage/">Android消息机制3-Handler(实战) - Gityuan博客 | 袁辉辉的技术博客</a></p>
</blockquote>
<p><img src="https://s2.loli.net/2025/03/13/L5CiEXG1Mlet7Zo.png" srcset="/img/loading.gif" lazyload></p>
<p>先看一个普通的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        textViewResult = findViewById(R.id.text_view_result);<br>        buttonSendMessage = findViewById(R.id.button_send_message);<br>        <span class="hljs-comment">// 启动 LooperThread(后台线程)</span><br>        looperThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LooperThread</span>();<br>        looperThread.start();<br>        <span class="hljs-comment">// 设置按钮点击事件</span><br>        buttonSendMessage.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                <span class="hljs-comment">// 发送消息到 LooperThread(后台线程)</span><br>                <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> looperThread.handler.obtainMessage(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello from Main Thread!&quot;</span>);<br>                looperThread.handler.sendMessage(message);<br>            &#125;<br>        &#125;);<br>        <br>    &#125;<br><br>        <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        <span class="hljs-comment">// 退出 Looper，释放资源</span><br>        looperThread.handler.getLooper().quit();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>**<code>LooperThread</code>**：</p>
<ul>
<li>继承自 <code>Thread</code>，在 <code>run()</code> 方法中初始化 <code>Looper</code> 并创建 <code>Handler</code>。</li>
<li><code>Handler</code> 的 <code>handleMessage()</code> 方法用于处理消息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LooperThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>       <span class="hljs-keyword">public</span> Handler handler;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>           Looper.prepare(); <span class="hljs-comment">// 初始化 Looper</span><br>           handler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.myLooper()) &#123;<br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>                   <span class="hljs-comment">// 处理消息</span><br>                   <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                       <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                           <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Received: &quot;</span> + msg.obj;<br>                           <span class="hljs-comment">// 更新 UI（需要在主线程中执行）</span><br>                           runOnUiThread(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                               <span class="hljs-meta">@Override</span><br>                               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                                   textViewResult.setText(result);<br>                               &#125;<br>                           &#125;);<br>                           <span class="hljs-keyword">break</span>;<br>                       <span class="hljs-keyword">default</span>:<br>                           <span class="hljs-keyword">break</span>;<br>                   &#125;<br>               &#125;<br>           &#125;;<br>           Looper.loop(); <span class="hljs-comment">// 启动消息循环</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>发送消息</strong>：<ul>
<li>在 <code>MainActivity</code> 中，通过 <code>looperThread.handler.sendMessage()</code> 发送消息到后台线程。</li>
</ul>
</li>
<li><strong>更新 UI</strong>：<ul>
<li>在 <code>handleMessage()</code> 中，使用 <code>runOnUiThread()</code> 更新 UI，因为 Android 不允许在非主线程中直接更新 UI。</li>
</ul>
</li>
<li><strong>退出 Looper</strong>：<ul>
<li>在 <code>onDestroy()</code> 中调用 <code>looperThread.handler.getLooper().quit()</code>，确保线程资源被释放。</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/03/13/ncpRTt6aBEZhN5e.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a>ThreadLocal的工作原理</h1><p><code>ThreadLocal</code> 是 Java 中用于实现线程本地存储的类，Android 中也继承了这一机制。它的主要作用是为每个线程提供一个独立的变量副本，使得每个线程可以独立地操作自己的变量，而不会影响其他线程中的变量。</p>
<ul>
<li><code>ThreadLocal</code> 为每个线程维护一个独立的变量副本。</li>
<li>每个线程可以通过 <code>ThreadLocal</code> 的 <code>get()</code> 和 <code>set()</code> 方法访问和修改自己的变量副本。</li>
<li>不同线程之间的变量副本是隔离的，互不干扰。</li>
</ul>
<p>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取。如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。</p>
<p>当不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set()</code> 方法的作用是将线程本地变量存储到当前线程的 <code>ThreadLocalMap</code> 中。如果当前线程的 <code>ThreadLocalMap</code> 不存在，则会创建一个新的 <code>ThreadLocalMap</code>。通过 <code>ThreadLocalMap</code>，每个线程可以独立存储和管理自己的线程本地变量，实现了线程隔离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br>    <span class="hljs-comment">// 获取当前线程的 ThreadLocalMap</span><br>    <span class="hljs-comment">// ThreadLocalMap 是 ThreadLocal 的内部类，用于存储线程本地变量</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><br>    <span class="hljs-comment">// 如果当前线程的 ThreadLocalMap 已经存在</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 将当前 ThreadLocal 对象和值存储到 ThreadLocalMap 中</span><br>        <span class="hljs-comment">// this 是当前的 ThreadLocal 对象，value 是要存储的线程本地变量</span><br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果当前线程的 ThreadLocalMap 不存在</span><br>        <span class="hljs-comment">// 则创建一个新的 ThreadLocalMap，并将当前 ThreadLocal 对象和值存储到其中</span><br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="createMap"><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    <span class="hljs-comment">// 为当前线程创建一个新的 ThreadLocalMap，并将初始值存储到其中</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>    <span class="hljs-comment">// 初始化 Entry 数组，初始容量为 16</span><br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br><br>    <span class="hljs-comment">// 计算第一个键的哈希值，并确定其在数组中的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 创建一个新的 Entry 对象，并将其存储到数组中</span><br>    table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br><br>    <span class="hljs-comment">// 设置当前大小为 1</span><br>    size = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 设置扩容阈值</span><br>    setThreshold(INITIAL_CAPACITY);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p><code>get()</code> 方法的作用是获取当前线程的线程本地变量。如果当前线程的 <code>ThreadLocalMap</code> 不存在，或者当前 <code>ThreadLocal</code> 对象没有对应的值，则调用 <code>setInitialValue()</code> 方法初始化并返回默认值。通过 <code>ThreadLocalMap</code>，每个线程可以独立存储和管理自己的线程本地变量，实现了线程隔离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br>    <span class="hljs-comment">// 获取当前线程的 ThreadLocalMap</span><br>    <span class="hljs-comment">// ThreadLocalMap 是 ThreadLocal 的内部类，用于存储线程本地变量</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><br>    <span class="hljs-comment">// 如果当前线程的 ThreadLocalMap 已经存在</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 从 ThreadLocalMap 中获取当前 ThreadLocal 对象对应的 Entry</span><br>        <span class="hljs-comment">// Entry 是 ThreadLocalMap 的内部类，存储键值对（ThreadLocal 对象为键，线程本地变量为值）</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-comment">// 如果 Entry 存在</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 获取 Entry 中的值（线程本地变量）</span><br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br><br>            <span class="hljs-comment">// 返回线程本地变量</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 ThreadLocalMap 不存在，或者当前 ThreadLocal 对象没有对应的值</span><br>    <span class="hljs-comment">// 调用 setInitialValue() 方法初始化并返回默认值</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从ThreadLocal的set和get方法可以看出，它们所操作的对象都是当前线程的localValues对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，它们对ThreadLocal所做的读&#x2F;写操作仅限于各自线程的内部</p>
<p><code>ThreadLocal</code> 的另一个重要使用场景确实是 <strong>复杂逻辑下的对象传递</strong>，尤其是在多线程环境下，某些对象需要在线程内部全局共享，但又不能影响其他线程。通过 <code>ThreadLocal</code>，可以避免通过函数参数传递对象的繁琐，也不需要依赖静态变量，从而让代码更加简洁和可维护。</p>
<h1 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h1><p>每个消息用<code>Message</code>表示，<code>Message</code>主要包含以下内容：</p>
<table>
<thead>
<tr>
<th><strong>字段&#x2F;方法</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>what</code></strong></td>
<td><code>int</code></td>
<td>消息的标识符，用于区分不同类型的消息。</td>
</tr>
<tr>
<td><strong><code>arg1</code></strong></td>
<td><code>int</code></td>
<td>用于传递简单的整型数据。</td>
</tr>
<tr>
<td><strong><code>arg2</code></strong></td>
<td><code>int</code></td>
<td>用于传递简单的整型数据。</td>
</tr>
<tr>
<td><strong><code>obj</code></strong></td>
<td><code>Object</code></td>
<td>用于传递任意类型的对象数据。</td>
</tr>
<tr>
<td><strong><code>callback</code></strong></td>
<td><code>Runnable</code></td>
<td>消息的回调任务。如果设置了<code>callback</code>，<code>Handler</code>会直接执行该<code>Runnable</code>。</td>
</tr>
<tr>
<td><strong><code>target</code></strong></td>
<td><code>Handler</code></td>
<td>消息的目标<code>Handler</code>，即消息将由哪个<code>Handler</code>处理。</td>
</tr>
<tr>
<td><strong><code>when</code></strong></td>
<td><code>long</code></td>
<td>消息的触发时间（以毫秒为单位），用于<code>MessageQueue</code>中的消息排序。</td>
</tr>
<tr>
<td><strong><code>data</code></strong></td>
<td><code>Bundle</code></td>
<td>用于传递复杂的数据，可以存储多个键值对。</td>
</tr>
<tr>
<td><strong><code>flags</code></strong></td>
<td><code>int</code></td>
<td>消息的标志位，用于控制消息的行为（如是否异步、是否已使用等）。</td>
</tr>
<tr>
<td><strong><code>obtain()</code></strong></td>
<td><code>static Message</code></td>
<td>从消息池中获取一个<code>Message</code>对象，避免频繁创建和销毁对象。</td>
</tr>
<tr>
<td><strong><code>recycle()</code></strong></td>
<td><code>void</code></td>
<td>将消息回收到消息池中，以便重用。</td>
</tr>
<tr>
<td><strong><code>setData(Bundle)</code></strong></td>
<td><code>void</code></td>
<td>设置消息的<code>Bundle</code>数据。</td>
</tr>
<tr>
<td><strong><code>getData()</code></strong></td>
<td><code>Bundle</code></td>
<td>获取消息的<code>Bundle</code>数据。</td>
</tr>
</tbody></table>
<h2 id="categories-逆向与风控-Android逆向-源码阅读-Handler机制"><a href="#categories-逆向与风控-Android逆向-源码阅读-Handler机制" class="headerlink" title="categories:- [逆向与风控, Android逆向, 源码阅读, Handler机制]"></a>categories:<br>- [逆向与风控, Android逆向, 源码阅读, Handler机制]</h2><h2 id="消息的创建与发送"><a href="#消息的创建与发送" class="headerlink" title="消息的创建与发送"></a><strong>消息的创建与发送</strong></h2><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Message.obtain()</code></strong></td>
<td>从消息池中获取一个<code>Message</code>对象。</td>
</tr>
<tr>
<td><strong><code>Handler.obtainMessage()</code></strong></td>
<td>从<code>Handler</code>关联的消息池中获取一个<code>Message</code>对象，并自动设置<code>target</code>。</td>
</tr>
<tr>
<td><strong><code>Handler.sendMessage()</code></strong></td>
<td>将消息发送到<code>Handler</code>关联的<code>MessageQueue</code>中。</td>
</tr>
<tr>
<td><strong><code>Handler.post()</code></strong></td>
<td>发送一个<code>Runnable</code>任务，<code>Handler</code>会将其封装为<code>Message</code>并发送。</td>
</tr>
</tbody></table>
<hr>
<h2 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a><strong>消息的处理</strong></h2><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Handler.handleMessage()</code></strong></td>
<td>在<code>Handler</code>中处理消息。开发者需要重写该方法以实现自定义逻辑。</td>
</tr>
<tr>
<td><strong><code>Handler.Callback.handleMessage()</code></strong></td>
<td>通过<code>Handler.Callback</code>接口处理消息，避免继承<code>Handler</code>。</td>
</tr>
</tbody></table>
<h2 id="categories-逆向与风控-Android逆向-源码阅读-Handler机制-1"><a href="#categories-逆向与风控-Android逆向-源码阅读-Handler机制-1" class="headerlink" title="categories:- [逆向与风控, Android逆向, 源码阅读, Handler机制]"></a>categories:<br>- [逆向与风控, Android逆向, 源码阅读, Handler机制]</h2><h2 id="消息的回收与移除"><a href="#消息的回收与移除" class="headerlink" title="消息的回收与移除"></a><strong>消息的回收与移除</strong></h2><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>Message.recycle()</code></strong></td>
<td>将消息回收到消息池中，以便重用。</td>
</tr>
<tr>
<td><strong><code>Handler.removeMessages()</code></strong></td>
<td>从<code>MessageQueue</code>中移除未处理的消息。</td>
</tr>
</tbody></table>
<hr>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h2><h4 id="创建和发送消息"><a href="#创建和发送消息" class="headerlink" title="创建和发送消息"></a><strong>创建和发送消息</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                Log.d(<span class="hljs-string">&quot;Handler&quot;</span>, <span class="hljs-string">&quot;Received message type 1&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">super</span>.handleMessage(msg);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>msg.what = <span class="hljs-number">1</span>;<br>msg.arg1 = <span class="hljs-number">10</span>;<br>msg.obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>handler.sendMessage(msg);<br></code></pre></td></tr></table></figure>

<h4 id="发送Runnable任务"><a href="#发送Runnable任务" class="headerlink" title="发送Runnable任务"></a><strong>发送Runnable任务</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>();<br>handler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        Log.d(<span class="hljs-string">&quot;Handler&quot;</span>, <span class="hljs-string">&quot;Running posted task&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="回收消息"><a href="#回收消息" class="headerlink" title="回收消息"></a><strong>回收消息</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>msg.recycle(); <span class="hljs-comment">// 回收消息</span><br></code></pre></td></tr></table></figure>

<h4 id="移除消息"><a href="#移除消息" class="headerlink" title="移除消息"></a><strong>移除消息</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>();<br>handler.removeMessages(<span class="hljs-number">1</span>); <span class="hljs-comment">// 移除what值为1的所有消息</span><br></code></pre></td></tr></table></figure>

<h1 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h1><h2 id="创建MessageQueue"><a href="#创建MessageQueue" class="headerlink" title="创建MessageQueue"></a>创建MessageQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">MessageQueue(<span class="hljs-type">boolean</span> quitAllowed) &#123;<br>    mQuitAllowed = quitAllowed;<br>    <span class="hljs-comment">//通过native方法初始化消息队列，其中mPtr是供native代码使用</span><br>    mPtr = nativeInit();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中这个nativeInit在native层被调用，具体流程参考：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://gityuan.com/2015/12/27/handler-message-native/">Android消息机制2-Handler(Native层) - Gityuan博客 | 袁辉辉的技术博客</a></p>
</blockquote>
<p>整体如下：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能描述</strong></th>
<th><strong>关键实现</strong></th>
<th><strong>底层调用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>nativeInit()</code></strong></td>
<td>初始化 Native 层的 <code>MessageQueue</code> 和 <code>Looper</code>，并设置事件监听机制。</td>
<td>- 创建 <code>NativeMessageQueue</code> 对象，增加其引用计数。<br>- 将 <code>NativeMessageQueue</code> 指针 <code>mPtr</code> 保存到 Java 层的 <code>MessageQueue</code>。<br>- 创建 Native 层的 <code>Looper</code> 对象。<br>- 调用 <code>epoll_create()</code> 和 <code>epoll_ctl()</code> 监听 <code>mWakeEventFd</code> 和 <code>mRequests</code> 的可读事件。</td>
<td>- <code>epoll_create()</code>：创建 epoll 实例。<br>- <code>epoll_ctl()</code>：注册事件监听。</td>
</tr>
<tr>
<td><strong><code>nativeDestroy()</code></strong></td>
<td>销毁 Native 层的 <code>MessageQueue</code> 对象，释放资源。</td>
<td>- 调用 <code>RefBase::decStrong()</code> 减少 <code>NativeMessageQueue</code> 的引用计数。<br>- 当引用计数为 0 时，删除 <code>NativeMessageQueue</code> 对象。</td>
<td>- <code>RefBase::decStrong()</code>：减少引用计数并释放资源。</td>
</tr>
<tr>
<td><strong><code>nativePollOnce()</code></strong></td>
<td>阻塞等待事件发生或超时，用于消息队列的空闲等待。</td>
<td>- 调用 <code>Looper::pollOnce()</code>，内部使用 <code>epoll_wait()</code> 等待事件发生或超时。</td>
<td>- <code>epoll_wait()</code>：阻塞等待文件描述符上的事件。<br>- <code>Looper::pollOnce()</code>：封装了事件等待逻辑。</td>
</tr>
<tr>
<td><strong><code>nativeWake()</code></strong></td>
<td>唤醒 <code>MessageQueue</code>，用于通知有新消息到达。</td>
<td>- 调用 <code>Looper::wake()</code>，向管道 <code>mWakeEventFd</code> 写入一个字符，触发事件。</td>
<td>- <code>write()</code>：向管道写入数据。<br>- <code>Looper::wake()</code>：封装了唤醒逻辑。</td>
</tr>
</tbody></table>
<ul>
<li>**<code>nativeInit()</code>**：负责初始化 Native 层的 <code>MessageQueue</code> 和 <code>Looper</code>。使用 <code>epoll</code> 机制监听文件描述符（如 <code>mWakeEventFd</code>）的事件，以实现高效的事件等待和唤醒。</li>
<li>**<code>nativeDestroy()</code>**：负责释放 Native 层的资源。通过引用计数机制确保资源被正确释放。</li>
<li>**<code>nativePollOnce()</code>**：用于阻塞等待事件发生或超时。内部调用 <code>epoll_wait()</code>，实现高效的事件等待。</li>
<li>**<code>nativeWake()</code>**：用于唤醒 <code>MessageQueue</code>。通过向管道写入数据触发事件，通知 <code>MessageQueue</code> 有新消息到达。</li>
</ul>
<h2 id="获取message-next"><a href="#获取message-next" class="headerlink" title="获取message[next()]"></a>获取message[next()]</h2><p><code>next()</code> 方法的作用是从消息队列中获取下一个待处理的 <code>Message</code>，并在没有消息时进入阻塞状态，等待新消息的到来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 如果消息队列已经退出并被释放，则直接返回 null。</span><br>    <span class="hljs-comment">// 这种情况可能发生在应用程序尝试在退出后重新启动 Looper，这是不被支持的。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 表示只在第一次迭代时运行 idle handlers</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 下一次轮询的超时时间（毫秒）</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 无限循环，直到获取到消息或退出</span><br>        <span class="hljs-comment">// 如果 nextPollTimeoutMillis 不为 0，则刷新 Binder 命令</span><br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br><br>        <span class="hljs-comment">// 调用 native 方法，阻塞等待消息或超时</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 加锁，确保线程安全</span><br>            <span class="hljs-comment">// 获取当前时间</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 前一个消息</span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages; <span class="hljs-comment">// 当前消息（队列头）</span><br><br>            <span class="hljs-comment">// 如果消息存在且消息的 target 为 null，说明遇到了屏障（barrier）</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 被屏障阻塞，寻找队列中下一个异步消息</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br><br>            <span class="hljs-comment">// 如果找到了消息</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果消息的执行时间还未到</span><br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// 计算需要等待的时间</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 消息已准备好，可以处理</span><br>                    mBlocked = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记为非阻塞状态</span><br><br>                    <span class="hljs-comment">// 从队列中移除消息</span><br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                        <span class="hljs-keyword">if</span> (prevMsg.next == <span class="hljs-literal">null</span>) &#123;<br>                            mLast = prevMsg;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                        <span class="hljs-keyword">if</span> (msg.next == <span class="hljs-literal">null</span>) &#123;<br>                            mLast = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 断开消息的链表连接</span><br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                    msg.markInUse(); <span class="hljs-comment">// 标记消息为正在使用</span><br><br>                    <span class="hljs-comment">// 如果消息是异步的，减少异步消息计数</span><br>                    <span class="hljs-keyword">if</span> (msg.isAsynchronous()) &#123;<br>                        mAsyncMessageCount--;<br>                    &#125;<br><br>                    <span class="hljs-keyword">return</span> msg; <span class="hljs-comment">// 返回消息</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 没有更多消息，设置超时时间为无限等待</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果消息队列正在退出，则释放资源并返回 null</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果是第一次进入空闲状态，则获取需要运行的 idle handlers 的数量</span><br>            <span class="hljs-comment">// idle handlers 只在队列为空或队列中的第一个消息还未到执行时间时运行</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                    &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br><br>            <span class="hljs-comment">// 如果没有 idle handlers 需要运行，则继续循环等待</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                mBlocked = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记为阻塞状态</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 初始化 idle handlers 数组</span><br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>            &#125;<br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>        &#125;<br><br>        <span class="hljs-comment">// 运行 idle handlers</span><br>        <span class="hljs-comment">// 只有在第一次迭代时才会进入此代码块</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 释放 handler 的引用</span><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 调用 idle handler 的 queueIdle 方法</span><br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br><br>            <span class="hljs-comment">// 如果 idle handler 返回 false，则从列表中移除</span><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 重置 idle handler 计数为 0，避免重复运行</span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 在调用 idle handler 的过程中，可能已经有新消息到达</span><br>        <span class="hljs-comment">// 因此重新检查消息队列，避免不必要的等待</span><br>        nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="添加message-enqueueMessage"><a href="#添加message-enqueueMessage" class="headerlink" title="添加message[enqueueMessage()]"></a>添加message[enqueueMessage()]</h2><p><code>enqueueMessage()</code> 方法的作用是将一个 <code>Message</code> 对象插入到消息队列中，并根据消息的执行时间（<code>when</code>）进行排序。如果消息队列当前处于阻塞状态，并且新插入的消息需要立即处理，则会唤醒消息队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">// 检查消息的 target（Handler）是否为 null</span><br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 加锁，确保线程安全</span><br>        <span class="hljs-comment">// 检查消息是否已经被使用</span><br>        <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果消息队列正在退出，则拒绝新消息</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle(); <span class="hljs-comment">// 回收消息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 标记消息为正在使用，并设置消息的执行时间</span><br>        msg.markInUse();<br>        msg.when = when;<br><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages; <span class="hljs-comment">// 当前队列头</span><br>        <span class="hljs-type">boolean</span> needWake; <span class="hljs-comment">// 是否需要唤醒消息队列</span><br><br>        <span class="hljs-comment">// 如果队列为空，或者新消息的执行时间早于队列头的消息，则将新消息插入队列头</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked; <span class="hljs-comment">// 如果队列当前处于阻塞状态，则需要唤醒</span><br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;<br>                mLast = mMessages; <span class="hljs-comment">// 如果队列为空，更新队列尾</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 新消息需要插入队列的中间或尾部</span><br>            <span class="hljs-comment">// 只有在队列头是屏障（barrier）且新消息是队列中最早的异步消息时，才需要唤醒队列</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br><br>            <span class="hljs-comment">// 根据是否启用尾节点跟踪（tail tracking），将代码分为两部分</span><br>            <span class="hljs-keyword">if</span> (Flags.messageQueueTailTracking()) &#123;<br>                <span class="hljs-comment">// 如果新消息的执行时间晚于队列尾的消息，则插入队列尾</span><br>                <span class="hljs-keyword">if</span> (when &gt;= mLast.when) &#123;<br>                    needWake = needWake &amp;&amp; mAsyncMessageCount == <span class="hljs-number">0</span>;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    mLast.next = msg;<br>                    mLast = msg;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 新消息需要插入队列的中间</span><br>                    Message prev;<br>                    <span class="hljs-keyword">for</span> (;;) &#123;<br>                        prev = p;<br>                        p = p.next;<br>                        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 如果新消息是异步消息，并且队列中已经有其他异步消息，则不需要唤醒</span><br>                        <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                            needWake = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 插入队列尾</span><br>                        mLast = msg;<br>                    &#125;<br>                    msg.next = p; <span class="hljs-comment">// 将新消息插入到 prev 和 p 之间</span><br>                    prev.next = msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果没有启用尾节点跟踪，则遍历队列找到插入位置</span><br>                Message prev;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    prev = p;<br>                    p = p.next;<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果新消息是异步消息，并且队列中已经有其他异步消息，则不需要唤醒</span><br>                    <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                        needWake = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                msg.next = p; <span class="hljs-comment">// 将新消息插入到 prev 和 p 之间</span><br>                prev.next = msg;<br><br>                <span class="hljs-comment">// 如果没有启用尾节点跟踪，则将 mLast 设置为 null，避免内存泄漏</span><br>                mLast = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果需要唤醒队列，则调用 native 方法唤醒</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><h2 id="Handler的构造"><a href="#Handler的构造" class="headerlink" title="Handler的构造"></a>Handler的构造</h2><h3 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(Looper looper)</span> &#123;<br>    <span class="hljs-built_in">this</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(Looper looper, Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>    mLooper = looper;<br>    mQueue = looper.mQueue;<br>    mCallback = callback;<br>    mAsynchronous = async;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。</p>
<h3 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(Callback callback, <span class="hljs-type">boolean</span> async)</span> &#123;<br>    <span class="hljs-comment">//匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span><br>    <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;<br>        <span class="hljs-keyword">final</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&gt; klass = getClass();<br>        <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;<br>                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +<br>                klass.getCanonicalName());<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//必须先执行Looper.prepare()，才能获取Looper对象，否则为null.</span><br>    mLooper = Looper.myLooper();  <span class="hljs-comment">//从当前线程的TLS中获取Looper对象【见2.1】</span><br>    <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    mQueue = mLooper.mQueue; <span class="hljs-comment">//消息队列，来自Looper对象</span><br>    mCallback = callback;  <span class="hljs-comment">//回调方法</span><br>    mAsynchronous = async; <span class="hljs-comment">//设置消息是否为异步处理方式</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。</p>
<h2 id="消息发送-sendMessage"><a href="#消息发送-sendMessage" class="headerlink" title="消息发送[sendMessage()]"></a>消息发送[sendMessage()]</h2><p>先看应用中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> looperThread.handler.obtainMessage(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello from Main Thread!&quot;</span>);<br>                looperThread.handler.sendMessage(message);<br></code></pre></td></tr></table></figure>

<p>跟进去查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/03/13/4FMPVmwHZDjlyGB.png" srcset="/img/loading.gif" lazyload></p>
<p>经过一系列调用链，可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span><br><span class="hljs-params">          <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>      msg.target = <span class="hljs-built_in">this</span>;<br>      msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>      <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>          msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p><code>Handler.sendEmptyMessage()</code>等系列方法最终调MessageQueue.enqueueMessage(msg, uptimeMillis)&#96;，将消息添加到消息队列中</p>
<h2 id="消息分发-dispatchMessage"><a href="#消息分发-dispatchMessage" class="headerlink" title="消息分发[dispatchMessage()]"></a>消息分发[dispatchMessage()]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-comment">// 检查消息是否有回调（Runnable对象）</span><br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果有回调，直接执行回调</span><br>        handleCallback(msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果没有回调，检查Handler是否设置了全局回调（mCallback）</span><br>        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果设置了全局回调，调用全局回调处理消息</span><br>            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                <span class="hljs-comment">// 如果全局回调处理了消息，直接返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果全局回调未处理消息，调用Handler的handleMessage方法处理消息</span><br>        handleMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>分发消息流程：</strong></p>
<ol>
<li>优先执行消息的回调：<ul>
<li>如果消息有<code>Runnable</code>回调（<code>msg.callback != null</code>），直接执行该回调。</li>
</ul>
</li>
<li>其次尝试全局回调：<ul>
<li>如果<code>Handler</code>设置了全局回调（<code>mCallback != null</code>），调用全局回调处理消息。</li>
<li>如果全局回调返回<code>true</code>，表示消息已被处理，直接返回。</li>
</ul>
</li>
<li>最后调用Handler的handleMessage方法：<ul>
<li>如果消息没有回调，且全局回调未处理消息，调用<code>Handler</code>的<code>handleMessage</code>方法处理消息。</li>
</ul>
</li>
</ol>
<h1 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h1><h2 id="取出消息并分发-loop"><a href="#取出消息并分发-loop" class="headerlink" title="取出消息并分发[loop()]"></a>取出消息并分发[loop()]</h2><p><code>loop()</code> 方法是 <code>Looper</code> 的核心方法之一，负责从消息队列中不断取出消息并分发给对应的 <code>Handler</code> 处理。它是一个无限循环，直到消息队列退出或被显式终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程的 Looper 对象</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果 Looper 为 null，说明当前线程没有调用 Looper.prepare()，抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 Looper 已经在循环中，则打印警告日志</span><br>    <span class="hljs-keyword">if</span> (me.mInLoop) &#123;<br>        Slog.w(TAG, <span class="hljs-string">&quot;Loop again would have the queued messages be executed&quot;</span><br>                + <span class="hljs-string">&quot; before this one completed.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 标记 Looper 进入循环状态</span><br>    me.mInLoop = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 清除调用线程的身份信息，并记录当前线程的身份标识</span><br>    Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ident</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br><br>    <span class="hljs-comment">// 允许通过系统属性覆盖慢消息检测的阈值</span><br>    <span class="hljs-comment">// 例如：adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">thresholdOverride</span> <span class="hljs-operator">=</span> getThresholdOverride();<br><br>    <span class="hljs-comment">// 初始化慢消息检测标志</span><br>    me.mSlowDeliveryDetected = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 无限循环，处理消息</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 调用 loopOnce() 方法处理单个消息</span><br>        <span class="hljs-comment">// 如果 loopOnce() 返回 false，则退出循环</span><br>        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="loopOnce"><a href="#loopOnce" class="headerlink" title="loopOnce()"></a>loopOnce()</h3><p><code>loopOnce</code>方法的主要作用是从<code>Looper</code>的消息队列中取出一个消息（<code>Message</code>），并将其分发给对应的<code>Handler</code>进行处理。它还包含了对消息分发性能的监控、日志记录、异常处理等功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,</span><br><span class="hljs-params">            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>    <span class="hljs-comment">// 从消息队列中获取下一个消息，可能会阻塞</span><br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next(); <span class="hljs-comment">// might block</span><br>    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果消息为null，表示消息队列正在退出，返回false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将日志记录器存储在局部变量中，防止UI事件修改日志记录器</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;<br>    <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 记录消息分发的开始日志</span><br>        logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span><br>                + msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>    &#125;<br><br>    <span class="hljs-comment">// 确保在处理事务时观察者不会改变</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Observer</span> <span class="hljs-variable">observer</span> <span class="hljs-operator">=</span> sObserver;<br><br>    <span class="hljs-comment">// 获取性能跟踪标签和慢分发/慢交付的阈值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">traceTag</span> <span class="hljs-operator">=</span> me.mTraceTag;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">slowDispatchThresholdMs</span> <span class="hljs-operator">=</span> me.mSlowDispatchThresholdMs;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">slowDeliveryThresholdMs</span> <span class="hljs-operator">=</span> me.mSlowDeliveryThresholdMs;<br><br>    <span class="hljs-comment">// 检查是否有阈值覆盖</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasOverride</span> <span class="hljs-operator">=</span> thresholdOverride &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (hasOverride) &#123;<br>        <span class="hljs-comment">// 如果有阈值覆盖，使用覆盖值</span><br>        slowDispatchThresholdMs = thresholdOverride;<br>        slowDeliveryThresholdMs = thresholdOverride;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否需要记录慢交付日志</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">logSlowDelivery</span> <span class="hljs-operator">=</span> (slowDeliveryThresholdMs &gt; <span class="hljs-number">0</span> || hasOverride)<br>            &amp;&amp; (msg.when &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断是否需要记录慢分发日志</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">logSlowDispatch</span> <span class="hljs-operator">=</span> (slowDispatchThresholdMs &gt; <span class="hljs-number">0</span> || hasOverride);<br><br>    <span class="hljs-comment">// 判断是否需要记录分发开始时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">needStartTime</span> <span class="hljs-operator">=</span> logSlowDelivery || logSlowDispatch;<br>    <span class="hljs-comment">// 判断是否需要记录分发结束时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">needEndTime</span> <span class="hljs-operator">=</span> logSlowDispatch;<br><br>    <span class="hljs-comment">// 如果启用了性能跟踪，记录消息分发的开始</span><br>    <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;<br>        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));<br>    &#125;<br><br>    <span class="hljs-comment">// 记录分发开始时间（如果需要）</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">dispatchStart</span> <span class="hljs-operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> dispatchEnd;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 如果存在观察者，通知观察者消息分发开始</span><br>    <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>        token = observer.messageDispatchStarting();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置消息的工作源</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">origWorkSource</span> <span class="hljs-operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将消息分发给目标Handler</span><br>        msg.target.dispatchMessage(msg);<br>        <span class="hljs-comment">// 如果存在观察者，通知观察者消息分发完成</span><br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.messageDispatched(token, msg);<br>        &#125;<br>        <span class="hljs-comment">// 记录分发结束时间（如果需要）</span><br>        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;<br>        <span class="hljs-comment">// 如果分发过程中抛出异常，通知观察者并重新抛出异常</span><br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.dispatchingThrewException(token, msg, exception);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> exception;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 恢复工作源</span><br>        ThreadLocalWorkSource.restore(origWorkSource);<br>        <span class="hljs-comment">// 如果启用了性能跟踪，记录消息分发的结束</span><br>        <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>            Trace.traceEnd(traceTag);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果需要记录慢交付日志</span><br>    <span class="hljs-keyword">if</span> (logSlowDelivery) &#123;<br>        <span class="hljs-keyword">if</span> (me.mSlowDeliveryDetected) &#123;<br>            <span class="hljs-comment">// 如果已经检测到慢交付，并且消息分发时间小于等于10ms，重置标志</span><br>            <span class="hljs-keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="hljs-number">10</span>) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Drained&quot;</span>);<br>                me.mSlowDeliveryDetected = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果检测到慢交付，记录日志并设置标志</span><br>            <span class="hljs-keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="hljs-string">&quot;delivery&quot;</span>,<br>                    msg)) &#123;<br>                me.mSlowDeliveryDetected = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果需要记录慢分发日志</span><br>    <span class="hljs-keyword">if</span> (logSlowDispatch) &#123;<br>        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="hljs-string">&quot;dispatch&quot;</span>, msg);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果存在日志记录器，记录消息分发的结束日志</span><br>    <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>        logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>    &#125;<br><br>    <span class="hljs-comment">// 确保在分发过程中线程身份没有被破坏</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">newIdent</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">if</span> (ident != newIdent) &#123;<br>        <span class="hljs-comment">// 如果线程身份发生变化，记录错误日志</span><br>        Log.wtf(TAG, <span class="hljs-string">&quot;Thread identity changed from 0x&quot;</span><br>                + Long.toHexString(ident) + <span class="hljs-string">&quot; to 0x&quot;</span><br>                + Long.toHexString(newIdent) + <span class="hljs-string">&quot; while dispatching to &quot;</span><br>                + msg.target.getClass().getName() + <span class="hljs-string">&quot; &quot;</span><br>                + msg.callback + <span class="hljs-string">&quot; what=&quot;</span> + msg.what);<br>    &#125;<br><br>    <span class="hljs-comment">// 回收消息对象</span><br>    msg.recycleUnchecked();<br><br>    <span class="hljs-comment">// 返回true，表示成功处理了一个消息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare()"></a>prepare()</h2><p>对于无参的情况，默认调用<code>prepare(true)</code>，表示的是这个Looper允许退出，而对于false的情况则表示当前Looper不允许退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    <span class="hljs-comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span><br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//创建Looper对象，并保存到当前线程的TLS区域</span><br>    sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的<code>sThreadLocal</code>是ThreadLocal类型</p>
<p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法：</p>
<ul>
<li><code>ThreadLocal.set(T value)</code>：将value存储到当前线程的TLS区域</li>
</ul>
<h1 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h1><p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()来开启主线程的消息循环。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/ActivityThread.java">Cross Reference: &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 开始追踪 &quot;ActivityThreadMain&quot; 事件，用于性能分析和调试</span><br>    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ActivityThreadMain&quot;</span>);<br><br>    <span class="hljs-comment">// CloseGuard 默认是启用的，可能会产生大量日志。我们在这里禁用它，</span><br>    <span class="hljs-comment">// 但在调试版本中通过 StrictMode 选择性启用（使用 DropBox 而不是日志）。</span><br>    CloseGuard.setEnabled(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-comment">// 初始化当前用户的环境配置</span><br>    Environment.initForCurrentUser();<br><br>    <span class="hljs-comment">// 设置 libcore 中事件日志的报告器</span><br>    EventLogger.setReporter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventLoggingReporter</span>());<br><br>    <span class="hljs-comment">// 确保 TrustedCertificateStore 在正确的位置查找 CA 证书</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">configDir</span> <span class="hljs-operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());<br>    TrustedCertificateStore.setDefaultUserDirectory(configDir);<br><br>    <span class="hljs-comment">// 设置进程的 argv[0] 为 &quot;&lt;pre-initialized&gt;&quot;，通常用于标识进程的初始状态</span><br>    Process.setArgV0(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>);<br><br>    <span class="hljs-comment">// 准备主线程的 Looper，Looper 是 Android 消息循环的核心组件</span><br>    Looper.prepareMainLooper();<br><br>    <span class="hljs-comment">// 从命令行参数中查找 PROC_START_SEQ_IDENT 的值（如果有的话）。</span><br>    <span class="hljs-comment">// 参数格式为 &quot;seq=114&quot;，用于标识进程启动的顺序。</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">startSeq</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> args.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (args[i] != <span class="hljs-literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;<br>                startSeq = Long.parseLong(<br>                        args[i].substring(PROC_START_SEQ_IDENT.length()));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建 ActivityThread 实例，这是 Android 应用主线程的核心类</span><br>    <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br><br>    <span class="hljs-comment">// 将 ActivityThread 附加到系统，false 表示不是系统进程</span><br>    thread.attach(<span class="hljs-literal">false</span>, startSeq);<br><br>    <span class="hljs-comment">// 如果主线程的 Handler 为空，则从 ActivityThread 中获取并设置</span><br>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>        sMainThreadHandler = thread.getHandler();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果为 false，则不启用消息日志记录（调试时可以使用）</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span><br>                <span class="hljs-title class_">LogPrinter</span>(Log.DEBUG, <span class="hljs-string">&quot;ActivityThread&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 结束 &quot;ActivityThreadMain&quot; 事件的追踪</span><br>    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br><br>    <span class="hljs-comment">// 启动主线程的消息循环，开始处理消息和事件</span><br>    Looper.loop();<br><br>    <span class="hljs-comment">// 如果 Looper 循环意外退出，抛出运行时异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主线程的消息循环开始了以后，ActivityThread还需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程。</p>
<p><img src="https://s2.loli.net/2025/03/14/RJfqbW5jXiu7Vcy.png" srcset="/img/loading.gif" lazyload></p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/" class="category-chain-item">逆向与风控</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Android%E9%80%86%E5%90%91/" class="category-chain-item">Android逆向</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Android%E9%80%86%E5%90%91/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="category-chain-item">源码阅读</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Android%E9%80%86%E5%90%91/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Handler%E6%9C%BA%E5%88%B6/" class="category-chain-item">Handler机制</a>
  
  

  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Handler原理</div>
      <div>http://example.com/2024/06/26/逆向与风控/Android逆向/源码阅读/Handler机制/Handler/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年6月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/05/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Android%E9%80%86%E5%90%91/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%85%E6%9E%90/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程与多线程机制">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">线程与多线程机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/22/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Js%E9%80%86%E5%90%91/%E8%A1%A5%E7%8E%AF%E5%A2%83/" title="补环境">
                        <span class="hidden-mobile">补环境</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
