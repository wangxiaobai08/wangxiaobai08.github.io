

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="开门见山React 是一个用于构建用户界面的 JavaScript 库，其核心开发思想是组件化和声明式编程。 React 将 UI 拆分为独立、可复用的组件，每个组件负责渲染自身的视图层，并通过 props 接收数据和回调函数进行通信，形成清晰的单向数据流。它采用虚拟 DOM（Virtual DOM）机制高效更新界面，开发者只需声明”UI 应该是什么状态”（声明式），而无需直接操作 DOM（命令式">
<meta property="og:type" content="article">
<meta property="og:title" content="React基础">
<meta property="og:url" content="http://example.com/2025/05/18/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E5%89%8D%E7%AB%AF/React%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="开门见山React 是一个用于构建用户界面的 JavaScript 库，其核心开发思想是组件化和声明式编程。 React 将 UI 拆分为独立、可复用的组件，每个组件负责渲染自身的视图层，并通过 props 接收数据和回调函数进行通信，形成清晰的单向数据流。它采用虚拟 DOM（Virtual DOM）机制高效更新界面，开发者只需声明”UI 应该是什么状态”（声明式），而无需直接操作 DOM（命令式">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-05-18T06:03:48.931Z">
<meta property="article:modified_time" content="2025-05-25T14:19:51.843Z">
<meta property="article:author" content="Ling">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>React基础 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"ture","follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"7a4M5yfyGptX0OG18qvJppXQ-gzGzoHsz","app_key":"y6dZFtA8I8Lg1KVhHbujblfB","server_url":"https://7a4m5yfy.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="React基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          45 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">React基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h1><p>React 是一个用于构建用户界面的 JavaScript 库，其核心开发思想是<strong>组件化</strong>和<strong>声明式编程</strong>。</p>
<p>React 将 UI 拆分为独立、可复用的组件，每个组件负责渲染自身的视图层，并通过 props 接收数据和回调函数进行通信，形成清晰的单向数据流。它采用虚拟 DOM（Virtual DOM）机制高效更新界面，开发者只需声明”UI 应该是什么状态”（声明式），而无需直接操作 DOM（命令式）。</p>
<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><h2 id="基本概念与使用"><a href="#基本概念与使用" class="headerlink" title="基本概念与使用"></a>基本概念与使用</h2><p>React 的 <strong>JSX</strong>（JavaScript XML）是一种语法扩展，它允许开发者在 JavaScript 代码中直接编写类似 HTML 的标记结构，用于声明式地描述 UI 组件。</p>
<p>JSX 会被编译工具（如 Babel）转换为标准的 JavaScript 函数调用（<code>React.createElement()</code>），最终生成虚拟 DOM 对象。  </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// JSX 代码</span><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><br><span class="hljs-comment">// 编译后结果</span><br><span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  <span class="hljs-string">&#x27;h1&#x27;</span>,<br>  &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;title&#x27;</span> &#125;,<br>  <span class="hljs-string">&#x27;Hello&#x27;</span><br>);<br></code></pre></td></tr></table></figure>

<p>其JSX 本质上仍然是 JavaScript，因此可以：使用 <code>&#123;&#125;</code> 嵌入任意 JavaScript 表达式并作为变量赋值、函数参数或返回值</p>
<p>在语法上面Jsx是 类 HTML 语法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>标签闭合</strong>：必须显式闭合（如 <code>&lt;img /&gt;</code>）</li>
<li><strong>属性命名</strong>：驼峰式（如 <code>className</code> 替代 <code>class</code>，<code>htmlFor</code> 替代 <code>for</code>）</li>
</ul>
<p>并且支持动态内容注入</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello, &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>; <span class="hljs-comment">// 输出: Hello, Alice</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>支持表达式</strong>：<code>&#123;user.isAdmin &amp;&amp; &lt;AdminPanel /&gt;&#125;</code></li>
<li><strong>禁止语句</strong>：不能直接使用 <code>if/for</code>（需转换为表达式）</li>
</ul>
<p>组件化标记：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Alice&quot;</span> /&gt;</span></span>; <span class="hljs-comment">// 自定义组件</span><br></code></pre></td></tr></table></figure>

<h2 id="JSX-的底层原理"><a href="#JSX-的底层原理" class="headerlink" title="JSX 的底层原理"></a>JSX 的底层原理</h2><h3 id="创建元素的三要素"><a href="#创建元素的三要素" class="headerlink" title="创建元素的三要素"></a>创建元素的三要素</h3><p>JSX 编译后的 <code>React.createElement()</code> 接收三个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  type,      <span class="hljs-comment">// 标签名（字符串）或组件（函数/类）</span><br>  props,     <span class="hljs-comment">// 属性对象（含 children）</span><br>  ...children <span class="hljs-comment">// 子元素（可选）</span><br>);<br></code></pre></td></tr></table></figure>

<h3 id="虚拟-DOM-结构"><a href="#虚拟-DOM-结构" class="headerlink" title="虚拟 DOM 结构"></a>虚拟 DOM 结构</h3><p>JSX 最终生成的对象描述：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;container&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Title&#x27;</span> &#125; &#125;,<br>      &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;Content&#x27;</span> &#125; &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="特殊规则"><a href="#特殊规则" class="headerlink" title="特殊规则"></a>特殊规则</h2><h3 id="必须返回单个根元素"><a href="#必须返回单个根元素" class="headerlink" title="必须返回单个根元素"></a>必须返回单个根元素</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//  错误</span><br><span class="hljs-keyword">const</span> element = (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>);<br><br><span class="hljs-comment">// 正确（使用 Fragment 或 div 包裹）</span><br><span class="hljs-keyword">const</span> element = (<br>  <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>);<br></code></pre></td></tr></table></figure>

<h3 id="属性差异"><a href="#属性差异" class="headerlink" title="属性差异"></a>属性差异</h3><table>
<thead>
<tr>
<th>HTML 属性</th>
<th>JSX 属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>class</code></td>
<td><code>className</code></td>
<td>避免与 JS 的 class 冲突</td>
</tr>
<tr>
<td><code>for</code></td>
<td><code>htmlFor</code></td>
<td>表单标签关联</td>
</tr>
<tr>
<td><code>style</code></td>
<td>对象形式</td>
<td><code>style=&#123;&#123; color: 'red' &#125;&#125;</code></td>
</tr>
<tr>
<td><code>onclick</code></td>
<td><code>onClick</code></td>
<td>事件驼峰命名</td>
</tr>
</tbody></table>
<h3 id="防止注入攻击"><a href="#防止注入攻击" class="headerlink" title="防止注入攻击"></a>防止注入攻击</h3><p>JSX 自动转义嵌入内容：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> userInput = <span class="hljs-string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>;<br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;userInput&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>; <span class="hljs-comment">// 安全渲染为文本</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>在 React 中，<strong>条件渲染</strong> 和 <strong>元素渲染</strong> 是构建动态 UI 的核心技能。****条件渲染是指根据不同的条件显示不同的 UI 内容。React 支持多种方式实现条件渲染。</p>
<h3 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a><code>if-else</code> 语句</h3><p>最基础的条件渲染方式，适用于简单的逻辑判断：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Greeting</span>(<span class="hljs-params">&#123; isLoggedIn &#125;: &#123; isLoggedIn: <span class="hljs-built_in">boolean</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome back!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Please sign up.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a><strong>三元运算符</strong></h3><p>适用于简单的条件判断，代码更简洁：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Greeting</span>(<span class="hljs-params">&#123; isLoggedIn &#125;: &#123; isLoggedIn: <span class="hljs-built_in">boolean</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> isLoggedIn ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome back!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Please sign up.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="逻辑与（-）短路运算"><a href="#逻辑与（-）短路运算" class="headerlink" title="逻辑与（&amp;&amp;）短路运算"></a>逻辑与（<code>&amp;&amp;</code>）短路运算</h3><p>适用于条件为真时渲染元素，否则不渲染：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Mailbox</span>(<span class="hljs-params">&#123; unreadMessages &#125;: &#123; unreadMessages: <span class="hljs-built_in">string</span>[] &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;unreadMessages.length &gt; 0 &amp;&amp; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>You have &#123;unreadMessages.length&#125; unread messages.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="** switch-case 语句**"></a>** <code>switch-case</code> 语句**</h3><p>适用于多个条件的情况：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">StatusBadge</span>(<span class="hljs-params">&#123; status &#125;: &#123; status: <span class="hljs-built_in">string</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (status) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;active&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;badge active&quot;</span>&gt;</span>Active<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;inactive&quot;</span>:<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;badge inactive&quot;</span>&gt;</span>Inactive<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;badge unknown&quot;</span>&gt;</span>Unknown<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="隐藏元素（返回-null）"><a href="#隐藏元素（返回-null）" class="headerlink" title="隐藏元素（返回 null）"></a><strong>隐藏元素（返回 <code>null</code>）</strong></h3><p>如果条件不满足，可以返回 <code>null</code> 来隐藏元素：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">WarningBanner</span>(<span class="hljs-params">&#123; warn &#125;: &#123; warn: <span class="hljs-built_in">boolean</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!warn) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;warning&quot;</span>&gt;</span>Warning!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a><strong>元素渲染</strong></h2><p>React 元素是不可变的（immutable），每次更新都会创建一个新的元素对象。React 通过比较新旧元素的差异来高效更新 DOM。</p>
<h3 id="创建-React-元素"><a href="#创建-React-元素" class="headerlink" title="创建 React 元素"></a><strong>创建 React 元素</strong></h3><p>使用 <code>React.createElement</code> 或 JSX 语法创建元素：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 使用 JSX</span><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><br><span class="hljs-comment">// 使用 React.createElement</span><br><span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  <span class="hljs-string">&quot;h1&quot;</span>,<br>  <span class="hljs-literal">null</span>,<br>  <span class="hljs-string">&quot;Hello, world!&quot;</span><br>);<br></code></pre></td></tr></table></figure>

<h3 id="动态渲染元素"><a href="#动态渲染元素" class="headerlink" title="动态渲染元素"></a><strong>动态渲染元素</strong></h3><p>可以通过变量存储 React 元素，并在条件判断后渲染：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">LoginButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleLogin&#125;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LogoutButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleLogout&#125;</span>&gt;</span>Logout<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserGreeting</span>(<span class="hljs-params">&#123; isLoggedIn &#125;: &#123; isLoggedIn: <span class="hljs-built_in">boolean</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> button = isLoggedIn ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> /&gt;</span></span> : <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> /&gt;</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;button&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a><strong>列表渲染</strong></h4><p>React 支持通过 <code>map</code> 方法渲染列表，并为每个元素添加唯一的 <code>key</code>：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NumberList</span>(<span class="hljs-params">&#123; numbers &#125;: &#123; numbers: <span class="hljs-built_in">number</span>[] &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;numbers.map((number) =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li><code>key</code> 必须是唯一的，通常使用数据的唯一标识（如 <code>id</code>）。</li>
<li>避免使用数组索引作为 <code>key</code>（除非列表是静态的且不会重新排序）。</li>
</ul>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p>React的组件开发是一种基于模块化和声明式的UI构建范式，其核心本质是将复杂的用户界面拆分为独立、可复用的代码单元（组件），<strong>每个组件封装自身的结构（JSX）、样式（CSS）和行为（逻辑与状态）。</strong></p>
<p>组件的本质是<strong>状态到UI的映射函数</strong>（UI &#x3D; f(state)），它接收输入（props）并返回描述界面应该如何渲染的React元素。</p>
<p>React组件的设计哲学强调<strong>单向数据流</strong>和<strong>组件组合</strong>，通过将UI分解为层次化的组件树，开发者可以像搭积木一样构建应用，每个组件只需关注自身的职责范围，父组件通过props向下传递数据，子组件通过回调函数向上通信。这种模式实现了<strong>关注点分离</strong>，使得代码更易于维护、测试和复用。</p>
<p>组件开发在React中有两种表现形式：<strong>类组件</strong>（通过ES6 class定义，包含生命周期方法）和<strong>函数组件</strong>（通过普通函数定义，借助Hooks获得状态管理能力）。现代React更推崇函数组件+Hooks的组合，因其更符合函数式编程思想，消除了类组件中this绑定的复杂性，同时通过Hooks机制（如useState、useEffect）赋予了函数组件与类组件等同的能力。</p>
<blockquote>
<p>组件化的核心价值在于<strong>可复用性</strong>（一次开发多处使用）、<strong>可维护性</strong>（隔离变化范围）和<strong>声明式编程</strong>（描述”UI应该是什么样子”而非具体操作DOM步骤）</p>
</blockquote>
<h2 id="Props【属性】"><a href="#Props【属性】" class="headerlink" title="Props【属性】"></a>Props【属性】</h2><p>React 的 <strong>Props（属性）机制</strong> 本质上是一种<strong>单向数据流的信号与槽模型</strong>，它通过父组件向子组件传递数据（信号）和回调函数（槽），实现组件间的通信与协作。</p>
<p>可以看作React 的 Props 机制是<strong>观察者模式</strong>的变体：</p>
<ul>
<li><strong>父组件</strong>：作为”发布者”，通过props下发数据和回调</li>
<li><strong>子组件</strong>：作为”订阅者”，接收数据并触发回调</li>
</ul>
<pre><code class=" mermaid">graph LR
  A[父组件] -- 传递props --&gt; B[子组件]
  B -- 调用回调函数 --&gt; A
</code></pre>

<h3 id="信号（Signal）——-数据传递"><a href="#信号（Signal）——-数据传递" class="headerlink" title="信号（Signal）—— 数据传递"></a><strong>信号（Signal）—— 数据传递</strong></h3><p><strong>数据下行</strong>：父组件通过 <code>props</code> 向子组件传递数据（如字符串、数字、对象等），子组件接收后用于渲染或逻辑处理。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 父组件发送信号（数据）</span><br>&lt;<span class="hljs-title class_">ChildComponent</span> title=<span class="hljs-string">&quot;Hello&quot;</span> data=&#123;items&#125; /&gt;<br><span class="hljs-comment">// 子组件接收</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params">&#123; title, data &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>; <span class="hljs-comment">// 直接使用props数据</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意其：</p>
<ul>
<li>单向流动（父 → 子）</li>
<li>只读性（子组件不能直接修改props）</li>
<li>类型检查（可通过PropTypes或TypeScript约束）</li>
</ul>
<h3 id="槽（Slot）——-回调通信"><a href="#槽（Slot）——-回调通信" class="headerlink" title="槽（Slot）—— 回调通信"></a><strong>槽（Slot）—— 回调通信</strong></h3><p><strong>事件上行</strong>：父组件通过 <code>props</code> 传递回调函数，子组件调用该函数通知父组件（触发状态更新或行为）。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 父组件定义槽（回调）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChildClick</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子组件触发了事件&quot;</span>, data);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleChildClick&#125;</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 子组件触发槽（回调）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params">&#123; onClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> onClick(&quot;数据&quot;)&#125;&gt;点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点</strong>：子组件通过调用父组件的回调函数”传信”,实现子组件到父组件的间接通信,并且遵循React的单向数据流原则</p>
<h3 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h3><p><strong>插槽（Children）</strong>：通过 <code>props.children</code> 传递子元素，实现内容分发</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&lt;<span class="hljs-title class_">Modal</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>自定义标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>  &#123;<span class="hljs-comment">/* 作为children传递 */</span>&#125;<br>&lt;/<span class="hljs-title class_">Modal</span>&gt;<br></code></pre></td></tr></table></figure>

<h2 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h2><p>React 的组件状态（State）是驱动组件动态交互和渲染的核心机制，它本质上是一个<strong>组件内部自维护的数据存储器</strong>，允许组件在生命周期中跟踪、更新并响应数据变化。</p>
<ul>
<li><strong>状态是 React 组件的核心数据来源</strong>，决定了组件的渲染和行为。</li>
<li><strong>状态是可变的</strong>（不同于 <code>props</code>，它是只读的），用于实现动态交互。</li>
<li><strong>状态变化会触发组件重新渲染</strong>，使 UI 保持同步。</li>
</ul>
<p>其状态的核心特性在于：</p>
<ul>
<li><strong>动态性</strong>：状态是组件内部可变的私有数据，通过 <code>useState</code>（函数组件）或 <code>this.state</code>（类组件）管理，变化时触发组件重新渲染。</li>
<li><strong>响应式更新</strong>：状态更新自动触发 React 的协调（Reconciliation）过程，计算虚拟 DOM 差异并高效更新真实 DOM。</li>
<li><strong>局部性</strong>：状态默认仅对所属组件可见，需通过 props 或状态管理工具（如 Redux）实现跨组件共享。</li>
</ul>
<blockquote>
<p>React 早期（2015 年前）只有类组件，函数组件仅用于无状态 UI（Stateless Components）。2019 年 React 16.8 引入 <strong>Hooks</strong>，函数组件可以管理状态和副作用，几乎能替代类组件。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">State（状态）</th>
<th align="left">Props（属性）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可变性</strong></td>
<td align="left">可变的（组件内部管理）</td>
<td align="left">不可变的（由父组件传入）</td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">存储组件内部数据</td>
<td align="left">用于父子组件通信</td>
</tr>
<tr>
<td align="left"><strong>更新方式</strong></td>
<td align="left"><code>setState</code>（类）或 <code>setXxx</code>（函数）</td>
<td align="left">由父组件重新渲染时传入新值</td>
</tr>
<tr>
<td align="left"><strong>默认值</strong></td>
<td align="left">可在组件内初始化</td>
<td align="left">可通过 <code>defaultProps</code> 设置</td>
</tr>
</tbody></table>
<h3 id="函数组件（Hooks）"><a href="#函数组件（Hooks）" class="headerlink" title="函数组件（Hooks）"></a>函数组件（Hooks）</h3><p>使用普通 JavaScript 函数，直接返回 JSX。没有 <code>this</code>，直接通过参数获取 <code>props</code>。使用 <strong>Hooks（如 <code>useState</code>、<code>useEffect</code>）</strong> 管理状态和副作用。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化状态</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> prevCount + <span class="hljs-number">1</span>); <span class="hljs-comment">// 函数式更新</span><br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>使用 ES6 <code>class</code> 语法，继承 <code>React.Component</code>。必须包含 <code>render()</code> 方法，返回 JSX。使用 <code>this</code> 访问 <code>props</code> 和 <code>state</code>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 初始化状态</span><br>  &#125;<br><br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 合并式更新</span><br>  &#125;;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.increment&#125;</span>&gt;</span>&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 React 类组件中，<code>render()</code> 是唯一必需的方法，用于返回组件的 UI 描述（React 元素或 JSX）。它必须保持纯净，即不修改组件状态或产生副作用，且返回的 JSX 只能有一个根元素（如 <code>&lt;div&gt;</code> 或 <code>&lt;&gt;...&lt;/&gt;</code>）。函数组件通过直接返回 JSX 实现相同功能，无需 <code>render()</code> 方法。每次调用 <code>render()</code> 的结果应仅由当前 <code>props</code> 和 <code>state</code> 决定。</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="组件内通信"><a href="#组件内通信" class="headerlink" title="组件内通信"></a>组件内通信</h3><p><strong>useState</strong>  ：函数组件的基础状态管理，适用于独立组件的私有数据：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 定义状态</span><br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新状态</span><br></code></pre></td></tr></table></figure>

<p><strong>useReducer</strong>  ：适合复杂状态逻辑（类似 Redux 的简化版）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);<br><span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span> &#125;); <span class="hljs-comment">// 通过action更新</span><br></code></pre></td></tr></table></figure>

<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a><strong>父子组件通信</strong></h3><p>前面在Props【属性】中提到的消息与槽通信.</p>
<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a><strong>兄弟组件通信</strong></h3><p><strong>状态提升</strong>：将共享状态提升到最近的共同父组件，并通过 <code>props</code> 和回调函数传递：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// Parent.tsx</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [sharedState, setSharedState] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">onSharedChange</span>=<span class="hljs-string">&#123;setSharedState&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> <span class="hljs-attr">sharedState</span>=<span class="hljs-string">&#123;sharedState&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// ChildA.tsx</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChildAProps</span> &#123;<br>  <span class="hljs-attr">onSharedChange</span>: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildA</span>(<span class="hljs-params">&#123; onSharedChange &#125;: ChildAProps</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onSharedChange(e.target.value)&#125; /&gt;</span>;<br>&#125;<br><br><span class="hljs-comment">// ChildB.tsx</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChildBProps</span> &#123;<br>  <span class="hljs-attr">sharedState</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildB</span>(<span class="hljs-params">&#123; sharedState &#125;: ChildBProps</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;sharedState&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="跨层级组件通信"><a href="#跨层级组件通信" class="headerlink" title="跨层级组件通信"></a><strong>跨层级组件通信</strong></h3><p><strong>Context API</strong>  跨层级组件共享状态（避免 prop drilling）：适用于深层嵌套组件间的状态共享（如主题、用户信息）。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dark&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>); <span class="hljs-comment">// 获取值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当应用复杂度增加时，原生方案可能面临以下问题：  </p>
<ul>
<li><strong>Props 层层传递</strong>（Prop Drilling）  </li>
<li><strong>Context 重复渲染</strong>  </li>
<li><strong>状态逻辑难以维护</strong></li>
</ul>
<p>此时会选择第三方状态管理如：Redux和Mobx</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>useState</strong></td>
<td>组件内部简单状态</td>
<td>简单直接</td>
</tr>
<tr>
<td><strong>Context + useReducer</strong></td>
<td>中小型应用的跨组件状态</td>
<td>内置方案，无依赖</td>
</tr>
<tr>
<td><strong>Redux</strong></td>
<td>大型应用&#x2F;严格的状态追溯</td>
<td>强约束，生态完善</td>
</tr>
<tr>
<td><strong>MobX</strong></td>
<td>复杂响应式逻辑</td>
<td>自动依赖追踪</td>
</tr>
<tr>
<td><strong>Recoil&#x2F;Jotai</strong></td>
<td>需要细粒度更新的场景</td>
<td>原子化状态，高性能</td>
</tr>
<tr>
<td><strong>Zustand</strong></td>
<td>追求简洁的中小型应用</td>
<td>API 极简，学习成本低</td>
</tr>
</tbody></table>
<h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a><strong>组件生命周期</strong></h2><p>React 组件的生命周期有三个不同的阶段：</p>
<ol>
<li><em>初始渲染阶段：</em>这是组件即将开始其生命之旅并进入 DOM 的阶段。</li>
<li><em>更新阶段：</em>一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。</li>
<li><em>卸载阶段：</em>这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。</li>
</ol>
<h3 id="生命周期方法。"><a href="#生命周期方法。" class="headerlink" title="生命周期方法。"></a><strong>生命周期方法。</strong></h3><p>一些最重要的生命周期方法是：</p>
<ol>
<li>componentWillMount()– 在渲染之前执行，在客户端和服务器端都会执行。</li>
<li>componentDidMount() – 仅在第一次渲染后在客户端执行。</li>
<li>componentWillReceiveProps*() – 当从父类接收到 props 并且在调用另一个渲染器之前调用。</li>
<li><strong>shouldComponentUpdate()</strong> – 根据特定条件返回 true 或 false。如果你希望更新组件，请返回<strong>true</strong> 否则返回 <strong>false</strong>。默认情况下，它返回 false。</li>
<li>componentWillUpdate()*– 在 DOM 中进行渲染之前调用。</li>
<li>componentDidUpdate() – 在渲染发生后立即调用。</li>
<li>componentWillUnmount() – 从 DOM 卸载组件后调用。用于清理内存空间。</li>
</ol>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>React 中的事件处理机制是构建交互式界面的核心，它通过<strong>合成事件（SyntheticEvent）</strong>系统提供跨浏览器的一致事件接口，并与组件状态紧密结合。</p>
<h2 id="基础事件绑定"><a href="#基础事件绑定" class="headerlink" title="基础事件绑定"></a>基础事件绑定</h2><p>采用驼峰命名（如 <code>onClick</code> 而非 <code>onclick</code>）,并且传入函数引用而非字符串</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;按钮被点击&quot;</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="事件对象（SyntheticEvent）"><a href="#事件对象（SyntheticEvent）" class="headerlink" title="事件对象（SyntheticEvent）"></a>事件对象（SyntheticEvent）</h3><p>React 封装了原生事件对象，提供跨浏览器兼容性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">InputField</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; &#123; <span class="hljs-comment">// e 是合成事件</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 获取输入值</span><br>    e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止默认行为</span><br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleChange&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="类组件-vs-函数组件"><a href="#类组件-vs-函数组件" class="headerlink" title="类组件 vs 函数组件"></a>类组件 vs 函数组件</h2><h3 id="类组件中的-this-绑定"><a href="#类组件中的-this-绑定" class="headerlink" title="类组件中的 this 绑定"></a>类组件中的 <code>this</code> 绑定</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 需要手动绑定this</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>); <br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>    <span class="hljs-comment">// 或使用箭头函数避免绑定</span><br>    <span class="hljs-comment">// onClick=&#123;() =&gt; this.handleClick()&#125;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>无需处理 <code>this</code>，直接使用闭包变量：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Toggle</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [on, setOn] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setOn</span>(!on); <span class="hljs-comment">// 直接访问状态和props</span><br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>&#123;on ? &quot;ON&quot; : &quot;OFF&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><p>React Hooks 是 React 16.8 引入的一项革命性特性，它允许你在函数组件中使用状态(state)和其他 React 特性，而无需编写类组件。下面我将详细介绍每一个主要的 Hook 及其用法。</p>
<h2 id="基础-Hooks"><a href="#基础-Hooks" class="headerlink" title="基础 Hooks"></a>基础 Hooks</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 是最基本的 Hook，用于在函数组件中添加局部状态。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明一个叫 &quot;count&quot; 的 state 变量，初始值为 0</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<p>返回一个数组，第一个元素是当前状态值，第二个是更新状态的函数。可以多次调用 <code>useState</code> 来声明多个状态变量。状态更新函数 (<code>setCount</code>) 不会自动合并对象，而是替换</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>useEffect</code> 用于处理副作用操作（数据获取、订阅、手动修改 DOM 等）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 相当于 componentDidMount 和 componentDidUpdate:</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 使用浏览器的 API 更新页面标题</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<p>默认情况下，effect 在每次渲染后都会执行。可以通过返回一个函数来指定如何”清除” effect（如取消订阅）。可以通过第二个参数传递依赖数组来优化性能（只在依赖变化时执行）</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> subscription = props.<span class="hljs-property">source</span>.<span class="hljs-title function_">subscribe</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 清除订阅</span><br>    subscription.<span class="hljs-title function_">unsubscribe</span>();<br>  &#125;;<br>&#125;, [props.<span class="hljs-property">source</span>]); <span class="hljs-comment">// 仅在 props.source 改变时重新订阅</span><br></code></pre></td></tr></table></figure>

<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p><code>useContext</code> 用于在函数组件中访问 React 的 Context。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定</p>
<h2 id="额外的-Hooks"><a href="#额外的-Hooks" class="headerlink" title="额外的 Hooks"></a>额外的 Hooks</h2><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p><code>useReducer</code> 是 <code>useState</code> 的替代方案，适用于复杂 state 逻辑。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> initialState = &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialState);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      Count: &#123;state.count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>适合 state 逻辑较复杂或包含多个子值的场景。可以配合 <code>useContext</code> 实现深层组件通信</p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 返回一个记忆化的回调函数，只有在依赖项变化时才会更新。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">doSomething</span>(a, b);<br>  &#125;,<br>  [a, b],<br>);<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>用于性能优化，避免不必要的重新渲染。相当于 <code>useMemo(() =&gt; fn, deps)</code> 的语法糖</p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 返回一个记忆化的值，只有在依赖项变化时才会重新计算。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b), [a, b]);<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>用于性能优化，避免每次渲染时都进行高开销计算。传入的函数会在渲染期间执行，不要在里面执行副作用操作</p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputEl = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onButtonClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span><br>    inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputEl&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>返回的 ref 对象在组件的整个生命周期内保持不变，可以保存任何可变值，类似于类组件中的实例字段。变更 <code>.current</code> 属性不会引发组件重新渲染</p>
<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p><code>useImperativeHandle</code> 可以自定义暴露给父组件的实例值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyInput</span>(<span class="hljs-params">props, ref</span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();<br>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;</span> <span class="hljs-attr">...</span> /&gt;</span></span>;<br>&#125;<br><span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">FancyInput</span>);<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>应当与 <code>forwardRef</code> 一起使用，用于限制子组件暴露给父组件的内容</p>
<h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p><code>useLayoutEffect</code> 与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 effect。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在浏览器绘制前执行测量等操作</span><br>  <span class="hljs-keyword">const</span> rect = ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">getBoundingClientRect</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>使用场景：需要读取 DOM 布局并同步触发重渲染时，会阻塞浏览器绘制，尽可能使用 <code>useEffect</code> 以避免阻塞视觉更新</p>
<h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFriendStatus</span>(<span class="hljs-params">friendID</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">// 在开发者工具中的这个 Hook 旁边显示标签</span><br>  <span class="hljs-title function_">useDebugValue</span>(isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>);<br>  <span class="hljs-keyword">return</span> isOnline;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>主要用于自定义 Hook 的调试。可以接受格式化函数作为第二个参数，用于延迟格式化</p>
<h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>自定义 Hook 是一个 JavaScript 函数，其名称以 “use” 开头，可以调用其他 Hook。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFriendStatus</span>(<span class="hljs-params">friendID</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>      <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>    &#125;<br><br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(friendID, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(friendID, handleStatusChange);<br>    &#125;;<br>  &#125;, [friendID]);<br><br>  <span class="hljs-keyword">return</span> isOnline;<br>&#125;<br><br><span class="hljs-comment">// 使用自定义 Hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> isOnline = <span class="hljs-title function_">useFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>);<br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点：</strong>可以在多个组件之间重用状态逻辑。每次调用 Hook 都会获得完全独立的 state。命名必须以 “use” 开头</p>
<h2 id="Hook-使用规则"><a href="#Hook-使用规则" class="headerlink" title="Hook 使用规则"></a>Hook 使用规则</h2><ul>
<li><strong>只在最顶层使用 Hook</strong>：不要在循环、条件或嵌套函数中调用 Hook。确保 Hook 在每次渲染时都按照同样的顺序被调用</li>
<li><strong>只在 React 函数中调用 Hook</strong>：在 React 的函数组件中调用 Hook。在自定义 Hook 中调用其他 Hook</li>
</ul>
<hr>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://zh-hans.react.dev/versions">React 版本 – React 中文文档</a></p>
<p><a target="_blank" rel="noopener" href="https://tailwindcss.com/plus">Official Tailwind UI Components &amp; Templates - Tailwind Plus</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/react/react-hooks.html">React Hooks | 菜鸟教程</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/" class="category-chain-item">全栈(数据采集处理)</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>React基础</div>
      <div>http://example.com/2025/05/18/全栈(数据采集处理)/前端/React基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/18/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E5%89%8D%E7%AB%AF/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80/" title="HTML和CSS基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTML和CSS基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/18/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Window%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/COM%E5%85%A8%E8%A7%A3/" title="COM编写">
                        <span class="hidden-mobile">COM编写</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
