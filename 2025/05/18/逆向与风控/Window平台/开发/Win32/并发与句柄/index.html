

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="推荐阅读：并发与线程 - The Peak Tower  进程什么是进程进程（Process） 是操作系统进行资源分配和调度的基本单位，它是程序在计算机中的一次动态执行过程，包含程序代码、数据、内存空间、系统资源（如文件句柄、网络连接）以及执行状态等完整上下文环境。  当用户启动一个应用程序时，操作系统会为其创建一个独立的进程，该进程拥有虚拟的4GB地址空间（32位系统）、独立的堆栈、寄存器集合">
<meta property="og:type" content="article">
<meta property="og:title" content="并发与句柄">
<meta property="og:url" content="http://example.com/2025/05/18/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Window%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/Win32/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%8F%A5%E6%9F%84/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="推荐阅读：并发与线程 - The Peak Tower  进程什么是进程进程（Process） 是操作系统进行资源分配和调度的基本单位，它是程序在计算机中的一次动态执行过程，包含程序代码、数据、内存空间、系统资源（如文件句柄、网络连接）以及执行状态等完整上下文环境。  当用户启动一个应用程序时，操作系统会为其创建一个独立的进程，该进程拥有虚拟的4GB地址空间（32位系统）、独立的堆栈、寄存器集合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/05/16/JYjKckEgMZO9Qw5.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/16/YCSg7JRNpodAruc.png">
<meta property="og:image" content="https://s2.loli.net/2025/04/14/3r81NpuU6v2hPVT.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/12/EM2qsxPThHGFLXi.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/12/T5uNWpCJmFKdOtX.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/12/kNvZoXgiSHYpsUd.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/PDOC1zWBcHY8JRF.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/12/ZwYp6RWCjLfKXsU.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/npfRoh6kCYv8eK9.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/16/FldZbYIUxaL8jus.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/lDSuG7gcJXyH51k.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/jcEUurR43szOiwJ.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/CdxEIaJ9twRhnTA.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/EFpik3s27SPdml4.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/3czMXapDEekCF2i.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/WwBz819pcbsLEx4.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/13/wVeKknL1YJZXWaI.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/16/8kEo3He467FMcvX.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/16/YLrdIM6e2t4pBTx.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/12/tBUZeLOwfGzi7RE.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/12/Nx3ZcmFjyDCOGkT.png">
<meta property="article:published_time" content="2025-05-18T05:54:35.859Z">
<meta property="article:modified_time" content="2025-05-25T06:34:06.907Z">
<meta property="article:author" content="Ling">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/05/16/JYjKckEgMZO9Qw5.png">
  
  
  
  <title>并发与句柄 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"ture","follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"7a4M5yfyGptX0OG18qvJppXQ-gzGzoHsz","app_key":"y6dZFtA8I8Lg1KVhHbujblfB","server_url":"https://7a4m5yfy.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="并发与句柄"></span>
          
        </div>

        
          
  <div class="mt-3">
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          44 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">并发与句柄</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://restack3.github.io/2025/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%BA%BF%E7%A8%8B/">并发与线程 - The Peak Tower</a></p>
</blockquote>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p><strong>进程（Process）</strong> 是操作系统进行资源分配和调度的基本单位，它是程序在计算机中的一次动态执行过程，包含程序代码、数据、内存空间、系统资源（如文件句柄、网络连接）以及执行状态等完整上下文环境。</p>
<p><img src="https://s2.loli.net/2025/05/16/JYjKckEgMZO9Qw5.png" srcset="/img/loading.gif" lazyload></p>
<p>当用户启动一个应用程序时，操作系统会为其创建一个独立的进程，该进程拥有虚拟的4GB地址空间（32位系统）、独立的堆栈、寄存器集合以及安全上下文，并与其他进程严格隔离——这意味着一个进程崩溃通常不会直接影响其他进程，这种隔离性通过内存管理单元（MMU）和操作系统的进程管理机制实现。</p>
<p><img src="https://s2.loli.net/2025/05/16/YCSg7JRNpodAruc.png" srcset="/img/loading.gif" lazyload></p>
<p>进程在执行过程中会经历创建（如Windows通过<code>CreateProcess</code>）、就绪、运行、阻塞和终止等多种状态变化，操作系统通过进程控制块（PCB）来记录每个进程的状态信息（如进程ID、优先级、资源占用等），并基于调度算法在多个进程间快速切换CPU时间片，从而形成多任务并发的效果。</p>
<blockquote>
<p>现代操作系统还支持进程间通信（IPC）机制（如管道、共享内存、消息队列等）和子进程创建（如<code>fork()</code>），使得进程能够协作完成复杂任务，同时进程作为资源容器，其内部可以包含多个执行线程，这些线程共享进程的资源但能并行执行不同代码路径，从而进一步提高程序执行效率。</p>
</blockquote>
<p><strong>程序所需要的资源（数据、代码…）是由进程提供的；进程是一种空间上的概念，它的责任就是提供资源，至于资源如何使用，与它无关。</strong></p>
<p><img src="https://s2.loli.net/2025/04/14/3r81NpuU6v2hPVT.png" srcset="/img/loading.gif" lazyload></p>
<p>进程也可以理解为是一堆模块组成的，可以使用OD打开一个进程看一下：</p>
<p><img src="https://s2.loli.net/2025/05/12/EM2qsxPThHGFLXi.png" srcset="/img/loading.gif" lazyload></p>
<p>这里面有很多的模块，每个模块都是一个可执行文件，它们遵守相同的格式，即PE结构，所以我们也可以理解进程就是一堆PE组合。</p>
<blockquote>
<p>进程—空间提供资源(代码+数据)的,由多个模块(一个exe和多个dll—PE表)组成，提供代码和数据—遵循PE结构。</p>
</blockquote>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>需要知道任何进程都是别的进程创建的，当我们在Windows下双击打开一个文件，实际上就是explore.exe这个进程创建的，类比在linux下所有进程都是由PID&#x3D;0的进程fork()出来的。在window平台下使用的方法是：CreateProcess()，简单看看整体流程：</p>
<p><img src="https://s2.loli.net/2025/05/12/T5uNWpCJmFKdOtX.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>映射EXE文件（低2G）</li>
<li>创建内核对象EPROCESS（高2G）</li>
<li>映射系统DLL（ntdll.dll）</li>
<li>创建线程内核对象RTHREAD（高2G）</li>
<li>系统启动线程：<ol>
<li>映射DLL（ntdll.LdrInitializeThunk）</li>
<li>线程开始执行</li>
</ol>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/05/12/kNvZoXgiSHYpsUd.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h3><blockquote>
<p>This function is used to run a new program. It creates <strong>a new process</strong> and <strong>its primary thread</strong>. The new process executes the specified executable file. </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    LPCTSTR lpApplicationName,                 <span class="hljs-comment">// name of executable module 进程名（完整文件路径）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPTSTR lpCommandLine,                      <span class="hljs-comment">// command line string 命令行传参</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span></span><br><span class="hljs-params"><span class="hljs-function">    LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="hljs-comment">// SD 进程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="hljs-comment">// SD 线程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    BOOL bInheritHandles,                      <span class="hljs-comment">// handle inheritance option 句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwCreationFlags,                     <span class="hljs-comment">// creation flags 标志</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPVOID lpEnvironment,                      <span class="hljs-comment">// new environment block 父进程环境变量</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPCTSTR lpCurrentDirectory,                <span class="hljs-comment">// current directory name 父进程目录作为当前目录，设置目录</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span></span><br><span class="hljs-params"><span class="hljs-function">    LPSTARTUPINFO lpStartupInfo,               <span class="hljs-comment">// startup information 结构体详细信息（启动进程相关信息）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPPROCESS_INFORMATION lpProcessInformation <span class="hljs-comment">// process information 结构体详细信息（进程ID、线程ID、进程句柄、线程句柄）</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>参数 <strong><code>DWORD dwCreationFlags</code></strong> 用于控制新进程的创建方式和行为标志。它是一个位掩码（bitmask）</p>
<p><img src="https://s2.loli.net/2025/05/13/PDOC1zWBcHY8JRF.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;DebugHive.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Windows.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv)</span></span><br><span class="hljs-function"></span>&#123;<br>	TCHAR ptr[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/winmine.exe&quot;</span>);<br>	STARTUPINFO sinfo;<br>	PROCESS_INFORMATION pinfo;<br><br>	<span class="hljs-built_in">ZeroMemory</span>(&amp;sinfo, <span class="hljs-built_in">sizeof</span>(sinfo));<br>	<span class="hljs-built_in">ZeroMemory</span>(&amp;pinfo, <span class="hljs-built_in">sizeof</span>(pinfo));<br>	sinfo.cb = <span class="hljs-built_in">sizeof</span>(sinfo);<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateProcess</span>(ptr, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;sinfo, &amp;pinfo)) <br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;成功&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;失败&quot;</span>);<br>	&#125;<br>	<span class="hljs-built_in">CloseHandle</span>(pinfo.hProcess);<br>	<span class="hljs-built_in">CloseHandle</span>(pinfo.hThread);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先我定义了进程路径、进程命令行参数，其次<strong>创建了sinfo、pinfo两个结构体</strong>，然后使用ZeroMemory(Fills a block of memory with zeros.To avoid any undesired effects of optimizing compilers, use the SecureZeroMemory function)函数用0填充结构体数据，再给<strong>si.cb成员赋值</strong>当前结构体大小。</p>
<blockquote>
<p>注意这里的<code>si.cb = sizeof(si);</code> 是 <strong>必要的</strong>，不能省略。它的作用是为 <code>STARTUPINFO</code> 结构体明确指定大小。<code>cb</code>（即 “count of bytes”）字段用于告诉 Windows API 当前使用的 <code>STARTUPINFO</code> 结构体的大小。不同版本的 Windows SDK 可能会扩展 <code>STARTUPINFO</code>（例如 <code>STARTUPINFOEX</code>），通过 <code>cb</code> 可以确保向后兼容。</p>
</blockquote>
<p>结果：</p>
<p><img src="https://s2.loli.net/2025/05/12/ZwYp6RWCjLfKXsU.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到成功打开了扫雷程序即创建了一个进程，再次体现了进程仅仅是一种空间上的概念，只需指定该空间上的代码，创建一个线程才能运行。It creates <strong>a new process</strong> and <strong>its primary thread</strong>.</p>
<h1 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h1><p>在 Windows 操作系统中，<strong>句柄（Handle）</strong> 是系统内核对象的核心引用机制，它本质上是一个不透明的数值标识符（通常为 32 位或 64 位无符号整数），由 Windows 内核动态生成并管理，用于唯一标识和访问系统资源（如文件、窗口、进程、线程、内存块、注册表键等）。</p>
<h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><p>当我们使用如下图所示的函数创建时，会在内核层创建一个结构体，比如当调用如<code>CreateFile</code>、<code>CreateThread</code>等函数时，内核会在<strong>内核空间</strong>创建一个数据结构（如<code>_FILE_OBJECT</code>）</p>
<p><img src="https://s2.loli.net/2025/05/13/npfRoh6kCYv8eK9.png" srcset="/img/loading.gif" lazyload></p>
<p>而我们该如何管理这些结构体呢？或者说如何使用这些结构体呢？</p>
<p>其实很好解决，我们可以通过内核结构体地址来管理，但是这样做存在问题：<strong>应用层很有可能操作不当导致修改啦内核结构体的地址</strong>，我们写应用层代码都知道访问到一个不存在的内存地址就会报错，而如果访问到一个内核地址是错误的，微软系统下则直接会蓝屏。或者更极端一点，知道内核相应结构体地址，就可以在内核干坏事，或者知晓相应结构体的组成</p>
<blockquote>
<p>注意：此时向用户暴露的是一个内核地址</p>
</blockquote>
<p>微软为了避免这种情况的发生，所以其不会讲内核结构体的地址暴露给应用层，也就是说没法通过这种方式来直接管理。</p>
<h2 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为了解决上述问题，在 Windows 操作系统中提供了<strong>句柄表</strong>。</p>
<p>句柄表是内核为每个进程维护的一个关键数据结构，它<strong>本质上是一个映射表</strong>，负责将用户态程序使用的句柄值（如 0x48、0x64 这类看似随机的数字）与内核态的实际对象（如文件、线程、窗口等内核结构体）建立安全关联。</p>
<p>微软设计句柄表的核心目的是实现用户态与内核态的严格隔离——当应用程序调用诸如 CreateFile 或 CreateThread 等 API 时，内核会在当前进程的句柄表中新增一条记录，分配一个唯一的句柄值并关联到新创建的内核对象（如 FILE_OBJECT 或 ETHREAD 结构体），但绝不会将内核对象的真实内存地址（如 0xFFFFF780A3B8C010）暴露给应用层。</p>
<p><img src="https://s2.loli.net/2025/05/16/FldZbYIUxaL8jus.png" srcset="/img/loading.gif" lazyload></p>
<p>这种设计从根本上杜绝了用户态程序直接操作内核内存的可能性：即使恶意程序获取了句柄值，也无法通过该值逆向推导出内核对象的内存布局或篡改其内部数据，因为所有通过句柄的操作都必须经过内核的合法性校验（例如检查进程是否具有对该句柄的读写权限）。</p>
<p>当应用程序调用 ReadFile 或 SetWindowText 等函数时，系统会通过当前进程的句柄表将用户传递的句柄值转换为实际的内核对象指针，并在执行操作前验证权限和有效性，若检测到非法访问（如尝试用文件句柄操作线程），则会立即返回 ERROR_INVALID_HANDLE 错误。</p>
<p>这种间接访问机制如同给内核对象加了一层保险箱，应用程序只能通过系统预定义的“钥匙”（句柄）按规则使用功能，而无法直接触碰保险箱内的物品（内核数据结构），从而确保了系统的稳定性和安全性。</p>
<blockquote>
<p>想象你去游乐园，把背包存进储物柜：</p>
<ol>
<li><strong>储物柜（资源）</strong>：比如3号柜子，它实际存放你的背包（相当于系统资源，如窗口、文件）。</li>
<li><strong>小票（句柄）</strong>：管理员给你一张小票，上面写“A12”（不是柜子本身，而是一个编号）–这个编号每次去都是随机的。你凭这个小票才能开柜取包。<ul>
<li><strong>句柄就像小票</strong>：它本身不是储物柜（资源），但通过它你能操作储物柜。</li>
<li><strong>系统保护</strong>：没有小票的人无法乱开柜子（防止程序随意访问其他资源）。</li>
</ul>
</li>
</ol>
<p>句柄本质上就一个防火墙，将应用层、内核层隔离开来，通过句柄就可以控制进程内核结构体，我们得到所谓句柄的值实际上就是句柄表里的一个索引。</p>
</blockquote>
<p><img src="https://s2.loli.net/2025/05/13/lDSuG7gcJXyH51k.png" srcset="/img/loading.gif" lazyload></p>
<p>OpenProcess</p>
<blockquote>
<p>This function returns a handle to an existing process object.</p>
<p><strong>Return Values</strong>:An open handle to the specified process indicates success. NULL indicates failure. </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HANDLE <span class="hljs-title">OpenProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">DWORD fdwAccess,<span class="hljs-comment">// 访问权限标志位</span></span></span><br><span class="hljs-params"><span class="hljs-function">BOOL fInherit, <span class="hljs-comment">// 句柄继承标志</span></span></span><br><span class="hljs-params"><span class="hljs-function">DWORD IDProcess<span class="hljs-comment">// 目标进程ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>此时向用户返回的句柄值只是当前进程下的句柄，放在其他进程下就无效了，句柄本质是<strong>进程句柄表中的一个受控入口</strong>，背后由内核全权管理。用户无法窥见整个句柄表。</p>
<blockquote>
<p>只有进程才会有句柄表，并且每一个进程都会有一个句柄表。</p>
</blockquote>
<h3 id="句柄类型"><a href="#句柄类型" class="headerlink" title="句柄类型"></a><strong>句柄类型</strong></h3><p><img src="https://s2.loli.net/2025/05/13/jcEUurR43szOiwJ.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>典型的如:</strong></p>
<table>
<thead>
<tr>
<th align="left">句柄类型</th>
<th align="left">对应资源</th>
<th align="left">创建API示例</th>
<th align="left">关闭API</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>HANDLE</code></td>
<td align="left">文件、进程、线程</td>
<td align="left"><code>CreateFile</code></td>
<td align="left"><code>CloseHandle</code></td>
</tr>
<tr>
<td align="left"><code>HWND</code></td>
<td align="left">窗口对象</td>
<td align="left"><code>CreateWindow</code></td>
<td align="left"><code>DestroyWindow</code></td>
</tr>
<tr>
<td align="left"><code>HKEY</code></td>
<td align="left">注册表键</td>
<td align="left"><code>RegOpenKey</code></td>
<td align="left"><code>RegCloseKey</code></td>
</tr>
<tr>
<td align="left"><code>HDC</code></td>
<td align="left">设备上下文（绘图）</td>
<td align="left"><code>GetDC</code></td>
<td align="left"><code>ReleaseDC</code></td>
</tr>
<tr>
<td align="left"><code>HMODULE</code></td>
<td align="left">加载的DLL模块</td>
<td align="left"><code>LoadLibrary</code></td>
<td align="left"><code>FreeLibrary</code></td>
</tr>
</tbody></table>
<h3 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h3><p>每个进程都有一份私有的句柄表，而操作系统也有一份句柄表，我们称之为全局句柄表，这张表里包含了所有正在运行的进程、线程：</p>
<p><img src="https://s2.loli.net/2025/05/13/CdxEIaJ9twRhnTA.png" srcset="/img/loading.gif" lazyload></p>
<p>PID我们就可以理解为是全局句柄表中的一个索引，那么PID和句柄的区别就很容易看出来来了:</p>
<p><strong>PID是全局的，在任何进程中都有意义，都可以使用，而句柄则是局部的、私有的</strong>；PID是<strong>唯一的，绝对不可能出现重复的存在</strong>，但是当进程消失，那么这个PID就有可能会分给另外一个进程。（<strong>PID不是句柄，但是可以通过PID获得到全局句柄表中其对应的句柄</strong>）</p>
<h2 id="共享内核对象"><a href="#共享内核对象" class="headerlink" title="共享内核对象"></a>共享内核对象</h2><p>如下图所示，A进程通过<strong>CreateProcess函数</strong>创建了一个内核对象；B进程通过<strong>OpenProcess函数</strong>可以打开别人创建好的一个进程，也就是可以操作其的内核对象。</p>
<p>A进程想要操作内核对象就通过<strong>其对应</strong>的句柄表的句柄（索引）来操作；B进程操作这个内核对象也是通过它自己的句柄表的句柄（索引）来操作内核对象。</p>
<blockquote>
<p>（<strong>需要注意的是：句柄表是一个私有的，句柄值就是进程自己句柄表的索引</strong>）</p>
</blockquote>
<p><img src="https://s2.loli.net/2025/05/13/EFpik3s27SPdml4.png" srcset="/img/loading.gif" lazyload></p>
<p>在之前的例子中我们提到了CloseHandle这个函数是用来关闭进程、线程的，其实它的本质就是释放句柄，但是并不代表执行了这个函数，创建的内核对象就会<strong>彻底消失</strong>。</p>
<p>如上图中所示内核对象存在一个计数器，目前是2，它的值是根据调用A的次数来决定的，如果我们只是在A进程中执行了<strong>CloseHandle函数</strong>，内核对象并不会消失，因为进程B还在使用，而只有进程B也执行了<strong>CloseHandle函数</strong>，这个内核对象的计数器为0，就会关闭消失了。</p>
<blockquote>
<p><strong>最后</strong>：注意，以上所述特性适合于除了线程以外的所有内核对象，创建进程，同时也会创建线程，如果你想把线程关闭，首先需要<strong>CloseHandle函数</strong>要让其计数器为0，其次需要有人将其关闭，所以假设我们创建了一个IE进程打开了一个网站，如果我们只是在代码中使用了<strong>CloseHandle函数</strong>，这样IE浏览器并不会关闭，需要我们手动点击窗口的关闭按钮才行（<strong>只有线程关闭了，进程才会关闭</strong>）。</p>
</blockquote>
<h3 id="句柄继承"><a href="#句柄继承" class="headerlink" title="句柄继承"></a>句柄继承</h3><p>除了我们上述的方式可以进行共享内核对象以外，Windows还设计了一种方式来提供我们共享内核对象，我们先来了解一下句柄是否”可以”被继承。</p>
<p>如下图所示（<strong>句柄表是有三列的，句柄是否可以被继承、分别是句柄值、内核结构体地址</strong>），比如说我们在A进程（父进程）创建了4个内核对象：</p>
<p><img src="https://s2.loli.net/2025/05/13/3czMXapDEekCF2i.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="句柄继承方式"><a href="#句柄继承方式" class="headerlink" title="句柄继承方式"></a>句柄继承方式</h4><p>我们可以让句柄被继承，但也仅仅是可以，要真正完成继承，或者说我们允许子进程继承父进程的句柄，这时候就需要另外一个参数了。</p>
<p><img src="https://s2.loli.net/2025/05/13/WwBz819pcbsLEx4.png" srcset="/img/loading.gif" lazyload></p>
<p>以CreateProcess函数举例，其有一个参数<strong>BOOL bInheritHandles</strong>，这个参数决定了是否允许创建的子进程继承句柄：</p>
<p><img src="https://s2.loli.net/2025/05/13/wVeKknL1YJZXWaI.png" srcset="/img/loading.gif" lazyload></p>
<p>只有这个参数设置为TRUE时，我们创建的子进程才允许继承父进程的句柄。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程（Thread）是操作系统能够进行运算调度的最小执行单元，它被包含在进程之中，是进程中的实际运作单位。</p>
<p>一个进程可以包含多个线程，所有线程共享进程的资源（如内存空间、文件句柄等），但每个线程拥有独立的程序计数器、寄存器集合和栈空间，使得它们能够并发执行不同的代码路径。</p>
<p><img src="https://s2.loli.net/2025/05/16/8kEo3He467FMcvX.png" srcset="/img/loading.gif" lazyload alt="image-20250516213141548"></p>
<p>当操作系统调度程序分配CPU时间片时，是以线程为单位进行调度的，而非进程——即使属于同一个进程的多个线程也可能被分配到不同的CPU核心上并行运行（在多核系统中），这种特性使得线程成为实现并发编程的高效手段。</p>
<p><img src="https://s2.loli.net/2025/05/16/YLrdIM6e2t4pBTx.png" srcset="/img/loading.gif" lazyload></p>
<p>线程的创建、切换和销毁比进程更轻量级，因为不需要像进程那样涉及内存空间、文件描述符表等资源的重新分配，只需维护线程私有的执行上下文即可，但这也带来了线程同步的挑战（如竞态条件、死锁等问题），需要通过互斥锁、信号量等机制来协调对共享资源的访问。</p>
<blockquote>
<p>现代操作系统通常提供用户态线程（由运行时库管理）和内核态线程（由操作系统直接管理）两种实现方式，前者切换开销小但无法利用多核，后者能真正并行但切换成本较高，某些系统（如Windows）采用一对一模型（每个用户线程对应一个内核线程），而Linux则通过更灵活的线程组（Thread Group）机制来平衡效率与功能。<strong>无论是哪种实现，线程的核心价值都在于通过共享地址空间内的多任务执行来提高程序的响应性和资源利用率。</strong></p>
</blockquote>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>CreateThread</p>
<blockquote>
<p>This function creates a thread to execute within the address space of the calling process. </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HANDLE <span class="hljs-title">CreateThread</span><span class="hljs-params">( <span class="hljs-comment">// 返回值是线程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="hljs-comment">// SD 安全属性，包含安全描述符</span></span></span><br><span class="hljs-params"><span class="hljs-function">  SIZE_T dwStackSize,                       <span class="hljs-comment">// initial stack size 初始堆栈</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPTHREAD_START_ROUTINE lpStartAddress,    <span class="hljs-comment">// thread function 线程执行的函数代码</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID lpParameter,                       <span class="hljs-comment">// thread argument 线程需要的参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD dwCreationFlags,                    <span class="hljs-comment">// creation option 标识，也可以以挂起形式创建线程</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpThreadId                        <span class="hljs-comment">// thread identifier 返回当前线程ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>注意这里的:<code>lpStartAddress</code>【Long pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread; represents the starting address of the thread. <em>For more information on the thread function, see <strong>ThreadProc</strong></em>】</p>
<blockquote>
<p>Note:It is invalid to set lpStartAddr to NULL. If this value is passed in the parameter, the function will return ERROR_INVALID_PARAMETER.</p>
</blockquote>
<p><img src="https://s2.loli.net/2025/05/12/tBUZeLOwfGzi7RE.png" srcset="/img/loading.gif" lazyload></p>
<p>这里简单的总结一下：</p>
<p><strong>1.函数签名必须匹配</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">DWORD WINAPI <span class="hljs-built_in">ThreadProc</span>(LPVOID lpParameter);  <span class="hljs-comment">// WINAPI 表示__stdcall调用约定</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>返回类型</strong>：<code>DWORD</code>（线程退出码，通常返回 0 表示成功）。</li>
<li><strong>调用约定</strong>：<code>WINAPI</code>（即 <code>__stdcall</code>），确保栈平衡。</li>
<li><strong>参数</strong>：<code>LPVOID</code>（通用指针，用于传递数据）。</li>
</ul>
<p><strong>2.禁止在内部直接使用某些C运行时函数</strong></p>
<p>若线程中调用了 <code>malloc</code>、<code>printf</code> 等C运行时函数，**必须改用 <code>_beginthreadex</code>**（而非 <code>CreateThread</code>），否则可能导致内存泄漏。原因：C运行时库（如MSVCRT）需要为每个线程初始化内部状态，<code>CreateThread</code> 不会自动处理。</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2025/05/12/Nx3ZcmFjyDCOGkT.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="线程挂起与恢复"><a href="#线程挂起与恢复" class="headerlink" title="线程挂起与恢复"></a><strong>线程挂起与恢复</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD <span class="hljs-title function_">SuspendThread</span><span class="hljs-params">(HANDLE hThread)</span>;  <span class="hljs-comment">// 挂起次数+1</span><br>DWORD <span class="hljs-title function_">ResumeThread</span><span class="hljs-params">(HANDLE hThread)</span>;   <span class="hljs-comment">// 挂起次数-1，当=0时恢复执行</span><br></code></pre></td></tr></table></figure>

<h3 id="线程优先级控制"><a href="#线程优先级控制" class="headerlink" title="线程优先级控制"></a><strong>线程优先级控制</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">SetThreadPriority</span><span class="hljs-params">(</span><br><span class="hljs-params">  HANDLE hThread,     </span><br><span class="hljs-params">  <span class="hljs-type">int</span>    nPriority   <span class="hljs-comment">// THREAD_PRIORITY_* 常量</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">// 获取当前优先级</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetThreadPriority</span><span class="hljs-params">(HANDLE hThread)</span>;<br></code></pre></td></tr></table></figure>

<h3 id="设置、获取线程上下文"><a href="#设置、获取线程上下文" class="headerlink" title="设置、获取线程上下文"></a>设置、获取线程上下文</h3><p>SuspendThread函数</p>
<blockquote>
<p>This function suspends the specified thread. </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">SuspendThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread   <span class="hljs-comment">// handle to thread</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>GetThreadContext函数</p>
<blockquote>
<p>This function retrieves the context of the specified thread.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">GetThreadContext</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread,       <span class="hljs-comment">// handle to thread with context 句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPCONTEXT lpContext   <span class="hljs-comment">// context structure</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="线程终止方式"><a href="#线程终止方式" class="headerlink" title="线程终止方式"></a>线程终止方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">TerminateThread</span><span class="hljs-params">(</span><br><span class="hljs-params">  HANDLE hThread,    <span class="hljs-comment">// 线程句柄</span></span><br><span class="hljs-params">  DWORD dwExitCode   <span class="hljs-comment">// 退出代码</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p><strong>线程安全问题</strong>是指在多线程并发执行的环境下，当多个线程同时访问共享资源（如全局变量、内存数据、文件或硬件设备等）时，由于线程执行的随机性和不确定性，可能导致程序出现不可预期的错误行为，例如数据竞争（Data Race）、脏读（Dirty Read）、死锁（Deadlock）或计算结果不一致等问题。</p>
<p>这种问题的本质在于<strong>线程执行的交错性</strong>——由于操作系统对线程的调度是抢占式的，线程在执行过程中可能随时被中断，而其他线程对共享资源的修改可能破坏当前线程的执行逻辑。例如，若两个线程同时对一个全局计数器进行自增操作，由于“读取-修改-写入”这一系列操作并非原子性（Atomic）的，最终可能导致计数结果错误。类似地，当一个线程正在修改某个数据结构（如链表）时，若另一线程尝试读取或修改该结构，可能引发内存访问异常或逻辑错误。</p>
<p>为了解决这些问题，必须引入<strong>线程同步机制</strong>，通过对共享资源的访问施加约束，确保任一时刻只有一个线程能执行临界区（Critical Section）代码，或者通过协调线程间的执行顺序，实现数据的安全访问和操作的原子性。</p>
<blockquote>
<p>常见的同步机制包括互斥锁（Mutex）、信号量（Semaphore）、条件变量（Condition Variable）、读写锁（Read-Write Lock）以及原子操作（Atomic Operations）等，它们从不同维度提供了线程间协同工作的基础能力，从而保障多线程程序的正确性和可靠性。</p>
</blockquote>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><h4 id="线程锁【单进程内】"><a href="#线程锁【单进程内】" class="headerlink" title="线程锁【单进程内】"></a>线程锁【单进程内】</h4><p>CRITICAL_SECTION</p>
<blockquote>
<p>Retrieves a CRITICAL_SECTION object</p>
</blockquote>
<p>InitializeCriticalSection</p>
<blockquote>
<p>This function initializes a critical section object. </p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitializeCriticalSection</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">LPCRITICAL_SECTION lpCriticalSection</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>; <br></code></pre></td></tr></table></figure>

<p>EnterCriticalSection</p>
<p>This function waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EnterCriticalSection</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">  LPCRITICAL_SECTION lpCriticalSection </span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>; <br></code></pre></td></tr></table></figure>

<p>LeaveCriticalSection</p>
<p>This function releases ownership of the specified critical section object. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LeaveCriticalSection</span><span class="hljs-params">( </span><br><span class="hljs-params">  LPCRITICAL_SECTION lpCriticalSection </span><br><span class="hljs-params">)</span>; <br></code></pre></td></tr></table></figure>

<h4 id="互斥体【内核级】"><a href="#互斥体【内核级】" class="headerlink" title="互斥体【内核级】"></a>互斥体【内核级】</h4><p><strong>CreateMutex</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateMutex</span><span class="hljs-params">(</span><br><span class="hljs-params">  LPSECURITY_ATTRIBUTES lpMutexAttributes,  <span class="hljs-comment">// SD 安全属性，包含安全描述符</span></span><br><span class="hljs-params">  BOOL bInitialOwner,                       <span class="hljs-comment">// initial owner 是否希望互斥体创建出来就有信号，或者说就可以使用，如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权</span></span><br><span class="hljs-params">  LPCTSTR lpName                            <span class="hljs-comment">// object name 互斥体的名字</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p>WaitForSingleObject</p>
<blockquote>
<p>This function returns when the specified object is in the signaled state or when the time-out interval elapses.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD <span class="hljs-title function_">WaitForSingleObject</span><span class="hljs-params">( </span><br><span class="hljs-params">  HANDLE hHandle, </span><br><span class="hljs-params">  DWORD dwMilliseconds </span><br><span class="hljs-params">)</span>; <br></code></pre></td></tr></table></figure>

<p>ReleaseMutex</p>
<blockquote>
<p>This function releases ownership of the specified mutex object. </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">ReleaseMutex</span><span class="hljs-params">( </span><br><span class="hljs-params">  HANDLE hMutex </span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Win32事件是Windows操作系统提供的一种同步对象，用于线程间通信和同步。它本质上是一个内核对象，可以处于”已通知”（signaled）或”未通知”（non-signaled）两种状态。</p>
<p>CreateEvent</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateEvent</span><span class="hljs-params">(</span><br><span class="hljs-params">  LPSECURITY_ATTRIBUTES lpEventAttributes, ``<span class="hljs-comment">// SD 安全属性，包含安全描述符</span></span><br><span class="hljs-params">  BOOL bManualReset,                       ``<span class="hljs-comment">// reset type 如果你希望当前事件类型是通知类型则写TRUE，反之FALSE</span></span><br><span class="hljs-params">  BOOL bInitialState,                      ``<span class="hljs-comment">// initial state 初始状态，决定创建出来时候是否有信号，有为TRUE，没有为FALSE</span></span><br><span class="hljs-params">  LPCTSTR lpName                           ``<span class="hljs-comment">// object name 事件名字</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p>SetEvent</p>
<blockquote>
<p>This function sets the state of the specified event object to signaled.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">SetEvent</span><span class="hljs-params">(</span><br><span class="hljs-params">  HANDLE hEvent </span><br><span class="hljs-params">)</span>; <br></code></pre></td></tr></table></figure>

<p>WaitForMultipleObjects</p>
<blockquote>
<p>This function returns a value when either any one of the specified objects is in the signaled state, or the time-out interval elapses.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD <span class="hljs-title function_">WaitForMultipleObjects</span><span class="hljs-params">(</span><br><span class="hljs-params">  DWORD nCount, </span><br><span class="hljs-params">  CONST HANDLE* lpHandles, </span><br><span class="hljs-params">  BOOL fWaitAll, </span><br><span class="hljs-params">  DWORD dwMilliseconds </span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p>事件相关API函数:</p>
<table>
<thead>
<tr>
<th align="center">API函数</th>
<th align="center">功能描述</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>CreateEvent</code></td>
<td align="center">创建事件对象</td>
<td align="center">参数控制手动&#x2F;自动重置、初始状态和名称</td>
</tr>
<tr>
<td align="center"><code>OpenEvent</code></td>
<td align="center">打开已存在的事件对象</td>
<td align="center">需要事件名称和访问权限</td>
</tr>
<tr>
<td align="center"><code>SetEvent</code></td>
<td align="center">将事件设为已通知状态</td>
<td align="center">唤醒等待线程</td>
</tr>
<tr>
<td align="center"><code>ResetEvent</code></td>
<td align="center">将事件设为未通知状态</td>
<td align="center">仅对手动重置事件有效</td>
</tr>
<tr>
<td align="center"><code>PulseEvent</code></td>
<td align="center">短暂触发事件后立即重置</td>
<td align="center">不推荐使用（可靠性问题）</td>
</tr>
<tr>
<td align="center"><code>CloseHandle</code></td>
<td align="center">关闭事件句柄</td>
<td align="center">释放系统资源</td>
</tr>
</tbody></table>
<h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><p>以下是Win32事件的主要消息通知类型：</p>
<table>
<thead>
<tr>
<th align="center">事件类型</th>
<th align="center">API创建函数</th>
<th align="center">通知行为</th>
<th align="center">典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>手动重置事件</strong></td>
<td align="center"><code>CreateEvent(NULL, TRUE, bInitialState, lpName)</code></td>
<td align="center">需要手动调用<code>ResetEvent</code>重置状态</td>
<td align="center">多线程同时唤醒</td>
</tr>
<tr>
<td align="center"><strong>自动重置事件</strong></td>
<td align="center"><code>CreateEvent(NULL, FALSE, bInitialState, lpName)</code></td>
<td align="center">当单个等待线程被释放后自动重置</td>
<td align="center">单线程唤醒</td>
</tr>
<tr>
<td align="center"><strong>命名事件</strong></td>
<td align="center"><code>CreateEvent(..., lpName)</code></td>
<td align="center">可通过名称跨进程共享</td>
<td align="center">进程间通信</td>
</tr>
<tr>
<td align="center"><strong>匿名事件</strong></td>
<td align="center"><code>CreateEvent(..., NULL)</code></td>
<td align="center">仅限进程内使用</td>
<td align="center">线程同步</td>
</tr>
</tbody></table>
<hr>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wenzhou1219/article/details/17659485">深入了解Windows句柄到底是什么_windows.h句柄-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpcdbky/p/4652151.html">图解说明——究竟什么是Windows句柄 - 同勉共进 - 博客园</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/" class="category-chain-item">逆向与风控</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Windows%E5%B9%B3%E5%8F%B0/" class="category-chain-item">Windows平台</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Windows%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/" class="category-chain-item">开发</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Windows%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/Win32/" class="category-chain-item">Win32</a>
  
  

  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>并发与句柄</div>
      <div>http://example.com/2025/05/18/逆向与风控/Window平台/开发/Win32/并发与句柄/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/18/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Window%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/Win32/%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6%E6%8E%A2%E8%AE%A8/" title="窗口机制探讨">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">窗口机制探讨</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/18/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Window%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/Win32/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BC%96%E7%A8%8B/" title="注册表编程">
                        <span class="hidden-mobile">注册表编程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
