

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="MFC概述Microsoft Foundation Classes（MFC）是微软公司为简化Windows应用程序开发而提供的一个C++类库框架，最早随Microsoft C&#x2F;C++ 7.0编译器于1992年发布，后成为Visual Studio的核心组件之一。 MFC封装了大部分Windows API（如窗口管理、消息处理、图形设备接口GDI等），通过面向对象的方式（如文档-视图架构、">
<meta property="og:type" content="article">
<meta property="og:title" content="MFC开发">
<meta property="og:url" content="http://example.com/2025/05/18/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Window%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/MFC%E5%85%A8%E8%A7%A3/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="MFC概述Microsoft Foundation Classes（MFC）是微软公司为简化Windows应用程序开发而提供的一个C++类库框架，最早随Microsoft C&#x2F;C++ 7.0编译器于1992年发布，后成为Visual Studio的核心组件之一。 MFC封装了大部分Windows API（如窗口管理、消息处理、图形设备接口GDI等），通过面向对象的方式（如文档-视图架构、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/05/17/l1DzbX6NfqesxVM.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/17/ycN2FLg4t1GWsXA.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/17/x1awAZI8YCkNJgE.png">
<meta property="og:image" content="https://gh0st.cn/Binary-Learning/images/download/attachments/1015822/image2021-6-24_10-32-2.png">
<meta property="og:image" content="https://gh0st.cn/Binary-Learning/images/download/attachments/1015822/image2021-6-24_10-57-1.png">
<meta property="og:image" content="https://gh0st.cn/Binary-Learning/images/download/attachments/1015822/image2021-6-24_11-23-38.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/17/pTfH2FlBLYXk5KZ.png">
<meta property="og:image" content="https://s2.loli.net/2025/05/17/vOyCQ7z6hcg5aFx.png">
<meta property="article:published_time" content="2025-05-18T05:54:35.869Z">
<meta property="article:modified_time" content="2025-05-25T11:32:03.034Z">
<meta property="article:author" content="Ling">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/05/17/l1DzbX6NfqesxVM.png">
  
  
  
  <title>MFC开发 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"ture","follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"7a4M5yfyGptX0OG18qvJppXQ-gzGzoHsz","app_key":"y6dZFtA8I8Lg1KVhHbujblfB","server_url":"https://7a4m5yfy.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MFC开发"></span>
          
        </div>

        
          
  <div class="mt-3">
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          50 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MFC开发</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="MFC概述"><a href="#MFC概述" class="headerlink" title="MFC概述"></a>MFC概述</h1><p>Microsoft Foundation Classes（MFC）是微软公司为简化Windows应用程序开发而提供的一个C++类库框架，最早随Microsoft C&#x2F;C++ 7.0编译器于1992年发布，后成为Visual Studio的核心组件之一。</p>
<p>MFC封装了大部分Windows API（如窗口管理、消息处理、图形设备接口GDI等），通过面向对象的方式（如文档-视图架构、消息映射机制）显著降低了Win32平台GUI程序的开发复杂度，同时保留了原生API的灵活性和性能。</p>
<p><img src="https://s2.loli.net/2025/05/17/l1DzbX6NfqesxVM.png" srcset="/img/loading.gif" lazyload></p>
<p>它提供了一系列预构建类（如CWinApp、CFrameWnd、CDocument、CView等）来处理应用程序生命周期、用户界面元素及数据管理，并支持ActiveX、OLE、数据库访问（ODBC&#x2F;DAO）等高级功能。</p>
<blockquote>
<p>尽管现代开发中逐渐被WPF、UWP或跨平台框架取代，MFC因其稳定性、对遗留系统的兼容性以及对资源受限场景的高效支持，仍在工业控制、金融系统等传统Win32领域保持应用，其设计思想对后续框架如ATL、.NET WinForms产生了深远影响。</p>
</blockquote>
<h1 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h1><p>本文将系统剖析MFC的关键技术链：</p>
<p>从<strong>初始化阶段</strong>的<code>CWinApp</code>全局对象构建应用程序骨架，到<strong>窗口创建</strong>时<code>CFrameWnd</code>与文档视图架构的协同；进而深入<strong>消息映射</strong>机制如何将Windows消息转化为C++成员函数调用，并探讨<strong>命令传递</strong>体系实现菜单、工具栏与视图的交互逻辑。在此基础上，分析<strong>CDC类</strong>如何封装GDI绘图接口，支撑图形渲染；随后解析<strong>控件</strong>（如<code>CButton</code>、<code>CListCtrl</code>）的封装与数据绑定，并最终延伸至<strong>文件与资源操作</strong>模块，展示序列化、对话框资源加载等实战场景。</p>
<table>
<thead>
<tr>
<th><strong>模块</strong></th>
<th><strong>核心类&#x2F;机制</strong></th>
<th><strong>关键功能</strong></th>
<th><strong>关联模块</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MFC初始化</strong></td>
<td><code>CWinApp</code>, <code>InitInstance</code></td>
<td>应用程序入口、主线程初始化</td>
<td>→ 创建流程、消息循环</td>
</tr>
<tr>
<td><strong>MFC创建</strong></td>
<td><code>CFrameWnd</code>, <code>CDocTemplate</code></td>
<td>主窗口生成、文档-视图绑定</td>
<td>→ 消息映射、命令传递</td>
</tr>
<tr>
<td><strong>消息映射</strong></td>
<td><code>DECLARE_MESSAGE_MAP</code>宏</td>
<td>消息路由（如<code>WM_PAINT</code>→<code>OnPaint</code>）</td>
<td>→ CDC绘图、控件交互</td>
</tr>
<tr>
<td><strong>命令传递</strong></td>
<td><code>ON_COMMAND</code>, <code>CCmdTarget</code></td>
<td>菜单&#x2F;工具栏事件分发至视图&#x2F;文档</td>
<td>→ 文件操作、资源响应</td>
</tr>
<tr>
<td><strong>CDC类</strong></td>
<td><code>CDC</code>, <code>CPaintDC</code></td>
<td>图形绘制（文本、形状、位图）</td>
<td>→ 控件渲染、界面美化</td>
</tr>
<tr>
<td><strong>MFC控件</strong></td>
<td><code>CButton</code>, <code>CEdit</code></td>
<td>对话框控件管理、数据交换（<code>DDX_</code>）</td>
<td>→ 资源加载、消息处理</td>
</tr>
<tr>
<td><strong>文件与资源操作</strong></td>
<td><code>CFile</code>, <code>CArchive</code></td>
<td>序列化存储、资源文件（<code>.rc</code>）动态加载</td>
<td>← 命令触发、文档架构支持</td>
</tr>
</tbody></table>
<h1 id="手动创建第一个MFC程序"><a href="#手动创建第一个MFC程序" class="headerlink" title="手动创建第一个MFC程序"></a>手动创建第一个MFC程序</h1><p>从之前的介绍中可以看出：MFC本质上是<strong>对Win32 API的面向对象封装</strong>，它通过类（如<code>CWinApp</code>、<code>CFrameWnd</code>）和宏（如<code>DECLARE_MESSAGE_MAP</code>）简化了Windows GUI程序的开发。相比直接使用Win32 API，MFC提供了更高级的抽象，减少了重复代码（如窗口注册、消息循环等），使开发更高效。但同时</p>
<ul>
<li>向导生成的代码较复杂，初学者可能难以理解。</li>
<li>某些高级定制仍需直接调用Win32 API。</li>
</ul>
<p><img src="https://s2.loli.net/2025/05/17/ycN2FLg4t1GWsXA.png" srcset="/img/loading.gif" lazyload></p>
<p>下面是一个<strong>纯手写</strong>的MFC窗口程序，仅依赖必要的代码，避免冗余，有助于直观的理解：</p>
<ul>
<li>**<code>CMyApp</code>**：继承<code>CWinApp</code>，负责初始化。</li>
<li>**<code>CMainWindow</code>**：继承<code>CFrameWnd</code>，作为主窗口。</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;afxwin.h&gt;</span>  <span class="hljs-comment">// MFC核心头文件</span></span><br><br><span class="hljs-comment">// 自定义主窗口类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMainWindow</span> : <span class="hljs-keyword">public</span> CFrameWnd &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CMainWindow</span>() &#123;<br>        <span class="hljs-comment">// 创建窗口（参数：窗口类名、窗口标题、样式、初始位置和大小）</span><br>        <span class="hljs-built_in">Create</span>(<span class="hljs-literal">nullptr</span>, _T(<span class="hljs-string">&quot;手写MFC窗口&quot;</span>), WS_OVERLAPPEDWINDOW, <span class="hljs-built_in">CRect</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 消息映射声明（必须放在类内）</span><br>    <span class="hljs-built_in">DECLARE_MESSAGE_MAP</span>()<br>&#125;;<br><br><span class="hljs-comment">// 消息映射实现（放在类外）</span><br><span class="hljs-built_in">BEGIN_MESSAGE_MAP</span>(CMainWindow, CFrameWnd)<br>    <span class="hljs-comment">// 可以在此添加消息处理，例如 ON_WM_PAINT()</span><br><span class="hljs-built_in">END_MESSAGE_MAP</span>()<br><br><span class="hljs-comment">// 自定义应用程序类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyApp</span> : <span class="hljs-keyword">public</span> CWinApp &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">BOOL <span class="hljs-title">InitInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 创建主窗口</span><br>        m_pMainWnd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CMainWindow</span>();<br>        m_pMainWnd-&gt;<span class="hljs-built_in">ShowWindow</span>(SW_SHOW);  <span class="hljs-comment">// 显示窗口</span><br>        m_pMainWnd-&gt;<span class="hljs-built_in">UpdateWindow</span>();       <span class="hljs-comment">// 强制刷新窗口</span><br>        <span class="hljs-keyword">return</span> TRUE;  <span class="hljs-comment">// 返回TRUE进入消息循环</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 全局应用程序对象（MFC要求必须有一个全局实例）</span><br>CMyApp theApp;<br></code></pre></td></tr></table></figure>

<h2 id="CWinApp"><a href="#CWinApp" class="headerlink" title="CWinApp"></a>CWinApp</h2><p>CWinApp类是Windows应用程序对象基类（父类）的派生类（子类），应用程序对象提供了用于初始化应用程序和运行应用程序的成员函数；使用MFC的每个应用程序只能（也必须）包含一个CWinApp类的派生类（子类）的对象；当你CWinApp<strong>派生应用程序类时，需要覆盖</strong>InitInstance<strong>成员函数以创建应用程序的主窗口对象；它还有一个成员变量</strong>m_pMainWnd用来记录创建的主窗口的对象。</p>
<blockquote>
<p><strong><code>CWinApp</code> 必须覆盖的虚函数</strong>：<code>InitInstance()</code>其是程序入口点，负责初始化（如创建主窗口）。**必须返回<code>TRUE</code>**，否则程序会立即终止。</p>
<p><code>CWinApp</code> 的成员变量 <code>m_pMainWnd</code>，用于存储主窗口指针，MFC通过它管理应用程序生命周期。如果<code>m_pMainWnd</code>为<code>nullptr</code>，程序会自动退出。</p>
</blockquote>
<h2 id="CFrameWnd"><a href="#CFrameWnd" class="headerlink" title="CFrameWnd"></a>CFrameWnd</h2><p>CFrameWnd类提供了Windows单文档界面（SDI）重叠或弹出框架窗口的功能，<strong>以及用于管理窗口的成员</strong>；要为应用程序创建有用的框架窗口，请从CFrameWnd派生类（子类）；向派生类（子类）添加成员变量以存储特定于您的应用程序的数据；在派生类（子类）中实现消息处理程序成员函数和消息映射，以指定在将消息定向到窗口时会发生什么。</p>
<p>有三种方法来构造框架窗口：</p>
<ul>
<li>使用Create直接构造它 </li>
<li>使用LoadFrame直接构造</li>
<li>使用文档模板间接构建它</li>
</ul>
<blockquote>
<p>注：<strong>可以认为CFrameWnd类取代了窗口过程函数</strong>。</p>
</blockquote>
<h3 id="Create-成员函数"><a href="#Create-成员函数" class="headerlink" title="Create 成员函数"></a>Create 成员函数</h3><p>CFrameWnd :: Create 成员函数语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Create</span>(<br>    LPCTSTR lpszClassName,  <span class="hljs-comment">// 窗口类名（nullptr表示使用默认MFC类）</span><br>    LPCTSTR lpszWindowName, <span class="hljs-comment">// 窗口标题</span><br>    DWORD dwStyle,          <span class="hljs-comment">// 窗口样式（如WS_OVERLAPPEDWINDOW）</span><br>    <span class="hljs-type">const</span> RECT&amp; rect,       <span class="hljs-comment">// 初始位置和大小（CRect或RECT）</span><br>    CWnd* pParentWnd = <span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// 父窗口（无则为nullptr）</span><br>    LPCTSTR lpszMenuName = <span class="hljs-literal">nullptr</span> <span class="hljs-comment">// 菜单资源ID（无则为nullptr）</span><br>);<br></code></pre></td></tr></table></figure>

<p><strong>为什么代码里没有WinMain？MFC没有WinMain函数吗？</strong>其实MFC是在内部接管了WinMain，我们可以认为CWinApp就是WinMain，只不过我们没法很直观的看见WinMain函数。</p>
<p><img src="https://s2.loli.net/2025/05/17/x1awAZI8YCkNJgE.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="MFC初始化"><a href="#MFC初始化" class="headerlink" title="MFC初始化"></a>MFC初始化</h1><p>前节回顾:</p>
<p><strong>MFC初始化</strong>是构建MFC应用程序的基础阶段，主要由<code>CWinApp</code>派生类及其<code>InitInstance()</code>函数实现，负责为整个应用程序搭建运行环境并完成关键配置。当程序启动时，MFC框架会隐式创建全局唯一的应用程序对象（如<code>CMyApp theApp</code>）。本节将接着上一节继续探讨MFC的初始化过程：</p>
<p>MFC框架在创建应用程序对象随后自动调用其构造函数初始化静态数据，并进入MFC提供的<code>WinMain()</code>入口函数。</p>
<p>在<code>WinMain()</code>内部，框架会进一步调用<code>InitInstance()</code>方法执行动态初始化流程，包括注册窗口类、初始化COM&#x2F;OLE支持（如调用<code>AfxOleInit()</code>）、设置应用程序的文档模板（通过<code>CDocTemplate</code>绑定文档、视图和框架窗口类），以及创建并显示主窗口（通常赋值给<code>m_pMainWnd</code>）。这一阶段还负责加载核心资源（如图标、字符串表）、配置消息循环基础参数，并最终返回<code>TRUE</code>以启动消息泵。</p>
<pre><code class=" mermaid">graph TD
    A[程序启动] --&gt; B[全局CWinApp对象构造]
    B --&gt; C[调用CWinApp构造函数]
    C --&gt; D[初始化MFC内部状态]
    D --&gt; E[进入MFC提供的WinMain/AfxWinMain]
    E --&gt; F[调用AfxGetApp获取全局对象]
    F --&gt; G[执行pApp-&gt;InitInstance]
    G --&gt; H[注册文档模板?]
    H --&gt;|是| I[创建主窗口m_pMainWnd]
    H --&gt;|否| J[默认窗口创建]
    I --&gt; K[显示窗口ShowWindow]
    K --&gt; L[更新窗口UpdateWindow]
    L --&gt; M[InitInstance返回TRUE]
    M --&gt; N[进入消息循环pApp-&gt;Run]
    N --&gt; O[窗口消息处理]
</code></pre>

<p>我们可以看出：在MFC程序中，<strong>全局<code>CWinApp</code>对象（如<code>theApp</code>）的构造时机早于<code>WinMain</code>函数</strong>，而MFC的<code>WinMain</code>函数（实际由<code>AfxWinMain</code>实现）<strong>需要访问全局的<code>CWinApp</code>对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// MFC内部伪代码（简化版）</span><br><span class="hljs-function"><span class="hljs-type">int</span> AFXAPI <span class="hljs-title">AfxWinMain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 获取全局CWinApp对象（通过AfxGetApp()）</span><br>    CWinApp* pApp = <span class="hljs-built_in">AfxGetApp</span>();  <br><br>    <span class="hljs-comment">// 2. 调用pApp-&gt;InitInstance()初始化应用程序</span><br>    <span class="hljs-keyword">if</span> (!pApp-&gt;<span class="hljs-built_in">InitInstance</span>()) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 3. 运行消息循环</span><br>    pApp-&gt;<span class="hljs-built_in">Run</span>();  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>AfxGetApp()</code></strong> 返回的是全局<code>theApp</code>的地址。如果<code>theApp</code>不是全局对象，<code>AfxWinMain</code>将无法找到应用程序实例，导致崩溃。</p>
<blockquote>
<p>全局对象的建构会比程序入口点更早，所以CWinApp类的对象构造函数将早于WinMain函数，而<strong>WinMain函数又广泛使用了应用程序对象</strong>，这就是为什么应该程序对象<strong>必须做全局声明</strong>的原因。</p>
</blockquote>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h1 id="MFC运行时类型识别（RTTI）"><a href="#MFC运行时类型识别（RTTI）" class="headerlink" title="MFC运行时类型识别（RTTI）"></a>MFC运行时类型识别（RTTI）</h1><p>MFC运行时类型识别(Runtime Type Information, RTTI)是微软基础类库(MFC)提供的一套类型系统，它允许在程序运行时获取对象的类型信息，这是MFC框架实现动态创建、序列化等功能的基础机制。</p>
<h2 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h2><p>MFC的RTTI系统主要通过以下三个层次的宏实现：</p>
<ol>
<li><p><strong>基础RTTI支持</strong>（DECLARE_DYNAMIC&#x2F;IMPLEMENT_DYNAMIC）</p>
<ul>
<li>提供基本的类型识别能力</li>
<li>支持IsKindOf()类型检查</li>
<li>不支持对象创建</li>
</ul>
</li>
<li><p><strong>动态创建支持</strong>（DECLARE_DYNCREATE&#x2F;IMPLEMENT_DYNCREATE）</p>
<ul>
<li>包含基础RTTI功能</li>
<li>添加动态创建能力</li>
<li>文档&#x2F;视图架构必需</li>
</ul>
</li>
<li><p><strong>序列化支持</strong>（DECLARE_SERIAL&#x2F;IMPLEMENT_SERIAL）</p>
<ul>
<li>包含动态创建功能</li>
<li>添加对象序列化能力</li>
<li>支持版本控制</li>
</ul>
</li>
</ol>
<h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><p>MFC通过CRuntimeClass结构保存类型信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CRuntimeClass</span> &#123;<br>    LPCSTR m_lpszClassName;    <span class="hljs-comment">// 类名</span><br>    <span class="hljs-type">int</span> m_nObjectSize;         <span class="hljs-comment">// 对象大小</span><br>    UINT m_wSchema;            <span class="hljs-comment">// 模式号（序列化用）</span><br>    CObject* (PASCAL* m_pfnCreateObject)(); <span class="hljs-comment">// 创建函数指针</span><br>    CRuntimeClass* m_pBaseClass; <span class="hljs-comment">// 基类信息</span><br>    <br>    <span class="hljs-comment">// 核心方法</span><br>    <span class="hljs-function">CObject* <span class="hljs-title">CreateObject</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 动态创建对象</span><br>    <span class="hljs-function">BOOL <span class="hljs-title">IsDerivedFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> CRuntimeClass* pBaseClass)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 类型检查</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h2><h3 id="1-类型安全检查"><a href="#1-类型安全检查" class="headerlink" title="1. 类型安全检查"></a>1. 类型安全检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessObject</span><span class="hljs-params">(CObject* pObj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(pObj-&gt;<span class="hljs-built_in">IsKindOf</span>(<span class="hljs-built_in">RUNTIME_CLASS</span>(CMyClass))) &#123;<br>        CMyClass* pMyObj = (CMyClass*)pObj;<br>        <span class="hljs-comment">// 安全处理...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-动态对象创建"><a href="#2-动态对象创建" class="headerlink" title="2. 动态对象创建"></a>2. 动态对象创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CRuntimeClass* pClass = <span class="hljs-built_in">RUNTIME_CLASS</span>(CMyClass);<br>CObject* pObj = pClass-&gt;<span class="hljs-built_in">CreateObject</span>();<br><span class="hljs-keyword">if</span>(pObj != <span class="hljs-literal">NULL</span>) &#123;<br>    CMyClass* pMyObj = <span class="hljs-built_in">dynamic_cast</span>&lt;CMyClass*&gt;(pObj);<br>    <span class="hljs-comment">// 使用对象...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-序列化支持"><a href="#3-序列化支持" class="headerlink" title="3. 序列化支持"></a>3. 序列化支持</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在文档类中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyDoc::Serialize</span><span class="hljs-params">(CArchive&amp; ar)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(ar.<span class="hljs-built_in">IsStoring</span>()) &#123;<br>        <span class="hljs-comment">// 保存</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 加载时会自动调用CreateObject</span><br>        CObject* pObj;<br>        ar &gt;&gt; pObj;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="与标准C-RTTI的比较"><a href="#与标准C-RTTI的比较" class="headerlink" title="与标准C++ RTTI的比较"></a>与标准C++ RTTI的比较</h2><table>
<thead>
<tr>
<th>特性</th>
<th>MFC RTTI</th>
<th>标准C++ RTTI</th>
</tr>
</thead>
<tbody><tr>
<td>实现方式</td>
<td>宏和CRuntimeClass</td>
<td>typeid和dynamic_cast</td>
</tr>
<tr>
<td>动态创建支持</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>序列化支持</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>类型信息丰富度</td>
<td>更丰富(含类名等)</td>
<td>较少</td>
</tr>
<tr>
<td>性能</td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td>跨DLL兼容性</td>
<td>需要特别处理</td>
<td>通常兼容</td>
</tr>
</tbody></table>
<h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><h3 id="对象工厂模式"><a href="#对象工厂模式" class="headerlink" title="对象工厂模式"></a>对象工厂模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">CWnd* <span class="hljs-title">CreateControl</span><span class="hljs-params">(<span class="hljs-type">const</span> CString&amp; strType)</span> </span>&#123;<br>    CRuntimeClass* pClass = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span>(strType == <span class="hljs-string">&quot;Button&quot;</span>) pClass = <span class="hljs-built_in">RUNTIME_CLASS</span>(CMyButton);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(strType == <span class="hljs-string">&quot;Edit&quot;</span>) pClass = <span class="hljs-built_in">RUNTIME_CLASS</span>(CMyEdit);<br>    <br>    <span class="hljs-keyword">if</span>(pClass &amp;&amp; pClass-&gt;<span class="hljs-built_in">IsDerivedFrom</span>(<span class="hljs-built_in">RUNTIME_CLASS</span>(CWnd))) &#123;<br>        <span class="hljs-keyword">return</span> (CWnd*)pClass-&gt;<span class="hljs-built_in">CreateObject</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><strong>基类要求</strong>：必须从CObject派生才能使用完整功能</li>
<li><strong>DLL边界</strong>：跨DLL使用时需确保类型信息共享</li>
<li><strong>性能考虑</strong>：频繁的类型检查可能影响性能</li>
<li><strong>版本控制</strong>：序列化时版本号需谨慎管理</li>
<li><strong>与标准RTTI混用</strong>：可以但需注意区分场景</li>
</ol>
<h1 id="MFC创建"><a href="#MFC创建" class="headerlink" title="MFC创建"></a>MFC创建</h1><h2 id="关于MFC的动态创建"><a href="#关于MFC的动态创建" class="headerlink" title="关于MFC的动态创建"></a>关于MFC的动态创建</h2><p>MFC的动态创建基本和C++的new运算符创建没有区别，但是他弥补了C++语言中不让如下语句执行的缺点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* className = <span class="hljs-string">&quot;MyClass&quot;</span>;<br>CObject* obj = new className;<br></code></pre></td></tr></table></figure>

<p>如上代码我们的本意就是创建一个MyClass类的对象，但是C++是无法创建的。</p>
<h3 id="什么时候需要动态创建"><a href="#什么时候需要动态创建" class="headerlink" title="什么时候需要动态创建"></a>什么时候需要动态创建</h3><p>MFC有一个永久保存机制，就是将内存中的东西写入到文件中，写入的数据可能是对象中的成员，所以我们需要根据文件中记载的信息去创建对象，才能将写入的数据读取保存。</p>
<p>CRuntimeClass::CreateObject（<strong>动态创建函数</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型记录链表结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CRuntimeClass</span></span><br><span class="hljs-class">&#123;</span><br>LPCSTR m_lpszClassName;  <span class="hljs-comment">// 类名称</span><br><span class="hljs-type">int</span>`` m_nObjectSize;   <span class="hljs-comment">// 类的大小</span><br>UINT m_wSchema; <span class="hljs-comment">// 加载类的模式编号</span><br>CObject* (PASCAL* m_pfnCreateObject)(); <span class="hljs-comment">// 函数指针，定义了一个函数指针m_pfnCreateObject用来存放需要支持动态创建类的CreateObject函数</span><br>m_pBaseClass;   <span class="hljs-comment">// 父类指针</span><br>CObject* <span class="hljs-title function_">CreateObject</span><span class="hljs-params">()</span>;   <span class="hljs-comment">// 动态创建函数</span><br><span class="hljs-comment">// 判断函数</span><br>BOOL <span class="hljs-title function_">IsDerivedFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> CRuntimeClass* pBaseClass)</span> <span class="hljs-type">const</span>; …<br>CRuntimeClass* m_pNextClass;    <span class="hljs-comment">// 指向下一个CRuntimeClass </span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="使用动态创建"><a href="#使用动态创建" class="headerlink" title="使用动态创建"></a>使用动态创建</h2><p>我们可以跟进CFramWnd类、CWinApp类来看一下谁支持动态创建，也就是<strong>谁使用了相关的宏</strong>：</p>
<p><img src="https://gh0st.cn/Binary-Learning/images/download/attachments/1015822/image2021-6-24_10-32-2.png" srcset="/img/loading.gif" lazyload></p>
<p>如上图所示我们可以很清晰的看见<strong>CFrameWnd类使用了DECLARE_DYNCREATE宏</strong>，也就表示其支持动态创建。</p>
<p>所以我们可以在其派生的CMainWindow类也使用动态创建，这里宏的使用和RTTI宏的使用是一样的：</p>
<p><img src="https://gh0st.cn/Binary-Learning/images/download/attachments/1015822/image2021-6-24_10-57-1.png" srcset="/img/loading.gif" lazyload></p>
<p>在InitInstance函数中<strong>将new运算符替代为动态创建函数CreateObject</strong>即可。</p>
<p><img src="https://gh0st.cn/Binary-Learning/images/download/attachments/1015822/image2021-6-24_11-23-38.png" srcset="/img/loading.gif" lazyload alt="images/download/attachments/1015822/image2021-6-24_11-23-38.png"></p>
<p>这个就很好理解了就是调用CreateObject函数会判断<strong>m_pfnCreateObject</strong>（这是一个函数指针存放当前的CreateObject函数的地址），如果不为空则调用这个函数将其返回值给到pObject，最后再返回pObject也就是new CMainWindow。</p>
<h1 id="消息映射"><a href="#消息映射" class="headerlink" title="消息映射"></a>消息映射</h1><p>消息映射是 <strong>MFC的核心机制</strong>，用于将 <strong>Windows消息（如鼠标点击、键盘输入）自动路由到对应的C++类成员函数</strong>。它通过宏和固定代码结构实现，避免了传统Win32 API中冗长的<code>switch-case</code>消息处理逻辑。</p>
<h2 id="消息映射的核心组成"><a href="#消息映射的核心组成" class="headerlink" title="消息映射的核心组成"></a><strong>消息映射的核心组成</strong></h2><table>
<thead>
<tr>
<th align="left"><strong>组成部分</strong></th>
<th align="left"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>DECLARE_MESSAGE_MAP</code></strong></td>
<td align="left">声明类拥有消息映射表（必须放在类定义内部）。</td>
</tr>
<tr>
<td align="left"><strong><code>BEGIN_MESSAGE_MAP</code></strong></td>
<td align="left">开始定义消息映射表（指定当前类和父类）。</td>
</tr>
<tr>
<td align="left"><strong><code>ON_XXX</code>宏</strong></td>
<td align="left">绑定具体消息到处理函数（如<code>ON_WM_PAINT()</code>对应<code>OnPaint()</code>）。</td>
</tr>
<tr>
<td align="left"><strong><code>END_MESSAGE_MAP</code></strong></td>
<td align="left">结束消息映射表。</td>
</tr>
</tbody></table>
<h3 id="MFC三大类消息"><a href="#MFC三大类消息" class="headerlink" title="MFC三大类消息"></a><strong>MFC三大类消息</strong></h3><p>在MFC中，消息主要分为 <strong>标准消息</strong>、<strong>命令消息（WM_COMMAND）</strong> 和 <strong>控件通知消息</strong> 三大类。它们的处理方式、来源和应用场景各不相同，理解这些消息类型是掌握MFC消息机制的关键。</p>
<ul>
<li><strong>标准消息</strong> ：直接对应Windows系统事件，处理函数名称固定（如<code>WM_PAINT</code>→<code>OnPaint()</code>）。  仅窗口类可处理，无路由机制。</li>
<li><strong>命令消息</strong>  ：由用户界面触发，支持多对象路由（如文档优先处理）。  需指定资源ID（如<code>ID_FILE_OPEN</code>），函数名可自定义。</li>
<li><strong>控件通知</strong>  ：子控件发送给父窗口的事件，需同时指定控件ID和通知码。  简单通知（如按钮点击）用<code>ON_BN_CLICKED</code>，复杂通知（如列表视图）用<code>ON_NOTIFY</code>。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>标准消息 (Windows Messages)</strong></th>
<th><strong>命令消息 (WM_COMMAND)</strong></th>
<th><strong>控件通知消息 (Control Notifications)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>消息标识</strong></td>
<td><code>WM_</code>前缀（如<code>WM_PAINT</code>、<code>WM_SIZE</code>）</td>
<td><code>WM_COMMAND</code></td>
<td><code>WM_COMMAND</code>或<code>WM_NOTIFY</code> + 通知码（如<code>BN_CLICKED</code>）</td>
</tr>
<tr>
<td><strong>消息来源</strong></td>
<td>操作系统（窗口事件）</td>
<td>菜单项、工具栏按钮、快捷键</td>
<td>子控件（按钮、编辑框、列表框等）</td>
</tr>
<tr>
<td><strong>处理类</strong></td>
<td><code>CWnd</code>派生类（窗口类）</td>
<td><code>CCmdTarget</code>派生类（文档、视图、框架窗口、应用等）</td>
<td>父窗口（通常是<code>CDialog</code>或<code>CFormView</code>）</td>
</tr>
<tr>
<td><strong>绑定宏</strong></td>
<td><code>ON_WM_XXX()</code>（如<code>ON_WM_PAINT()</code>）</td>
<td><code>ON_COMMAND(ID, Handler)</code></td>
<td><code>ON_BN_CLICKED(ID, Handler)</code>等</td>
</tr>
<tr>
<td><strong>处理函数签名</strong></td>
<td>固定格式（如<code>OnPaint()</code>、<code>OnLButtonDown()</code>）</td>
<td>自定义函数（如<code>OnFileOpen()</code>）</td>
<td>自定义函数（如<code>OnButtonClick()</code>）</td>
</tr>
<tr>
<td><strong>消息路由</strong></td>
<td>仅由当前窗口处理</td>
<td>按顺序传递：视图→文档→框架窗口→应用程序</td>
<td>通常由父窗口直接处理</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>窗口绘制、鼠标&#x2F;键盘输入、系统事件</td>
<td>用户命令（如文件操作、编辑操作）</td>
<td>控件交互（如按钮点击、编辑框输入变化）</td>
</tr>
<tr>
<td><strong>示例代码</strong></td>
<td><code>ON_WM_PAINT()</code><br><code>void OnPaint() &#123;...&#125;</code></td>
<td><code>ON_COMMAND(ID_OPEN, OnFileOpen)</code><br><code>void OnFileOpen() &#123;...&#125;</code></td>
<td><code>ON_BN_CLICKED(IDC_BUTTON1, OnClick)</code><br><code>void OnClick() &#123;...&#125;</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>消息映射机制</strong>（<code>DECLARE_MESSAGE_MAP</code>等）是<strong>技术基础</strong>，三大类消息是<strong>逻辑分类</strong>。  </li>
<li><strong>标准消息</strong>和<strong>控件通知</strong>属于<strong>系统&#x2F;控件驱动</strong>，<strong>命令消息</strong>属于<strong>用户驱动</strong>。  </li>
<li>所有消息最终通过消息映射表绑定到对应的C++成员函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyWindow</span> : <span class="hljs-keyword">public</span> CFrameWnd &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DECLARE_MESSAGE_MAP</span>()<br><br>    <span class="hljs-comment">// 标准消息处理</span><br>    <span class="hljs-function">afx_msg <span class="hljs-type">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 命令消息处理</span><br>    <span class="hljs-function">afx_msg <span class="hljs-type">void</span> <span class="hljs-title">OnFileOpen</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 控件通知处理</span><br>    <span class="hljs-function">afx_msg <span class="hljs-type">void</span> <span class="hljs-title">OnButtonClick</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-built_in">BEGIN_MESSAGE_MAP</span>(CMyWindow, CFrameWnd)<br>    <span class="hljs-comment">// 标准消息</span><br>    <span class="hljs-built_in">ON_WM_PAINT</span>()<br>    <span class="hljs-comment">// 命令消息</span><br>    <span class="hljs-built_in">ON_COMMAND</span>(ID_FILE_OPEN, OnFileOpen)<br>    <span class="hljs-comment">// 控件通知</span><br>    <span class="hljs-built_in">ON_BN_CLICKED</span>(IDC_BUTTON1, OnButtonClick)<br><span class="hljs-built_in">END_MESSAGE_MAP</span>()<br></code></pre></td></tr></table></figure>

<h2 id="消息映射的工作原理"><a href="#消息映射的工作原理" class="headerlink" title="消息映射的工作原理"></a><strong>消息映射的工作原理</strong></h2><h3 id="（1）声明消息映射（类定义中）"><a href="#（1）声明消息映射（类定义中）" class="headerlink" title="（1）声明消息映射（类定义中）"></a><strong>（1）声明消息映射（类定义中）</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CMyWindow</span> : <span class="hljs-keyword">public</span> CFrameWnd &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CMyWindow</span>();<br><br>    <span class="hljs-comment">// 声明消息映射（必须放在类内）</span><br>    <span class="hljs-built_in">DECLARE_MESSAGE_MAP</span>()<br><br>    <span class="hljs-comment">// 消息处理函数</span><br>    <span class="hljs-function">afx_msg <span class="hljs-type">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// WM_PAINT处理函数</span><br>    <span class="hljs-function">afx_msg <span class="hljs-type">void</span> <span class="hljs-title">OnLButtonDown</span><span class="hljs-params">(UINT nFlags, CPoint point)</span></span>; <span class="hljs-comment">// WM_LBUTTONDOWN</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong><code>DECLARE_MESSAGE_MAP</code>：宏展开后会在类中插入隐藏代码，生成消息映射表结构。</strong></p>
<h3 id="（2）实现消息映射（类实现中）"><a href="#（2）实现消息映射（类实现中）" class="headerlink" title="（2）实现消息映射（类实现中）"></a><strong>（2）实现消息映射（类实现中）</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 消息映射表实现（必须放在类外）</span><br><span class="hljs-built_in">BEGIN_MESSAGE_MAP</span>(CMyWindow, CFrameWnd)<br>    <span class="hljs-built_in">ON_WM_PAINT</span>()                <span class="hljs-comment">// 绑定WM_PAINT到OnPaint</span><br>    <span class="hljs-built_in">ON_WM_LBUTTONDOWN</span>()          <span class="hljs-comment">// 绑定WM_LBUTTONDOWN到OnLButtonDown</span><br><span class="hljs-built_in">END_MESSAGE_MAP</span>()<br><br><span class="hljs-comment">// 具体消息处理函数实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyWindow::OnPaint</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">CPaintDC <span class="hljs-title">dc</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    dc.<span class="hljs-built_in">TextOut</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, _T(<span class="hljs-string">&quot;Hello, MFC!&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyWindow::OnLButtonDown</span><span class="hljs-params">(UINT nFlags, CPoint point)</span> </span>&#123;<br>    <span class="hljs-built_in">MessageBox</span>(_T(<span class="hljs-string">&quot;左键点击！&quot;</span>), _T(<span class="hljs-string">&quot;提示&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="消息映射的底层机制"><a href="#消息映射的底层机制" class="headerlink" title="消息映射的底层机制"></a><strong>消息映射的底层机制</strong></h2><h3 id="（1）MFC如何找到消息处理函数？"><a href="#（1）MFC如何找到消息处理函数？" class="headerlink" title="（1）MFC如何找到消息处理函数？"></a><strong>（1）MFC如何找到消息处理函数？</strong></h3><ol>
<li><strong>消息循环</strong>：MFC的<code>CWinApp::Run()</code>调用<code>::GetMessage</code>获取消息。</li>
<li><strong>路由决策</strong>：通过<code>CWnd::WindowProc</code>分发消息。查找类的消息映射表（由<code>DECLARE_MESSAGE_MAP</code>生成）。</li>
<li><strong>函数调用</strong>：若找到匹配的<code>ON_XXX</code>条目，调用对应的成员函数（如<code>OnPaint</code>）。若未找到，交给父类处理（通过<code>BEGIN_MESSAGE_MAP</code>的第二个参数指定）。</li>
</ol>
<h3 id="（2）消息映射表的结构（伪代码）"><a href="#（2）消息映射表的结构（伪代码）" class="headerlink" title="（2）消息映射表的结构（伪代码）"></a><strong>（2）消息映射表的结构（伪代码）</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// MFC内部生成的隐藏数据结构</span><br><span class="hljs-type">static</span> AFX_MSGMAP_ENTRY _messageEntries[] = &#123;<br>    &#123; WM_PAINT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;OnPaint &#125;,<br>    &#123; WM_LBUTTONDOWN, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;OnLButtonDown &#125;,<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 消息映射表链</span><br><span class="hljs-type">static</span> AFX_MSGMAP _messageMap = &#123;<br>    &amp;CFrameWnd::messageMap, <span class="hljs-comment">// 父类消息映射</span><br>    &amp;_messageEntries        <span class="hljs-comment">// 当前类消息映射</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SunsetR/p/12293188.html">【逆向】MFC消息映射定位与识别 - SunsetR - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/242305.html">MFC逆向之查找控件消息处理函数 - FreeBuf网络安全行业门户</a></p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/17bdw/p/8851049.html">系统安全19] 面向对象逆向-虚函数、MFC逆向 - 17bdw - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/205348.html">MFC框架软件逆向研究 - SecPulse.COM | 安全脉搏</a></p>
</blockquote>
<h1 id="命令传递"><a href="#命令传递" class="headerlink" title="命令传递"></a>命令传递</h1><p><strong>命令传递</strong>是MFC框架中处理<code>WM_COMMAND</code>消息的核心机制，它允许<strong>菜单项、工具栏按钮、快捷键等用户命令</strong>在应用程序的多个对象之间自动传递，直到找到合适的处理函数。</p>
<h2 id="命令传递的基本流程"><a href="#命令传递的基本流程" class="headerlink" title="命令传递的基本流程"></a>命令传递的基本流程</h2><p>当用户触发一个命令时(如点击菜单)，MFC框架会按照以下顺序传递命令：</p>
<ol>
<li><strong>活动视图(Active View)</strong> - 最先有机会处理命令</li>
<li><strong>与视图关联的文档(Document)</strong></li>
<li><strong>文档模板(Document Template)</strong></li>
<li><strong>主框架窗口(Main Frame Window)</strong></li>
<li><strong>应用程序对象(Application Object)</strong></li>
</ol>
<h2 id="各对象处理命令的优先级"><a href="#各对象处理命令的优先级" class="headerlink" title="各对象处理命令的优先级"></a>各对象处理命令的优先级</h2><ol>
<li><p><strong>CView派生类</strong>：处理与视图显示相关的命令,如绘图、缩放等视图特定操作</p>
</li>
<li><p><strong>CDocument派生类</strong>：处理与文档数据相关的命令,如保存、打开等文档操作</p>
</li>
<li><p><strong>CDocTemplate派生类</strong>：较少直接处理命令</p>
</li>
<li><p>**CFrameWnd派生类(主框架)**：处理框架相关命令,如窗口排列、工具栏显示等</p>
</li>
<li><p>**CWinApp派生类(应用程序对象)**：处理应用级命令,如退出、关于对话框等</p>
</li>
</ol>
<h2 id="实际应用示例-1"><a href="#实际应用示例-1" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在视图类中处理&quot;绘制&quot;命令</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyView::OnDrawCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 视图特有的绘制代码</span><br>&#125;<br><br><span class="hljs-comment">// 在文档类中处理&quot;保存&quot;命令</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyDocument::OnFileSave</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 文档保存逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 在主框架中处理&quot;工具栏显示&quot;命令</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMainFrame::OnViewToolbar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 显示/隐藏工具栏的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="MFC的CDC类"><a href="#MFC的CDC类" class="headerlink" title="MFC的CDC类"></a>MFC的CDC类</h1><h2 id="GDI基础概念"><a href="#GDI基础概念" class="headerlink" title="GDI基础概念"></a><strong>GDI基础概念</strong></h2><p><strong>GDI（Graphics Device Interface）</strong> 是Windows系统中负责图形输出的核心组件，它提供了一套与设备无关的图形编程接口。主要特点包括：</p>
<ul>
<li><strong>设备无关性</strong>：开发者无需关心底层硬件细节（如显卡型号）。</li>
<li><strong>DC（Device Context）</strong>：逻辑绘图平面，包含绘图所需的属性（如画笔、画刷、字体等）。</li>
<li><strong>统一管理</strong>：通过驱动程序隐藏设备差异，开发者只需操作虚拟的DC。</li>
</ul>
<h2 id="CDC类及其派生类"><a href="#CDC类及其派生类" class="headerlink" title="CDC类及其派生类"></a>CDC类及其派生类</h2><p>CDC类是MFC对GDI的封装，派生类针对不同场景优化：</p>
<table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>用途</strong></th>
<th><strong>生命周期管理</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPaintDC</strong></td>
<td>仅在<code>OnPaint</code>函数内使用，自动调用<code>BeginPaint</code>&#x2F;<code>EndPaint</code></td>
<td>构造时获取DC，析构时释放</td>
</tr>
<tr>
<td><strong>CClientDC</strong></td>
<td>在窗口客户区绘图（如鼠标实时绘图），非<code>WM_PAINT</code>消息时使用</td>
<td>同CPaintDC</td>
</tr>
<tr>
<td><strong>CWindowDC</strong></td>
<td>在整个窗口（含非客户区，如标题栏）绘图</td>
<td>同CPaintDC</td>
</tr>
<tr>
<td><strong>CMetaFileDC</strong></td>
<td>记录矢量图形到Windows图元文件</td>
<td>需手动调用<code>Create</code>和<code>Close</code></td>
</tr>
</tbody></table>
<p><strong>代码示例：使用CPaintDC</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyView::OnPaint</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">CPaintDC <span class="hljs-title">dc</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;  <span class="hljs-comment">// 自动管理DC</span><br>    dc.<span class="hljs-built_in">Rectangle</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);  <span class="hljs-comment">// 绘制矩形</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="GDI绘图基础"><a href="#GDI绘图基础" class="headerlink" title="GDI绘图基础"></a><strong>GDI绘图基础</strong></h2><p><strong>常用绘图方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>MoveTo(x, y)</code></td>
<td>设置绘图起点</td>
<td><code>dc.MoveTo(10, 10);</code></td>
</tr>
<tr>
<td><code>LineTo(x, y)</code></td>
<td>从当前位置画线到目标点</td>
<td><code>dc.LineTo(100, 100);</code></td>
</tr>
<tr>
<td><code>Ellipse(l, t, r, b)</code></td>
<td>绘制椭圆</td>
<td><code>dc.Ellipse(10, 10, 200, 150);</code></td>
</tr>
<tr>
<td><code>TextOut(x, y, text)</code></td>
<td>输出文本</td>
<td><code>dc.TextOut(20, 20, _T(&quot;Hello&quot;));</code></td>
</tr>
</tbody></table>
<p><strong>属性设置</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 设置红色实线画笔</span><br><span class="hljs-function">CPen <span class="hljs-title">pen</span><span class="hljs-params">(PS_SOLID, <span class="hljs-number">1</span>, RGB(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))</span></span>;<br>CPen* pOldPen = dc.<span class="hljs-built_in">SelectObject</span>(&amp;pen);<br><br><span class="hljs-comment">// 设置绿色填充画刷</span><br><span class="hljs-function">CBrush <span class="hljs-title">brush</span><span class="hljs-params">(RGB(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))</span></span>;<br>dc.<span class="hljs-built_in">SelectObject</span>(&amp;brush);<br><br><span class="hljs-comment">// 恢复原有对象</span><br>dc.<span class="hljs-built_in">SelectObject</span>(pOldPen);<br></code></pre></td></tr></table></figure>

<h2 id="坐标系统与映射模式"><a href="#坐标系统与映射模式" class="headerlink" title="坐标系统与映射模式"></a><strong>坐标系统与映射模式</strong></h2><p><strong>映射模式</strong></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>逻辑单位</strong></th>
<th><strong>坐标方向</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>MM_TEXT</code></td>
<td>1像素</td>
<td>x+右, y+下</td>
<td>默认模式，像素级精确控制</td>
</tr>
<tr>
<td><code>MM_LOMETRIC</code></td>
<td>0.1毫米</td>
<td>x+右, y-上</td>
<td>物理尺寸精确绘图</td>
</tr>
<tr>
<td><code>MM_ISOTROPIC</code></td>
<td>用户自定义</td>
<td>等比例缩放</td>
<td>保持纵横比缩放图形</td>
</tr>
<tr>
<td><code>MM_ANISOTROPIC</code></td>
<td>用户自定义</td>
<td>独立缩放x&#x2F;y轴</td>
<td>自由变形图形</td>
</tr>
</tbody></table>
<p><strong>示例：设置等比例缩放</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyView::OnPaint</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">CPaintDC <span class="hljs-title">dc</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    dc.<span class="hljs-built_in">SetMapMode</span>(MM_ISOTROPIC);<br>    dc.<span class="hljs-built_in">SetWindowExt</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);          <span class="hljs-comment">// 逻辑窗口范围</span><br>    dc.<span class="hljs-built_in">SetViewportExt</span>(rect.<span class="hljs-built_in">Width</span>(), rect.<span class="hljs-built_in">Height</span>());  <span class="hljs-comment">// 设备视口范围</span><br>    dc.<span class="hljs-built_in">Ellipse</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);        <span class="hljs-comment">// 始终绘制正圆</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="鼠标与键盘消息处理"><a href="#鼠标与键盘消息处理" class="headerlink" title="鼠标与键盘消息处理"></a><strong>鼠标与键盘消息处理</strong></h2><h3 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a><strong>鼠标消息</strong></h3><p><img src="https://s2.loli.net/2025/05/17/pTfH2FlBLYXk5KZ.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>示例：鼠标画线</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CPoint m_ptStart;  <span class="hljs-comment">// 记录起点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyView::OnLButtonDown</span><span class="hljs-params">(UINT nFlags, CPoint point)</span> </span>&#123;<br>    m_ptStart = point;<br>    <span class="hljs-built_in">SetCapture</span>();  <span class="hljs-comment">// 捕获鼠标</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyView::OnLButtonUp</span><span class="hljs-params">(UINT nFlags, CPoint point)</span> </span>&#123;<br>    <span class="hljs-function">CClientDC <span class="hljs-title">dc</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    dc.<span class="hljs-built_in">MoveTo</span>(m_ptStart);<br>    dc.<span class="hljs-built_in">LineTo</span>(point);<br>    <span class="hljs-built_in">ReleaseCapture</span>();  <span class="hljs-comment">// 释放鼠标</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a><strong>键盘消息</strong></h3><table>
<thead>
<tr>
<th><strong>消息</strong></th>
<th><strong>处理函数</strong></th>
<th><strong>关键参数</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>WM_KEYDOWN</code></td>
<td><code>OnKeyDown</code></td>
<td><code>nChar</code>: 虚拟键码（如<code>VK_A</code>）</td>
</tr>
<tr>
<td><code>WM_CHAR</code></td>
<td><code>OnChar</code></td>
<td><code>nChar</code>: ASCII字符（区分大小写）</td>
</tr>
</tbody></table>
<p><strong>示例：响应回车键</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyView::OnChar</span><span class="hljs-params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nChar == VK_RETURN) &#123;<br>        <span class="hljs-built_in">MessageBox</span>(_T(<span class="hljs-string">&quot;回车键按下&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="对话框与控件"><a href="#对话框与控件" class="headerlink" title="对话框与控件"></a><strong>对话框与控件</strong></h2><p><strong>模态对话框</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyView::ShowDialog</span><span class="hljs-params">()</span> </span>&#123;<br>    CMyDialog dlg;<br>    <span class="hljs-keyword">if</span> (dlg.<span class="hljs-built_in">DoModal</span>() == IDOK) &#123;  <span class="hljs-comment">// 阻塞直到关闭</span><br>        CString str = dlg.<span class="hljs-built_in">GetInputText</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>动态数据交换（DDX）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在对话框类中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CMyDialog::DoDataExchange</span><span class="hljs-params">(CDataExchange* pDX)</span> </span>&#123;<br>    CDialog::<span class="hljs-built_in">DoDataExchange</span>(pDX);<br>    <span class="hljs-built_in">DDX_Text</span>(pDX, IDC_EDIT1, m_strInput);  <span class="hljs-comment">// 绑定编辑框到变量</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-built_in">UpdateData</span>(TRUE);   <span class="hljs-comment">// 控件值 → 变量</span><br><span class="hljs-built_in">UpdateData</span>(FALSE);  <span class="hljs-comment">// 变量值 → 控件</span><br></code></pre></td></tr></table></figure>

<h1 id="文件和资源操作"><a href="#文件和资源操作" class="headerlink" title="文件和资源操作"></a>文件和资源操作</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h2><p>直接读写二进制或文本文件。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Open()</code></td>
<td align="left">打开文件（支持读写模式）</td>
</tr>
<tr>
<td align="left"><code>Read()</code> &#x2F; <code>Write()</code></td>
<td align="left">读写数据</td>
</tr>
<tr>
<td align="left"><code>Seek()</code></td>
<td align="left">移动文件指针</td>
</tr>
<tr>
<td align="left"><code>Close()</code></td>
<td align="left">关闭文件</td>
</tr>
</tbody></table>
<p>注意：</p>
<p>打开文件的方法：</p>
<ol>
<li>构造一个没有初始化的CFile对象，对象调用CFile::Open函数；</li>
<li>用CFile的构造函数打开文件；</li>
<li>如果要创建一个新的文件，而不是打开一个现存文件，则需要在CFile::Open函数或者CFile的构造函数的第二个参数包含一个CFile::modeCreate标志。</li>
</ol>
<p><img src="https://s2.loli.net/2025/05/17/vOyCQ7z6hcg5aFx.png" srcset="/img/loading.gif" lazyload></p>
<p>如果想在这个写入之后跟着去填写的话直接使用<strong>Write</strong>函数是会被覆盖的，需要使用<strong>SeekToEnd</strong>函数将写入位置指向文件末尾然后再使用<strong>Write</strong>函数，最后记得要关闭这个文件。</p>
<h2 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h2><p>MFC的资源就是我们之前所说的存储一些图片、图标、信息的…我们可以去查找资源、获取资源的大小、加载资源。</p>
<table>
<thead>
<tr>
<th align="left">资源类型</th>
<th align="left">描述</th>
<th align="left">访问方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>对话框</strong></td>
<td align="left">界面布局</td>
<td align="left"><code>CDialog</code>派生类</td>
</tr>
<tr>
<td align="left"><strong>图标</strong></td>
<td align="left">程序或窗口图标</td>
<td align="left"><code>LoadIcon()</code> &#x2F; <code>SetIcon()</code></td>
</tr>
<tr>
<td align="left"><strong>位图</strong></td>
<td align="left">图像资源</td>
<td align="left"><code>CBitmap::LoadBitmap()</code></td>
</tr>
<tr>
<td align="left"><strong>字符串表</strong></td>
<td align="left">多语言文本</td>
<td align="left"><code>CString::LoadString()</code></td>
</tr>
<tr>
<td align="left"><strong>菜单</strong></td>
<td align="left">窗口菜单栏</td>
<td align="left"><code>CMenu::LoadMenu()</code></td>
</tr>
<tr>
<td align="left"><strong>快捷键</strong></td>
<td align="left">键盘加速键</td>
<td align="left"><code>LoadAccelerators()</code></td>
</tr>
</tbody></table>
<p>简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CHelloComboBoxDlg::OnButton1</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 查找资源</span><br>    <span class="hljs-comment">// 第二个参数需要填写资源名称，这个是由MAKEINTRESOURCE(Id)去获取的，Id就是我们的资源ID</span><br>    <span class="hljs-comment">// 第三个参数是资源类型，就输入我们刚刚自定义的资源类型</span><br>    HRSRC hrSrc = <span class="hljs-built_in">FindResource</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MAKEINTRESOURCE</span>(IDR_TXT1), <span class="hljs-string">&quot;TXT&quot;</span>); <span class="hljs-comment">// 返回一个句柄</span><br>    <span class="hljs-comment">// 获取资源大小</span><br>    <span class="hljs-type">int</span> rSize = <span class="hljs-built_in">SizeofResource</span>(<span class="hljs-literal">NULL</span>, hrSrc);<br>    <span class="hljs-comment">// 加载资源</span><br>    HGLOBAL hMap = <span class="hljs-built_in">LoadResource</span>(<span class="hljs-literal">NULL</span>, hrSrc);<br>    <span class="hljs-comment">// 读取数据</span><br>    CFile cf;<br>    cf.<span class="hljs-built_in">Open</span>(<span class="hljs-string">&quot;new.txt&quot;</span>, CFile::modeCreate|CFile::modeWrite);<br>    cf.<span class="hljs-built_in">Write</span>(hMap, rSize);<br>    cf.<span class="hljs-built_in">Close</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MrYuan/p/4739810.html">MFC六大核心机制之一：MFC程序的初始化 - 超酷小子 - 博客园</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/" class="category-chain-item">逆向与风控</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Windows%E5%B9%B3%E5%8F%B0/" class="category-chain-item">Windows平台</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Windows%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/" class="category-chain-item">开发</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MFC开发</div>
      <div>http://example.com/2025/05/18/逆向与风控/Window平台/开发/MFC全解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/18/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/Window%E5%B9%B3%E5%8F%B0/%E5%BC%80%E5%8F%91/QT%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6/" title="QT信号与槽机制">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">QT信号与槽机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/18/%E9%80%86%E5%90%91%E4%B8%8E%E9%A3%8E%E6%8E%A7/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B1%87%E7%BC%96/X86%E4%B8%8EARM%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B7%AE%E5%BC%82/" title="X86与ARM架构与指令集差异">
                        <span class="hidden-mobile">X86与ARM架构与指令集差异</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
