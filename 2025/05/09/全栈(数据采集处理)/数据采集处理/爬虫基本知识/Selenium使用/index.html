

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="selenium历程 java - Selenium 工作原理 - 个人文章 - SegmentFault 思否这篇文章中作者对selenium的发展历程谈的比较仔细，这里简单总结一下就是：   04年，诞生了Selenium Core，Selenium Core是基于浏览器并且采用JavaScript编程语言的测试工具，运行在浏览器的安全沙箱中，设计理念是将待测试产品、Selenium Core">
<meta property="og:type" content="article">
<meta property="og:title" content="Selenium学习">
<meta property="og:url" content="http://example.com/2025/05/09/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Selenium%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="selenium历程 java - Selenium 工作原理 - 个人文章 - SegmentFault 思否这篇文章中作者对selenium的发展历程谈的比较仔细，这里简单总结一下就是：   04年，诞生了Selenium Core，Selenium Core是基于浏览器并且采用JavaScript编程语言的测试工具，运行在浏览器的安全沙箱中，设计理念是将待测试产品、Selenium Core">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/Y6FKudEhliRbByr.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/D7b5XsZPhECkKSd.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/1gdZLDiBczHGwNU.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/nNovexcErXbDP3Z.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/7dhIPgrLR69GYl8.png">
<meta property="og:image" content="c:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250117165145564.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/jZSIyfJ2HAW4EuN.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/u6p9gklWnRX3ZmK.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/GfDR1PW8sdy2XKl.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/4ykmbNUueEw1RO6.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/rY7p5bNx6Ei1BaC.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/wfQMNyPYGmD2H5c.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/17/3xqtUgojYhdbeav.png">
<meta property="article:published_time" content="2025-05-09T07:31:42.214Z">
<meta property="article:modified_time" content="2025-05-09T13:15:40.779Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="数据采集处理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/01/17/Y6FKudEhliRbByr.png">
  
  
  
  <title>Selenium学习 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Selenium学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-09 15:31" pubdate>
          2025年5月9日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          39 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Selenium学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="selenium历程"><a href="#selenium历程" class="headerlink" title="selenium历程"></a><strong>selenium历程</strong></h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022207984#item-1">java - Selenium 工作原理 - 个人文章 - SegmentFault 思否</a>这篇文章中作者对selenium的发展历程谈的比较仔细，这里简单总结一下就是：</p>
</blockquote>
<ol>
<li>04年，诞生了Selenium Core，Selenium Core是基于浏览器并且采用JavaScript编程语言的测试工具，运行在浏览器的安全沙箱中，设计理念是将待测试产品、Selenium Core和测试脚本均部署到同一台<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cvm/?from_column=20065&from=20065">服务器</a>上来完成自动化测试的工作(同源策略问题)。</li>
<li>05年，Selenium RC诞生，就是selenium1 ，这个时候，Selenium Core其实是Selenium RC的核心。 Selenium RC让待测试产品、Selenium Core和测试脚本三者分散在不同的服务器上。（测试脚本只关心将HTTP请求发送到指定的URL上，selenium本身不需要关心HTTP请求由于什么程序编程语言编写而成） Selenium RC包括两部分：一个是Selenium RC Server，一个是提供各种编程语言的客户端驱动来编写测试脚本 </li>
<li>07年，Webdriver诞生，WebDriver的设计理念是将端到端测试与底层具体的测试工具分隔离，并采用设计模式Adapter适配器来达到目标。WebDriver的API组织更多的是面向对象。 </li>
<li>08&#x2F;09年，selenium2诞生，selenium2其实是selenium rc和webdriver的合并，合并的根本原因是相互补充各自的缺点 </li>
<li>09年，selenium3诞生，这个版本剔除了selenium rc ， 主要由 selenium webdriver和selenium Grid组成， 我们日常使用的其实就是selenium webdriver，至于selenium grid是一个分布式实现自动化测试的工具</li>
</ol>
<h1 id="简单谈谈什么是webdriver"><a href="#简单谈谈什么是webdriver" class="headerlink" title="简单谈谈什么是webdriver?"></a>简单谈谈什么是webdriver?</h1><p>在前面简单谈到了Webdriver,在写自动化测试程序时,通常也必须写：</p>
<p><img src="https://s2.loli.net/2025/01/17/Y6FKudEhliRbByr.png" srcset="/img/loading.gif" lazyload alt="image-20250117162213156"></p>
<h3 id="W3C-WebDriver-协议"><a href="#W3C-WebDriver-协议" class="headerlink" title="W3C WebDriver 协议"></a>W3C WebDriver 协议</h3><blockquote>
<p><strong>W3C WebDriver 协议</strong>（即 <strong>WebDriver W3C Specification</strong>）是一个由 <strong>W3C（World Wide Web Consortium，万维网联盟）</strong> 制定的标准，它定义了 Web 浏览器与自动化客户端（如 Selenium、Appium 等）之间的通信协议。这个协议为浏览器自动化提供了一种标准化的方式，确保不同浏览器和不同的浏览器驱动程序能够实现一致的行为。</p>
</blockquote>
<p>W3C WebDriver 协议定义了一个标准的 HTTP API，浏览器驱动通过这个 API 接收和执行命令。其主要组成部分包括：</p>
<ol>
<li><strong>命令</strong>（Commands）：定义了与浏览器交互的基本操作。<ul>
<li><strong>导航命令</strong>（如：<code>GET</code>、<code>BACK</code>、<code>FORWARD</code>、<code>REFRESH</code>）</li>
<li><strong>元素交互命令</strong>（如：<code>CLICK</code>、<code>SEND_KEYS</code>、<code>CLEAR</code>）</li>
<li><strong>获取信息命令</strong>（如：<code>GET_TITLE</code>、<code>GET_CURRENT_URL</code>、<code>GET_ELEMENT_TEXT</code>）</li>
<li><strong>窗口与框架命令</strong>（如：<code>SWITCH_TO_WINDOW</code>、<code>SWITCH_TO_FRAME</code>）</li>
</ul>
</li>
<li><strong>响应</strong>（Responses）：WebDriver 服务器对命令执行后的响应，返回执行结果或错误信息。<ul>
<li><strong>成功响应</strong>：包含操作的结果（如元素的位置、页面标题等）。</li>
<li><strong>失败响应</strong>：包含错误信息，通常是由于元素未找到、超时等原因导致的。</li>
</ul>
</li>
<li><strong>会话管理</strong>（Session Management）：定义了如何启动、管理和终止 WebDriver 会话。<ul>
<li><strong>新建会话</strong>：启动 WebDriver 实例并创建会话，返回一个会话 ID。</li>
<li><strong>结束会话</strong>：关闭当前会话并退出浏览器。</li>
</ul>
</li>
<li><strong>异步操作</strong>（Asynchronous Operations）：WebDriver 协议支持异步操作，这意味着可以处理长时间运行的操作（如等待元素加载、获取页面截图等）。</li>
<li><strong>元素定位与交互</strong>：协议定义了元素定位和交互的标准方法，包括通过 ID、名称、类名、XPath、CSS 选择器等方式定位元素，以及与元素进行交互（如点击、输入、清空等）。</li>
<li><strong>事件与鼠标&#x2F;键盘操作</strong>：WebDriver 协议支持模拟复杂的用户交互行为，例如鼠标悬停、点击、键盘输入、拖放等。</li>
</ol>
<h3 id="W3C-WebDriver-协议的工作原理"><a href="#W3C-WebDriver-协议的工作原理" class="headerlink" title="W3C WebDriver 协议的工作原理"></a>W3C WebDriver 协议的工作原理</h3><p>WebDriver 协议基于客户端和服务器的通信模型。其工作过程如下：</p>
<ol>
<li>客户端（例如 Selenium）<ul>
<li>自动化脚本运行在 WebDriver 客户端，它会向 WebDriver 服务器（浏览器驱动）发送 HTTP 请求。</li>
<li>请求内容通常是一些浏览器操作命令，例如：打开 URL、点击元素、获取页面标题等。</li>
</ul>
</li>
<li>WebDriver 服务器（浏览器驱动）<ul>
<li>WebDriver 服务器接收到客户端请求后，负责将命令转化为浏览器可执行的操作。</li>
<li>每个浏览器都有自己的 WebDriver 服务器（如 Chrome 的 <code>chromedriver</code>，Firefox 的 <code>geckodriver</code>，Safari 的 <code>safaridriver</code>），这些驱动程序通过与浏览器的原生 API 进行通信来执行命令。</li>
</ul>
</li>
<li>浏览器<ul>
<li>浏览器通过其原生接口（如 Chrome 的 DevTools 协议、Firefox 的 Marionette）接收和执行操作。</li>
<li>浏览器返回执行结果（例如成功、失败、元素位置等）给 WebDriver 服务器，WebDriver 服务器再将结果传递给客户端。</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/01/17/D7b5XsZPhECkKSd.png" srcset="/img/loading.gif" lazyload alt="image-20250117162950019"></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="https://s2.loli.net/2025/01/17/1gdZLDiBczHGwNU.png" srcset="/img/loading.gif" lazyload alt="db533e98a7164936ed5591d6b2609679"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote>
<p>这里我直接以selenium4.5.0版本为例，并驱动谷歌浏览器</p>
</blockquote>
<h3 id="WebDriver"><a href="#WebDriver" class="headerlink" title="WebDriver"></a>WebDriver</h3><p><img src="https://s2.loli.net/2025/01/17/nNovexcErXbDP3Z.png" srcset="/img/loading.gif" lazyload alt="image-20250117163853540"></p>
<p>这里可以看出：</p>
<p>定义了 <code>WebDriver</code> 类的示例，继承自 <code>ChromiumDriver</code> 类，用于控制 Chrome 浏览器并启动 ChromeDriver 服务。</p>
<ul>
<li><strong>弃用警告</strong>：许多旧版本的参数已经被弃用（如 <code>executable_path</code>、<code>chrome_options</code>、<code>keep_alive</code>），并且推荐通过 <code>Service</code> 对象来处理这些配置。</li>
<li><strong><code>Service</code> 对象</strong>：新的配置方式是通过 <code>Service</code> 对象来启动和管理浏览器驱动服务。</li>
<li><strong>调用父类构造方法</strong>：<code>super().__init__</code> 调用父类 <code>ChromiumDriver</code> 的构造方法，初始化浏览器驱动。传递了浏览器的能力、端口、选项、日志路径等配置。</li>
</ul>
<h3 id="ChromiumDriver"><a href="#ChromiumDriver" class="headerlink" title="ChromiumDriver"></a>ChromiumDriver</h3><p><img src="https://s2.loli.net/2025/01/17/7dhIPgrLR69GYl8.png" srcset="/img/loading.gif" lazyload alt="image-20250117164644929"></p>
<p><em><strong>关键点分析</strong></em></p>
<p>**继承自 <code>RemoteWebDriver</code>**：</p>
<ul>
<li>该类继承自 <code>RemoteWebDriver</code>，说明它可以在远程浏览器实例上执行命令，通过远程服务器与 Chromium 浏览器进行交互。</li>
</ul>
<p>**初始化方法 (<code>__init__</code>)**：</p>
<ul>
<li><code>__init__</code> 方法用于初始化 <code>ChromiumDriver</code> 实例。它设置了许多过时的参数（如 <code>port</code>, <code>desired_capabilities</code>, <code>service_log_path</code>, <code>keep_alive</code>），并且建议使用 <code>Service</code> 对象来代替这些配置。</li>
<li>通过 <code>service</code> 参数传入的 <code>Service</code> 对象负责启动和管理 ChromiumDriver 服务。</li>
<li>启动服务后，<code>super().__init__()</code> 调用父类的构造方法，初始化 <code>RemoteWebDriver</code>。</li>
</ul>
<p>**<code>launch_app</code>**：</p>
<ul>
<li>启动指定的 Chromium 应用程序（通过 <code>id</code>）。</li>
<li>这个功能与 Chrome 或 Edge 的应用启动相关，可以用来启动特定的浏览器应用。</li>
</ul>
<p>**网络模拟 (<code>get_network_conditions</code>, <code>set_network_conditions</code>, <code>delete_network_conditions</code>)**：</p>
<ul>
<li>这些方法提供了网络条件模拟功能（例如模拟延迟、下载&#x2F;上传速率等）。<code>set_network_conditions</code> 方法可以模拟不同的网络环境，<code>get_network_conditions</code> 用于获取当前的网络条件，<code>delete_network_conditions</code> 用于重置网络模拟。</li>
</ul>
<p>**权限管理 (<code>set_permissions</code>)**：</p>
<ul>
<li><code>set_permissions</code> 方法允许用户设置 Chromium 浏览器中某些权限（如对剪贴板、摄像头等的访问权限）。</li>
</ul>
<p>**执行 Chrome DevTools 协议命令 (<code>execute_cdp_cmd</code>)**：</p>
<ul>
<li>通过 <code>execute_cdp_cmd</code> 方法，用户可以执行任意的 Chrome DevTools 协议命令。这为用户提供了更底层的控制功能，允许访问和操作 Chromium 的许多高级功能，例如网络请求、页面加载等。</li>
</ul>
<p>**Casting 控制 (<code>get_sinks</code>, <code>set_sink_to_use</code>, <code>start_desktop_mirroring</code>, <code>start_tab_mirroring</code>, <code>stop_casting</code>)**：</p>
<ul>
<li>提供与 Chromecast 或类似设备的交互接口。用户可以列出可用的接收器（sinks）、设置接收器、启动&#x2F;停止桌面或标签页镜像等。</li>
</ul>
<p><strong><code>quit</code> 方法</strong>：</p>
<ul>
<li>关闭浏览器并停止 ChromiumDriver 服务。</li>
</ul>
<p><strong><code>create_options</code> 方法</strong>：</p>
<ul>
<li>根据 <code>vendor_prefix</code>（浏览器的厂商前缀）创建对应的浏览器配置选项。如果是 Edge 浏览器，则创建 <code>EdgeOptions</code>，否则创建 <code>ChromeOptions</code>。</li>
</ul>
<h4 id="start-self"><a href="#start-self" class="headerlink" title="start(self)"></a>start(self)</h4><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250117165145564.png" srcset="/img/loading.gif" lazyload alt="image-20250117165145564"></p>
<p>可以看到这里执行了一个cmd命令，这个命令主要是启动了一个ChromeDriver.exe浏览器驱动，我们每次在执行脚本前，程序会自动帮我们启动浏览器驱动，这个效果就跟我们自己手动启动是一样的效果。</p>
<blockquote>
<p> 第一步工作我们已经知道了执行脚本webdriver.Chrome()会自动执行 chromedirver.exe驱动程序，然后开启一个进程</p>
</blockquote>
<h3 id="RemoteWebDriver"><a href="#RemoteWebDriver" class="headerlink" title="RemoteWebDriver"></a>RemoteWebDriver</h3><p>在ChromiumDriver中我们看到：启动服务后，<code>super().__init__()</code> 调用父类的构造方法，初始化 <code>RemoteWebDriver</code>。接下来就看看这一个父类的初始化</p>
<p><img src="https://s2.loli.net/2025/01/17/jZSIyfJ2HAW4EuN.png" srcset="/img/loading.gif" lazyload alt="image-20250117165658882"></p>
<p>这里有一行最重要的代码，self.start_session(capabilities, browser_profile) 这个方法，继续看一下这个方法的源码做了什么工作</p>
<p><img src="https://s2.loli.net/2025/01/17/u6p9gklWnRX3ZmK.png" srcset="/img/loading.gif" lazyload alt="image-20250117170020962"></p>
<p>用于在 WebDriver 中启动一个新的浏览器会话，并传入指定的（capabilities）进行初始化。</p>
<p>以上代码都说明了一件事：向地址localhost:4444&#x2F;session发送了一个post请求，参数是json格式的，然后返回特定的响应信息给程序(这里主要就是新建了一个sessionid)，最终打开了浏览器</p>
<blockquote>
<p>第二步：成功打开了浏览器</p>
</blockquote>
<p>之后再次回到ChromiumDriver，通过</p>
<p><img src="https://s2.loli.net/2025/01/17/GfDR1PW8sdy2XKl.png" srcset="/img/loading.gif" lazyload alt="image-20250117170703250"></p>
<p>执行对应操作</p>
<h3 id="ChromiumRemoteConnection"><a href="#ChromiumRemoteConnection" class="headerlink" title="ChromiumRemoteConnection"></a>ChromiumRemoteConnection</h3><p><img src="https://s2.loli.net/2025/01/17/4ykmbNUueEw1RO6.png" srcset="/img/loading.gif" lazyload alt="image-20250117170810253"></p>
<p><code>ChromiumRemoteConnection</code> 类为与 Chromium 浏览器的远程通信提供了特定的命令接口，开发者可以通过这些命令与浏览器进行更为细致的交互。例如，可以用它来设置模拟的网络条件，执行 Chrome DevTools Protocol 命令，或者与 Cast 设备交互（如启动桌面镜像、控制 Cast 会话等）。</p>
<p>这些命令大多是通过 HTTP 请求发送到远程 WebDriver 服务，并与 Chromium 浏览器进行交互，类似于其它 WebDriver 命令，但这里特别针对 Chromium 浏览器的需求进行扩展。</p>
<blockquote>
<p>所有的操作对应接口地址我们知道了，那么又怎样执行这些接口来达到在浏览器上实现各种操作呢？继续看紧接着接口地址定义下面的源码？</p>
</blockquote>
<p><img src="https://s2.loli.net/2025/01/17/rY7p5bNx6Ei1BaC.png" srcset="/img/loading.gif" lazyload alt="image-20250117171009369"></p>
<p> 可以看到主要是通过execute方法调用_request方法通过urilib3标准库向服务器发送对应操作请求地址，进而实现了浏览器各种操作。</p>
<p><img src="https://s2.loli.net/2025/01/17/wfQMNyPYGmD2H5c.png" srcset="/img/loading.gif" lazyload alt="image-20250117163430758"></p>
<h2 id="结合案例分析"><a href="#结合案例分析" class="headerlink" title="结合案例分析"></a>结合案例分析</h2><h3 id="1-测试脚本初始化"><a href="#1-测试脚本初始化" class="headerlink" title="1. 测试脚本初始化"></a>1. <strong>测试脚本初始化</strong></h3><p>当你编写一个 Selenium 自动化测试脚本时，它通常会使用一个语言的客户端库（例如 Python 的 <code>selenium</code> 库）。测试脚本通常开始时会导入 Selenium 的相关模块并初始化一个 WebDriver 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-comment"># 初始化 WebDriver</span><br>driver = webdriver.Chrome(executable_path=<span class="hljs-string">&#x27;path_to_chromedriver&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="2-启动服务与浏览器驱动"><a href="#2-启动服务与浏览器驱动" class="headerlink" title="2. 启动服务与浏览器驱动"></a>2. <strong>启动服务与浏览器驱动</strong></h3><ul>
<li><strong>服务启动</strong>：WebDriver 会通过启动一个特定的服务来与浏览器驱动程序（例如 <code>chromedriver.exe</code>、<code>geckodriver.exe</code>）通信。这个浏览器驱动程序充当了 WebDriver 客户端与浏览器之间的桥梁。</li>
<li><strong>浏览器驱动程序</strong>：浏览器驱动程序是一个独立的进程，负责启动和控制实际的浏览器（如 Chrome、Firefox）。浏览器驱动程序通过 WebDriver 协议与 Selenium 客户端进行通信。</li>
</ul>
<p>这一部分是浏览器启动的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 启动浏览器并打开指定页面</span><br>driver.get(<span class="hljs-string">&quot;https://www.example.com&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="3-HTTP-请求与响应机制"><a href="#3-HTTP-请求与响应机制" class="headerlink" title="3. HTTP 请求与响应机制"></a>3. <strong>HTTP 请求与响应机制</strong></h3><ul>
<li><strong>发送请求</strong>：测试脚本通过 <code>RemoteWebDriver</code> 向浏览器驱动程序发送 HTTP 请求。具体来说，测试脚本执行的每个动作（如打开网页、查找元素、点击等）都会被转换为一个 HTTP 请求，并发送到浏览器驱动程序（远程服务器）。</li>
<li><strong>浏览器驱动程序解析请求</strong>：浏览器驱动程序接收到 HTTP 请求后，会解析请求并执行相应的操作。例如，如果脚本要求打开一个 URL，浏览器驱动程序会在浏览器中打开指定的网页。</li>
<li><strong>会话 ID</strong>：浏览器驱动程序启动浏览器时，会生成一个唯一的会话 ID（<code>sessionId</code>），该 ID 会在每个后续请求中携带。通过这个 <code>sessionId</code>，浏览器驱动程序能够识别当前的浏览器会话，并执行相应的操作。</li>
</ul>
<p>请求示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.get(<span class="hljs-string">&quot;https://www.example.com&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>此命令会向浏览器驱动程序发送一个 HTTP 请求，浏览器驱动程序解析该请求并打开网页。</p>
<h3 id="4-RemoteConnection-与-Remote-Server"><a href="#4-RemoteConnection-与-Remote-Server" class="headerlink" title="4. RemoteConnection 与 Remote Server"></a>4. <strong>RemoteConnection 与 Remote Server</strong></h3><ul>
<li><strong>RemoteConnection</strong>：在 Selenium 中，<code>RemoteConnection</code> 负责与浏览器驱动程序之间的通信。通过该连接，Selenium 可以发送 HTTP 请求并等待浏览器驱动程序的响应。<code>RemoteConnection</code> 是 WebDriver 与远程浏览器（或远程浏览器驱动程序）之间的桥梁。</li>
<li><strong>Remote Server</strong>：浏览器驱动程序作为一个远程服务器（remote server）运行，它监听来自客户端（测试脚本）的 HTTP 请求。所有的 Selenium 操作（如查找元素、点击、执行 JavaScript 等）都通过 <code>RemoteConnection</code> 发送到浏览器驱动程序，再由浏览器驱动程序传递给浏览器。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element_by_id(<span class="hljs-string">&quot;login&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>这条命令会通过 <code>RemoteConnection</code> 将请求发送给浏览器驱动程序，浏览器驱动程序会使用浏览器的 DOM 查找 ID 为 <code>login</code> 的元素并返回结果。</p>
<blockquote>
<p>当我们在脚本中执行 <code>driver.find_element_by_id(&quot;login&quot;)</code> 时，实际上是调用了 <code>WebDriver</code> 的 <code>find_element</code> 方法，该方法会将查找元素的请求转化为一个 HTTP 请求发送到浏览器驱动程序。</p>
<p>在 Selenium 的内部，<code>find_element</code> 方法会调用 <code>RemoteWebDriver</code> 类中的一个方法，这个方法会根据 WebDriver 协议构建请求数据。具体来说，Selenium 通过 <code>RemoteConnection</code> 将该请求转换为一个 <strong>POST</strong> 请求，并且请求的 URL 是 <code>/session/$sessionId/element</code>，其中 <code>$sessionId</code> 是当前浏览器会话的唯一标识符。</p>
</blockquote>
<h3 id="5-浏览器驱动程序执行操作"><a href="#5-浏览器驱动程序执行操作" class="headerlink" title="5. 浏览器驱动程序执行操作"></a>5. <strong>浏览器驱动程序执行操作</strong></h3><ul>
<li><strong>执行浏览器操作</strong>：浏览器驱动程序接收到来自 Selenium 客户端的请求后，会在浏览器中执行相应的动作。比如，浏览器驱动程序会使用浏览器的 API 打开网页、填写表单、点击按钮等。</li>
<li><strong>返回执行结果</strong>：执行完成后，浏览器驱动程序会将操作结果（如页面加载成功、元素是否找到等）通过 HTTP 响应返回给 Selenium 客户端。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.get(<span class="hljs-string">&quot;https://www.example.com&quot;</span>)<br><span class="hljs-built_in">print</span>(driver.title)  <span class="hljs-comment"># 获取当前页面的标题</span><br></code></pre></td></tr></table></figure>

<h3 id="6-结果返回到测试脚本"><a href="#6-结果返回到测试脚本" class="headerlink" title="6. 结果返回到测试脚本"></a>6. <strong>结果返回到测试脚本</strong></h3><ul>
<li><strong>测试结果</strong>：浏览器执行完成后，浏览器驱动程序会把执行的结果（例如页面标题、元素文本、截图等）通过 HTTP 响应返回给测试脚本。测试脚本可以利用这些结果进行验证、断言等操作。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">title = driver.title<br><span class="hljs-keyword">assert</span> title == <span class="hljs-string">&quot;Example Domain&quot;</span>  <span class="hljs-comment"># 验证页面标题</span><br></code></pre></td></tr></table></figure>

<h3 id="7-浏览器关闭与会话结束"><a href="#7-浏览器关闭与会话结束" class="headerlink" title="7. 浏览器关闭与会话结束"></a>7. <strong>浏览器关闭与会话结束</strong></h3><ul>
<li><strong>关闭浏览器</strong>：测试脚本完成自动化操作后，通常会调用 <code>driver.quit()</code> 来结束浏览器会话，并关闭浏览器窗口。此时，浏览器驱动程序会接收到关闭浏览器的请求，执行相关操作并结束会话。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.quit()  <span class="hljs-comment"># 关闭浏览器</span><br></code></pre></td></tr></table></figure>

<h3 id="总结：Selenium-的工作流程"><a href="#总结：Selenium-的工作流程" class="headerlink" title="总结：Selenium 的工作流程"></a>总结：Selenium 的工作流程</h3><ol>
<li>selenium client(python等语言编写的自动化测试脚本)初始化一个service服务，通过Webdriver启动浏览器驱动程序chromedriver.exe </li>
<li>通过RemoteWebDriver向浏览器驱动程序发送HTTP请求，浏览器驱动程序解析请求，打开浏览器，并获得sessionid，如果再次对浏览器操作需携带此id </li>
<li>打开浏览器，绑定特定的端口，把启动后的浏览器作为webdriver的remote server </li>
<li>打开浏览器后，所有的selenium的操作(访问地址，查找元素等)均通过RemoteConnection链接到remote server，然后使用execute方法调用_request方法通过urlib3向remote server发送请求 </li>
<li>浏览器通过请求的内容执行对应动作 </li>
<li>浏览器再把执行的动作结果通过浏览器驱动程序返回给测试脚本</li>
</ol>
<h1 id="初步基本使用"><a href="#初步基本使用" class="headerlink" title="初步基本使用"></a>初步基本使用</h1><blockquote>
<p>初次接触的可以用：<a target="_blank" rel="noopener" href="https://seleniumbase.io/demo_page">Web Testing Page</a>练练手</p>
<p>如何使用—》重点观看官方文档就行了：<br><a target="_blank" rel="noopener" href="https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/">入门指南 | Selenium</a></p>
<p><a target="_blank" rel="noopener" href="https://selenium-python-docs-zh.readthedocs.io/zh-cn/latest/">Selenium Python 文档 — selenium-python-docs-zh 2.53.0 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://selenium-python-zh.readthedocs.io/en/latest/getting-started.html">2. 快速入门 — Selenium-Python中文文档 2 documentation</a></p>
</blockquote>
<blockquote>
<p>个人觉得重点在于如何定位元素和一些鼠标事件的触发</p>
<p>其中定位元素:xpath和css选择器是相对比较重要的，以后有时间单独出文章总结说明</p>
<p>鼠标事件之类的看看源码，多使用就知道了比如：</p>
</blockquote>
<p><img src="https://s2.loli.net/2025/01/17/3xqtUgojYhdbeav.png" srcset="/img/loading.gif" lazyload alt="image-20250117173104881"></p>
<p>下面是 <code>ActionChains</code> 类中各个方法的功能总结</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
<th><strong>参数</strong></th>
<th><strong>返回</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>__init__</code></strong></td>
<td>初始化 <code>ActionChains</code> 对象，创建一个动作链。</td>
<td>- <code>driver</code>: WebDriver 实例  - <code>duration</code>: 动作持续时间（默认 250ms）</td>
<td>无</td>
</tr>
<tr>
<td><strong><code>perform</code></strong></td>
<td>执行存储的所有操作。</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td><strong><code>reset_actions</code></strong></td>
<td>清除已经存储的操作。</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td><strong><code>click</code></strong></td>
<td>单击元素。</td>
<td>- <code>on_element</code>: 要点击的元素，默认为当前鼠标位置</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>click_and_hold</code></strong></td>
<td>按住左键在元素上。</td>
<td>- <code>on_element</code>: 要按住点击的元素，默认为当前鼠标位置</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>context_click</code></strong></td>
<td>右键点击（上下文点击）。</td>
<td>- <code>on_element</code>: 要右键点击的元素，默认为当前鼠标位置</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>double_click</code></strong></td>
<td>双击元素。</td>
<td>- <code>on_element</code>: 要双击的元素，默认为当前鼠标位置</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>drag_and_drop</code></strong></td>
<td>按住左键拖动源元素到目标元素。</td>
<td>- <code>source</code>: 要按住点击的源元素  - <code>target</code>: 目标元素</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>drag_and_drop_by_offset</code></strong></td>
<td>按住左键拖动源元素，然后移动到指定偏移位置并释放。</td>
<td>- <code>source</code>: 要按住点击的源元素  - <code>xoffset</code>: 水平偏移量  - <code>yoffset</code>: 垂直偏移量</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>key_down</code></strong></td>
<td>按下一个键，通常用于按住修饰键（如 Shift、Ctrl）。</td>
<td>- <code>value</code>: 要按下的键，来自 <code>Keys</code> 类  - <code>element</code>: 要发送键的元素（可选）</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>key_up</code></strong></td>
<td>释放一个键。</td>
<td>- <code>value</code>: 要释放的键，来自 <code>Keys</code> 类  - <code>element</code>: 要发送键的元素（可选）</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>move_by_offset</code></strong></td>
<td>将鼠标移动到当前位置的偏移量处。</td>
<td>- <code>xoffset</code>: 水平偏移量  - <code>yoffset</code>: 垂直偏移量</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>move_to_element</code></strong></td>
<td>将鼠标移动到元素的中间。</td>
<td>- <code>to_element</code>: 要移动到的 Web 元素</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>move_to_element_with_offset</code></strong></td>
<td>将鼠标移动到元素的中间，并按指定的偏移量调整位置。</td>
<td>- <code>to_element</code>: 要移动到的 Web 元素  - <code>xoffset</code>: 水平偏移量  - <code>yoffset</code>: 垂直偏移量</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>pause</code></strong></td>
<td>暂停所有操作，指定持续时间（秒）。</td>
<td>- <code>seconds</code>: 暂停的秒数</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>release</code></strong></td>
<td>在元素上释放鼠标按键。</td>
<td>- <code>on_element</code>: 要释放的元素，默认为当前鼠标位置</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>send_keys</code></strong></td>
<td>向当前焦点元素发送按键。</td>
<td>- <code>keys_to_send</code>: 要发送的按键，来自 <code>Keys</code> 类</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>send_keys_to_element</code></strong></td>
<td>向指定元素发送按键。</td>
<td>- <code>element</code>: 要发送按键的元素  - <code>keys_to_send</code>: 要发送的按键，来自 <code>Keys</code> 类</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>scroll_to_element</code></strong></td>
<td>将元素滚动到视口的底部。</td>
<td>- <code>element</code>: 要滚动到视口的元素</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>scroll_by_amount</code></strong></td>
<td>滚动指定的距离（水平和垂直）。</td>
<td>- <code>delta_x</code>: 水平滚动距离  - <code>delta_y</code>: 垂直滚动距离</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>scroll_from_origin</code></strong></td>
<td>从指定原点滚动指定的距离。</td>
<td>- <code>scroll_origin</code>: 滚动原点（元素或视口）  - <code>delta_x</code>: 水平滚动距离  - <code>delta_y</code>: 垂直滚动距离</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>scroll</code></strong></td>
<td>滚动指定的坐标和距离（已弃用）。</td>
<td>- <code>x</code>: 起始 X 坐标  - <code>y</code>: 起始 Y 坐标  - <code>delta_x</code>: 水平滚动距离  - <code>delta_y</code>: 垂直滚动距离  - <code>duration</code>: 滚动持续时间（毫秒）  - <code>origin</code>: 滚动原点（默认为 “viewport”）</td>
<td><code>ActionChains</code> (已弃用)</td>
</tr>
<tr>
<td><strong><code>__enter__</code></strong></td>
<td>允许 <code>ActionChains</code> 在 <code>with</code> 语句中作为上下文管理器使用。</td>
<td>无</td>
<td><code>ActionChains</code></td>
</tr>
<tr>
<td><strong><code>__exit__</code></strong></td>
<td>允许 <code>ActionChains</code> 在 <code>with</code> 语句中作为上下文管理器使用。</td>
<td>- <code>_type</code>, <code>_value</code>, <code>_traceback</code>: 上下文管理器传入的参数（通常不使用）</td>
<td>无</td>
</tr>
</tbody></table>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/" class="category-chain-item">全栈(数据采集处理)</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/" class="category-chain-item">数据采集处理</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" class="category-chain-item">爬虫基本知识</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/" class="print-no-link">#数据采集处理</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Selenium学习</div>
      <div>http://example.com/2025/05/09/全栈(数据采集处理)/数据采集处理/爬虫基本知识/Selenium使用/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/09/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式基本使用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">正则表达式基本使用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/09/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Scrapy%E4%BD%BF%E7%94%A8/" title="Scrapy初步使用">
                        <span class="hidden-mobile">Scrapy初步使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
