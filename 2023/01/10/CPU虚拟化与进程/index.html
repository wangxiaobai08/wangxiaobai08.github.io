

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="虚拟化(美丽的假象)假设一个计算机只有一个CPU，虚拟化要做的就是将这个CPU虚拟成多个虚拟CPU并分给每一个进程使用，通过时间分片调度和资源隔离技术，操作系统 会将这个物理 CPU 的使用时间切分成多个时间片，并分配给不同的进程或虚拟机使用。因此，每个应用都以为自己在独占CPU，但实际上只有一个CPU。这样操作系统就创造了美丽的假象——它虚拟化了CPU。 更好的实现CPU的虚拟化机制(受限直接执">
<meta property="og:type" content="article">
<meta property="og:title" content="CPU虚拟化与进程">
<meta property="og:url" content="http://example.com/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="虚拟化(美丽的假象)假设一个计算机只有一个CPU，虚拟化要做的就是将这个CPU虚拟成多个虚拟CPU并分给每一个进程使用，通过时间分片调度和资源隔离技术，操作系统 会将这个物理 CPU 的使用时间切分成多个时间片，并分配给不同的进程或虚拟机使用。因此，每个应用都以为自己在独占CPU，但实际上只有一个CPU。这样操作系统就创造了美丽的假象——它虚拟化了CPU。 更好的实现CPU的虚拟化机制(受限直接执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/QWOf38Za9AJXYgI.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/sUVZq4RxSLJcn5p.png">
<meta property="og:image" content="c:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222175204613.png">
<meta property="og:image" content="c:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222180155226.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/NDSmHrP96vz3URs.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/g7KiEPcd14eRoOB.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/29/WOejUv2nhb1Rqox.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/29/lKU72cAyIfePCkz.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/04/5SezB2FfjdOTKxr.png">
<meta property="article:published_time" content="2023-01-10T12:58:14.000Z">
<meta property="article:modified_time" content="2025-01-04T08:24:27.112Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/12/22/QWOf38Za9AJXYgI.png">
  
  
  
  <title>CPU虚拟化与进程 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CPU虚拟化与进程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-10 20:58" pubdate>
          2023年1月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          105 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CPU虚拟化与进程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="虚拟化-美丽的假象"><a href="#虚拟化-美丽的假象" class="headerlink" title="虚拟化(美丽的假象)"></a>虚拟化(美丽的假象)</h1><p>假设一个计算机只有一个CPU，虚拟化要做的就是将这个CPU虚拟成多个虚拟CPU并分给每一个进程使用，通过<strong>时间分片调度</strong>和<strong>资源隔离</strong>技术，操作系统 会将这个物理 CPU 的使用时间切分成多个时间片，并分配给不同的进程或虚拟机使用。因此，每个应用都以为自己在独占CPU，但实际上只有一个CPU。这样操作系统就创造了美丽的假象——它虚拟化了CPU。</p>
<h2 id="更好的实现CPU的虚拟化"><a href="#更好的实现CPU的虚拟化" class="headerlink" title="更好的实现CPU的虚拟化"></a>更好的实现CPU的虚拟化</h2><h3 id="机制-受限直接执行"><a href="#机制-受限直接执行" class="headerlink" title="机制(受限直接执行)"></a>机制(受限直接执行)</h3><h4 id="第一个是性能：如何在不增加系统开销的情况下实现虚拟化？"><a href="#第一个是性能：如何在不增加系统开销的情况下实现虚拟化？" class="headerlink" title="第一个是性能：如何在不增加系统开销的情况下实现虚拟化？"></a>第一个是性能：如何在不增加系统开销的情况下实现虚拟化？</h4><p>只需直接在CPU上运行程序即可。因此，当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。表6.1展示了这种基本的直接执行协议（没有任何限制），使用正常的调用并返回跳转到程序的main()，并在稍后回到内核。</p>
<p><img src="https://s2.loli.net/2024/12/22/QWOf38Za9AJXYgI.png" srcset="/img/loading.gif" lazyload alt="image-20241222173814892"></p>
<h4 id="第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？"><a href="#第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？" class="headerlink" title="第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？"></a>第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？</h4><p>控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息。</p>
<h5 id="一个进程必须能够执行I-O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？"><a href="#一个进程必须能够执行I-O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？" class="headerlink" title="一个进程必须能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？"></a>一个进程必须能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？</h5><p>引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出I&#x2F;O请求。这样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出I&#x2F;O请求和执行所有类型的受限指令。</p>
<h6 id="如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？"><a href="#如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？" class="headerlink" title="如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？"></a>如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？</h6><p>提供用户程序执行系统调用的能力。它允许内核小心地向用户程序暴露某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。</p>
<p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</p>
<p><strong>陷阱如何知道在OS内运行哪些代码？</strong></p>
<p>发起调用的过程不能指定要跳转到的地址，这样做让程序可以跳转到内核中的任意位置，这显然是一个糟糕的主意（想象一下跳到访问文件的代码，但在权限检查之后。实际上，这种能力很可能让一个狡猾的程序员令内核运行任意代码序列）。因此内核必须谨慎地控制在陷阱上执行的代码。</p>
<p>内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码？操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器，并且硬件知道在发生系统调用和其他异常事件时要做什么（即跳转到哪段代码）。</p>
<img src="https://s2.loli.net/2024/12/22/sUVZq4RxSLJcn5p.png" srcset="/img/loading.gif" lazyload alt="image-20241222174427511" style="zoom:25%;" />

<h5 id="操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？"><a href="#操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？" class="headerlink" title="操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？"></a>操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？</h5><p>悖论：如果一个进程在CPU上运行，这就意味着操作系统没有运行。如果操作系统没有运行，它怎么能做事情？</p>
<h6 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h6><p>操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务。大多数进程通过进行系统调用，将CPU的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程。像这样的系统通常包括一个显式的yield系统调用，它什么都不干，只是将控制权交给操作系统，以便系统可以运行其他进程。</p>
<p>如果应用程序执行了某些非法操作，也会将控制转移给操作系统。例如，如果应用程序以0为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制CPU（并可能终止违规进程）。</p>
<p>缺点：如果某个进程（无论是恶意的还是充满缺陷的）进入无限循环，并且从不进行系统调用，会发生什么情况？那时操作系统能做什么？</p>
<p>即使进程不协作，操作系统如何获得CPU的控制权？操作系统可以做什么来确保流氓进程不会占用机器？</p>
<h6 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h6><blockquote>
<p>时钟中断（timer interrupt）[M+63]。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p>
</blockquote>
<p>首先，操作系统必须通知硬件哪些代码在发生时钟中断时运行。因此，在启动时，操作系统就是这样做的。其次，在启动过程中，操作系统也必须启动时钟，这当然是一项特权操作。一旦时钟开始运行，操作系统就感到安全了，因为控制权最终会归还给它，因此操作系统可以自由运行用户程序。时钟也可以关闭（也是特权操作），</p>
<h6 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h6><p>当操作系统重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断更强制执行，都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。</p>
<p>如果决定进行切换，OS就会执行一些底层代码，即所谓的上下文切换（context switch）。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p>
<p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p>
<img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222175204613.png" srcset="/img/loading.gif" lazyload alt="2" style="zoom:25%;" />

<p>在此协议中，有两种类型的寄存器保存&#x2F;恢复。第一种是发生时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从A切换到B。在这种情况下，内核寄存器被软件（即OS）明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由A陷入内核，变成好像刚刚由B陷入内核。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p><strong>该如何开发一个考虑调度策略的基本框架？什么是关键假设？哪些指标非常重要？</strong></p>
<blockquote>
<p>进程调度算法有很多也很重要这里只做概览性简单介绍，后续会单独讲解</p>
</blockquote>
<p><strong>进程调度</strong>是指操作系统为多个进程分配CPU资源的机制，它决定了在任意时刻哪个进程可以使用CPU进行执行。由于系统资源（尤其是CPU）是有限的，而进程通常多于可用的资源，因此需要通过进程调度来公平、高效地管理资源使用。</p>
<hr>
<h4 id="进程调度的核心内容"><a href="#进程调度的核心内容" class="headerlink" title="进程调度的核心内容"></a><strong>进程调度的核心内容</strong></h4><table>
<thead>
<tr>
<th><strong>内容</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>调度目标</strong></td>
<td>在多任务系统中高效利用资源，减少等待时间，保证系统响应和吞吐量。</td>
</tr>
<tr>
<td><strong>调度时机</strong></td>
<td>- <strong>进程状态变化时</strong>（如运行态到阻塞态）。- <strong>时间片到期</strong>。</td>
</tr>
<tr>
<td><strong>调度算法</strong></td>
<td>操作系统采用的算法决定了进程调度的公平性与效率。</td>
</tr>
<tr>
<td><strong>调度方式</strong></td>
<td>可分为抢占式调度和非抢占式调度。</td>
</tr>
</tbody></table>
<hr>
<h4 id="进程调度的关键步骤"><a href="#进程调度的关键步骤" class="headerlink" title="进程调度的关键步骤"></a><strong>进程调度的关键步骤</strong></h4><table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 进程分类</strong></td>
<td>区分就绪、运行、阻塞等状态的进程。</td>
</tr>
<tr>
<td><strong>2. 选择进程</strong></td>
<td>根据调度算法从就绪队列中选取一个进程。</td>
</tr>
<tr>
<td><strong>3. 分配资源</strong></td>
<td>将CPU资源分配给选定的进程，并切换上下文。</td>
</tr>
<tr>
<td><strong>4. 开始运行</strong></td>
<td>进程获得CPU后，从上次暂停处继续执行或从头开始执行。</td>
</tr>
</tbody></table>
<hr>
<h4 id="常见的调度算法"><a href="#常见的调度算法" class="headerlink" title="常见的调度算法"></a><strong>常见的调度算法</strong></h4><table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>说明</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>先来先服务（FCFS）</strong></td>
<td>按到达顺序调度进程，简单但可能导致较长的等待时间。</td>
<td>任务简单、实时性要求不高的系统。</td>
</tr>
<tr>
<td><strong>短作业优先（SJF）</strong></td>
<td>优先调度执行时间最短的进程，可能会导致长任务饥饿。</td>
<td>作业时间可预测的批处理系统。</td>
</tr>
<tr>
<td><strong>时间片轮转（RR）</strong></td>
<td>每个进程分配固定时间片，时间到则切换到下一个进程。</td>
<td>交互式系统，例如桌面操作系统。</td>
</tr>
<tr>
<td><strong>优先级调度</strong></td>
<td>根据进程优先级调度，优先级高的进程先运行。</td>
<td>实时系统或对任务重要性有要求的环境。</td>
</tr>
<tr>
<td><strong>多级反馈队列调度</strong></td>
<td>根据进程特性动态调整优先级，综合性较强。</td>
<td>通用系统，例如桌面和服务器操作系统。</td>
</tr>
</tbody></table>
<hr>
<h4 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a><strong>调度方式</strong></h4><table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>非抢占式调度</strong></td>
<td>进程一旦占用CPU，直到主动放弃或阻塞，才切换到其他进程。</td>
</tr>
<tr>
<td><strong>抢占式调度</strong></td>
<td>操作系统可以强制中断正在运行的进程，将CPU分配给其他进程。</td>
</tr>
</tbody></table>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程（Process）是操作系统中程序的一个运行实例<strong>。它是程序在计算机上的一次</strong>动态执行，包括程序代码和其运行时需要的所有资源。从操作系统的角度看，进程是资源分配的最小单位，也是程序执行的基本单位。【进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。】</p>
<p><strong>进程的机器状态构成</strong>：程序在运行时可以读取或更新的内容。在任何时刻，机器的哪些部分对执行该程序很重要。</p>
<ul>
<li>内存：指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分。</li>
<li>寄存器：许多指令明确地读取或更新寄存器，因此显然，它们对于执行该进程很重要。</li>
<li>I&#x2F;O信息：程序也经常访问持久存储设备。此类I&#x2F;O信息可能包含当前打开的文件列表。</li>
</ul>
<p><strong>如何将程序转化为进程？</strong></p>
<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 调用系统接口</strong></td>
<td>使用系统调用创建进程，例如：<code>fork()</code>（Linux）或 <code>CreateProcess()</code>（Windows）。</td>
</tr>
<tr>
<td><strong>2. 分配资源</strong></td>
<td>为进程分配内存（代码段、数据段、栈段）、文件句柄、I&#x2F;O 缓冲区等。</td>
</tr>
<tr>
<td><strong>3. 加载程序</strong></td>
<td>将程序的代码和数据从磁盘加载到内存，并为其分配独立的地址空间。</td>
</tr>
<tr>
<td><strong>4. 初始化 PCB</strong></td>
<td>设置进程控制块（PCB），记录进程 ID、状态、程序计数器等信息。</td>
</tr>
<tr>
<td><strong>5. 设置运行环境</strong></td>
<td>初始化寄存器、栈指针，设置全局变量和静态变量的初始值。</td>
</tr>
<tr>
<td><strong>6. 加入调度队列</strong></td>
<td>将新创建的进程放入操作系统的就绪队列，等待调度器分配 CPU。</td>
</tr>
<tr>
<td><strong>7. 开始执行</strong></td>
<td>调度器分配 CPU 后，进程从入口地址（如 <code>main()</code>）开始执行。</td>
</tr>
</tbody></table>
<h2 id="进程状态及其演变"><a href="#进程状态及其演变" class="headerlink" title="进程状态及其演变"></a>进程状态及其演变</h2><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222180155226.png" srcset="/img/loading.gif" lazyload alt="3"></p>
<h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><p>为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——**进程控制块PCB(Process Control Block)**，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。操作系统通过PCB来跟踪和控制进程的运行状态。</p>
<h4 id="PCB-的作用机制"><a href="#PCB-的作用机制" class="headerlink" title="PCB 的作用机制"></a><strong>PCB 的作用机制</strong></h4><ol>
<li><strong>进程切换时的角色</strong><ul>
<li>当发生进程切换时，操作系统将当前进程的CPU状态保存到PCB中，并从新进程的PCB中恢复CPU状态。</li>
<li>PCB中的上下文信息决定了进程可以从上次暂停的位置继续执行。</li>
</ul>
</li>
<li><strong>进程调度中的作用</strong><ul>
<li>调度器通过PCB判断进程的状态、优先级等信息，从而选择适合的进程运行。</li>
</ul>
</li>
<li><strong>进程通信中的作用</strong><ul>
<li>PCB中记录了进程间通信所需的信息，如共享内存的指针等。</li>
</ul>
</li>
</ol>
<h4 id="PCB-的组成"><a href="#PCB-的组成" class="headerlink" title="PCB 的组成"></a><strong>PCB 的组成</strong></h4><table>
<thead>
<tr>
<th><strong>部分</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 进程标识信息</strong></td>
<td>- <strong>进程ID</strong>：唯一标识进程的ID号。 - <strong>父进程ID</strong>：创建它的父进程的ID号。</td>
</tr>
<tr>
<td><strong>2. 进程状态信息</strong></td>
<td>- 当前进程的状态（如就绪、运行、阻塞）。 - 优先级、调度信息等。</td>
</tr>
<tr>
<td><strong>3. CPU寄存器信息</strong></td>
<td>- 进程切换时保存的寄存器值，如程序计数器、堆栈指针等。</td>
</tr>
<tr>
<td><strong>4. 内存管理信息</strong></td>
<td>- 指向进程地址空间的指针（如页表指针）。</td>
</tr>
<tr>
<td><strong>5. 文件管理信息</strong></td>
<td>- 进程打开的文件列表、文件描述符表等。</td>
</tr>
<tr>
<td><strong>6. 资源分配信息</strong></td>
<td>- 占用的资源信息（如I&#x2F;O设备、信号量等）。</td>
</tr>
<tr>
<td><strong>7. 其他信息</strong></td>
<td>- 进程所属用户信息、信号处理机制等。</td>
</tr>
</tbody></table>
<h4 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h4><p><strong>线性方式</strong>：将系统种所有PCB都组织在一张线性表中，将该表首地址存在内存的一个专用区域<br>实现简单，开销小，但是每次都需要扫描整张表，适合进程数目不多的系统</p>
<p><strong>链接方式</strong>：把同一状态的PCB链接成一个队列，形成就绪队列、若干个阻塞队列和空白队列等<br>对其中的就绪队列常按进程优先级的高低排列，优先级高排在队前，此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I&#x2F;O 操作完成的队列和等待分配内存的队列等</p>
<img src="https://s2.loli.net/2024/12/22/NDSmHrP96vz3URs.png" srcset="/img/loading.gif" lazyload alt="1" style="zoom: 50%;" />

<p><strong>索引方式</strong>：系统根据所有进程的状态建立几张索引表，例如就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中，在每个索引表的表目中，记录具有相应状态的某个PCB在PCB址</p>
<img src="https://s2.loli.net/2024/12/22/g7KiEPcd14eRoOB.png" srcset="/img/loading.gif" lazyload alt="2" style="zoom:50%;" />

<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><h4 id="什么是父子进程？"><a href="#什么是父子进程？" class="headerlink" title="什么是父子进程？"></a>什么是父子进程？</h4><p>在 Unix 和 Linux中，每个进程都有一个唯一的进程标识符（PID），以及一个父进程标识符（PPID），这两个值使得子进程能够知道它们的父进程是什么。</p>
<ol>
<li><strong>PID（Process ID）</strong>：这是操作系统分配给每个进程的唯一标识符。每个进程都有一个唯一的 PID。</li>
<li><strong>PPID（Parent Process ID）</strong>：这是进程的父进程的 PID。PPID 指示了哪个进程创建了当前进程。</li>
</ol>
<p>当进程 A 调用 <code>fork()</code> 时，会创建一个子进程 B。对于子进程 B，它的 PPID 会被设置为进程 A 的 PID。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Process</span> A: PID = <span class="hljs-number">12345</span><br>Parent process: PID = <span class="hljs-number">12345</span>, Child PID = <span class="hljs-number">12346</span><br>Child process: PID = <span class="hljs-number">12346</span>, PPID = <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<p><strong>同时父进程会获得一个非零的PID（子进程的PID），而子进程会获得0作为返回值。这使得我们可以通过检查返回值的大小来区分父子进程</strong></p>
<p><strong>注意这里的返回0并不是将子进程PID设为0</strong>，而是出于以下方面考虑：</p>
<ul>
<li><p><strong>区分父进程和子进程的执行流</strong></p>
<p>当调用 <code>fork()</code> 时，会创建一个新的子进程。<code>fork()</code> 在父进程中返回子进程的 PID，而在子进程中返回 0。这种设计让同一段代码能够在两个不同的进程中执行不同的逻辑。</p>
</li>
<li><p><strong>简化错误处理</strong></p>
<p>如果 <code>fork()</code> 返回一个负值（通常是 -1），这表明进程创建失败。父进程可以立即检查这个返回值并进行相应的错误处理。</p>
</li>
<li><p><strong>方便进程间通信和同步</strong></p>
<p>由于 <code>fork()</code> 在子进程中返回 0，父进程可以使用返回的子进程 PID 来进行进程间的通信和同步操作。例如，父进程可以等待子进程结束，或者通过信号与子进程进行通信。</p>
</li>
<li><p><strong>实现多进程并发</strong></p>
<p><code>fork()</code> 机制使得多进程并发编程变得简单。父进程可以连续调用 <code>fork()</code> 多次，创建多个子进程来处理不同的任务或相同任务的不同部分，从而实现并发处理。</p>
</li>
</ul>
<h4 id="1-进程创建阶段"><a href="#1-进程创建阶段" class="headerlink" title="1. 进程创建阶段"></a><strong>1. 进程创建阶段</strong></h4><table>
<thead>
<tr>
<th>阶段</th>
<th>实现原理</th>
<th>父子进程关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>分配标识</strong></td>
<td>操作系统为每个新进程分配唯一的进程ID（PID），并在PCB表中为其预留存储位置。</td>
<td>父进程通过系统调用（如 <code>fork()</code>）创建子进程，子进程获得一个新的PID。</td>
</tr>
<tr>
<td><strong>分配资源</strong></td>
<td>- 内存分配：分配进程代码段、数据段和堆栈段的内存空间。- 文件表：初始化文件描述符表。</td>
<td>子进程继承父进程的部分资源（如文件描述符、内存空间的副本）。</td>
</tr>
<tr>
<td><strong>初始化PCB</strong></td>
<td>初始化PCB内容，包括进程状态设为“就绪”，设置优先级、调度信息等。</td>
<td>父进程创建子进程时，操作系统会为子进程初始化PCB并赋予初始状态。</td>
</tr>
<tr>
<td><strong>添加到队列</strong></td>
<td>将新创建的PCB插入到就绪队列中，等待调度程序选中执行。</td>
<td>父进程和子进程的PCB都被添加到就绪队列中，操作系统会调度执行。</td>
</tr>
</tbody></table>
<h4 id="2-进程执行阶段"><a href="#2-进程执行阶段" class="headerlink" title="2. 进程执行阶段"></a><strong>2. 进程执行阶段</strong></h4><table>
<thead>
<tr>
<th>阶段</th>
<th>实现原理</th>
<th>父子进程关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>调度选择</strong></td>
<td>调度程序根据进程调度算法（如时间片轮转、优先级调度等），从就绪队列中选取合适进程。</td>
<td>父进程和子进程都在就绪队列中，操作系统根据调度算法选择其中一个进程执行。</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>- 保存当前运行进程的CPU状态（如寄存器内容、程序计数器）到PCB。- 恢复新进程的CPU状态。</td>
<td>在父进程和子进程之间，操作系统通过上下文切换保存和恢复进程的状态。</td>
</tr>
<tr>
<td><strong>执行控制</strong></td>
<td>CPU执行新进程的指令，同时操作系统监控该进程的运行，处理系统调用、中断等事件。</td>
<td>父进程和子进程在独立的进程空间中执行，操作系统管理并监控它们的运行。</td>
</tr>
</tbody></table>
<h4 id="3-进程阻塞阶段"><a href="#3-进程阻塞阶段" class="headerlink" title="3. 进程阻塞阶段"></a><strong>3. 进程阻塞阶段</strong></h4><table>
<thead>
<tr>
<th>阶段</th>
<th>实现原理</th>
<th>父子进程关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态更新</strong></td>
<td>操作系统将进程的状态从“运行”改为“阻塞”，更新PCB中的状态字段。</td>
<td>父进程和子进程都可以进入阻塞状态，当它们等待资源或事件时，操作系统会更新其PCB。</td>
</tr>
<tr>
<td><strong>队列管理</strong></td>
<td>将进程从运行队列移至等待队列，等待资源或事件完成后重新激活。</td>
<td>被阻塞的父进程或子进程会被移至等待队列，直到事件触发后再次唤醒。</td>
</tr>
<tr>
<td><strong>资源释放</strong></td>
<td>在阻塞时释放占用的CPU资源，允许调度程序将CPU分配给其他就绪进程。</td>
<td>阻塞的进程（父进程或子进程）释放CPU资源，操作系统可调度其他进程执行。</td>
</tr>
</tbody></table>
<h4 id="4-进程唤醒阶段"><a href="#4-进程唤醒阶段" class="headerlink" title="4. 进程唤醒阶段"></a><strong>4. 进程唤醒阶段</strong></h4><table>
<thead>
<tr>
<th>阶段</th>
<th>实现原理</th>
<th>父子进程关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>事件触发</strong></td>
<td>某事件（如I&#x2F;O完成、信号量释放）触发时，通知操作系统唤醒等待的进程。</td>
<td>子进程阻塞后，当事件触发时，操作系统会唤醒子进程，父进程也可以因为等待子进程结果而被唤醒。</td>
</tr>
<tr>
<td><strong>状态更新</strong></td>
<td>将进程状态从“阻塞”修改为“就绪”，并更新PCB。</td>
<td>被唤醒的进程（父进程或子进程）会更新其PCB状态为“就绪”。</td>
</tr>
<tr>
<td><strong>队列操作</strong></td>
<td>将该进程的PCB从等待队列移至就绪队列，等待调度程序再次选中运行。</td>
<td>父进程和子进程的PCB会移至就绪队列，等待操作系统再次调度。</td>
</tr>
</tbody></table>
<h4 id="5-进程终止阶段"><a href="#5-进程终止阶段" class="headerlink" title="5. 进程终止阶段"></a><strong>5. 进程终止阶段</strong></h4><table>
<thead>
<tr>
<th>阶段</th>
<th>实现原理</th>
<th>父子进程关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>释放资源</strong></td>
<td>- 内存释放：释放分配给进程的内存区域。- 文件关闭：关闭进程打开的文件。</td>
<td>子进程在终止时，释放资源，父进程回收子进程的资源。</td>
</tr>
<tr>
<td><strong>更新PCB</strong></td>
<td>修改PCB状态为“终止”，从进程表中移除对应记录。</td>
<td>父进程可能需要处理子进程的终止，更新父进程的状态和资源。</td>
</tr>
<tr>
<td><strong>回收PID</strong></td>
<td>将进程ID (PID) 回收到操作系统的可用PID池中。</td>
<td>子进程终止后，其PID被回收，操作系统可分配给新创建的进程。</td>
</tr>
<tr>
<td><strong>通知父进程</strong></td>
<td>如果是子进程终止，向父进程发送通知（如信号）以处理终止后的资源回收。</td>
<td>操作系统通过信号（如 <code>SIGCHLD</code>）通知父进程子进程的终止，父进程可回收子进程的资源。</td>
</tr>
</tbody></table>
<h4 id="6-异常处理阶段"><a href="#6-异常处理阶段" class="headerlink" title="6. 异常处理阶段"></a><strong>6. 异常处理阶段</strong></h4><table>
<thead>
<tr>
<th>阶段</th>
<th>实现原理</th>
<th>父子进程关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>中断触发</strong></td>
<td>当异常发生时，硬件触发中断信号，并将控制权交给操作系统内核的异常处理程序。</td>
<td>如果父进程或子进程发生异常，操作系统通过中断处理并决定是否终止进程。</td>
</tr>
<tr>
<td><strong>状态保存</strong></td>
<td>操作系统保存当前进程的状态，以便后续恢复或终止。</td>
<td>操作系统在处理父进程或子进程的异常时，保存进程状态并采取适当措施。</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>- 执行适当的处理策略： 1. 终止进程（如访问非法内存）。 2. 恢复运行（如页错误处理）。</td>
<td>异常可能导致父进程或子进程的终止或恢复。</td>
</tr>
<tr>
<td><strong>日志记录</strong></td>
<td>操作系统记录异常信息（如错误码、进程ID）以供系统管理员或开发者调试。</td>
<td>异常处理日志有助于父进程和子进程的调试和故障排除。</td>
</tr>
</tbody></table>
<h4 id="其他进程创建方式"><a href="#其他进程创建方式" class="headerlink" title="其他进程创建方式"></a>其他进程创建方式</h4><table>
<thead>
<tr>
<th><strong>创建方式</strong></th>
<th><strong>描述</strong></th>
<th><strong>典型例子</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>父进程创建子进程</strong></td>
<td>最常见的进程创建方式，父进程通过系统调用（如 <code>fork()</code> 或 <code>CreateProcess()</code>）创建子进程，子进程继承父进程的部分属性。</td>
<td>- Unix&#x2F;Linux：<code>fork()</code>- Windows：<code>CreateProcess()</code></td>
</tr>
<tr>
<td><strong>操作系统初始化进程</strong></td>
<td>操作系统在启动时直接创建一些基础进程，例如初始化进程（如 <code>init</code> 或 <code>systemd</code>）。</td>
<td>- Linux：<code>init</code> 或 <code>systemd</code>- Windows：<code>System</code></td>
</tr>
<tr>
<td><strong>内核进程</strong></td>
<td>内核或系统进程在启动时由操作系统内核直接创建，不依赖传统的父进程。这些进程通常由内核的初始化逻辑启动。</td>
<td>- Linux：<code>kthreadd</code>（内核线程）- Windows：内核线程</td>
</tr>
<tr>
<td><strong>线程创建</strong></td>
<td>线程是进程中的轻量级任务，线程由进程创建，但并非子进程。它们共享进程的资源，如内存空间和文件描述符。</td>
<td>- Linux&#x2F;Windows：线程由进程（父进程）创建，通常通过 <code>pthread_create()</code> 或 <code>CreateThread()</code> 调用。</td>
</tr>
<tr>
<td><strong>自身创建（自我复制）</strong></td>
<td>某些程序（如恶意软件或病毒）可能通过自身复制来创建新的进程，而不依赖任何特定的父进程。</td>
<td>- 恶意软件&#x2F;病毒通过 <code>fork()</code> 或其他方法自我复制。</td>
</tr>
</tbody></table>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步是指多个进程在并发执行时，为了避免由于共享资源访问冲突而导致的不一致性或错误，采取的一些技术手段和机制。进程同步的目的是确保多个进程在执行时能够协调一致地访问共享资源，以避免竞态条件（race condition）、数据不一致等问题。</p>
<blockquote>
<p>这一部分将在后来文章的并发部分介绍</p>
</blockquote>
<h2 id="进程通信（IPC）"><a href="#进程通信（IPC）" class="headerlink" title="进程通信（IPC）"></a>进程通信（IPC）</h2><p>进程通信主要解决的是 <strong>如何在不同进程之间传递信息或共享数据</strong>。当多个进程需要交换数据、共享资源时，操作系统提供不同的进程通信机制。</p>
<h3 id="1-管道（Pipe）"><a href="#1-管道（Pipe）" class="headerlink" title="1. 管道（Pipe）"></a>1. <strong>管道（Pipe）</strong></h3><p>Linux的管道机制允许一个进程的输出直接作为另一个进程的输入，从而实现进程间的通信（IPC）。管道有两种：无名管道和命名管道（FIFO）。无名管道通常用于具有亲缘关系的进程之间的通信（如父子进程），而命名管道可以用于任意两个进程之间的通信。</p>
<h4 id="管道的工作原理"><a href="#管道的工作原理" class="headerlink" title="管道的工作原理"></a>管道的工作原理</h4><p>管道在内核中创建一个缓冲区，一个进程可以向缓冲区写入数据，另一个进程可以从缓冲区读取数据。管道是单向的，即数据只能单方向流动。</p>
<p><img src="https://s2.loli.net/2024/05/29/WOejUv2nhb1Rqox.png" srcset="/img/loading.gif" lazyload alt="20200730212919317"></p>
<h4 id="管道通信与共享内存通信有何区别？"><a href="#管道通信与共享内存通信有何区别？" class="headerlink" title="管道通信与共享内存通信有何区别？"></a>管道通信与共享内存通信有何区别？</h4><p>管道通信适用于有亲缘关系的进程，适合简单的数据传输；而共享内存通信适用于无亲缘关系的进程，适合大量数据共享和对性能要求较高的场景</p>
<h5 id="管道通信："><a href="#管道通信：" class="headerlink" title="管道通信："></a><strong>管道通信：</strong></h5><ol>
<li>管道是一种半双工的通信机制，只能在具有亲缘关系的进程之间使用（例如父子进程）。</li>
<li>管道是基于 I&#x2F;O 流的通信方式，数据写入管道的一端，从另一端读出。</li>
<li>管道通信是通过操作系统提供的管道文件进行的，可以是匿名管道（只存在于进程间）或命名管道（存在于文件系统中）。</li>
<li>管道通信适用于需要在两个相关进程之间进行简单数据传输的场景。</li>
</ol>
<p><strong>共享内存通信：</strong></p>
<ol>
<li>共享内存是一种进程间通信的机制，可以在无亲缘关系的进程之间使用。</li>
<li>共享内存允许多个进程访问同一块物理内存空间，因此可以实现高效的数据共享。</li>
<li>共享内存通信需要使用操作系统提供的共享内存 API，通过映射共享内存区域来实现进程间数据共享。</li>
<li>共享内存通信适用于需要大量数据交换且对性能要求较高的场景，因为它避免了数据复制的开销。</li>
</ol>
<h5 id="使用管道的步骤"><a href="#使用管道的步骤" class="headerlink" title="使用管道的步骤"></a>使用管道的步骤</h5><ol>
<li><strong>创建管道</strong>：使用 <code>pipe()</code> 系统调用创建一个无名管道。</li>
<li><strong>创建子进程</strong>：使用 <code>fork()</code> 创建子进程。</li>
<li><strong>重定向输入&#x2F;输出</strong>：使用 <code>dup2()</code> 将管道的读或写端重定向到标准输入或标准输出。</li>
<li><strong>关闭不需要的管道端</strong>：父进程和子进程都要关闭各自不需要使用的管道端。</li>
<li><strong>执行程序</strong>：使用 <code>execlp()</code> 或其他 <code>exec</code> 函数执行新程序。</li>
</ol>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello from parent process!&quot;</span>;<br><br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">if</span> (pipe(pipe_fd) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br><br>        <span class="hljs-comment">// 读取管道</span><br>        <span class="hljs-type">ssize_t</span> nbytes = read(pipe_fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// 打印读取到的消息</span><br>        buf[nbytes] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child received message: %s\n&quot;</span>, buf);<br><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br><br>        <span class="hljs-comment">// 写入管道</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[<span class="hljs-number">1</span>], msg, <span class="hljs-built_in">strlen</span>(msg)) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        wait(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中<code>pipe()</code> 创建一个无名管道，<code>pipe_fd</code> 是一个包含两个文件描述符的数组，<code>pipe_fd[0]</code> 是读端，<code>pipe_fd[1]</code> 是写端。</p>
<p>在这个示例中没有使用 <code>dup2()</code> 重定向输入&#x2F;输出，而是直接使用文件描述符进行读写。你也可以通过 <code>dup2(pipe_fd[0], STDIN_FILENO)</code> 或 <code>dup2(pipe_fd[1], STDOUT_FILENO)</code> 来重定向标准输入&#x2F;输出。</p>
<p><strong>注意:当父进程fork()出子进程时，子进程会继承父进程的文件描述符。因此，子进程可以直接使用这些继承而来的文件描述符来读取或写入数据，从而与父进程进行通信。而无需使用<code>dup2()</code>来重定向输入&#x2F;输出。</strong></p>
<p>将管道的读端重定向到标准输入或将管道的写端重定向到标准输出是实现进程间通信的一种常见方式。这种方法可以实现多个进程之间的数据传输，而无需使用临时文件进行交换。</p>
<p>例如，如果一个进程需要从另一个进程中读取数据，可以通过将管道的读端重定向到标准输入来实现。这样，另一个进程输出的数据就会被发送到管道中，而第一个进程可以通过标准输入读取这些数据。</p>
<p>这种方法的好处在于，它提供了一种简单而高效的方式让不同的进程之间进行数据交换，而不需要创建临时文件或者复杂的通信协议。这对于实现诸如管道、重定向、过滤器等功能非常有用，同时也能够方便地实现进程间的通信和协作</p>
<h3 id="2-消息队列（Message-Queue）"><a href="#2-消息队列（Message-Queue）" class="headerlink" title="2. 消息队列（Message Queue）"></a>2. <strong>消息队列（Message Queue）</strong></h3><p>消息队列是一种允许进程以消息的形式进行通信的机制，多个进程可以向同一个队列中写入消息或从队列中读取消息。</p>
<ul>
<li>特点<ul>
<li>提供异步通信。</li>
<li>进程可以读取消息队列中的消息，或将消息发送到队列。</li>
<li>消息队列通常具有先进先出（FIFO）的顺序。</li>
</ul>
</li>
<li><strong>使用场景</strong>：适用于多个进程间异步交换数据的场景。</li>
</ul>
<h3 id="3-共享内存（Shared-Memory）"><a href="#3-共享内存（Shared-Memory）" class="headerlink" title="3. 共享内存（Shared Memory）"></a>3. <strong>共享内存（Shared Memory）</strong></h3><p>共享内存是一种允许多个进程访问同一块内存区域的通信方式。共享内存的读写操作直接在内存中进行，因此速度非常快。</p>
<ul>
<li>特点<ul>
<li>高效，因为直接操作内存而不需要通过内核。</li>
<li>需要同步机制（如互斥锁、信号量）来防止多个进程同时访问共享内存导致的数据竞争。</li>
</ul>
</li>
<li><strong>使用场景</strong>：适用于需要大量数据交换或频繁通信的进程。</li>
</ul>
<h3 id="4-信号量（Semaphore）"><a href="#4-信号量（Semaphore）" class="headerlink" title="4. 信号量（Semaphore）"></a>4. <strong>信号量（Semaphore）</strong></h3><p>信号量通常用于同步进程，它也可以用于进程间通信，特别是在控制资源访问时。信号量用于控制对共享资源的访问数量，通常配合其他IPC机制使用。</p>
<ul>
<li>特点<ul>
<li>可以用于同步多个进程的执行顺序。</li>
<li>信号量的值可以表示资源的数量或者进程的状态（如是否可继续执行）。</li>
</ul>
</li>
<li><strong>使用场景</strong>：用于控制访问资源的同步机制，常与其他IPC方式结合使用。</li>
</ul>
<h3 id="5-信号（Signal）"><a href="#5-信号（Signal）" class="headerlink" title="5. 信号（Signal）"></a>5. <strong>信号（Signal）</strong></h3><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="https://s2.loli.net/2024/05/29/lKU72cAyIfePCkz.png" srcset="/img/loading.gif" lazyload alt="ef5085c798d54fc081611d0d488dfeb1"></p>
<blockquote>
<p><strong>信号</strong>：信号是 Linux 进程间通信的一种简单机制。它是由操作系统或进程向另一个进程发送的软件中断，用于通知进程发生了某种事件。</p>
<p><strong>信号处理程序</strong>：每个信号都与一个信号处理程序相关联，用于在收到信号时执行特定的操作。信号处理程序可以是预定义的函数，也可以是用户自定义的函数。</p>
<p><strong>信号的发送和接收</strong>：信号可以由内核、其他进程或进程自身发送。接收信号的进程可以选择忽略信号、执行默认操作或安装自定义的信号处理程序。</p>
<p><strong>常见的信号</strong>：Linux 系统定义了许多标准信号，如 SIGALRM（定时器到期）、SIGINT（终端中断）、SIGKILL（强制终止进程）等。</p>
<p><strong>信号的处理方式</strong>：每个进程都有一个信号处理表，记录了每个信号的处理方式。可以通过 <code>sigaction()</code> 函数来修改信号处理方式。</p>
<p><strong>信号的异步性</strong>：信号是异步事件，即进程可能在任何时刻接收到信号，而不一定是在某个特定的程序点。因此，编写信号处理程序时需要注意处理信号的竞态条件和可重入性。</p>
</blockquote>
<h5 id="使用Linux信号机制具体步骤："><a href="#使用Linux信号机制具体步骤：" class="headerlink" title="使用Linux信号机制具体步骤："></a>使用Linux信号机制具体步骤：</h5><ol>
<li><strong>定义信号处理程序</strong>：编写一个函数来处理特定的信号。</li>
<li><strong>注册信号处理程序</strong>：使用 <code>signal()</code> 或 <code>sigaction()</code> 函数将信号处理程序与特定的信号关联起来。</li>
<li><strong>触发信号</strong>：通过特定的操作或系统调用触发信号，或使用 <code>kill()</code> 函数向自己或其他进程发送信号。</li>
</ol>
<h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 定义信号处理程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGINT) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGINT (Ctrl+C). Exiting gracefully...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sig == SIGALRM) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGALRM. Performing scheduled task...\n&quot;</span>);<br>        <span class="hljs-comment">// 在这里执行你需要的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注册信号处理程序</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    sa.sa_handler = signal_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    sigemptyset(&amp;sa.sa_mask);<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGINT handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGALRM handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个定时器，5秒后发送 SIGALRM 信号</span><br>    alarm(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 无限循环，等待信号</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for signals...\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-套接字（Socket）"><a href="#6-套接字（Socket）" class="headerlink" title="6. 套接字（Socket）"></a>6. <strong>套接字（Socket）</strong></h3><p>套接字是一种网络通信机制，允许在不同计算机或同一计算机上运行的不同进程之间进行通信。套接字支持不同协议（如 TCP&#x2F;IP、UDP等）。</p>
<ul>
<li>特点<ul>
<li>支持进程间通信，也支持跨机器的通信。</li>
<li>可以进行全双工通信，支持发送和接收。</li>
</ul>
</li>
<li><strong>使用场景</strong>：适用于跨网络或本地的进程间通信，广泛用于客户端-服务器架构中的通信。</li>
</ul>
<h3 id="7-内存映射文件（Memory-Mapped-Files）"><a href="#7-内存映射文件（Memory-Mapped-Files）" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）"></a>7. <strong>内存映射文件（Memory-Mapped Files）</strong></h3><p>内存映射文件是一种将磁盘上的文件映射到进程的虚拟内存空间的机制。多个进程可以映射同一个文件，进程通过读写内存区域来进行通信。</p>
<ul>
<li>特点<ul>
<li>允许多个进程通过共享的内存映射文件进行通信。</li>
<li>对文件的修改会立即反映到内存中，从而实现高效的进程间数据共享。</li>
</ul>
</li>
<li><strong>使用场景</strong>：适用于需要高效共享大数据量的场景。</li>
</ul>
<h3 id="8-远程过程调用（RPC）"><a href="#8-远程过程调用（RPC）" class="headerlink" title="8. 远程过程调用（RPC）"></a>8. <strong>远程过程调用（RPC）</strong></h3><p>远程过程调用允许进程调用其他计算机或同一计算机上运行的进程的过程。RPC的核心思想是将分布式系统中的调用抽象成“本地调用”，即使实际执行的代码是在远程主机上。</p>
<ul>
<li>特点<ul>
<li>通过代理方式，使得分布式系统中的进程可以像调用本地进程一样调用远程进程。</li>
<li>在调用过程中，调用者和被调用者可以通过网络通信。</li>
</ul>
</li>
<li><strong>使用场景</strong>：适用于分布式计算、微服务架构中的进程间通信。</li>
</ul>
<h3 id="9-管道与FIFO文件（FIFOs）"><a href="#9-管道与FIFO文件（FIFOs）" class="headerlink" title="9. 管道与FIFO文件（FIFOs）"></a>9. <strong>管道与FIFO文件（FIFOs）</strong></h3><p>FIFOs（命名管道）是一种特殊类型的文件，允许进程通过文件进行通信。不同于传统的文件，FIFOs是进程间通信的媒介，可以让一个进程向FIFO文件写数据，另一个进程从中读取。</p>
<ul>
<li>特点<ul>
<li>支持跨进程的通信。</li>
<li>使用FIFO文件时，进程之间不需要共享内存或使用复杂的同步机制。</li>
</ul>
</li>
<li><strong>使用场景</strong>：适用于跨进程通信的简便场景。</li>
</ul>
<h1 id="处理机调度算法"><a href="#处理机调度算法" class="headerlink" title="处理机调度算法"></a>处理机调度算法</h1><h3 id="1-先来先服务算法-FCFS"><a href="#1-先来先服务算法-FCFS" class="headerlink" title="1. 先来先服务算法 (FCFS)"></a>1. 先来先服务算法 (FCFS)</h3><p><strong>定义</strong>：<br>FCFS 是一种最简单的调度算法，按照进程到达就绪队列的顺序进行调度，即先到达的进程先执行。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>非抢占式：一旦进程开始执行，直到完成才能被中断。</li>
<li>容易实现，但可能会导致长作业阻塞短作业的问题（即“太长的作业可能导致短作业的等待时间过长”）。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：实现简单，容易理解。</li>
<li>缺点：可能导致“饥饿”现象，也即长作业可能一直得不到执行，尤其是在处理短作业的情况下。</li>
</ul>
<p>假设有 4 个进程，分别是 P1、P2、P3 和 P4，它们的到达时间和执行时间如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>P4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>根据 FCFS 算法，按照进程到达顺序依次执行。</li>
<li>进程 P1 到达时，CPU 空闲，因此 P1 开始执行，执行 4 个时间单位。</li>
<li>进程 P2 到达时，P1 正在执行，P2 等待，直到 P1 执行完。</li>
<li>进程 P2 执行 3 个时间单位。</li>
<li>然后 P3 执行 5 个时间单位，最后 P4 执行 2 个时间单位。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p><strong>等待时间</strong>：</p>
<ul>
<li>P1：等待时间 &#x3D; 0</li>
<li>P2：等待时间 &#x3D; 4 - 1 &#x3D; 3</li>
<li>P3：等待时间 &#x3D; 7 - 2 &#x3D; 5</li>
<li>P4：等待时间 &#x3D; 12 - 3 &#x3D; 9</li>
</ul>
<hr>
<h3 id="2-短作业优先算法-SJF"><a href="#2-短作业优先算法-SJF" class="headerlink" title="2. 短作业优先算法 (SJF)"></a>2. 短作业优先算法 (SJF)</h3><p>SJF 基于每个进程的估计执行时间，选择执行时间最短的进程。它有两种形式：非抢占式和抢占式。</p>
<h4 id="2-1-非抢占式短作业优先-Non-preemptive-SJF"><a href="#2-1-非抢占式短作业优先-Non-preemptive-SJF" class="headerlink" title="2.1 非抢占式短作业优先 (Non-preemptive SJF)"></a>2.1 非抢占式短作业优先 (Non-preemptive SJF)</h4><p><strong>定义</strong>：<br>在非抢占式 SJF 中，调度选择就绪队列中最短的进程。如果一个进程正在执行，其他进程即使需要更短的时间，也要等到当前进程执行完才有机会执行。</p>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：最小化平均等待时间。</li>
<li>缺点：可能会导致“长作业饥饿”现象。由于长作业总是被短作业抢占，导致长作业可能永远得不到执行。</li>
</ul>
<p>假设有相同的 4 个进程，它们的到达时间和执行时间如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>P4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>P1 到达时，CPU 空闲，执行 4 个时间单位。</li>
<li>到达时间顺序为 P1 → P2 → P3 → P4，但根据 SJF 算法，选择执行时间最短的进程。</li>
<li>P2 执行，时间为 3，接着是 P4 执行，时间为 2，最后 P3 执行，时间为 5。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p><strong>等待时间</strong>：</p>
<ul>
<li>P1：等待时间 &#x3D; 0</li>
<li>P2：等待时间 &#x3D; 4 - 1 &#x3D; 3</li>
<li>P4：等待时间 &#x3D; 7 - 3 &#x3D; 4</li>
<li>P3：等待时间 &#x3D; 9 - 2 &#x3D; 7</li>
</ul>
<h4 id="2-2-抢占式短作业优先-Preemptive-SJF-SRTF"><a href="#2-2-抢占式短作业优先-Preemptive-SJF-SRTF" class="headerlink" title="2.2 抢占式短作业优先 (Preemptive SJF, SRTF)"></a>2.2 抢占式短作业优先 (Preemptive SJF, SRTF)</h4><p><strong>定义</strong>：<br>在抢占式 SJF 中，如果一个新的进程到达，并且其执行时间比当前执行的进程剩余的时间要短，那么当前进程会被抢占，新的进程将立即执行。</p>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：能够保证短作业尽早完成，减少平均等待时间。</li>
<li>缺点：可能会增加上下文切换的次数，增加开销。</li>
</ul>
<p>假设 4 个进程的到达时间和执行时间如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>P4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>P1 开始执行，但在 P2 到达时，P2 的执行时间（3）比 P1 剩余的时间（3）短，因此 P1 被抢占，P2 执行。</li>
<li>P2 执行完后，P4 的执行时间为 2，比 P1 剩余的时间短，因此 P4 执行。</li>
<li>然后，P1 和 P3 执行。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">P1 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>-<span class="hljs-number">1</span>)</span> -&gt;</span> P2 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>-<span class="hljs-number">4</span>)</span> -&gt;</span> P4 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>-<span class="hljs-number">6</span>)</span> -&gt;</span> P1 <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">6</span>-<span class="hljs-number">7</span>)</span> -&gt;</span> P3 (<span class="hljs-number">7</span>-<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure>

<p><strong>等待时间</strong>：</p>
<ul>
<li>P1：等待时间 &#x3D; 6 - 0 - 4 &#x3D; 2</li>
<li>P2：等待时间 &#x3D; 1 - 1 &#x3D; 0</li>
<li>P3：等待时间 &#x3D; 7 - 2 &#x3D; 5</li>
<li>P4：等待时间 &#x3D; 4 - 3 &#x3D; 1</li>
</ul>
<hr>
<h3 id="3-优先调度算法-PSA"><a href="#3-优先调度算法-PSA" class="headerlink" title="3. 优先调度算法 (PSA)"></a>3. 优先调度算法 (PSA)</h3><p><strong>定义</strong>：<br>每个进程都会被分配一个优先级，调度器选择具有最高优先级的进程执行。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>可以是抢占式或非抢占式。</li>
<li>优先级越高的进程优先执行。</li>
</ul>
<h4 id="3-1-非抢占式优先调度"><a href="#3-1-非抢占式优先调度" class="headerlink" title="3.1 非抢占式优先调度"></a>3.1 非抢占式优先调度</h4><ul>
<li>一旦一个进程开始执行，直到完成才会被其他进程抢占。</li>
<li>如果多个进程有相同的优先级，则使用 FCFS 算法。</li>
</ul>
<h4 id="3-2-抢占式优先调度"><a href="#3-2-抢占式优先调度" class="headerlink" title="3.2 抢占式优先调度"></a>3.2 抢占式优先调度</h4><ul>
<li>如果一个新到的进程的优先级高于当前正在执行的进程，则会发生抢占，新的进程将被调度执行。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：优先级高的进程能够得到快速执行，适用于重要的任务。</li>
<li>缺点：低优先级的进程可能会长期等待，导致饥饿现象。</li>
</ul>
<p>假设有 4 个进程，它们的到达时间和执行时间如下，同时每个进程也有一个优先级（数字越大优先级越高）：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>执行时间</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>P4</td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>P1 到达时，CPU 空闲，开始执行。</li>
<li>P2 到达时，P1 正在执行，等待。</li>
<li>P3 到达时，它的优先级最高（4），因此抢占 P1 执行。</li>
<li>然后，P4 执行，最后 P1 和 P2 按顺序执行。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p><strong>等待时间</strong>：</p>
<ul>
<li>P1：等待时间 &#x3D; 6 - 0 - 4 &#x3D; 2</li>
<li>P2：等待时间 &#x3D; 6 - 1 &#x3D; 5</li>
<li>P3：等待时间 &#x3D; 0</li>
<li>P4：等待时间 &#x3D; 4 - 3 &#x3D; 1</li>
</ul>
<h3 id="4-高响应比优先调度算法-HRRN"><a href="#4-高响应比优先调度算法-HRRN" class="headerlink" title="4. 高响应比优先调度算法 (HRRN)"></a>4. 高响应比优先调度算法 (HRRN)</h3><p><strong>定义</strong>：<br>HRRN 是基于响应比来调度进程的一种算法。响应比定义为： R&#x3D;Tw+TcTcR &#x3D; \frac{T_w + T_c}{T_c}R&#x3D;Tc​Tw​+Tc​​ 其中，TwT_wTw​ 是进程等待的时间，TcT_cTc​ 是进程的计算时间。HRRN 通过计算每个进程的响应比，选择响应比最高的进程执行。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>响应比高的进程优先执行，响应比计算考虑了等待时间和计算时间，能够综合考虑进程的等待情况。</li>
<li>通过动态调整优先级来减少饥饿现象。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：比优先级调度更公平，避免了“长作业饥饿”现象。</li>
<li>缺点：需要实时计算响应比，可能增加一些调度开销。</li>
</ul>
<p>假设有 4 个进程，它们的到达时间和执行时间如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>P4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>初始时，所有进程的响应比可以通过公式 <img src="https://s2.loli.net/2025/01/04/5SezB2FfjdOTKxr.png" srcset="/img/loading.gif" lazyload alt="image-20250104162131081" style="zoom:50%;" /> 来计算（Tw 为等待时间，Tc为执行时间)。</li>
<li>开始时 P1 执行，因为它是第一个到达的。</li>
<li>随后 P2 和 P4 会根据响应比来选择优先执行。</li>
</ul>
<p><strong>计算响应比</strong>：</p>
<ul>
<li>初始：P1 &#x3D; 1.0, P2 &#x3D; 2.33, P3 &#x3D; 1.4, P4 &#x3D; 2.5</li>
<li>选择 P4 执行（响应比最大），接着选择 P2 和 P3。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">rust<br><br><br>复制代码<br><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p><strong>平均等待时间</strong>： HRRN 通过计算响应比动态调整选择执行的进程，避免了长作业饥饿的现象。</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h3 id="1-时间轮转调度算法-Round-Robin-RR"><a href="#1-时间轮转调度算法-Round-Robin-RR" class="headerlink" title="1. 时间轮转调度算法 (Round Robin, RR)"></a>1. 时间轮转调度算法 (Round Robin, RR)</h3><p><strong>定义</strong>：<br> 时间轮转调度算法是最常用的抢占式调度算法，特别适用于时间共享系统。在 RR 算法中，每个进程被分配一个时间片（time quantum），当进程执行完一个时间片后，如果它仍未完成，则被挂起并移到队列末尾等待下一次调度。调度器按照进程的顺序轮流分配 CPU。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>每个进程的时间片相同，公平分配 CPU 时间。</li>
<li>适用于时间共享系统，如多用户系统。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：公平性较好，每个进程都能在有限时间内获得 CPU 时间。</li>
<li>缺点：时间片的选择至关重要，过长可能导致效率低下，过短会导致过多的上下文切换。</li>
</ul>
<p><strong>示意图</strong>： 假设有 4 个进程 P1、P2、P3 和 P4，时间片大小为 2 单位时间，进程到达时间均为 0，执行时间如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>6</td>
</tr>
<tr>
<td>P4</td>
<td>4</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>P1 执行 2 单位时间，剩余 3 单位时间。</li>
<li>P2 执行 2 单位时间，剩余 1 单位时间。</li>
<li>P3 执行 2 单位时间，剩余 4 单位时间。</li>
<li>P4 执行 2 单位时间，剩余 2 单位时间。</li>
<li>回到 P1，执行 2 单位时间，剩余 1 单位时间。</li>
<li>回到 P2，执行完毕，剩余 0 单位时间。</li>
<li>然后继续其他进程执行。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">P1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>-<span class="hljs-number">2</span>)</span> -&gt;</span> P2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>-<span class="hljs-number">4</span>)</span> -&gt;</span> P3<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>-<span class="hljs-number">6</span>)</span> -&gt;</span> P4<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">6</span>-<span class="hljs-number">8</span>)</span> -&gt;</span> P1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">8</span>-<span class="hljs-number">10</span>)</span> -&gt;</span> P2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">10</span>-<span class="hljs-number">11</span>)</span> -&gt;</span> P3<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">11</span>-<span class="hljs-number">13</span>)</span> -&gt;</span> P4<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">13</span>-<span class="hljs-number">14</span>)</span> -&gt;</span> P3(<span class="hljs-number">14</span>-<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-多队列调度算法-Multilevel-Queue-Scheduling"><a href="#2-多队列调度算法-Multilevel-Queue-Scheduling" class="headerlink" title="2. 多队列调度算法 (Multilevel Queue Scheduling)"></a>2. 多队列调度算法 (Multilevel Queue Scheduling)</h3><p><strong>定义</strong>：<br> 多队列调度算法将进程划分为不同的队列，每个队列有不同的优先级。通常，高优先级队列执行时间短、交互性强的进程，低优先级队列执行长时间计算密集型的进程。调度器会根据进程的类型决定其所处的队列。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>每个队列有不同的调度算法（例如：高优先级队列使用 RR，低优先级队列使用 FCFS）。</li>
<li>适用于需要将进程分配给不同类别的场景。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：能有效区分不同类型的进程，保证响应时间。</li>
<li>缺点：难以平衡各队列的负载，可能导致某些队列的过载或空闲。</li>
</ul>
<p><strong>示意图</strong>： 假设有两个队列，一个用于交互性进程，一个用于批处理进程。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>队列</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>高</td>
<td>3</td>
</tr>
<tr>
<td>P2</td>
<td>高</td>
<td>2</td>
</tr>
<tr>
<td>P3</td>
<td>低</td>
<td>6</td>
</tr>
<tr>
<td>P4</td>
<td>低</td>
<td>5</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>高优先级队列（交互进程）使用轮转调度算法执行。</li>
<li>低优先级队列（批处理进程）使用 FCFS 调度算法执行。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">P</span><span class="hljs-number">1</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">2</span> (高优先级队列)<br><span class="hljs-keyword">P</span><span class="hljs-number">3</span> -&gt; <span class="hljs-keyword">P</span><span class="hljs-number">4</span> (低优先级队列)<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-多级反馈队列调度算法-Multilevel-Feedback-Queue-Scheduling"><a href="#3-多级反馈队列调度算法-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="3. 多级反馈队列调度算法 (Multilevel Feedback Queue Scheduling)"></a>3. 多级反馈队列调度算法 (Multilevel Feedback Queue Scheduling)</h3><p><strong>定义</strong>：<br> 多级反馈队列调度算法是多队列调度的扩展，它允许进程根据其行为在不同的队列之间移动。当进程需要更多 CPU 时间时，它将被移动到较低优先级的队列；如果进程表现为短作业，它会被移到较高优先级的队列。这种算法结合了时间共享和优先级调度的优点。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>动态调整进程的队列优先级。</li>
<li>适用于处理多种类型的进程（短作业、长作业、交互式进程等）。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：能够根据进程的行为动态调整队列，避免了饥饿现象。</li>
<li>缺点：算法较复杂，配置不当可能会导致不稳定性。</li>
</ul>
<p><strong>示意图</strong>： 假设有 3 个队列，分别对应不同的优先级和调度算法。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>执行时间</th>
<th>初始队列</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>3</td>
<td>队列 1</td>
<td>1</td>
</tr>
<tr>
<td>P2</td>
<td>6</td>
<td>队列 2</td>
<td>2</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>队列 1</td>
<td>1</td>
</tr>
<tr>
<td>P4</td>
<td>8</td>
<td>队列 3</td>
<td>3</td>
</tr>
</tbody></table>
<p><strong>执行过程</strong>：</p>
<ul>
<li>P1 和 P3 先进入队列 1，并使用 RR 调度。</li>
<li>P2 进入队列 2，并使用 FCFS 调度。</li>
<li>P4 进入队列 3，并使用 FCFS 调度。</li>
<li>如果 P1 和 P3 仍未完成，它们会被转移到较低优先级队列。</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/11598647.html">操作系统——死锁的概念以及死锁处理策略 - 王陸 - 博客园</a></p>
<p>资源分配化简</p>
<p>具体参考：</p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/joiln/p/10253288.html">转]操作系统-资源分配图化简法 - 仔仔的棒棒糖 - 博客园</a></p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2201_75475240/article/details/137777008">【操作系统】7种进程调度算法，及其甘特图的绘制（练习markdown画图）_模拟操作系统进程调度相关算法代码图片-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1460903">《操作系统》—— 处理机调度算法-阿里云开发者社区</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="category-chain-item">基础知识</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CPU虚拟化与进程</div>
      <div>http://example.com/2023/01/10/CPU虚拟化与进程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/12/%E9%93%BE%E8%A1%A8/" title="链表">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">链表</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/10/%E6%A0%91(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/" title="树">
                        <span class="hidden-mobile">树</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
