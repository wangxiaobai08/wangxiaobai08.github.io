

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="I&#x2F;O系统的功能,模型和接口I&#x2F;O系统的层次结构和模型I&#x2F;O软件的层次结构   层次 功能描述 举例    用户层 I&#x2F;O 软件 与用户交互，提供I&#x2F;O请求生成、格式化、排队等功能 read()、write() 系统调用，Spooling 系统   设备独立性软件 提供设备抽象，统一设备命令，资源分配与缓冲区管理 操作系统中与设备独立的驱动接口">
<meta property="og:type" content="article">
<meta property="og:title" content="外存管理【补充】">
<meta property="og:url" content="http://example.com/2023/01/25/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="I&#x2F;O系统的功能,模型和接口I&#x2F;O系统的层次结构和模型I&#x2F;O软件的层次结构   层次 功能描述 举例    用户层 I&#x2F;O 软件 与用户交互，提供I&#x2F;O请求生成、格式化、排队等功能 read()、write() 系统调用，Spooling 系统   设备独立性软件 提供设备抽象，统一设备命令，资源分配与缓冲区管理 操作系统中与设备独立的驱动接口">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/01/03/YdmZncQXk1Ny9ib.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/03/OIZmf6QMzTNaSyG.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/04/DP8JrEHTdAXaUS3.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/04/LP5wZUQ1TOoVm3J.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/04/o4OnLIrsWqEiKfz.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/04/qvDzoaSCGwgyZcF.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/04/92R8slSg7VjLwF1.png">
<meta property="article:published_time" content="2023-01-25T05:08:14.000Z">
<meta property="article:modified_time" content="2025-03-09T09:06:34.170Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/01/03/YdmZncQXk1Ny9ib.png">
  
  
  
  <title>外存管理【补充】 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="外存管理【补充】"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-25 13:08" pubdate>
          2023年1月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          99 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">外存管理【补充】</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="I-O系统的功能-模型和接口"><a href="#I-O系统的功能-模型和接口" class="headerlink" title="I&#x2F;O系统的功能,模型和接口"></a>I&#x2F;O系统的功能,模型和接口</h1><h2 id="I-O系统的层次结构和模型"><a href="#I-O系统的层次结构和模型" class="headerlink" title="I&#x2F;O系统的层次结构和模型"></a>I&#x2F;O系统的层次结构和模型</h2><h3 id="I-O软件的层次结构"><a href="#I-O软件的层次结构" class="headerlink" title="I&#x2F;O软件的层次结构"></a>I&#x2F;O软件的层次结构</h3><table>
<thead>
<tr>
<th><strong>层次</strong></th>
<th><strong>功能描述</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>用户层 I&#x2F;O 软件</strong></td>
<td>与用户交互，提供I&#x2F;O请求生成、格式化、排队等功能</td>
<td><code>read()</code>、<code>write()</code> 系统调用，Spooling 系统</td>
</tr>
<tr>
<td><strong>设备独立性软件</strong></td>
<td>提供设备抽象，统一设备命令，资源分配与缓冲区管理</td>
<td>操作系统中与设备独立的驱动接口</td>
</tr>
<tr>
<td><strong>设备驱动程序</strong></td>
<td>直接控制硬件设备，执行操作命令，数据传输</td>
<td>磁盘驱动程序，打印机驱动程序</td>
</tr>
<tr>
<td><strong>中断处理程序 (ISR)</strong></td>
<td>处理硬件中断，保存和恢复现场，执行中断响应</td>
<td>设备I&#x2F;O完成中断，硬件故障中断处</td>
</tr>
</tbody></table>
<p><img src="https://s2.loli.net/2025/01/03/YdmZncQXk1Ny9ib.png" srcset="/img/loading.gif" lazyload alt="image-20250103210526054"></p>
<h3 id="IO系统各模块之间的层次视图"><a href="#IO系统各模块之间的层次视图" class="headerlink" title="IO系统各模块之间的层次视图"></a><strong>IO系统各模块之间的层次视图</strong></h3><p><img src="https://s2.loli.net/2025/01/03/OIZmf6QMzTNaSyG.png" srcset="/img/loading.gif" lazyload alt="image-20250103210726591"></p>
<h4 id="I-O系统的上下接口"><a href="#I-O系统的上下接口" class="headerlink" title="I&#x2F;O系统的上下接口"></a>I&#x2F;O系统的上下接口</h4><h5 id="1-上层接口（上接口）"><a href="#1-上层接口（上接口）" class="headerlink" title="1. 上层接口（上接口）"></a>1. <strong>上层接口（上接口）</strong></h5><ul>
<li><p><strong>与用户或应用程序的接口</strong>，即用户应用程序或操作系统与I&#x2F;O系统的交互接口。上层接口负责接受用户的I&#x2F;O请求，格式化数据、提供操作等，并将这些请求传递到下层。具体而言，用户层会通过操作系统的系统调用向I&#x2F;O控制层发送请求。</p>
</li>
<li><p>典型接口</p>
<ul>
<li><strong>系统调用</strong>：如<code>read()</code>、<code>write()</code>、<code>open()</code>、<code>close()</code>等，这些都是用户程序与操作系统间的交互接口，通过这些接口，程序可以发起文件操作、设备操作等。</li>
<li><strong>文件系统接口</strong>：为用户程序提供抽象的文件操作接口，如打开、读写文件，关闭文件等，文件系统会把这些请求转化为低级的I&#x2F;O请求。</li>
<li><strong>I&#x2F;O库函数</strong>：例如C标准库中的<code>fopen()</code>, <code>fread()</code>等，提供更高层次的抽象，简化用户的I&#x2F;O操作。</li>
</ul>
</li>
</ul>
<h5 id="2-下层接口（下接口）"><a href="#2-下层接口（下接口）" class="headerlink" title="2. 下层接口（下接口）"></a>2. <strong>下层接口（下接口）</strong></h5><ul>
<li><p><strong>与硬件或设备驱动的接口</strong>，即I&#x2F;O系统与硬件设备之间的接口。下层接口是操作系统与设备之间的通信桥梁，它接收来自上层的请求并转发至具体的硬件或设备驱动。</p>
</li>
<li><p>典型接口</p>
<ul>
<li><strong>设备驱动程序接口</strong>：设备驱动程序通常会提供接口，接收来自I&#x2F;O控制管理层的命令并将其转化为具体的硬件操作。例如，磁盘驱动程序提供的接口可以包括读、写、寻址等功能。</li>
<li><strong>硬件接口</strong>：这是操作系统与硬件设备之间的低级接口，通过总线和硬件协议与设备进行交互。例如，硬件中断、DMA（直接内存存取）等机制是底层设备与系统进行通信的关键部分。</li>
<li><strong>中断服务程序（ISR）</strong>：通过中断机制，硬件设备可以向操作系统发出中断信号，中断服务程序负责处理中断并响应硬件设备。</li>
</ul>
</li>
</ul>
<h4 id="I-O系统的分层"><a href="#I-O系统的分层" class="headerlink" title="I&#x2F;O系统的分层"></a>I&#x2F;O系统的分层</h4><h5 id="1-中断处理程序（Interrupt-Service-Routine-ISR）"><a href="#1-中断处理程序（Interrupt-Service-Routine-ISR）" class="headerlink" title="1. 中断处理程序（Interrupt Service Routine, ISR）"></a>1. <strong>中断处理程序（Interrupt Service Routine, ISR）</strong></h5><ul>
<li><strong>功能</strong>：中断处理程序位于I&#x2F;O系统的最底层，负责响应硬件设备发出的中断信号。当设备完成I&#x2F;O操作或发生错误时，硬件通过中断信号通知操作系统。ISR会及时响应并进行相应处理。</li>
<li>职责：<ul>
<li><strong>保存进程状态</strong>：当中断发生时，操作系统需要保存当前执行进程的现场，以便在中断处理后恢复执行。</li>
<li><strong>处理中断</strong>：ISR会根据中断源的类型执行相应的操作，例如读取设备状态、清除中断标志、向设备发送确认信号等。</li>
<li><strong>恢复现场</strong>：完成中断服务后，ISR需要恢复被中断程序的执行状态，确保程序从中断发生前的状态继续执行。</li>
</ul>
</li>
<li><strong>作用</strong>：ISR是操作系统与硬件之间的桥梁，负责处理中断事件并启动相应的设备或进程。中断机制能够保证操作系统对外部设备的实时响应。</li>
</ul>
<p><strong>举例</strong>：</p>
<ul>
<li>硬盘完成一次读写操作后，通过中断通知操作系统，ISR将处理该中断，可能进行数据拷贝或更新缓存，然后恢复应用程序的执行。</li>
</ul>
<hr>
<h5 id="2-设备驱动程序（Device-Driver）"><a href="#2-设备驱动程序（Device-Driver）" class="headerlink" title="2. 设备驱动程序（Device Driver）"></a>2. <strong>设备驱动程序（Device Driver）</strong></h5><ul>
<li><strong>功能</strong>：设备驱动程序直接与硬件设备交互，实现具体的I&#x2F;O操作。它位于操作系统的较低层次，负责接收I&#x2F;O控制管理层（或者上层）的命令，执行设备的控制指令，并管理设备的数据传输。</li>
<li>职责：<ul>
<li><strong>硬件操作</strong>：驱动程序实现对硬件的直接控制，如磁盘的读写、网络设备的数据发送等。</li>
<li><strong>设备初始化与配置</strong>：在设备启用前，驱动程序需要进行初始化配置，设置设备的参数、操作模式等。</li>
<li><strong>数据传输</strong>：设备驱动程序通过中断或直接内存存取（DMA）将数据从内存传输到设备，或将数据从设备传回内存。</li>
<li><strong>错误处理</strong>：驱动程序也负责监控设备的工作状态，处理可能出现的硬件错误或通信问题。</li>
</ul>
</li>
<li><strong>作用</strong>：设备驱动程序将操作系统的高层命令转换为硬件可理解的命令，确保硬件设备按照预期执行操作。每个硬件设备通常有一个或多个对应的设备驱动程序。</li>
</ul>
<p><strong>举例</strong>：</p>
<ul>
<li>磁盘驱动程序根据I&#x2F;O请求，向硬盘发出指令（例如读、写命令），并根据硬盘的响应执行相应的操作（例如更新缓冲区或向应用程序返回数据）。</li>
</ul>
<hr>
<h5 id="3-设备独立性软件（Device-Independence-Software）"><a href="#3-设备独立性软件（Device-Independence-Software）" class="headerlink" title="3. 设备独立性软件（Device Independence Software）"></a>3. <strong>设备独立性软件（Device Independence Software）</strong></h5><ul>
<li><strong>功能</strong>：设备独立性软件位于I&#x2F;O系统的中层，提供一个统一的接口，使得操作系统和用户程序能够不关心具体的硬件实现，统一地对外提供设备访问接口。</li>
<li>职责：<ul>
<li><strong>屏蔽硬件差异</strong>：设备独立性软件的核心任务是屏蔽不同设备之间的差异。操作系统通过这一层抽象接口，统一设备的操作方式。例如，磁盘、打印机和键盘的具体硬件实现不同，但操作系统通过设备独立性层提供统一的I&#x2F;O接口给上层应用。</li>
<li><strong>设备资源管理</strong>：管理设备的资源（如设备的分配、释放和共享），确保多个进程对同一设备的访问不会发生冲突。</li>
<li><strong>缓冲区管理</strong>：对输入输出的数据进行缓冲，以提高I&#x2F;O操作的效率。</li>
<li><strong>任务调度</strong>：设备独立性软件也可能负责设备请求的排队和调度，确保设备能够高效地为多个进程提供服务。</li>
</ul>
</li>
<li><strong>作用</strong>：设备独立性软件将设备硬件的复杂性封装起来，为操作系统和应用程序提供统一的、设备无关的接口，从而使得程序能够不关心设备的具体实现。</li>
</ul>
<p><strong>举例</strong>：</p>
<ul>
<li>操作系统通过设备独立性软件为文件系统提供统一的接口，应用程序可以通过<code>read()</code>和<code>write()</code>进行文件I&#x2F;O操作，而不需要知道是通过磁盘、网络还是其他设备来进行的实际数据传输。</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>       应用程序层（<span class="hljs-variable">User</span> <span class="hljs-variable">Layer</span>）       <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 与用户交互，发起<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>请求<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>   设备独立性软件层（<span class="hljs-variable">Device</span> <span class="hljs-variable">Independence</span> <span class="hljs-variable">Software</span>）   <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 屏蔽硬件差异，提供统一接口<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>         <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>控制管理层（<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> <span class="hljs-built_in">Control</span> <span class="hljs-variable">Layer</span>）         <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 管理设备资源，调度<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>请求<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>           设备驱动程序层（<span class="hljs-variable">Device</span> <span class="hljs-variable">Driver</span> <span class="hljs-variable">Layer</span>）    <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 控制硬件设备，进行<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>           中断处理程序（<span class="hljs-built_in">Interrupt</span> <span class="hljs-variable">Service</span> <span class="hljs-variable">Routine</span>）<span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 处理中断，进行硬件控制<br><span class="hljs-operator">+-------------------------------------+</span><br><span class="hljs-operator">|</span>               硬件层（<span class="hljs-variable">Hardware</span> <span class="hljs-variable">Layer</span>）              <span class="hljs-operator">|</span>  <span class="hljs-operator">&lt;--</span> 执行实际<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作<br><span class="hljs-operator">+-------------------------------------+</span><br><br></code></pre></td></tr></table></figure>

<h2 id="I-O系统接口"><a href="#I-O系统接口" class="headerlink" title="I&#x2F;O系统接口"></a>I&#x2F;O系统接口</h2><p>I&#x2F;O系统中的接口是操作系统与硬件设备、应用程序之间进行交互的桥梁。不同类型的设备有不同的接口，这些接口可以分为<strong>块设备接口</strong>、<strong>流设备接口</strong>和<strong>网络通信接口</strong>。每种接口适应不同类型的I&#x2F;O设备，提供相应的操作方法和协议。</p>
<h3 id="1-块设备接口（Block-Device-Interface）"><a href="#1-块设备接口（Block-Device-Interface）" class="headerlink" title="1. 块设备接口（Block Device Interface）"></a>1. <strong>块设备接口（Block Device Interface）</strong></h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>块设备（Block Devices）是指那些支持按块（Block）进行数据访问的设备，数据在这些设备上是按固定大小的块进行组织的。常见的块设备包括硬盘、固态硬盘（SSD）、光盘等。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>数据存取单位</strong>：块设备的存取单位是“块”，通常是512字节或4KB的倍数。</li>
<li><strong>随机访问</strong>：块设备支持随机访问，允许直接读取或写入任何块。</li>
<li><strong>持久性</strong>：块设备上的数据通常是持久化存储，即数据在设备断电后仍然存在。</li>
</ul>
<h4 id="接口操作："><a href="#接口操作：" class="headerlink" title="接口操作："></a>接口操作：</h4><p>块设备的接口通常包括以下几种操作：</p>
<ul>
<li><strong>读&#x2F;写操作</strong>：对指定的块进行读写操作。</li>
<li><strong>寻址操作</strong>：通过设备的逻辑块地址（LBA）来定位和访问数据块。</li>
<li><strong>设备控制操作</strong>：例如初始化、格式化、修复坏块等。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><ul>
<li>**<code>read()</code>**：从块设备的指定块中读取数据。</li>
<li>**<code>write()</code>**：向块设备的指定块写入数据。</li>
<li>**<code>ioctl()</code>**：用于控制设备的各种命令，如格式化、调整块大小等。</li>
</ul>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul>
<li><strong>硬盘、固态硬盘（SSD）</strong>：这些存储设备都采用块存储模型，操作系统通过块设备接口进行读写操作。</li>
</ul>
<h3 id="2-流设备接口（Character-Device-Interface）"><a href="#2-流设备接口（Character-Device-Interface）" class="headerlink" title="2. 流设备接口（Character Device Interface）"></a>2. <strong>流设备接口（Character Device Interface）</strong></h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>流设备（Character Devices）是指那些支持按字节流进行数据访问的设备。流设备通常是串行的，数据流通常是连续的，不以块为单位进行存储。常见的流设备包括串口设备、键盘、鼠标、打印机等。</p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>数据存取单位</strong>：流设备的数据存取单位是字节（byte），数据是顺序读取的，通常是逐个字节地传输。</li>
<li><strong>顺序访问</strong>：流设备不支持随机访问，数据必须按照顺序进行处理。</li>
<li><strong>实时性</strong>：流设备的数据传输通常具有实时性要求，操作系统需要及时处理这些数据。</li>
</ul>
<h4 id="接口操作：-1"><a href="#接口操作：-1" class="headerlink" title="接口操作："></a>接口操作：</h4><p>流设备的接口通常包括以下几种操作：</p>
<ul>
<li><strong>读&#x2F;写操作</strong>：从流设备中读取字节或向流设备写入字节。</li>
<li><strong>设备控制操作</strong>：流设备可能还包括对设备的控制命令，例如获取设备状态、控制设备开启或关闭等。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><ul>
<li>**<code>read()</code>**：从流设备中读取一个字节的数据。</li>
<li>**<code>write()</code>**：向流设备写入一个字节的数据。</li>
<li>**<code>ioctl()</code>**：控制设备操作，例如设置串口的波特率、打开或关闭设备等。</li>
</ul>
<h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h4><ul>
<li><strong>串口设备、键盘、鼠标</strong>：这些设备通常处理按字节顺序的数据，操作系统通过流设备接口进行数据交换。</li>
</ul>
<h3 id="3-网络通信接口（Network-Communication-Interface）"><a href="#3-网络通信接口（Network-Communication-Interface）" class="headerlink" title="3. 网络通信接口（Network Communication Interface）"></a>3. <strong>网络通信接口（Network Communication Interface）</strong></h3><h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h4><p>网络通信接口用于处理网络设备（如网卡）和操作系统之间的数据传输。它是通过网络协议栈来实现的，支持通过不同的通信协议进行数据交换。常见的网络接口有以太网、Wi-Fi、蓝牙等。</p>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>基于协议栈</strong>：网络通信接口依赖于协议栈（如TCP&#x2F;IP协议栈）来进行数据的分发、路由和传输。</li>
<li><strong>支持异步通信</strong>：网络通信通常是异步的，数据可能在不同时间到达，且可能需要重试、流量控制和确认等操作。</li>
<li><strong>可扩展性</strong>：网络通信接口需要支持不同的协议和网络配置，如IPv4、IPv6、TCP、UDP等。</li>
</ul>
<h4 id="接口操作：-2"><a href="#接口操作：-2" class="headerlink" title="接口操作："></a>接口操作：</h4><p>网络通信接口通常支持以下操作：</p>
<ul>
<li><strong>发送&#x2F;接收数据</strong>：通过协议栈发送和接收数据包。</li>
<li><strong>连接管理</strong>：建立、管理和关闭网络连接。</li>
<li><strong>设备控制</strong>：网络接口的配置、状态查询等。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><ul>
<li>**<code>socket()</code>**：创建一个套接字，进行网络连接的初始化。</li>
<li>**<code>send()</code>&#x2F;<code>recv()</code>**：向网络连接发送或接收数据。</li>
<li>**<code>ioctl()</code>**：设置网络设备的参数，查询设备状态等。</li>
</ul>
<h4 id="使用场景：-2"><a href="#使用场景：-2" class="headerlink" title="使用场景："></a>使用场景：</h4><ul>
<li><strong>以太网卡、Wi-Fi适配器</strong>：操作系统通过网络通信接口和网络设备进行数据传输，处理与其他计算机或设备的通信。</li>
</ul>
<hr>
<h3 id="各接口的比较"><a href="#各接口的比较" class="headerlink" title="各接口的比较"></a>各接口的比较</h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>块设备接口（Block Device）</strong></th>
<th><strong>流设备接口（Character Device）</strong></th>
<th><strong>网络通信接口（Network Interface）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存取单位</strong></td>
<td>块（通常为512字节或4KB）</td>
<td>字节（按字节流传输数据）</td>
<td>数据包（按照网络协议进行分组和传输）</td>
</tr>
<tr>
<td><strong>访问类型</strong></td>
<td>随机访问</td>
<td>顺序访问</td>
<td>异步、流式访问（可能是双向或单向）</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>硬盘、SSD、光盘等存储设备</td>
<td>键盘、鼠标、打印机、串口设备等</td>
<td>网卡、Wi-Fi、蓝牙、互联网连接等</td>
</tr>
<tr>
<td><strong>常用操作</strong></td>
<td><code>read()</code>, <code>write()</code>, <code>ioctl()</code></td>
<td><code>read()</code>, <code>write()</code>, <code>ioctl()</code></td>
<td><code>socket()</code>, <code>send()</code>, <code>recv()</code>, <code>ioctl()</code></td>
</tr>
<tr>
<td><strong>协议&#x2F;规范</strong></td>
<td>物理设备上的数据块操作</td>
<td>流式数据传输，没有固定的协议</td>
<td>基于网络协议栈（如TCP&#x2F;IP、UDP）</td>
</tr>
</tbody></table>
<hr>
<h1 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h1><p><img src="https://s2.loli.net/2025/01/04/DP8JrEHTdAXaUS3.png" srcset="/img/loading.gif" lazyload alt="image-20250104090411981"></p>
<p>在<a target="_blank" rel="noopener" href="https://wangxiaobai08.github.io/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/">CPU虚拟化与进程 - The Peak Tower</a>我们提到中断是操作系统夺回CPU控制的唯一途径，当中断发生时，就意味着操作系统介入，进行管理工作。正因如此多道程序才能进行并发运行，合理的移交CPU控制权</p>
<p>我们知道用户态的程序进行系统调用时会触发库函数(并不是每一个库函数都会进行中断)里的中断，进而陷入内核态。</p>
<blockquote>
<p>那么当内核态操作系统完成调用时，如何将控制器移交给用户程序呢？</p>
</blockquote>
<p><img src="https://s2.loli.net/2025/01/04/LP5wZUQ1TOoVm3J.png" srcset="/img/loading.gif" lazyload alt="image-20250104084448013"></p>
<p>流程大体如下：</p>
<ol>
<li><strong>用户程序</strong>通过系统调用请求操作系统服务。</li>
<li><strong>CPU</strong>切换到<strong>内核模式</strong>，操作系统执行相应任务。</li>
<li><strong>操作系统</strong>执行完成任务，保存内核态的上下文。</li>
<li>操作系统将<strong>控制权返回到用户态</strong>，并恢复用户程序的上下文。</li>
<li><strong>返回结果</strong>给用户程序（通常是通过寄存器或内存返回）。</li>
<li><strong>用户程序</strong>继续执行，使用返回的结果。</li>
</ol>
<p>这里简单介绍一下什么是特权指令和非特权指令：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>特权指令</strong></th>
<th><strong>非特权指令</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行模式</strong></td>
<td>仅能在<strong>内核模式</strong>下执行</td>
<td>可以在<strong>用户模式</strong>下执行</td>
</tr>
<tr>
<td><strong>访问权限</strong></td>
<td>具有对硬件和系统资源的访问权限</td>
<td>仅能访问用户程序自身的数据和代码</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>操作系统核心功能，如内存管理、中断控制、I&#x2F;O操作等</td>
<td>一般为普通程序逻辑运算，如算术运算、数据传输等</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>- 修改控制寄存器- 禁用&#x2F;启用中断- I&#x2F;O控制</td>
<td>- 加法、减法运算- 数据传送（<code>mov</code>）- 跳转（<code>jmp</code>）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>执行不当可能破坏系统稳定性，具有潜在风险</td>
<td>不涉及系统资源，执行不会对系统造成直接风险</td>
</tr>
<tr>
<td><strong>操作系统介入</strong></td>
<td>需要操作系统或内核来执行，中断或异常处理</td>
<td>不需要操作系统介入，可以由普通程序执行</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>操作系统内部功能、硬件设备的直接控制、进程管理等</td>
<td>普通应用程序的计算、数据处理、逻辑控制等</td>
</tr>
</tbody></table>
<blockquote>
<p>当执行中断陷入内核态时，操作系统怎么知道哪一个中断触发了它，后续如何处理中断？</p>
</blockquote>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a><strong>中断向量表</strong></h2><p>当中断（无论是硬件中断还是软件中断）发生时，操作系统需要确定哪个中断源触发了中断，并执行相应的处理程序。中断向量表是一个数据结构，用于存储所有中断的入口地址（即对应中断服务程序的地址）。</p>
<ul>
<li><strong>中断向量表</strong>包含了所有中断的入口地址，处理不同的中断请求（IRQ）。每个中断都有一个对应的向量（即一个唯一的编号），该向量指向相应的<strong>中断服务程序</strong>（ISR）。</li>
<li>在中断发生时，CPU会根据中断源的编号查找中断向量表，从而跳转到对应的中断服务程序。</li>
</ul>
<p>举例：</p>
<ul>
<li><strong>硬件中断</strong>：例如，键盘按键中断、磁盘I&#x2F;O中断等，都有不同的中断向量。</li>
<li><strong>软件中断（如系统调用）</strong>：在x86架构中，系统调用会通过<code>int 0x80</code>指令触发中断，并跳转到内核模式的系统调用处理程序。</li>
</ul>
<p><img src="https://s2.loli.net/2025/01/04/o4OnLIrsWqEiKfz.png" srcset="/img/loading.gif" lazyload alt="de06c8c75719a3f2df6e795b673a3a29"></p>
<blockquote>
<p>接下来我们需要继续完善中断执行流程</p>
</blockquote>
<p><strong>触发中断</strong>：</p>
<ul>
<li>当硬件中断或系统调用发生时，CPU停止当前的指令执行，将当前的状态（程序计数器、寄存器等）保存在堆栈中。</li>
</ul>
<ol>
<li><p><strong>查找中断向量</strong>：</p>
<ul>
<li>CPU根据中断号（或系统调用号）在中断向量表中查找相应的中断服务程序（ISR）地址。</li>
<li>对于系统调用，通常会有一个系统调用号，操作系统会根据该号在系统调用表中查找对应的处理函数。</li>
</ul>
</li>
<li><p><strong>执行中断服务程序（ISR）</strong>：</p>
<ul>
<li>操作系统执行相应的中断处理或系统调用的处理程序。</li>
</ul>
</li>
<li><p><strong>保存&#x2F;恢复进程上下文</strong>：</p>
<ul>
<li>在执行中断服务程序之前，操作系统保存当前进程的上下文信息（如寄存器值、程序计数器等）。</li>
<li>在中断处理程序结束后，恢复之前保存的上下文，确保用户程序能够继续执行。</li>
</ul>
</li>
<li><p><strong>返回用户态</strong>：</p>
<ul>
<li>操作系统通过<strong>返回中断</strong>指令（如<code>iret</code>或<code>sysret</code>）将控制权交还给用户程序。</li>
<li>用户程序继续执行，从发生系统调用或中断的位置开始。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>操作系统管理每个进程的状态信息，并存储在<strong>进程控制块（PCB）</strong>中。PCB包括了进程的上下文（寄存器状态、程序计数器等），当发生中断时，操作系统会保存当前进程的PCB，并根据中断的类型决定下一步的操作。</p>
<ul>
<li>对于<strong>系统调用</strong>，操作系统通过查找当前进程的系统调用号（通常存储在寄存器中）来决定该执行哪个系统调用处理程序。</li>
<li>对于<strong>硬件中断</strong>，操作系统通过中断向量表查找对应的中断服务程序，执行完相应操作后，恢复进程执行。</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><table>
<thead>
<tr>
<th><strong>分类标准</strong></th>
<th><strong>中断类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>按触发源分类</strong></td>
<td><strong>硬件中断</strong></td>
<td>由外部硬件设备或内部设备触发，通常用于响应外部事件，如I&#x2F;O操作、定时器等。</td>
</tr>
<tr>
<td></td>
<td><strong>软件中断</strong></td>
<td>由程序通过特定指令（如<code>syscall</code>或<code>int</code>）触发，通常用于系统调用或异常处理。</td>
</tr>
<tr>
<td><strong>按发生时机分类</strong></td>
<td><strong>同步中断</strong></td>
<td>中断与当前执行指令密切相关，通常由程序执行中的错误或特定操作触发。</td>
</tr>
<tr>
<td></td>
<td><strong>异步中断</strong></td>
<td>中断与当前执行的指令无关，通常由外部硬件或外部事件触发，如设备完成数据传输。</td>
</tr>
<tr>
<td><strong>按响应机制分类</strong></td>
<td><strong>屏蔽中断</strong></td>
<td>可以被操作系统或CPU屏蔽的中断，通常用于允许某些关键操作不中断。</td>
</tr>
<tr>
<td></td>
<td><strong>非屏蔽中断</strong></td>
<td>无法被操作系统或CPU屏蔽的中断，通常用于紧急事件，如硬件故障、紧急安全事件等。</td>
</tr>
<tr>
<td><strong>按优先级分类</strong></td>
<td><strong>可调优先级中断</strong></td>
<td>中断有不同的优先级，操作系统根据优先级处理高优先级的中断，低优先级的中断可以被打断。</td>
</tr>
<tr>
<td></td>
<td><strong>固定优先级中断</strong></td>
<td>中断有固定的优先级，通常由硬件设置，优先级不变。</td>
</tr>
<tr>
<td><strong>常见中断类型</strong></td>
<td><strong>外部中断</strong></td>
<td>由外部设备或事件触发的中断，如I&#x2F;O设备、定时器中断等。</td>
</tr>
<tr>
<td></td>
<td><strong>内部中断</strong></td>
<td>程序执行中出现的错误或异常事件，如除零错误、非法内存访问等。</td>
</tr>
<tr>
<td></td>
<td><strong>系统调用中断</strong></td>
<td>用户程序请求操作系统服务时触发的中断，通过<code>syscall</code>等指令发起。</td>
</tr>
<tr>
<td></td>
<td><strong>硬件故障中断</strong></td>
<td>硬件故障或错误引发的中断，如内存故障、总线错误等。</td>
</tr>
<tr>
<td></td>
<td><strong>定时器中断</strong></td>
<td>定时器触发的中断，通常用于操作系统调度、时间片轮转等。</td>
</tr>
</tbody></table>
<p><img src="https://s2.loli.net/2025/01/04/qvDzoaSCGwgyZcF.png" srcset="/img/loading.gif" lazyload alt="image-20250104090449719"></p>
<h1 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h1><h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>设备控制器是一个硬件组件，它充当了计算机中央处理单元（CPU）与外部设备（如硬盘、打印机、显示器、网络卡等）之间的中介。设备控制器负责管理设备的操作和状态控制，提供设备与CPU之间的通信通道。它的作用是将设备的物理操作转换为计算机可以理解和处理的数字信号，并通过设备驱动程序与操作系统进行交互。</p>
<p>简言之，设备控制器就是计算机与外部硬件设备之间的“桥梁”，它通过控制设备的输入输出（I&#x2F;O）操作，协调设备的工作。</p>
<p>确切地说，<strong>设备控制器</strong>的存在正是为了屏蔽不同硬件设备之间的差异，使得操作系统和应用程序可以以统一的方式与不同的硬件进行交互。每种设备（如硬盘、显示器、打印机等）通常会有一个对应的设备控制器组件，该组件负责处理与设备相关的底层操作，简化了操作系统对硬件的管理。下面进一步详细解释这一点。</p>
<table>
<thead>
<tr>
<th><strong>作用</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>屏蔽硬件差异</strong></td>
<td>提供统一接口，将不同硬件设备之间的通信协议、数据格式和信号方式等差异抽象化，使操作系统和应用程序无需关心硬件细节。</td>
<td>操作系统通过相同接口（如文件系统接口）进行硬盘的读写，无论是IDE、SATA硬盘还是SSD，底层控制器处理硬件差异。</td>
</tr>
<tr>
<td><strong>提供统一的操作接口</strong></td>
<td>操作系统通过设备控制器发出命令，控制设备进行相应的操作。设备控制器将操作系统的高层请求转化为适合硬件的操作。</td>
<td>操作系统使用通用I&#x2F;O接口进行数据交换（如读&#x2F;写命令），硬盘控制器将高层请求转化为硬盘的具体操作（如数据读取&#x2F;写入）。</td>
</tr>
<tr>
<td><strong>优化硬件资源管理</strong></td>
<td>管理设备资源，协调多个设备之间的竞争，防止资源冲突，进行资源的合理分配（如内存缓冲、DMA通道等）。</td>
<td>显卡控制器管理显示缓冲区，硬盘控制器管理数据块分配，确保设备资源不冲突并实现高效数据传输。</td>
</tr>
<tr>
<td><strong>处理设备中断</strong></td>
<td>接收并处理硬件设备发出的中断请求，当设备完成任务或发生错误时，生成中断信号通知操作系统进行后续处理。</td>
<td>网络卡控制器接收到数据包后发出中断，操作系统或驱动程序接收并处理这些数据。硬盘控制器在完成数据传输后也会生成中断。</td>
</tr>
</tbody></table>
<p>其中组成部分在<a target="_blank" rel="noopener" href="https://wangxiaobai08.github.io/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/">外存管理 - The Peak Tower</a>有过介绍不多赘述，</p>
<blockquote>
<p>那 CPU 是如何与设备的控制寄存器和数据缓冲区进行通信的？</p>
</blockquote>
<ul>
<li><em><strong>端口 I&#x2F;O</strong></em>，每个控制寄存器被分配一个 I&#x2F;O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 <code>in/out</code> 类似的指令。</li>
<li><em><strong>内存映射 I&#x2F;O</strong></em>，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区</li>
</ul>
<p>I&#x2F;O <strong>控制方式</strong></p>
<p>在前面我知道，每种设备都有一个设备控制器，控制器相当于一个小 CPU，它可以自己处理一些事情，但有个问题是，当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，它读完的时候，要怎么通知 CPU 呢？</p>
<p>在<a target="_blank" rel="noopener" href="https://wangxiaobai08.github.io/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/">外存管理 - The Peak Tower</a>同样介绍过，这里简单总结一下</p>
<table>
<thead>
<tr>
<th><strong>控制方式</strong></th>
<th><strong>描述</strong></th>
<th><strong>优缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Polling）</strong></td>
<td>CPU 定期检查设备控制器的状态寄存器，等待设备完成操作并返回结果。</td>
<td><strong>优点</strong>：实现简单，设备状态查询直观；<strong>缺点</strong>：占用大量 CPU 时间，CPU 需要一直轮询设备，效率低，浪费资源。</td>
<td>适用于设备操作时间较短且 I&#x2F;O 请求较少的场景。</td>
</tr>
<tr>
<td><strong>中断（Interrupt）</strong></td>
<td>当设备完成操作时，通过中断机制通知 CPU 停止当前任务并处理中断请求，设备完成 I&#x2F;O 操作后触发中断信号。</td>
<td><strong>优点</strong>：减少 CPU 空闲时的浪费，CPU 只在有需要时被打断；<strong>缺点</strong>：频繁的中断会导致 CPU 频繁中断当前任务，消耗时间。</td>
<td>适用于较为复杂、需要响应的设备（如网络卡、打印机等），但不适合频繁 I&#x2F;O 操作的设备。</td>
</tr>
<tr>
<td><strong>DMA（Direct Memory Access）</strong></td>
<td>设备控制器通过 DMA 控制器将数据直接从设备传输到内存，CPU 只需要在开始和结束时干预，完成数据传输后通过中断通知 CPU。</td>
<td><strong>优点</strong>：不占用 CPU 处理时间，提升 I&#x2F;O 性能；<strong>缺点</strong>：硬件实现复杂，需要支持 DMA 的设备和 DMA 控制器。</td>
<td>适用于大规模、高频率的数据传输，如磁盘、网络等，能够减少 CPU 干预，提升整体系统性能。</td>
</tr>
</tbody></table>
<p><img src="https://s2.loli.net/2025/01/04/92R8slSg7VjLwF1.png" srcset="/img/loading.gif" lazyload alt="image-20250104092551860"></p>
<hr>
<h2 id="引入设备驱动程序"><a href="#引入设备驱动程序" class="headerlink" title="引入设备驱动程序"></a>引入设备驱动程序</h2><p>虽然设备控制器屏蔽了设备的众多细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了设备驱动程序。</p>
<p>设备驱动程序作为操作系统的一部分，它位于操作系统与硬件之间，负责将操作系统的高层请求转换为适合具体硬件的低层命令，并处理硬件设备的控制器寄存器、缓冲区等不同的使用模式。</p>
<blockquote>
<p>设备控制器不属于操作系统范畴，它是属于硬件，而设备驱动程序属于操作系统的一部分，操作系统的内核代码可以像本地调用代码一样使用设备驱动程序接口，而设备驱动程序是面向设备控制器的代码，它发出操控设备控制器的指令后，才可以操作设备控制器。</p>
</blockquote>
<h2 id="设备驱动程序的功能"><a href="#设备驱动程序的功能" class="headerlink" title="设备驱动程序的功能"></a><strong>设备驱动程序的功能</strong></h2><table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>接收命令并转换要求</strong></td>
<td>设备驱动程序接收来自设备独立性软件的命令和参数，并将命令中的抽象要求转化为具体的硬件指令。例如，磁盘驱动程序将逻辑的磁盘块号转换为物理的盘面、磁道号和扇区号。</td>
<td>将用户请求中的文件读取操作，转换为具体硬盘的物理寻址操作，如将文件的逻辑块号转化为实际的磁盘块号、盘面号、扇区号。</td>
</tr>
<tr>
<td><strong>检查I&#x2F;O请求的合法性</strong></td>
<td>设备驱动程序需要检查用户发出的 I&#x2F;O 请求的合法性，确保请求参数正确，同时获取设备当前状态，设置设备的工作模式。</td>
<td>检查 I&#x2F;O 请求中给定的文件路径是否有效，设备是否空闲，设备是否支持请求的操作（如磁盘是否有足够空间，是否支持特定的读写模式）。</td>
</tr>
<tr>
<td><strong>发出I&#x2F;O命令</strong></td>
<td>当设备空闲时，驱动程序发出 I&#x2F;O 命令并启动设备完成操作；若设备忙碌，则将请求挂起，等待设备空闲后再执行。</td>
<td>当用户发出文件读取命令时，如果硬盘空闲，驱动程序立即发出磁盘读取命令；如果硬盘忙碌，驱动程序将该请求加入队列，等待硬盘空闲后再执行。</td>
</tr>
<tr>
<td><strong>响应中断请求</strong></td>
<td>设备控制器或通道发出的中断信号会通知驱动程序处理设备状态变化或任务完成，驱动程序根据中断类型调用相应的中断处理程序。</td>
<td>硬盘在完成数据读写后，发送中断信号，驱动程序响应中断，读取硬盘控制器的状态，获取数据，并通知操作系统处理。</td>
</tr>
<tr>
<td><strong>构成通道程序（对于有通道的系统）</strong></td>
<td>对于支持通道的计算机系统，设备驱动程序根据用户的 I&#x2F;O 请求构成通道程序，指示计算机如何操作设备。</td>
<td>对于支持 DMA 通道的系统，驱动程序会根据 I&#x2F;O 请求自动生成通道程序，并通过 DMA 控制器将数据从硬盘传输到内存，而无需 CPU 参与。</td>
</tr>
</tbody></table>
<h2 id="设备处理方式"><a href="#设备处理方式" class="headerlink" title="设备处理方式"></a>设备处理方式</h2><p>在不同的操作系统中所采用的设备处理方式并不完全相同。</p>
<p>根据在设备处理时是否设置进程，以及设置什么样的进程而把设备处理方式分成以下三类：</p>
<ul>
<li><p>为每一类设备设置一个进程，专门用于执行这类设备的I&#x2F;O操作。 比如，为所有的交互式终端设置一个交互式终端进程；为同一类型的打印机设置一个打印进程。</p>
</li>
<li><p>在整个系统中设置一个I&#x2F;O进程，专门用于执行系统中所有各类设备的I&#x2F;O操作。也可以设置一个输入进程和一个输出进程，分别处理系统中所有各类设备的输入和输出操作。</p>
</li>
<li><p>不设置专门的设备处理进程，而只为各类设备设置相应的设备处理程序（模块），供用户进程或系统进程调用。</p>
</li>
</ul>
<h2 id="设备驱动程序的特点"><a href="#设备驱动程序的特点" class="headerlink" title="设备驱动程序的特点"></a>设备驱动程序的特点</h2><table>
<thead>
<tr>
<th><strong>特点</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>与 I&#x2F;O 进程和设备控制器之间的通信转换</strong></td>
<td>驱动程序将进程的 I&#x2F;O 请求转换为适合设备控制器的指令，并将设备的状态和 I&#x2F;O 操作完成情况反馈给进程。</td>
</tr>
<tr>
<td><strong>与硬件特性紧密相关</strong></td>
<td>每种设备或同一类型的设备（由于厂商不同）需要不同的驱动程序，设备驱动程序与硬件设备的特性紧密相关。</td>
</tr>
<tr>
<td><strong>与 I&#x2F;O 控制方式相关</strong></td>
<td>驱动程序与设备使用的 I&#x2F;O 控制方式相关，如 <strong>中断驱动</strong> 和 <strong>DMA 驱动</strong>，两者的编写方式和处理机制不同。</td>
</tr>
<tr>
<td><strong>部分驱动程序需要汇编语言编写</strong></td>
<td>由于设备驱动程序需要直接操作硬件，一些底层驱动程序使用汇编语言编写，部分驱动程序已被固化在 <strong>ROM</strong> 中，减少内存消耗。</td>
</tr>
<tr>
<td><strong>支持可重入性</strong></td>
<td>驱动程序需支持可重入性，即在驱动程序执行过程中可以被再次调用，例如网络驱动程序在处理一个数据包时，可以同时处理另一个数据包的到达。</td>
</tr>
<tr>
<td><strong>不允许直接调用系统调用</strong></td>
<td>驱动程序不能直接进行普通的系统调用，但可以通过调用内核过程（如内存管理）来进行某些操作，以满足与内核的交互需求。</td>
</tr>
</tbody></table>
<h2 id="设备驱动程序处理过程"><a href="#设备驱动程序处理过程" class="headerlink" title="设备驱动程序处理过程"></a>设备驱动程序处理过程</h2><table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1）将抽象要求转换为具体要求</strong></td>
<td>驱动程序将用户和上层软件提出的抽象命令转换为设备控制器能够理解的具体命令。驱动程序负责处理命令、参数和数据，并将它们正确地传递到控制器的寄存器。</td>
</tr>
<tr>
<td><strong>2）检查 I&#x2F;O 请求的合法性</strong></td>
<td>驱动程序检查用户发出的 I&#x2F;O 请求是否合法，确保请求不超出设备能力范围，避免对设备造成不正常的操作。</td>
</tr>
<tr>
<td><strong>3）读出和检查设备的状态</strong></td>
<td>驱动程序读取设备的状态信息，判断设备是否处于空闲状态，是否可以接受新的 I&#x2F;O 请求。通常检查设备是否处于 “忙” 状态，避免与其他操作冲突。</td>
</tr>
<tr>
<td><strong>4）传送必要的参数</strong></td>
<td>对于一些设备（如磁盘等块设备），驱动程序需要将相关参数（如数据传送的字节数、数据存储地址等）传送到设备控制器的相关寄存器中。</td>
</tr>
<tr>
<td><strong>5）工作方式的设置</strong></td>
<td>设置设备的工作模式，例如确定是同步 I&#x2F;O 还是异步 I&#x2F;O，配置设备的缓冲区、DMA 模式等，以确保设备在合适的工作模式下执行操作。</td>
</tr>
<tr>
<td><strong>6）启动 I&#x2F;O 设备</strong></td>
<td>向设备控制器发送启动命令，启动 I&#x2F;O 操作。驱动程序之后会将自己阻塞，直到设备完成 I&#x2F;O 操作并通过中断通知驱动程序完成任务。</td>
</tr>
</tbody></table>
<h1 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I&#x2F;O软件"></a>与设备无关的I&#x2F;O软件</h1><p><strong>与设备无关的 I&#x2F;O 软件</strong>是指操作系统中一类不依赖于具体硬件设备的 I&#x2F;O 管理软件模块。它的主要任务是提供一种抽象层，屏蔽不同硬件设备之间的差异，使得上层应用程序和操作系统能够以统一的方式进行 I&#x2F;O 操作，而无需关心具体设备的硬件细节。</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>设备抽象</strong></td>
<td>与设备无关的 I&#x2F;O 软件提供对设备的抽象，使操作系统和应用程序不直接与硬件设备交互，通过统一的接口（如文件系统接口）访问不同类型的设备（如硬盘、打印机、网络设备等）。</td>
</tr>
<tr>
<td><strong>设备管理</strong></td>
<td>负责设备的分配、调度和回收。例如，文件系统管理磁盘上的文件，但不直接与硬盘交互，而是通过 I&#x2F;O 软件层实现这一管理功能。</td>
</tr>
<tr>
<td><strong>I&#x2F;O 调度</strong></td>
<td>根据设备请求进行调度，确保多个 I&#x2F;O 请求按顺序处理。与设备无关的软件负责制定 I&#x2F;O 调度策略，且不关心设备的具体实现。</td>
</tr>
<tr>
<td><strong>统一接口</strong></td>
<td>提供统一的 API（如读写文件），使得应用程序和操作系统可以通过标准接口进行 I&#x2F;O 操作，这些接口与具体设备实现无关，确保不同硬件设备的兼容性。</td>
</tr>
<tr>
<td><strong>设备驱动模块与 I&#x2F;O 中介</strong></td>
<td>操作系统通过设备驱动程序与硬件交互，但这些驱动程序由与设备无关的 I&#x2F;O 软件管理，减少应用层对硬件的依赖，使驱动程序专注于硬件操作。</td>
</tr>
</tbody></table>
<h3 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h3><ol>
<li><strong>文件系统</strong>：<ul>
<li>文件系统为用户提供了一个统一的接口，使得用户可以通过文件操作命令（如 <code>open</code>、<code>read</code>、<code>write</code>）访问不同类型的存储设备（如硬盘、SSD、网络存储等）。用户无需关心文件存储在何处，如何在磁盘上进行具体的读写操作，这些由与设备无关的 I&#x2F;O 软件处理。</li>
</ul>
</li>
<li><strong>设备驱动程序接口</strong>：<ul>
<li>操作系统通过设备驱动程序与具体硬件进行交互，但与设备无关的 I&#x2F;O 软件提供了一个统一的接口给操作系统，操作系统通过这个接口来调用不同的设备驱动程序，而无需关心每种硬件的具体细节。</li>
</ul>
</li>
<li><strong>标准输入输出流（stdin, stdout, stderr）</strong>：<ul>
<li>在许多操作系统中，标准输入输出流是由与设备无关的 I&#x2F;O 软件管理的。用户可以通过 <code>printf</code> 输出信息，或通过 <code>scanf</code> 获取输入，而这些操作背后可能会涉及键盘、终端、文件等多种设备，但用户无需了解这些细节。</li>
</ul>
</li>
</ol>
<h2 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h2><p>设备独立性（是指操作系统及其应用程序不需要了解底层硬件设备的具体实现细节，而能够通过统一的接口与不同的设备进行交互。通过设备独立性，操作系统提供一个抽象层，屏蔽了硬件的差异，使得应用程序在处理设备时能够实现设备无关操作。</p>
<p>设备独立性的核心思想是：上层软件（如操作系统和应用程序）通过设备无关的 I&#x2F;O 软件层来与硬件设备交互，而不需要直接控制每个具体硬件的细节。这使得用户可以在不同硬件环境下运行相同的软件，且无需对设备进行修改。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li><strong>提高可移植性</strong><br> 设备独立性使得应用程序和操作系统不依赖于特定的硬件设备。当硬件发生变化时，只需要修改底层的设备驱动程序或硬件抽象层，而不需要更改应用程序或操作系统的其他部分。因此，应用程序可以在不同硬件平台上无缝运行。</li>
<li><strong>简化应用程序开发</strong><br> 通过提供统一的接口，开发者不需要了解每个硬件设备的具体细节，如不同硬盘、打印机、显示器等设备的控制方式。开发者只需通过标准的系统调用和接口来进行设备的访问，简化了开发过程。</li>
<li><strong>增强系统的扩展性</strong><br> 设备独立性使得系统能够更容易地添加新设备。操作系统只需提供新设备的驱动程序，并将其纳入现有的 I&#x2F;O 软件架构中，无需修改应用程序或核心的其他部分。新的硬件设备可以以最小的代价集成进系统。</li>
<li><strong>减少硬件依赖性</strong><br> 在多种硬件平台上，操作系统和应用程序能以相同的方式运行，减少了对特定硬件的依赖。这使得系统能够更好地适应硬件的更新换代，延长软件的生命周期。</li>
<li><strong>提高兼容性</strong><br> 设备独立性通过提供统一的接口和抽象，使得不同厂商、不同型号的硬件设备能够与操作系统兼容。用户无需为每个设备配置单独的软件，操作系统能够处理不同硬件设备间的差异，提高了兼容性。</li>
<li><strong>简化系统维护和更新</strong><br> 由于硬件与操作系统的关系通过设备驱动程序隔离，系统的维护和更新变得更加容易。如果需要更换或更新硬件，只需更新或替换相关的设备驱动程序，而不需要修改应用程序或操作系统的其他部分。</li>
</ol>
<h3 id="设备独立性的实现方式"><a href="#设备独立性的实现方式" class="headerlink" title="设备独立性的实现方式"></a>设备独立性的实现方式</h3><ol>
<li><strong>统一的 I&#x2F;O 接口</strong><br> 操作系统提供统一的 I&#x2F;O 接口，供应用程序进行文件、设备等操作。例如，文件系统通过标准的读写接口来操作硬盘，而不需要关注硬盘的具体型号和工作原理。</li>
<li><strong>设备抽象层</strong><br> 操作系统通过设备驱动程序提供对硬件设备的抽象。设备驱动程序将硬件设备的操作抽象为统一的接口，使得上层的软件无需关心设备的具体实现。</li>
<li><strong>虚拟设备</strong><br> 操作系统可能使用虚拟设备的方式来实现设备独立性。例如，操作系统会为每种硬件设备创建一个虚拟设备接口，所有硬件设备都通过该虚拟接口与操作系统和应用程序交互。</li>
</ol>
<h2 id="I-O-重定向与设备独立性"><a href="#I-O-重定向与设备独立性" class="headerlink" title="I&#x2F;O 重定向与设备独立性"></a>I&#x2F;O 重定向与设备独立性</h2><p><strong>I&#x2F;O 重定向</strong> 是操作系统中一个重要的功能，它允许用户改变标准输入、标准输出和标准错误的默认设备。例如，可以将命令行中的输出重定向到文件，或者将一个程序的输入重定向到另一个程序的输出。通过重定向，用户可以灵活地指定 I&#x2F;O 操作的目标和源，而不必修改程序的代码。</p>
<p>I&#x2F;O 重定向与设备独立性有紧密关系。由于设备独立性提供了统一的 I&#x2F;O 接口，操作系统和应用程序可以通过标准的文件和设备接口进行交互，I&#x2F;O 重定向正是利用这种抽象能力，允许 I&#x2F;O 操作不受底层硬件或设备的限制。</p>
<h3 id="I-O-重定向的概念"><a href="#I-O-重定向的概念" class="headerlink" title="I&#x2F;O 重定向的概念"></a>I&#x2F;O 重定向的概念</h3><p>I&#x2F;O 重定向指的是改变进程的标准输入、标准输出和标准错误流的默认设备。比如，命令行中常见的输入输出重定向操作：</p>
<ul>
<li><p>标准输出重定向将程序的输出写入文件而不是显示在屏幕上。</p>
<ul>
<li>示例：<code>echo &quot;Hello, World!&quot; &gt; output.txt</code></li>
</ul>
</li>
<li><p>标准输入重定向将文件的内容作为输入传递给程序。</p>
<ul>
<li>示例：<code>sort &lt; input.txt</code></li>
</ul>
</li>
<li><p>管道将一个程序的输出传递到另一个程序的输入。</p>
<ul>
<li>示例：<code>cat file.txt | grep &quot;keyword&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="I-O-重定向如何利用设备独立性"><a href="#I-O-重定向如何利用设备独立性" class="headerlink" title="I&#x2F;O 重定向如何利用设备独立性"></a>I&#x2F;O 重定向如何利用设备独立性</h3><ol>
<li><strong>统一的接口</strong>： 设备独立性通过提供统一的文件系统接口，使得 I&#x2F;O 重定向操作可以透明地在不同设备间进行。例如，用户可以通过简单的命令将数据从磁盘重定向到屏幕，或者将标准输出重定向到一个文件。操作系统提供统一的接口来处理这些操作，而不需要考虑设备类型或硬件的具体实现。</li>
<li><strong>增强的灵活性</strong>： 设备独立性允许操作系统支持多种不同的设备，而 I&#x2F;O 重定向可以使得用户在不改变应用程序代码的情况下，灵活地选择输入输出的目标。这种灵活性是由设备无关的 I&#x2F;O 软件实现的，它通过统一接口屏蔽了硬件差异，使得用户可以根据需要重定向 I&#x2F;O 到不同的设备或文件中。</li>
<li><strong>简化的应用程序设计</strong>： 设备独立性简化了应用程序的设计，使得应用程序可以忽略硬件设备的细节。应用程序只需要处理标准的输入输出流，而不需要关心数据从哪个设备来或去往哪个设备。因此，I&#x2F;O 重定向在应用程序中变得更加简洁，程序设计不需要为不同的设备编写专门的代码。</li>
<li><strong>增强的系统可移植性</strong>： 由于设备独立性，程序可以在不同的硬件平台上无缝运行。而 I&#x2F;O 重定向的功能也与设备无关，因此它增强了系统的可移植性。用户可以在不同操作系统或硬件环境中使用相同的 I&#x2F;O 重定向命令，不会受到底层硬件差异的影响。</li>
</ol>
<p>具体参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/05-ivyli-19/p/17378319.html">第五章 输入输出系统 5.5 与设备无关的I&#x2F;O软件 - LEE_Minhyung - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38499859/article/details/81172220">操作系统19———IO系统之与设备无关的I&#x2F;O软件&amp;用户层的I&#x2F;O软件_与设备无关性的基本含义是什么? 为什么要设置该层?-CSDN博客</a></p>
<h1 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I&#x2F;O软件"></a>用户层的I&#x2F;O软件</h1><p>用户层的 I&#x2F;O 软件是操作系统中的一部分，它位于内核层的 I&#x2F;O 子系统与用户程序之间，主要负责向应用程序提供与硬件设备交互的接口。用户层 I&#x2F;O 软件通常提供更高层次的抽象，简化了用户对设备的访问方式，同时也增加了设备访问的灵活性和可移植性。</p>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>I&#x2F;O 系统调用接口</strong></td>
<td>提供用户与操作系统之间进行设备交互的接口，包含文件读写、设备控制等常用功能。</td>
</tr>
<tr>
<td><strong>标准 I&#x2F;O 库</strong></td>
<td>提供易于使用的高层次 API，封装了底层的系统调用，简化了 I&#x2F;O 操作。</td>
</tr>
<tr>
<td><strong>文件系统</strong></td>
<td>为用户提供统一的文件和目录管理接口，将硬件存储抽象为文件，并支持文件操作、目录操作等。</td>
</tr>
<tr>
<td><strong>设备驱动接口</strong></td>
<td>提供设备驱动程序的标准接口，用户程序通过这些接口访问硬件设备，而无需关注底层硬件的实现细节。</td>
</tr>
<tr>
<td><strong>设备无关的 I&#x2F;O 软件</strong></td>
<td>提供设备抽象，屏蔽硬件差异，简化设备的管理和操作，使应用程序与硬件设备无关。</td>
</tr>
<tr>
<td><strong>异步 I&#x2F;O</strong></td>
<td>允许用户程序在发起 I&#x2F;O 操作时继续执行其他任务，提高了程序的响应性和性能。</td>
</tr>
<tr>
<td><strong>缓存与缓冲区管理</strong></td>
<td>提供高效的数据缓存和缓冲管理，减少 I&#x2F;O 操作的次数，提高数据访问效率。</td>
</tr>
</tbody></table>
<p>具体参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tang7mj/article/details/136191815">6.6 用户层的I&#x2F;O软件_用户层软件-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liyaaixuexi/p/17352046.html">考研408操作系统-SPOOLing技术（假脱机技术） - liya今天学什么 - 博客园</a></p>
<h1 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/533321012">操作系统–缓冲管理 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_61888137/article/details/134085322">操作系统缓冲区管理（单缓冲，双缓冲，循环缓冲，缓冲池）_单缓冲区和双缓冲区的问题-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44096670/article/details/121632471">操作系统缓冲区管理（单缓冲、双缓冲、循环缓冲以及缓冲池）_单缓冲区-CSDN博客</a></p>
<h1 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h1><p>具体参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/05-ivyli-19/p/17399022.html">第五章 输入输出系统 5.8 磁盘存储器的性能和调度 - LEE_Minhyung - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40212930/article/details/105393493">图解五种磁盘调度算法, FCFS, SSTF, SCAN, C-SCAN, LOOK_scan算法-CSDN博客</a></p>
<blockquote>
<p>需要留意这里的磁盘调度算法</p>
</blockquote>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26553393/article/details/122239406">1.1.5 中断的概念和作用、内部中断、外部中断、中断机制的基本原理_处理器中断-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_73077810/article/details/136356343">如何理解操作系统中的设备控制与设备驱动程序？_设备驱动程序和设备控制器-CSDN博客</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="category-chain-item">基础知识</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>外存管理【补充】</div>
      <div>http://example.com/2023/01/25/外存管理【补充】/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/30/%E7%BD%91%E7%BB%9C%E5%B1%82/" title="网络层">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网络层</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/22/%E3%80%8AC++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E3%80%8B%E9%98%85%E8%AF%BB(%E5%9B%9B)/" title="《C++反汇编与逆向分析》阅读总结(四)">
                        <span class="hidden-mobile">《C++反汇编与逆向分析》阅读总结(四)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
