

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础知识基本数据类型的表现形式 一个char字符&#x3D;&#x3D;一个ASCII 编码&#x3D;&#x3D;1 字节，即 8 位 int 类型占 4 字节（32 位），即使数字 1 本身是一个小的值，它依然会占用 4 字节的内存空间，再比如123456789也占4字节，注意与字符区分。将四个数字转换成字节后，就构成了一个 16 字节的 AES 密钥。 123456789101112int">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++反汇编与逆向分析》阅读总结(一)">
<meta property="og:url" content="http://example.com/2023/01/08/%E3%80%8AC++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E3%80%8B%E9%98%85%E8%AF%BB%E4%B8%80/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="基础知识基本数据类型的表现形式 一个char字符&#x3D;&#x3D;一个ASCII 编码&#x3D;&#x3D;1 字节，即 8 位 int 类型占 4 字节（32 位），即使数字 1 本身是一个小的值，它依然会占用 4 字节的内存空间，再比如123456789也占4字节，注意与字符区分。将四个数字转换成字节后，就构成了一个 16 字节的 AES 密钥。 123456789101112int">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/03/03/mFMlRj53sY2GBdx.jpg">
<meta property="og:image" content="https://s2.loli.net/2025/03/03/gRr5ZUbyC1cJtx3.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/12/bBYNcywFk1R5SKQ.jpg">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/X9gRyc814lTYMb6.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/06/p3IEzarKhcegBuU.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/j54DOfT21te7VZP.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/VBXOI2naRcuLi7F.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/stMI6Rj8vlDgSAZ.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/ozXQG1ukjfpJFTt.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/06/OTjN14vtIuLmnM3.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/qvgHUtIoyzQdPcV.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/LDF8guGV5SE9maR.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/RxNyfGgZEvYJIzc.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/v7iGQnKUkI6s2Rm.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/Al6LvjV5NFXgxkn.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/WI4lKhazN3LrHUJ.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/ObfQerpXYai6KJN.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/hwy6v1kT2bqiaAP.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/HR3kXJNFQrdBKbA.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/02/fs9QiuLnzcHTvlh.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/05/lLjNg2PAcCfRBhi.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/06/DMQWZiEYXOrFdag.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/06/3AZH69PWGE5Ykxf.png">
<meta property="article:published_time" content="2023-01-08T10:12:54.000Z">
<meta property="article:modified_time" content="2025-03-09T09:14:50.704Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="逆向(android)">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/03/03/mFMlRj53sY2GBdx.jpg">
  
  
  
  <title>《C++反汇编与逆向分析》阅读总结(一) - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="《C++反汇编与逆向分析》阅读总结(一)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-08 18:12" pubdate>
          2023年1月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          58 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">《C++反汇编与逆向分析》阅读总结(一)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基本数据类型的表现形式"><a href="#基本数据类型的表现形式" class="headerlink" title="基本数据类型的表现形式"></a>基本数据类型的表现形式</h2><p><img src="https://s2.loli.net/2025/03/03/mFMlRj53sY2GBdx.jpg" srcset="/img/loading.gif" lazyload></p>
<p>一个char字符&#x3D;&#x3D;一个ASCII 编码&#x3D;&#x3D;<strong>1 字节</strong>，即 <strong>8 位</strong></p>
<p><code>int</code> 类型占 <strong>4 字节</strong>（32 位），即使数字 1 本身是一个小的值，它依然会占用 4 字节的内存空间，再比如123456789也占4字节，注意与字符区分。将四个数字转换成字节后，就构成了一个 16 字节的 AES 密钥。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> key1 = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 第一个 int 数字</span><br><span class="hljs-type">int</span> key2 = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 第二个 int 数字</span><br><span class="hljs-type">int</span> key3 = <span class="hljs-number">3</span>;    <span class="hljs-comment">// 第三个 int 数字</span><br><span class="hljs-type">int</span> key4 = <span class="hljs-number">4</span>;    <span class="hljs-comment">// 第四个 int 数字</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> aes_key[<span class="hljs-number">16</span>]; <span class="hljs-comment">// 16 字节 AES 密钥</span><br><br><span class="hljs-comment">// 将 4 个 int 数字转换为字节</span><br>aes_key[<span class="hljs-number">0</span>] = (key1 &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xFF</span>;  <span class="hljs-comment">// key1 的最高字节</span><br>aes_key[<span class="hljs-number">1</span>] = (key1 &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>;<br>aes_key[<span class="hljs-number">2</span>] = (key1 &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>;<br>aes_key[<span class="hljs-number">3</span>] = key1 &amp; <span class="hljs-number">0xFF</span>;  <span class="hljs-comment">// key1 的最低字节</span><br></code></pre></td></tr></table></figure>

<p><strong>ASCII 编码</strong>（美国标准信息交换码）本身是字符编码标准，它是用来表示字符（例如字母、数字和符号）的一种方式。ASCII 编码并没有定义 <strong>int 类型</strong>，它只处理字符类型的数据。因此，在 ASCII 编码中，只涉及字符（<strong>char</strong> 类型），而不是整数（<strong>int</strong> 类型）。</p>
<ul>
<li><p><strong>ASCII</strong> 编码：每个字符占 <strong>1 字节</strong>，因为它使用 <strong>7 位</strong>来表示字符，最高位（8 位）通常为 0。</p>
</li>
<li><p>Unicode</p>
<p>编码：字符占用的字节数取决于编码格式：</p>
<ul>
<li><strong>UTF-8</strong>：1 到 4 字节</li>
<li><strong>UTF-16</strong>：2 或 4 字节</li>
<li><strong>UTF-32</strong>：4 字节</li>
</ul>
</li>
</ul>
<p>所以，<strong>ASCII 字符集</strong>中每个字符都占 <strong>1 字节</strong>，而 <strong>Unicode</strong> 编码的字符根据所用的编码格式和字符的范围，占用的字节数可能不同。</p>
<p><img src="https://s2.loli.net/2025/03/03/gRr5ZUbyC1cJtx3.png" srcset="/img/loading.gif" lazyload></p>
<p>在汇编语言中，通常使用 <strong>16 进制</strong> 来表示数据和操作数，而不是二进制。这是因为 <strong>16 进制</strong> 更紧凑、易于阅读，并且与计算机硬件（尤其是处理器的寄存器）密切相关，方便与机器语言（机器码）之间的转换。</p>
<p>在 16 进制表示中，<strong>每个 16 进制字符</strong>（即一个十六进制数字）占用 <strong>4 位</strong>（即 4 个二进制位），而不是字节。两个 16 进制字符（即一个 16 进制字节）构成一个 <strong>字节</strong>（8 位）。</p>
<hr>
<h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p><img src="https://s2.loli.net/2024/12/12/bBYNcywFk1R5SKQ.jpg" srcset="/img/loading.gif" lazyload alt="大端序和小端序"></p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>字节序指的是在多字节数据类型（例如整数和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238598868&content_type=Article&match_order=1&q=%E6%B5%AE%E7%82%B9%E6%95%B0&zhida_source=entity">浮点数</a>）存储时，字节的排列顺序。在<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=238598868&content_type=Article&match_order=1&q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98&zhida_source=entity">计算机内存</a>中，多字节数据类型通常由多个字节组成，而字节序决定了这些字节的排列顺序。</p>
<p>字节序是计算机体系结构的一部分，主要影响数据在内存中的存储顺序。字节序的问题的由来，通常是由计算机的 <strong>处理器架构</strong>（CPU）和 <strong>网络传输</strong>协议决定的。</p>
<blockquote>
<p>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，<strong>计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序</strong>。</p>
</blockquote>
<p><strong>处理器架构</strong></p>
<p>不同的处理器架构可能采用不同的字节序。例如：</p>
<ul>
<li><strong>Intel</strong> x86 和 x86_64 系列处理器采用 <strong>小端序</strong>。</li>
<li><strong>Motorola 68k</strong> 和一些 <strong>RISC</strong> 架构（如 PowerPC）采用 <strong>大端序</strong>。</li>
<li>一些处理器架构（如 <strong>ARM</strong>）可以配置为大端或小端模式，这称为 <strong>Bi-endian</strong>。</li>
</ul>
<p>因此，当不同架构的系统互相交换数据时，必须考虑字节序的兼容性，才能正确解析数据。</p>
<p><strong>网络传输</strong></p>
<p>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合比如网络传输和文件储存，几乎都是用的大端字节序。正是因为这些原因才有了字节序。计算机处理字节序的时候，如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序则正好相反。在网络协议（如 <strong>TCP&#x2F;IP</strong>）中，通常使用 <strong>大端序</strong>（也称为 “网络字节序”）来传输数据。这是因为在网络标准中，采用大端序能够确保不同平台之间的数据一致性。</p>
<p>例如，在传输 4 字节的整数时，不管发送方是使用大端还是小端序，接收方都需要按大端序解析数据，以确保正确接收。</p>
<h1 id="流程语句的识别"><a href="#流程语句的识别" class="headerlink" title="流程语句的识别"></a>流程语句的识别</h1><h2 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x+<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码：</p>
<img src="https://s2.loli.net/2025/03/02/X9gRyc814lTYMb6.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<blockquote>
<p>if的比较条件为“x &#x3D;&#x3D; 0”，如果成立，即为真值，则进入if语句块内执行语句。但是，转换后的汇编代码使用的条件跳转指令bne判断结果为“不等于0跳转”。</p>
</blockquote>
<p>汇编语言的条件跳转指令（如 <code>bne</code>）是基于 <strong>条件不满足时跳转</strong> 的逻辑设计的。</p>
<ul>
<li>在大多数情况下，<code>if</code> 语句的条件为假的概率更高（例如错误处理分支）。</li>
<li>通过“条件不满足时跳转”，可以减少跳转次数，提高代码的执行效率。</li>
</ul>
<p>编译器在生成汇编代码时，通常会优先处理“条件不满足时跳转”的逻辑，因为这更符合 CPU 的指令集设计和性能优化需求。可以简单的认为CPU更倾向早点结束一段程序。</p>
<h2 id="If-else语句"><a href="#If-else语句" class="headerlink" title="If-else语句"></a>If-else语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;world hello&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x+<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码：</p>
<img src="https://s2.loli.net/2025/03/06/p3IEzarKhcegBuU.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>按if…else…的逻辑，如果满足if条件，则执行if语句块；否则执行else语句块，两者有且仅有一个会执行。所以，如果编译器生成的代码在<code>bne   .L2</code>处的跳转条件成立，则必须到达else块的代码开始处。而.L2处有个无条件跳转<code>b    .L3</code>，它的作用是绕过else块，因为如果能执行这个<code>b    .L3</code>，if条件必然成立，对应的反汇编代码处的跳转条件必然不能成立，且if语句块已经执行完毕。由此，我<strong>们可以将这里的两处跳转指令作为“指路明灯”</strong>，准确划分if块和else块的边界。</p>
<p><img src="https://s2.loli.net/2025/03/02/j54DOfT21te7VZP.png" srcset="/img/loading.gif" lazyload></p>
<p>如果遇到a方案的指令序列，先考察其中的两个跳转指令，当第一个条件跳转指令跳转到地址else开始处之前有<code>b</code>指令，则将其视为由if…else…组合而成的双分支结构。根据这两个跳转指令可以得到if和else语句块的代码边界。通过cmp与<code>bxx</code>可还原if的比较信息，<code>b</code>指令之后即为else块的开始。依此分析，即可逆向分析出if…else…组合的原型.</p>
<h2 id="If的多分支语句"><a href="#If的多分支语句" class="headerlink" title="If的多分支语句"></a>If的多分支语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;world hello&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x+<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码</p>
<img src="https://s2.loli.net/2025/03/02/VBXOI2naRcuLi7F.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>从代码中可以分析出，每条if语句由<code>cmp</code>和<code>bxx</code>组成，而else由一个<code>b</code>跳转到分支结构的最后一个语句块结束地址组成。由此可见，虽然它们组合在了一起，但是每个if和else又都是独立的，if仍然是由CMP&#x2F;TEST加<code>bxx</code>组成，我们仍然可以根据上一节介绍的知识，利用<code>bxx</code>和<code>b</code>识别出if和else if语句块的边界，<code>bxx</code>指出了下一个else if的起始点，而<code>b</code>指出了整个多分支结构的末尾地址以及当前if或者else if语句块的末尾。最后else块的边界也很容易识别，如果发现多分支块内的某一段代码在执行前没有判定，即可定义为else块，如上述代码中的32地址处。</p>
<img src="https://s2.loli.net/2025/03/02/stMI6Rj8vlDgSAZ.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>如果遇到类似上述的代码块，需要考察各跳转指令之间的关系。当每个条件跳转指令的跳转地址之前都紧跟b指令，并且它们跳转的地址值一样时，可视为一个多分支结构。b指令指明了多分支结构的末尾，配合比较判断指令与条件跳转指令，可还原出各分支语句块的组成。如果某个分支语句块中没有判定类指令，但是存在语句块，且语句块的位置在多分支语句块范围内，可以判定其为else语句块。</p>
<p>GCC编译器在使用02优化选项下同样会使用b方案优化。这里注意编译优化，当代码中的分支结构形成永远不可抵达的分支语句块时，它永远不会被执行，可以被优化掉而不参与编译处理。比如常见的<em><strong>常量传播优化</strong></em></p>
<h2 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++源码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>  <span class="hljs-keyword">switch</span>(n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 1&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 3&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 100&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码：</p>
<img src="https://s2.loli.net/2025/03/02/ozXQG1ukjfpJFTt.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>对比分析：if…else if结构会在条件跳转后紧跟语句块；而switch结构则将所有的条件跳转都放置在一起，并没有发现case语句块的踪影。通过条件跳转指令，跳转到相应case语句块中，因此每个case的执行是由switch比较结果引导“跳”过来的。所有case语句块都是连在一起的，这样是为了实现C语法的要求，在case语句块中没有break语句时，可以顺序执行后续case语句块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>  <span class="hljs-keyword">switch</span>(n)&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 1&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 2&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 3&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 5&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 6&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 7&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="switch的优化特性"><a href="#switch的优化特性" class="headerlink" title="switch的优化特性"></a>switch的优化特性</h2><p>【当分支数大于3，并且case的判定值存在明显线性关系组合时】即将每个case语句块的地址预先保存在数组中，考察switch语句的参数，并依此查询case语句块地址的数组，从而得到对应case语句块的首地址。</p>
<img src="https://s2.loli.net/2025/03/06/OTjN14vtIuLmnM3.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>为什么要对r3减1呢？</p>
<p>因为代码中为case语句制作了一份case地址数组（或者称为“case地址表”），这个数组保存了每个case语句块的首地址，并且数组下标是以0起始的。而case中的最小值是1，与case地址表的起始下标不对应，所以需要对r3减1调整，使其可以作为表格的下标进行寻址。</p>
<p>在进入switch后会先进行一次比较，检查输入的数值是否大于case的最大值，由于case的最小值为1，那么对齐到0下标后，示例中case的最大值为6（7-1&#x3D;6）。又由于使用了无符号比较，当输入的数值为0或一个负数时，同样会大于6，流程将直接跳转到switch的末尾。当然，如果有default分支，就直接跳至default语句块的首地址。当case的最小值为0时，不需要调整下标，当然也不会出现类似“sub r3,1”这样的下标调整代码。保证switch的参数值在case最大值的范围内。</p>
<p><img src="https://s2.loli.net/2025/03/02/qvgHUtIoyzQdPcV.png" srcset="/img/loading.gif" lazyload></p>
<p>switch的识别有以下两个关键点。</p>
<ul>
<li>取数值内容进行比较。</li>
<li>比较跳转失败后，出现4字节的相对比例因子寻址方式。</li>
</ul>
<p>有了这两个特性，就可以从代码中分析出switch结构了。</p>
<h2 id="非线性的switch结构"><a href="#非线性的switch结构" class="headerlink" title="非线性的switch结构"></a>非线性的switch结构</h2><p>当switch为一个有序线性组合时，会对其case语句块制作地址表，以减少比较跳转次数。但并非所有switch结构都是有序线性的，当两个case值的间隔较大时，仍然使用switch的结尾地址或者default语句块的首地址代替地址表中缺少的case地址，这样就会造成极大的空间浪费。</p>
<p>对于非线性的switch结构，可以采用制作索引表的方法来优化。索引表优化需要两张表：一张为case语句块地址表，另一张为case语句块索引表。地址表中的每一项保存一个case语句块的首地址，有几个case语句块就有几项。default语句块也在其中，如果没有则保存一个switch结束地址。这个结束地址在地址表中只会保存一份，不会像有序线性地址表那样，重复保存switch的结束地址。</p>
<p>索引表中会保存地址表的编号，索引表的大小等于最大case值和最小case值的差。当差值大于255时，这种优化方案也会浪费空间，可通过树方式优化，这里就只讨论差值小于或等于255的情况。表中的每一项为一个字节大小，保存的数据为case语句块地址表中的索引编号。</p>
<p>当case值比较稀疏，且没有明显线性关系时，这样的情况可以采用二次查表法查找地址。首先将所有case语句块的首地址保存在一个地址表中。地址表中的表项个数会根据程序中的case分支决定。有多少个case分支，地址表就会有多少项，不会像有序线性那样浪费内存。但是，如何通过case值获取对应地址表中保存的case语句块首地址呢？为此建立了一张对应的索引表，如图5-7所示，索引表中保存了地址表中的下标值。索引表中最多可以存储256项，每一项1字节，这决定了case值不可以超过1字节的最大表示范围（0~255），因此索引表也只能存储256项索引编号。</p>
<p>在数值间隔过多的情况下，与制作单一的case线性地址表相比，制作索引表的方式更节省空间，但是由于在执行时需要通过索引表查询地址表，会多出一次查询地址表的过程，因此效率也会有所下降。</p>
<p><img src="https://s2.loli.net/2025/03/02/LDF8guGV5SE9maR.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++源码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>  <span class="hljs-keyword">switch</span>(n)  &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 1&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 2&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 3&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 5&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 6&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">255</span>:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n == 255&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<img src="https://s2.loli.net/2025/03/02/RxNyfGgZEvYJIzc.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h2 id="Do-while-for语句"><a href="#Do-while-for语句" class="headerlink" title="Do&#x2F;while&#x2F;for语句"></a>Do&#x2F;while&#x2F;for语句</h2><h3 id="do循环"><a href="#do循环" class="headerlink" title="do循环"></a>do循环</h3><p>先执行循环体，后比较判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        sum += i; <span class="hljs-comment">// 累加</span><br>        i++;      <span class="hljs-comment">// 更新计数器</span><br>    &#125; <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">5</span>); <span class="hljs-comment">// 条件判断</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;1 到 5 的和是: &quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码：</p>
<img src="https://s2.loli.net/2025/03/02/v7iGQnKUkI6s2Rm.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>转换成的汇编代码和if分支结构非常相似，但是:</p>
<ul>
<li>if语句的跳转地址大于当前代码的地址，是一个向下跳转的过程。</li>
<li>do循环结构中的跳转地址小于当前代码的地址，是一个向上跳转的过程</li>
</ul>
<p>所以条件跳转的逻辑与源码中的逻辑相同。有了这个特性，if语句与do循环就很好区分了。</p>
<p><img src="https://s2.loli.net/2025/03/02/Al6LvjV5NFXgxkn.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>先比较判断，后执行循环体.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// 条件判断</span><br>        sum += i;   <span class="hljs-comment">// 累加</span><br>        i++;        <span class="hljs-comment">// 更新计数器</span><br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;1 到 5 的和是: &quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码：</p>
<img src="https://s2.loli.net/2025/03/02/WI4lKhazN3LrHUJ.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>转换后的while和if语句一样，也是比较相反，向下跳转的。在条件跳转到的地址附近会有bxx指令修改程序流程，向上跳转，回到条件比较指令处。while循环结构中使用了两次跳转指令完成循环，因为多使用了一次跳转指令，所以while循环比do循环效率低一些。</p>
<img src="https://s2.loli.net/2025/03/02/ObfQerpXYai6KJN.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>根据条件跳转指令，可以还原相反的while循环判断。循环语句块的结尾地址即为条件跳转指令的目标地址，在这个地址之前会有一条b跳转指令，指令的目标地址为while循环的起始地址。需要注意的是，while循环结构很可能被优化成do循环结构，被转换后的while结构需要检查是否可以被成功执行一次，通常会被嵌套在if单分支结构中，还原后的高级代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(xxx)<br>&#123;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-comment">// ……</span><br>  &#125;<span class="hljs-keyword">while</span>(xxx)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>先初始化，再比较判断，最后执行循环体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123; <span class="hljs-comment">// 初始化; 条件判断; 更新</span><br>        sum += i; <span class="hljs-comment">// 累加</span><br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;1 到 5 的和是: &quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>汇编代码：</p>
<img src="https://s2.loli.net/2025/03/02/hwy6v1kT2bqiaAP.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>其中</p>
<img src="https://s2.loli.net/2025/03/02/HR3kXJNFQrdBKbA.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>for循环分为赋初值、设置循环条件、设置循环步长这3个部分</p>
<img src="https://s2.loli.net/2025/03/02/fs9QiuLnzcHTvlh.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>这种结构是for循环独有的，在计数器变量被赋初值后，利用b跳过第一次步长计算。然后，通过3个跳转指令还原for循环的各个组成部分：第一个b指令之前的代码为初始化部分；从第一个b指令到循环条件比较处（之间的代码为步长计算部分；在条件跳转指令bxx之后寻找一个b指令，这个b指令必须是向上跳转的，且其目标是到步长计算的位置，在bxx和这个b指令之间的代码即为循环语句块。</p>
<h1 id="函数工作原理"><a href="#函数工作原理" class="headerlink" title="函数工作原理"></a>函数工作原理</h1><h2 id="栈帧的形成和关闭"><a href="#栈帧的形成和关闭" class="headerlink" title="栈帧的形成和关闭"></a>栈帧的形成和关闭</h2><p><img src="https://s2.loli.net/2025/03/05/lLjNg2PAcCfRBhi.png" srcset="/img/loading.gif" lazyload></p>
<p>栈顶到栈底之间的存储空间被称为栈帧。栈帧是如何形成的呢？当栈顶指针esp小于栈底指针ebp时，就形成了栈帧。</p>
<p>不同的两次函数调用，形成的栈帧也不相同。当一个函数调用另一个函数时，就会针对调用的函数开辟所需的栈空间，形成此函数的栈帧。当这个函数结束调用时，需要清除它使用的栈空间，关闭栈帧，我们把这一过程称为栈平衡。</p>
<p>为什么要进行栈平衡呢？这就像借钱一样，“有借有还，再借不难”。如果某一函数开辟了新的栈空间后没有进行恢复，或者过度恢复，就会造成栈空间上溢或下溢，极有可能给程序带来致命错误</p>
<h2 id="各种调用方式的考察"><a href="#各种调用方式的考察" class="headerlink" title="各种调用方式的考察"></a>各种调用方式的考察</h2><p>在C++中，通常使用栈传递函数参数，因此传递函数的栈也属于被调用函数栈空间的一部分。当函数的参数为不定参数时，函数自身无法确定参数使用的栈空间的大小，因此无法由函数自身执行平衡操作，需要函数的调用者执行平衡操作。为了确定参数的平衡者以及参数的传递方式，我们定义了函数的调用约定。C++环境下的调用约定有3种：_cdecl、_stdcall、_fastcall。</p>
<ul>
<li><em>cdecl：C\C++默认的调用方式，调用方平衡栈，不定参数的函数可以使用这种方式。</em></li>
<li>stdcall：被调方平衡栈，不定参数的函数无法使用这种方式。</li>
<li>_fastcall：寄存器方式传参，被调方平衡栈，不定参数的函数无法使用这种方式。</li>
</ul>
<p>_cdecl调用方式在函数内没有任何平衡参数操作，而在退出函数后对esp执行了加4操作，从而实现栈平衡，_stdcall调用方式则与之相反。那么，是不是只要检查ret处是否有平衡操作即可得知函数的调用方式呢？由于汇编语言灵活多变，这种方法无法保证分析结果的准确性。在函数的结尾处，很有可能有其他汇编指令间接对esp做加法，如pop ecx这样的指令也可达到栈平衡的效果，而且指令周期较短。因此，还需要结合函数在执行过程中使用的栈空间与函数调用结束时的栈平衡数进行对在函数的结尾处，很有可能有其他汇编指令间接对esp做加法，如pop ecx这样的指令也可达到栈平衡的效果，而且指令周期较短。因此，还需要结合函数在执行过程中使用的栈空间与函数调用结束时的栈平衡数进行对比，以判断是否实现参数平衡。</p>
<p>_cdecl与_stdcall只在参数平衡上有所不同，其余部分都一样。但经过优化后，_cdecl调用方式的函数在同一作用域内多次使用，比_stdcall的效率高一些，这是因为_cdecl可以使用复写传播，而_stdcall都在函数内平衡参数，无法使用复写传播这种优化方式。在这3种调用方式中，_fastcall调用方式的传参效率最高，其他两种调用方式都是通过栈传递参数的，唯独_fastcall可以利用寄存器传递参数。因为寄存器数目很少，而参数可以很多，只能量力而行，所以_fastcall调用方式只使用了ecx和edx，分别传递第一个参数和第二个参数，其余参数则通过栈传参方式传递。</p>
<h2 id="使用ebp或esp寻址"><a href="#使用ebp或esp寻址" class="headerlink" title="使用ebp或esp寻址"></a>使用ebp或esp寻址</h2><p>局部变量是通过栈空间保存的。(在内存中，局部变量是以连续排列的方式存储在栈内的。)在函数开始时，通过调整esp为局部变量分配栈空间，并以调整前的esp为基址计算变量的固定偏移值。由于栈顶向0增长，偏移值为负数，在函数结尾处执行释放栈空间的操作。因此局部变量是有生命周期的，它的生命周期在进入函数体的时候开始，在函数执行结束的时候终止。</p>
<p>使用esp寻址虽能提升效率，但缺少ebp会导致无法保存栈底指针和进行栈平衡检测。在Release版中，由于已通过Debug调试，栈平衡检测可省去。</p>
<p>IDA在分析时，预先计算并记录变量的固定偏移值，方便寻址。若函数执行过程中esp发生改变，IDA通过调整esp的相对值（负数）加上标号值，定位变量地址。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>函数参数通过栈结构传递，C++中传参顺序为从右向左，最先定义的参数最后入栈。使用负数标号法可区分参数（正数）和局部变量（负数），0表示返回地址，简化反汇编代码分析。Debug版采用ebp寻址方式，ebp直接指向当前栈底，便于调试。</p>
<p>函数参数通过push指令压栈，形参是实参的副本，修改形参不影响实参。【因为函数的传参是通过栈方式传递的，使用push指令将数据压入栈中，而push指令将操作数复制到栈顶，所以这时压入栈中的数据和原数据是独立存在的，在两个不同地址处。因此对函数参数的修改，实际上是对当前函数栈内的参数中保存的值进行修改，与原数据没有任何关系。】</p>
<p>C&#x2F;C++中不定长参数函数需满足：</p>
<p>至少一个参数，不定长参数为dword类型，需描述参数总个数或设置结尾标记(例如，printf函数通过第一个参数中的“%”数量确定后续参数个数。)。通过第一个参数的地址及其类型信息，可依次访问后续参数，避免越界。</p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>函数调用结束后，<code>ret</code>指令能够返回到函数调用处的下一条指令，是因为<code>call</code>指令在执行时不仅跳转到函数入口，还会将下一条指令的地址（即返回地址）压入栈中。具体过程如下：</p>
<ol>
<li><strong><code>call</code>指令的执行</strong>：  <ul>
<li><code>call</code>指令跳转到函数入口的同时，将下一条指令的地址压入栈，esp被减4，修改为0x009AFB6C，并且该地址中保存的信息为0x008A19E3。当函数执行到ret指令时，当前esp已经被平衡，此时将再次指向0x009AFB70。函数退出前，会执行ret指令，这个指令取得esp指向的4字节内容作为函数的返回地址值更新eip，程序的流程回到返回地址处，同时执行esp加4的操作，以释放返回的地址空间，平衡栈顶。</li>
</ul>
</li>
<li><strong><code>ret</code>指令的执行</strong>：  <ul>
<li>函数执行结束时，<code>ret</code>指令从当前<code>esp</code>指向的栈中取出返回地址，将其赋值给<code>eip</code>，使程序流程返回到该地址。</li>
<li>同时，<code>esp</code>加4，释放返回地址的栈空间，恢复栈平衡。</li>
</ul>
</li>
<li><strong>函数返回值的处理</strong>：  <ul>
<li>编译器通常使用<code>eax</code>寄存器保存函数的返回值，适用于基本数据类型和<code>sizeof(type)</code>小于或等于4的自定义类型（浮点类型除外）。</li>
<li>若返回值类型大于4字节（如结构体），编译器可能使用多个寄存器（如<code>eax</code>和<code>edx</code>）或通过其他方式传递返回值。</li>
</ul>
</li>
</ol>
<h2 id="x64调用约定"><a href="#x64调用约定" class="headerlink" title="x64调用约定"></a>x64调用约定</h2><p>x86应用程序的函数调用有__stdcall、__cdecl、__fastcall等方式，但xx64应用程序的函数调用采用<strong>寄存器快速调用约定</strong>，其核心特点如下：</p>
<ol>
<li><p><strong>参数传递规则</strong>：  </p>
<ul>
<li>前4个参数通过寄存器传递，分别使用<strong>RCX</strong>（第1个参数）、<strong>RDX</strong>（第2个参数）、<strong>R8</strong>（第3个参数）、<strong>R9</strong>（第4个参数）。  </li>
<li>超过4个参数时，多余参数从右到左依次入栈。  </li>
<li>任何大于8字节或非1、2、4、8字节的参数通过<strong>引用传递</strong>。</li>
</ul>
</li>
<li><p><strong>浮点参数传递</strong>：  </p>
<ul>
<li>浮点参数通过<strong>XMM寄存器</strong>传递，分别使用<strong>XMM0</strong>、<strong>XMM1</strong>、<strong>XMM2</strong>和<strong>XMM3</strong>。</li>
</ul>
</li>
<li><p><strong>栈空间平衡</strong>：  </p>
<ul>
<li>由<strong>函数调用方</strong>负责平衡栈空间。</li>
</ul>
</li>
</ol>
<p>x64调用约定通过寄存器高效传递前4个参数，多余参数入栈，浮点参数使用XMM寄存器，调用方负责栈平衡，简化了函数调用机制并提升了性能。</p>
<p><img src="https://s2.loli.net/2025/03/06/DMQWZiEYXOrFdag.png" srcset="/img/loading.gif" lazyload></p>
<p>在x64调用约定中，当参数同时包含<strong>浮点类型</strong>和<strong>整数类型</strong>时，参数传递顺序为：第1个参数（<strong>XMM0</strong>）、第2个参数（<strong>RDX</strong>）、第3个参数（<strong>XMM2</strong>）、第4个参数（<strong>R9</strong>）。此外，需要注意：</p>
<ol>
<li><p><strong>栈预留空间</strong>：  </p>
<ul>
<li>虽然前4个参数通过寄存器传递，但栈中仍为这4个参数预留了<strong>32字节</strong>空间，称为<strong>栈预留空间</strong>。  </li>
<li>这32字节空间由<strong>函数调用者</strong>提前申请，并由调用者负责平衡栈空间。</li>
</ul>
</li>
<li><p><strong>寄存器不足问题</strong>：  </p>
<ul>
<li>由于前4个参数占用寄存器，函数内部可用的通用寄存器减少，可能导致复杂函数中寄存器不够用。  </li>
<li>为了解决这个问题，可以将寄存器的值保存到预留的栈空间中。</li>
</ul>
</li>
</ol>
<p>x64调用约定中，混合类型参数按固定顺序传递，栈预留空间为前4个参数提供备份，调用者负责申请和平衡栈空间，确保寄存器不足时数据可临时保存到栈中。</p>
<p>函数调用后，寄存器和内存的情况如图所示。</p>
<p><img src="https://s2.loli.net/2025/03/06/3AZH69PWGE5Ykxf.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AE%89%E5%8D%93/" class="category-chain-item">安卓</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AE%89%E5%8D%93/%E9%80%86%E5%90%91/" class="category-chain-item">逆向</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AE%89%E5%8D%93/%E9%80%86%E5%90%91/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B1%87%E7%BC%96/" class="category-chain-item">架构与汇编</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%80%86%E5%90%91-android/" class="print-no-link">#逆向(android)</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>《C++反汇编与逆向分析》阅读总结(一)</div>
      <div>http://example.com/2023/01/08/《C++反汇编与逆向分析》阅读一/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/10/%E6%A0%91(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/" title="树【基础】">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">树【基础】</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/01/Pandas%E4%BD%BF%E7%94%A8/" title="pandas使用">
                        <span class="hidden-mobile">pandas使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
