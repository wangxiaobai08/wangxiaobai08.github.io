

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="DexFile在开始之前需要搞清楚目标才不至于在偌大的源码世界里迷失方向，既然是Dex文件加载流程，首先需要关心的即DEX文件结构在android源码中的封装调用形式： DexFile 是 Dalvik Executable (DEX) 文件的封装对象，代表了 Dalvik 虚拟机中可执行的 .dex 文件，内部包含类定义、方法、字段以及常量等信息。 DEX 文件的结构从文件头到各种表（如字符串表">
<meta property="og:type" content="article">
<meta property="og:title" content="Dex加载流程">
<meta property="og:url" content="http://example.com/2023/05/15/Dex%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="DexFile在开始之前需要搞清楚目标才不至于在偌大的源码世界里迷失方向，既然是Dex文件加载流程，首先需要关心的即DEX文件结构在android源码中的封装调用形式： DexFile 是 Dalvik Executable (DEX) 文件的封装对象，代表了 Dalvik 虚拟机中可执行的 .dex 文件，内部包含类定义、方法、字段以及常量等信息。 DEX 文件的结构从文件头到各种表（如字符串表">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/02/26/8Pz3eWGCAJfT4mj.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/26/U4Nu9jacLv8RkI2.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/4Ykev6nwpsd37P2.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/27/QLPaYJWRgM5lGNz.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/9DbcjU1TetnwZQd.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/4lZ6xOtkR35wbBa.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/sF84ENnGvzWhjak.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/tqmxvVjZA5YGbMf.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/K2x9F8d3hOj1Iga.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/oEJlr9mZnbdcusH.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/yHglCDSRzvm8XhN.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/Yycrz2CtonAbSOg.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/uoRvTQa3JBALwSF.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/22/lTaPSI7RUbDKNzC.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/MAcehVTarDqkKwZ.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/Nca6WHpv5uzj1dx.png">
<meta property="og:image" content="c:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241226155035606.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/j1I7SZlUviHKtV6.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/uCfobliAh6k2xDs.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/iRftIkHoxhv7M2m.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/x4mUZOhTseBzXD3.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/keJ7Man28bSfsWB.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/tByco3XjExGmzUW.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/j16Vh2HeiZDEkSR.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/VOu2iCpNmkETaXh.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/f853BPYdhRMqtkH.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/FY1RJeSbmKzTMo8.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/fU6zpP2sY5bDet8.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/WLAXUfQgpx5bis6.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/26/K6CiXIpOMwL5tSk.png">
<meta property="article:published_time" content="2023-05-15T10:35:15.000Z">
<meta property="article:modified_time" content="2025-03-09T09:06:34.104Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="逆向(android)">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/02/26/8Pz3eWGCAJfT4mj.png">
  
  
  
  <title>Dex加载流程 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Dex加载流程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-15 18:35" pubdate>
          2023年5月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          83 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Dex加载流程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="DexFile"><a href="#DexFile" class="headerlink" title="DexFile"></a>DexFile</h1><p>在开始之前需要搞清楚目标才不至于在偌大的源码世界里迷失方向，既然是Dex文件加载流程，首先需要关心的即DEX文件结构在android源码中的封装调用形式：</p>
<p><code>DexFile</code> 是 Dalvik Executable (DEX) 文件的封装对象，代表了 Dalvik 虚拟机中可执行的 <code>.dex</code> 文件，内部包含类定义、方法、字段以及常量等信息。</p>
<p>DEX 文件的结构从文件头到各种表（如字符串表、类型表、方法表等）组成，每个表都通过偏移量进行索引。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://androidxref.com/9.0.0_r3/xref/dalvik/libdex/DexFile.h#588">http://androidxref.com/9.0.0_r3/xref/dalvik/libdex/DexFile.h#588</a></p>
</blockquote>
<p><img src="https://s2.loli.net/2025/02/26/8Pz3eWGCAJfT4mj.png" srcset="/img/loading.gif" lazyload alt="DexFile结构体"></p>
<p>其中注意Dex的文件头格式：</p>
<p><img src="https://s2.loli.net/2025/02/26/U4Nu9jacLv8RkI2.png" srcset="/img/loading.gif" lazyload alt="DexOptHeader"></p>
<p><code>DexFile</code>的构造函数。这个构造函数用于初始化一个<code>DexFile</code>对象</p>
<p><img src="https://s2.loli.net/2024/12/26/4Ykev6nwpsd37P2.png" srcset="/img/loading.gif" lazyload alt="DexFile的构造函数"></p>
<p>在接下来的源码阅读中，我们需要着重关注这个结构体。</p>
<h1 id="ART和Dalvik"><a href="#ART和Dalvik" class="headerlink" title="ART和Dalvik"></a>ART和Dalvik</h1><p>总所周知：Dalvik 基本上在 Android 4.x 及之前的所有设备中运行，所有的 Android 应用都会在 Dalvik 虚拟机上运行。Android 5.0 之后，ART 成为默认虚拟机，但是它保持了与 Dalvik 的兼容性。大多数旧版 Dalvik 应用可以在 ART 中运行，但对于某些特定应用（尤其是依赖 Dalvik 特性的应用），可能需要额外的调整。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>Dalvik</strong></th>
<th><strong>ART</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>编译方式</strong></td>
<td>JIT（Just-In-Time）编译</td>
<td>AOT（Ahead-Of-Time）编译</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>较慢（因运行时编译）</td>
<td>较快（因安装时编译）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>启动慢，但运行时逐步优化</td>
<td>启动快且性能较稳定，运行时优化更多</td>
</tr>
<tr>
<td><strong>内存使用</strong></td>
<td>较高（JIT 编译时占用更多内存）</td>
<td>较低（安装时已编译为本地机器码）</td>
</tr>
<tr>
<td><strong>垃圾回收</strong></td>
<td>标记-清除、分代垃圾回收</td>
<td>增量垃圾回收、并发垃圾回收</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>支持旧版应用，主要在 Android 4.x 及之前使用</td>
<td>向后兼容 Dalvik，但需要设备支持，Android 5.0 起成为默认虚拟机</td>
</tr>
<tr>
<td><strong>调试支持</strong></td>
<td>调试工具成熟，适应 JIT 编译</td>
<td>需要额外的调试工具支持 AOT 编译</td>
</tr>
<tr>
<td><strong>跨平台优化</strong></td>
<td>较少优化</td>
<td>更多硬件架构优化，安装时针对设备进行优化</td>
</tr>
</tbody></table>
<p>在接下来的探究中，将分为Dalvik和ART下加载dex，</p>
<p>其中ART下，在 Android 5.0（Lollipop）到 Android 7.x（Nougat）之间，Android 并没有引入专门的 <code>InMemoryClassLoader</code> 类。这一期间，类加载机制主要是通过传统的 <code>ClassLoader</code> 以及 <code>DexClassLoader</code> 来加载本地或外部的 <code>.dex</code> 文件。</p>
<p>而在Android 8.0以后新增InMemoryDexClassLoader类加载器，继承自BaseDexClassLoader，用于加载内存中的dex文件，大致流程和DexClassLoader是差不多的，最主要的区别还是在于InMemoryDexClassLoader过程中并没有生成oat文件</p>
<p>故下ART下将根据版本再划分android(5-7)和android8及以上进行讨论。</p>
<h1 id="Dalvik下Dex加载流程"><a href="#Dalvik下Dex加载流程" class="headerlink" title="Dalvik下Dex加载流程"></a>Dalvik下Dex加载流程</h1><img src="https://s2.loli.net/2024/12/27/QLPaYJWRgM5lGNz.png" srcset="/img/loading.gif" lazyload alt="image-20241227100031401" style="zoom:50%;" />

<h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p><img src="https://s2.loli.net/2024/10/22/9DbcjU1TetnwZQd.png" srcset="/img/loading.gif" lazyload alt="image-20241022193337296"></p>
<h2 id="BaseDexClassLoader-java层"><a href="#BaseDexClassLoader-java层" class="headerlink" title="BaseDexClassLoader(java层)"></a>BaseDexClassLoader(java层)</h2><p><img src="https://s2.loli.net/2024/10/22/4lZ6xOtkR35wbBa.png" srcset="/img/loading.gif" lazyload alt="image-20241022193830981"></p>
<h3 id="DexPathList"><a href="#DexPathList" class="headerlink" title="DexPathList"></a>DexPathList</h3><p><img src="https://s2.loli.net/2024/10/22/sF84ENnGvzWhjak.png" srcset="/img/loading.gif" lazyload alt="image-20241022194349357"></p>
<p><code>DexPathList</code> 主要用于管理 Android 应用的 <strong>DEX 文件</strong>，它通常与 <strong><code>PathClassLoader</code></strong> 和 <strong><code>DexClassLoader</code></strong> 结合使用。主要负责以下几个任务：</p>
<ul>
<li><strong>存储 DEX 文件路径</strong>：<code>DexPathList</code> 保存了所有相关的 DEX 文件（包括 APK 文件中的 DEX 文件和外部路径上的 DEX 文件）的路径。</li>
<li><strong>优化类加载</strong>：它通过维护 DEX 文件和对应的类的映射关系，帮助虚拟机优化类加载过程。</li>
<li><strong>支持多重路径和 DEX 文件加载</strong>：<code>DexPathList</code> 允许应用程序在多个路径下查找 DEX 文件，支持外部插件或多个 APK 文件的情况。</li>
</ul>
<p><code>DexPathList</code> 的构造通常依赖于一个或多个 DEX 文件路径，并将它们映射到内存中的 <code>DexFile</code> 对象。具体来说，<code>DexPathList</code> 会将每个指定路径下的 DEX 文件加载为一个 <code>DexFile</code> 对象，然后通过类加载器管理这些 <code>DexFile</code> 对象中的类。</p>
<h4 id="makeDexElements"><a href="#makeDexElements" class="headerlink" title="makeDexElements"></a>makeDexElements</h4><p><img src="https://s2.loli.net/2024/10/22/tqmxvVjZA5YGbMf.png" srcset="/img/loading.gif" lazyload alt="image-20241022195612513"></p>
<ol>
<li>如果文件是一个目录，表示这个目录将用于查找资源（而不是加载Dex字节码）。这个目录类型的文件将被直接添加到<code>elements</code>中。</li>
<li>如果文件是以<code>.dex</code>后缀结尾的，它被认为是原始的<code>.dex</code>文件，直接调用<code>loadDexFile()</code>加载该文件。如果加载失败，会捕获<code>IOException</code>，并输出日志。</li>
<li>如果文件不是<code>.dex</code>文件，则假定它可能是压缩包文件（<code>zip</code>或<code>apk</code>）。也调用<code>loadDexFile()</code>尝试加载它，并将可能抛出的<code>IOException</code>加入到<code>suppressedExceptions</code>列表中，供后续排查问题时使用。</li>
<li>如果一个文件成功加载了<code>.dex</code>文件，或者它是一个压缩包文件，都会被封装成<code>Element</code>对象，并添加到<code>elements</code>列表中。</li>
<li>最终，该方法将所有的<code>Element</code>对象转为数组，并返回。这个数组将用于后续的类加载操作。</li>
</ol>
<p><code>makeDexElements</code> 方法的主要作用是从指定的路径（如 APK 文件的路径、外部插件的路径等）创建并返回一个 <code>DexElement</code> 数组，这个数组将被 <code>DexPathList</code> 用于加载和管理 <code>DexFile</code>（即 <code>.dex</code> 文件）。而**<code>DexElement</code>**是 <code>DexPathList</code> 中的内部类，它包含了对一个 <code>DexFile</code> 或 <code>.dex</code> 文件的引用。<code>DexElement</code> 主要负责存储单个 <code>.dex</code> 文件的路径和它对应的 <code>DexFile</code> 对象（即字节码文件）。</p>
<h5 id="LoadDexFile"><a href="#LoadDexFile" class="headerlink" title="LoadDexFile"></a>LoadDexFile</h5><p><img src="https://s2.loli.net/2024/10/22/K2x9F8d3hOj1Iga.png" srcset="/img/loading.gif" lazyload alt="image-20241022195909286"></p>
<p>该方法通常用于将一个指定的 <code>.dex</code> 文件加载到内存中。加载后，<code>.dex</code> 文件的字节码和类信息会被解析并存储为 <code>DexFile</code> 对象，供系统或应用程序使用。</p>
<p><img src="https://s2.loli.net/2024/10/22/oEJlr9mZnbdcusH.png" srcset="/img/loading.gif" lazyload alt="image-20241022200042165"></p>
<p>调用loadDex方法，返回DexFile对象：</p>
<p><img src="https://s2.loli.net/2024/10/22/yHglCDSRzvm8XhN.png" srcset="/img/loading.gif" lazyload alt="image-20241022200233016"></p>
<p>这里有一个核心的地方，调用了openDexFile方法，然后返回一个int值</p>
<h6 id="openDexFile"><a href="#openDexFile" class="headerlink" title="openDexFile"></a>openDexFile</h6><p>Android 4及以下，最终调用带三个参数的native方法<code>openDexFile()</code>，但并不接受文件字节码作为参数。<strong>然而其另一个重载方法接受字节码数组作为参数传入</strong>，具体如下：</p>
<p><img src="https://s2.loli.net/2024/10/22/Yycrz2CtonAbSOg.png" srcset="/img/loading.gif" lazyload alt="202312101628175"></p>
<p>Android 5~7，最终调用<code>openDexFile()</code>方法，里面会调用native方法<code>openDexFileNative()</code>，然而并不接受文件字节码作为参数。因此需要借助<code>libart.so</code>库中的<code>OpenMemory()</code>函数来实现内存加载文件字节码（需要编写native层代码实现）。</p>
<p><img src="https://s2.loli.net/2024/10/22/uoRvTQa3JBALwSF.png" srcset="/img/loading.gif" lazyload alt="image-20241022200816916"></p>
<p><img src="https://s2.loli.net/2024/10/22/lTaPSI7RUbDKNzC.png" srcset="/img/loading.gif" lazyload alt="image-20241022200837731"></p>
<p>Android 8及以上，跟Android 5~7一样的流程，但是额外多了一个用于加载内存dex的类加载器InMemoryDexClassLoader</p>
<h2 id="openDexFileNative-native层"><a href="#openDexFileNative-native层" class="headerlink" title="openDexFileNative(native层)"></a>openDexFileNative(native层)</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp#133">http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp#133</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Dalvik_dalvik_system_DexFile_openDexFileNative</span><br><span class="hljs-comment">// 1. 获取输入参数中的 sourceName 和 outputName</span><br>sourceName = dvmCreateCstrFromString(sourceNameObj);<br><span class="hljs-keyword">if</span> (outputNameObj != <span class="hljs-literal">NULL</span>)<br>    outputName = dvmCreateCstrFromString(outputNameObj);<br><span class="hljs-keyword">else</span><br>    outputName = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 2. 校验是否尝试加载引导类路径的 DEX 文件（不允许重复加载）</span><br><span class="hljs-keyword">if</span> (dvmClassPathContains(gDvm.bootClassPath, sourceName)) &#123;<br>    dvmThrowIOException(<span class="hljs-string">&quot;Re-opening BOOTCLASSPATH DEX files is not allowed&quot;</span>);<br>    <span class="hljs-built_in">free</span>(sourceName);<br>    <span class="hljs-built_in">free</span>(outputName);<br>    RETURN_VOID();<br>&#125;<br><br><span class="hljs-comment">// 3. 尝试直接加载 `.dex` 文件，若失败则尝试加载 ZIP 格式的 `.jar`</span><br><span class="hljs-keyword">if</span> (hasDexExtension(sourceName)<br>        &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, <span class="hljs-literal">false</span>) == <span class="hljs-number">0</span>) &#123;<br>    pDexOrJar = (DexOrJar*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DexOrJar));<br>    pDexOrJar-&gt;isDex = <span class="hljs-literal">true</span>;<br>    pDexOrJar-&gt;pRawDexFile = pRawDexFile;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, <span class="hljs-literal">false</span>) == <span class="hljs-number">0</span>) &#123;<br>    pDexOrJar = (DexOrJar*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DexOrJar));<br>    pDexOrJar-&gt;isDex = <span class="hljs-literal">false</span>;<br>    pDexOrJar-&gt;pJarFile = pJarFile;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dvmThrowIOException(<span class="hljs-string">&quot;unable to open DEX file&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 4. 若加载成功，将 DexOrJar 对象保存到全局表</span><br><span class="hljs-keyword">if</span> (pDexOrJar != <span class="hljs-literal">NULL</span>) &#123;<br>    pDexOrJar-&gt;fileName = sourceName;<br>    addToDexFileTable(pDexOrJar);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">free</span>(sourceName);<br>&#125;<br><br><span class="hljs-comment">// 5. 清理资源并返回结果</span><br><span class="hljs-built_in">free</span>(outputName);<br>RETURN_PTR(pDexOrJar);<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong><code>dvmCreateCstrFromString</code></strong><br>将 Java 字符串对象转为 C 字符串。</li>
<li><strong><code>dvmClassPathContains</code></strong><br>检查文件是否属于引导类路径，防止重复加载引发冲突。</li>
<li><strong><code>hasDexExtension</code></strong><br>判断文件是否以 <code>.dex</code> 结尾。</li>
<li><strong><code>dvmRawDexFileOpen</code> 和 <code>dvmJarFileOpen</code></strong><br>分别用于加载原生 DEX 文件和 JAR 文件中的 <code>classes.dex</code>。</li>
<li><strong><code>addToDexFileTable</code></strong><br>将成功加载的 <code>DexOrJar</code> 对象存储到全局表中以供后续使用。</li>
<li><strong><code>dvmThrowIOException</code> 和 <code>RETURN_VOID/RETURN_PTR</code></strong><br>处理异常和函数返回。</li>
</ul>
<h3 id="dvmRawDexFileOpen"><a href="#dvmRawDexFileOpen" class="headerlink" title="dvmRawDexFileOpen"></a><strong>dvmRawDexFileOpen</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 打开一个原生 DEX 文件，并尝试从缓存加载优化后的版本。</span><br><span class="hljs-comment"> * 如果缓存无效或不存在，则生成新的优化文件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dvmRawDexFileOpen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* odexOutputName,</span><br><span class="hljs-params">    RawDexFile** ppRawDexFile, <span class="hljs-type">bool</span> isBootstrap)</span><br>&#123;<br>    DvmDex* pDvmDex = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 存储 DVM 中的 DEX 文件对象</span><br>    <span class="hljs-type">char</span>* cachedName = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 缓存文件名</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;         <span class="hljs-comment">// 返回值</span><br>    <span class="hljs-type">int</span> dexFd = <span class="hljs-number">-1</span>;          <span class="hljs-comment">// 原始 DEX 文件描述符</span><br>    <span class="hljs-type">int</span> optFd = <span class="hljs-number">-1</span>;          <span class="hljs-comment">// 优化后的 DEX 文件描述符</span><br>    u4 modTime = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 文件的最后修改时间</span><br>    u4 adler32 = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 文件校验和</span><br>    <span class="hljs-type">size_t</span> fileSize = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 文件大小</span><br>    <span class="hljs-type">bool</span> newFile = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 标记是否是新缓存文件</span><br>    <span class="hljs-type">bool</span> locked = <span class="hljs-literal">false</span>;     <span class="hljs-comment">// 标记缓存文件是否加锁</span><br>    <span class="hljs-comment">// 打开源文件 (只读模式)</span><br>    dexFd = open(fileName, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (dexFd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 设置文件描述符为子进程不可继承</span><br>    dvmSetCloseOnExec(dexFd);<br>    <span class="hljs-comment">// 校验文件头的合法性，并获取校验和</span><br>    <span class="hljs-keyword">if</span> (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;Error with header for %s&quot;</span>, fileName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 获取文件的最后修改时间和大小</span><br>    <span class="hljs-keyword">if</span> (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;Error with stat for %s&quot;</span>, fileName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 生成或使用指定的缓存文件名</span><br>    <span class="hljs-keyword">if</span> (odexOutputName == <span class="hljs-literal">NULL</span>) &#123;<br>        cachedName = dexOptGenerateCacheFileName(fileName, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 根据源文件名生成缓存文件名</span><br>        <span class="hljs-keyword">if</span> (cachedName == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">goto</span> bail;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cachedName = strdup(odexOutputName); <span class="hljs-comment">// 使用指定的 odex 文件名</span><br>    &#125;<br>    ALOGV(<span class="hljs-string">&quot;dvmRawDexFileOpen: Checking cache for %s (%s)&quot;</span>, fileName, cachedName);<br>    <span class="hljs-comment">// 尝试打开缓存文件，并判断是否需要重新生成</span><br>    optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime, adler32, isBootstrap, &amp;newFile, <span class="hljs-comment">/*createIfMissing=*/</span><span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (optFd &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGI(<span class="hljs-string">&quot;Unable to open or create cache for %s (%s)&quot;</span>, fileName, cachedName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    locked = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果缓存文件是新生成的，执行优化流程</span><br>    <span class="hljs-keyword">if</span> (newFile) &#123;<br>        u8 startWhen, copyWhen, endWhen;<br>        <span class="hljs-type">off_t</span> dexOffset;<br>        <span class="hljs-comment">// 获取当前文件位置（缓存文件偏移）</span><br>        dexOffset = lseek(optFd, <span class="hljs-number">0</span>, SEEK_CUR);<br>        <span class="hljs-keyword">if</span> (dexOffset &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bail;<br>        <span class="hljs-comment">// 将源 DEX 文件内容复制到缓存文件</span><br>        startWhen = dvmGetRelativeTimeUsec();<br>        <span class="hljs-keyword">if</span> (copyFileToFile(optFd, dexFd, fileSize) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bail;<br>        copyWhen = dvmGetRelativeTimeUsec();<br>        <span class="hljs-comment">// 执行 DEX 文件优化</span><br>        <span class="hljs-keyword">if</span> (!dvmOptimizeDexFile(optFd, dexOffset, fileSize, fileName, modTime, adler32, isBootstrap)) &#123;<br>            ALOGE(<span class="hljs-string">&quot;Unable to extract+optimize DEX from &#x27;%s&#x27;&quot;</span>, fileName);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        endWhen = dvmGetRelativeTimeUsec();<br>        ALOGD(<span class="hljs-string">&quot;DEX prep &#x27;%s&#x27;: copy in %dms, rewrite %dms&quot;</span>,<br>            fileName, (<span class="hljs-type">int</span>)(copyWhen - startWhen) / <span class="hljs-number">1000</span>, (<span class="hljs-type">int</span>)(endWhen - copyWhen) / <span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-comment">// 将优化后的缓存文件映射到内存</span><br>    <span class="hljs-keyword">if</span> (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != <span class="hljs-number">0</span>) &#123;<br>        ALOGI(<span class="hljs-string">&quot;Unable to map cached %s&quot;</span>, fileName);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 解锁缓存文件，允许其他进程访问</span><br>    <span class="hljs-keyword">if</span> (locked) &#123;<br>        <span class="hljs-keyword">if</span> (!dvmUnlockCachedDexFile(optFd)) &#123;<br>            ALOGE(<span class="hljs-string">&quot;Unable to unlock DEX file&quot;</span>);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        locked = <span class="hljs-literal">false</span>;<br>    &#125;<br>    ALOGV(<span class="hljs-string">&quot;Successfully opened &#x27;%s&#x27;&quot;</span>, fileName);<br>    <span class="hljs-comment">// 创建 RawDexFile 对象并返回</span><br>    *ppRawDexFile = (RawDexFile*) <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(RawDexFile));<br>    (*ppRawDexFile)-&gt;cacheFileName = cachedName;<br>    (*ppRawDexFile)-&gt;pDvmDex = pDvmDex;<br>    cachedName = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 防止资源被释放</span><br>    result = <span class="hljs-number">0</span>;<br>bail:<br>    <span class="hljs-comment">// 释放资源和关闭文件</span><br>    <span class="hljs-built_in">free</span>(cachedName);<br>    <span class="hljs-keyword">if</span> (dexFd &gt;= <span class="hljs-number">0</span>) close(dexFd);<br>    <span class="hljs-keyword">if</span> (optFd &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (locked) (<span class="hljs-type">void</span>) dvmUnlockCachedDexFile(optFd);<br>        close(optFd);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="dvmOptimizeDexFile"><a href="#dvmOptimizeDexFile" class="headerlink" title="dvmOptimizeDexFile"></a><strong>dvmOptimizeDexFile</strong></h4><p><code>dvmOptimizeDexFile</code> 是 Android 中 Dalvik 虚拟机源代码中的一个函数，主要用于优化 <code>.dex</code> 文件。优化的过程通常涉及对字节码进行某些优化，以提高执行效率。具体的优化操作由外部工具 <code>dexopt</code> 执行，<code>dvmOptimizeDexFile</code> 函数通过创建子进程来调用该工具。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">dvmOptimizeDexFile</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> dexOffset, <span class="hljs-type">long</span> dexLength,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, u4 modWhen, u4 crc, <span class="hljs-type">bool</span> isBootstrap)</span><br>&#123;<br>    <span class="hljs-comment">// 提取文件路径中的文件名部分</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* lastPart = <span class="hljs-built_in">strrchr</span>(fileName, <span class="hljs-string">&#x27;/&#x27;</span>);  <span class="hljs-comment">// 获取路径中的最后一个 &#x27;/&#x27; 字符的位置</span><br>    <span class="hljs-keyword">if</span> (lastPart != <span class="hljs-literal">NULL</span>)<br>        lastPart++;  <span class="hljs-comment">// 获取文件名（跳过路径部分）</span><br>    <span class="hljs-keyword">else</span><br>        lastPart = fileName;  <span class="hljs-comment">// 如果没有路径，则文件名就是文件本身</span><br><br>    ALOGD(<span class="hljs-string">&quot;DexOpt: --- BEGIN &#x27;%s&#x27; (bootstrap=%d) ---&quot;</span>, lastPart, isBootstrap);  <span class="hljs-comment">// 打印优化开始的日志</span><br><br>    <span class="hljs-type">pid_t</span> pid;<br><br>    <span class="hljs-comment">// 检查是否已经在进行优化，避免递归优化</span><br>    <span class="hljs-keyword">if</span> (gDvm.optimizing) &#123;<br>        ALOGW(<span class="hljs-string">&quot;Rejecting recursive optimization attempt on &#x27;%s&#x27;&quot;</span>, fileName);  <span class="hljs-comment">// 如果正在优化，则打印警告</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    pid = fork();  <span class="hljs-comment">// 创建子进程来执行优化任务</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 子进程执行优化</span><br>        <span class="hljs-comment">// 设置常量用于执行命令</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kUseValgrind = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* kDexOptBin = <span class="hljs-string">&quot;/bin/dexopt&quot;</span>;  <span class="hljs-comment">// dexopt 工具的路径</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* kValgrinder = <span class="hljs-string">&quot;/usr/bin/valgrind&quot;</span>;  <span class="hljs-comment">// 如果需要，调试时使用的 valgrind 路径</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFixedArgCount = <span class="hljs-number">10</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kValgrindArgCount = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxIntLen = <span class="hljs-number">12</span>;  <span class="hljs-comment">// 整数转字符串的最大长度</span><br>        <span class="hljs-type">int</span> bcpSize = dvmGetBootPathSize();  <span class="hljs-comment">// 获取引导类路径的大小</span><br>        <span class="hljs-type">int</span> argc = kFixedArgCount + bcpSize + (kValgrindArgCount * kUseValgrind);  <span class="hljs-comment">// 计算参数个数</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[argc + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 参数数组（最后一个为 NULL）</span><br>        <span class="hljs-type">char</span> values[argc][kMaxIntLen];  <span class="hljs-comment">// 存储每个参数值的数组</span><br>        <span class="hljs-type">char</span>* execFile;  <span class="hljs-comment">// 存储要执行的文件路径</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* androidRoot;  <span class="hljs-comment">// 存储 Android 根目录路径</span><br>        <span class="hljs-type">int</span> flags;  <span class="hljs-comment">// 存储优化标志</span><br><br>        <span class="hljs-comment">// 设置进程组，避免与其他进程冲突</span><br>        setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 获取 Android 根目录路径</span><br>        androidRoot = getenv(<span class="hljs-string">&quot;ANDROID_ROOT&quot;</span>);<br>        <span class="hljs-keyword">if</span> (androidRoot == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">// 如果没有设置 ANDROID_ROOT 环境变量，则使用默认路径</span><br>            ALOGW(<span class="hljs-string">&quot;ANDROID_ROOT not set, defaulting to /system&quot;</span>);<br>            androidRoot = <span class="hljs-string">&quot;/system&quot;</span>;<br>        &#125;<br>        execFile = (<span class="hljs-type">char</span>*)alloca(<span class="hljs-built_in">strlen</span>(androidRoot) + <span class="hljs-built_in">strlen</span>(kDexOptBin) + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(execFile, androidRoot);<br>        <span class="hljs-built_in">strcat</span>(execFile, kDexOptBin);  <span class="hljs-comment">// 拼接 dexopt 工具的完整路径</span><br><br>        <span class="hljs-comment">// 构建 dexopt 命令的参数</span><br>        <span class="hljs-type">int</span> curArg = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 如果启用了 valgrind 调试工具，添加相关的调试参数</span><br>        <span class="hljs-keyword">if</span> (kUseValgrind) &#123;<br>            argv[curArg++] = (<span class="hljs-type">char</span>*)kValgrinder;  <span class="hljs-comment">// valgrind 路径</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--tool=memcheck&quot;</span>;  <span class="hljs-comment">// 使用 memcheck 工具</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--leak-check=yes&quot;</span>;  <span class="hljs-comment">// 检查内存泄漏</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--leak-resolution=med&quot;</span>;  <span class="hljs-comment">// 设置内存泄漏分辨率</span><br>            argv[curArg++] = <span class="hljs-string">&quot;--num-callers=16&quot;</span>;  <span class="hljs-comment">// 设置调用栈的深度</span><br>            assert(curArg == kValgrindArgCount);  <span class="hljs-comment">// 确保参数个数正确</span><br>        &#125;<br><br>        <span class="hljs-comment">// 添加 dexopt 的执行路径到参数中</span><br>        argv[curArg++] = execFile;<br><br>        <span class="hljs-comment">// 添加 `--dex` 参数，表示要处理一个 dex 文件</span><br>        argv[curArg++] = <span class="hljs-string">&quot;--dex&quot;</span>;<br><br>        <span class="hljs-comment">// 添加 Dalvik VM 构建版本号</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">2</span>], <span class="hljs-string">&quot;%d&quot;</span>, DALVIK_VM_BUILD);<br>        argv[curArg++] = values[<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 添加文件描述符、偏移量和长度</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%d&quot;</span>, fd);<br>        argv[curArg++] = values[<span class="hljs-number">3</span>];<br><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">4</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) dexOffset);<br>        argv[curArg++] = values[<span class="hljs-number">4</span>];<br><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">5</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) dexLength);<br>        argv[curArg++] = values[<span class="hljs-number">5</span>];<br><br>        <span class="hljs-comment">// 添加文件名路径</span><br>        argv[curArg++] = (<span class="hljs-type">char</span>*)fileName;<br><br>        <span class="hljs-comment">// 添加文件的修改时间和 CRC 值</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">7</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) modWhen);<br>        argv[curArg++] = values[<span class="hljs-number">7</span>];<br><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">8</span>], <span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>) crc);<br>        argv[curArg++] = values[<span class="hljs-number">8</span>];<br><br>        <span class="hljs-comment">// 设置优化和验证标志</span><br>        flags = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (gDvm.dexOptMode != OPTIMIZE_MODE_NONE) &#123;<br>            flags |= DEXOPT_OPT_ENABLED;  <span class="hljs-comment">// 启用优化</span><br>            <span class="hljs-keyword">if</span> (gDvm.dexOptMode == OPTIMIZE_MODE_ALL)<br>                flags |= DEXOPT_OPT_ALL;  <span class="hljs-comment">// 启用所有优化</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (gDvm.classVerifyMode != VERIFY_MODE_NONE) &#123;<br>            flags |= DEXOPT_VERIFY_ENABLED;  <span class="hljs-comment">// 启用验证</span><br>            <span class="hljs-keyword">if</span> (gDvm.classVerifyMode == VERIFY_MODE_ALL)<br>                flags |= DEXOPT_VERIFY_ALL;  <span class="hljs-comment">// 启用所有验证</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (isBootstrap)  <span class="hljs-comment">// 如果是引导类路径，设置标志</span><br>            flags |= DEXOPT_IS_BOOTSTRAP;<br>        <span class="hljs-keyword">if</span> (gDvm.generateRegisterMaps)  <span class="hljs-comment">// 如果需要生成寄存器映射，设置标志</span><br>            flags |= DEXOPT_GEN_REGISTER_MAPS;<br>        <br>        <span class="hljs-comment">// 添加优化标志</span><br>        <span class="hljs-built_in">sprintf</span>(values[<span class="hljs-number">9</span>], <span class="hljs-string">&quot;%d&quot;</span>, flags);<br>        argv[curArg++] = values[<span class="hljs-number">9</span>];<br><br>        <span class="hljs-comment">// 添加引导类路径中的每个文件路径</span><br>        ClassPathEntry* cpe;<br>        <span class="hljs-keyword">for</span> (cpe = gDvm.bootClassPath; cpe-&gt;ptr != <span class="hljs-literal">NULL</span>; cpe++) &#123;<br>            argv[curArg++] = cpe-&gt;fileName;<br>        &#125;<br><br>        assert(curArg == argc);  <span class="hljs-comment">// 确保参数个数正确</span><br>        argv[curArg] = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 参数数组最后一个元素为 NULL</span><br><br>        <span class="hljs-comment">// 执行 dexopt 工具进行优化</span><br>        <span class="hljs-keyword">if</span> (kUseValgrind)<br>            execv(kValgrinder, const_cast&lt;<span class="hljs-type">char</span>**&gt;(argv));  <span class="hljs-comment">// 如果启用 valgrind 调试，执行 valgrind</span><br>        <span class="hljs-keyword">else</span><br>            execv(execFile, const_cast&lt;<span class="hljs-type">char</span>**&gt;(argv));  <span class="hljs-comment">// 执行 dexopt 工具</span><br><br>        <span class="hljs-comment">// 如果 execv 失败，打印错误信息并退出</span><br>        ALOGE(<span class="hljs-string">&quot;execv &#x27;%s&#x27;%s failed: %s&quot;</span>, execFile,<br>            kUseValgrind ? <span class="hljs-string">&quot; [valgrind]&quot;</span> : <span class="hljs-string">&quot;&quot;</span>, strerror(errno));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 父进程等待子进程完成</span><br>        ALOGV(<span class="hljs-string">&quot;DexOpt: waiting for verify+opt, pid=%d&quot;</span>, (<span class="hljs-type">int</span>) pid);<br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">pid_t</span> gotPid;<br><br>        <span class="hljs-comment">// 等待子进程完成优化</span><br>        ThreadStatus oldStatus = dvmChangeStatus(<span class="hljs-literal">NULL</span>, THREAD_VMWAIT);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            gotPid = waitpid(pid, &amp;status, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等待子进程退出</span><br>            <span class="hljs-keyword">if</span> (gotPid == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR) &#123;<br>                ALOGD(<span class="hljs-string">&quot;waitpid interrupted, retrying&quot;</span>);  <span class="hljs-comment">// 如果被中断，重新尝试</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        dvmChangeStatus(<span class="hljs-literal">NULL</span>, oldStatus);  <span class="hljs-comment">// 恢复线程状态</span><br><br>        <span class="hljs-comment">// 如果子进程成功退出，返回 true，表示优化成功</span><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == <span class="hljs-number">0</span>) &#123;<br>            ALOGD(<span class="hljs-string">&quot;DexOpt: --- END &#x27;%s&#x27; (success) ---&quot;</span>, lastPart);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则返回 false，表示优化失败</span><br>            ALOGW(<span class="hljs-string">&quot;DexOpt: --- END &#x27;%s&#x27; --- status=0x%04x, process failed&quot;</span>,<br>                lastPart, status);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="DexOpt"><a href="#DexOpt" class="headerlink" title="DexOpt"></a>DexOpt</h5><blockquote>
<p><a target="_blank" rel="noopener" href="http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp#416">http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/OptMain.cpp#416</a></p>
</blockquote>
<p><img src="https://s2.loli.net/2024/12/26/MAcehVTarDqkKwZ.png" srcset="/img/loading.gif" lazyload alt="image-20241226152644172"></p>
<h6 id="fromDex"><a href="#fromDex" class="headerlink" title="fromDex"></a>fromDex</h6><p><img src="https://s2.loli.net/2024/12/26/Nca6WHpv5uzj1dx.png" srcset="/img/loading.gif" lazyload alt="image-20241226155351156"></p>
<h6 id="dvmContinueOptimization"><a href="#dvmContinueOptimization" class="headerlink" title="dvmContinueOptimization"></a><strong>dvmContinueOptimization</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 继续优化 DEX 文件，处理字节码优化和依赖数据写入。</span><br><span class="hljs-comment"> * fd: 文件描述符</span><br><span class="hljs-comment"> * dexOffset: DEX 数据在文件中的偏移</span><br><span class="hljs-comment"> * dexLength: DEX 数据的长度</span><br><span class="hljs-comment"> * fileName: DEX 文件的路径</span><br><span class="hljs-comment"> * modWhen: 文件的最后修改时间</span><br><span class="hljs-comment"> * crc: 文件的校验和</span><br><span class="hljs-comment"> * isBootstrap: 是否为启动类加载器处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">dvmContinueOptimization</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> dexOffset, <span class="hljs-type">long</span> dexLength,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fileName, u4 modWhen, u4 crc, <span class="hljs-type">bool</span> isBootstrap)</span><br>&#123;<br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 优化结果</span><br>    <span class="hljs-type">void</span>* mapAddr;        <span class="hljs-comment">// 文件映射地址</span><br><br>    assert(dexOffset &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 检查 DEX 文件大小是否合法</span><br>    <span class="hljs-keyword">if</span> (dexLength &lt; (<span class="hljs-type">int</span>)<span class="hljs-keyword">sizeof</span>(DexHeader)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 文件过小&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dexOffset &lt; (<span class="hljs-type">int</span>)<span class="hljs-keyword">sizeof</span>(DexOptHeader)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;没有足够空间存储优化头&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 映射整个文件以支持读写操作</span><br>    mapAddr = mmap(<span class="hljs-literal">NULL</span>, dexOffset + dexLength, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (mapAddr == MAP_FAILED) &#123;<br>        ALOGE(<span class="hljs-string">&quot;无法映射 DEX 文件: %s&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br><br>    <span class="hljs-comment">// 确定是否需要验证和优化</span><br>    <span class="hljs-type">bool</span> doVerify = (gDvm.classVerifyMode == VERIFY_MODE_ALL) ||<br>                    (gDvm.classVerifyMode == VERIFY_MODE_REMOTE &amp;&amp; !isBootstrap);<br>    <span class="hljs-type">bool</span> doOpt = (gDvm.dexOptMode == OPTIMIZE_MODE_ALL) ||<br>                 ((gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED || gDvm.dexOptMode == OPTIMIZE_MODE_FULL) &amp;&amp; doVerify);<br><br>    <span class="hljs-comment">// 重写 DEX 文件，执行字节码优化和类验证</span><br>    <span class="hljs-keyword">if</span> (!rewriteDex(((u1*)mapAddr) + dexOffset, dexLength, doVerify, doOpt, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 文件优化失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 写入依赖数据（如依赖列表和优化数据）</span><br>    <span class="hljs-type">off_t</span> depsOffset = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br>    <span class="hljs-keyword">if</span> (writeDependencies(fd, modWhen, crc) != <span class="hljs-number">0</span>) &#123;<br>        ALOGW(<span class="hljs-string">&quot;写入依赖列表失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 写入优化后的数据</span><br>    <span class="hljs-keyword">if</span> (!writeOptData(fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)) &#123;<br>        ALOGW(<span class="hljs-string">&quot;写入优化数据失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算文件校验和并更新优化头</span><br>    u4 optChecksum;<br>    <span class="hljs-keyword">if</span> (!computeFileChecksum(fd, depsOffset, lseek(fd, <span class="hljs-number">0</span>, SEEK_END) - depsOffset, &amp;optChecksum)) &#123;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br><br>    DexOptHeader optHdr;<br>    <span class="hljs-built_in">memset</span>(&amp;optHdr, <span class="hljs-number">0xff</span>, <span class="hljs-keyword">sizeof</span>(optHdr));<br>    <span class="hljs-built_in">memcpy</span>(optHdr.magic, DEX_OPT_MAGIC, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">memcpy</span>(optHdr.magic + <span class="hljs-number">4</span>, DEX_OPT_MAGIC_VERS, <span class="hljs-number">4</span>);<br>    optHdr.dexOffset = (u4)dexOffset;<br>    optHdr.dexLength = (u4)dexLength;<br>    optHdr.depsOffset = (u4)depsOffset;<br>    optHdr.checksum = optChecksum;<br>    <span class="hljs-comment">// 确保写入的数据持久化，并写入优化头</span><br>    fsync(fd);<br>    lseek(fd, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-keyword">if</span> (sysWriteFully(fd, &amp;optHdr, <span class="hljs-keyword">sizeof</span>(optHdr), <span class="hljs-string">&quot;DexOpt opt header&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    result = <span class="hljs-literal">true</span>;<br>bail:<br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-keyword">if</span> (mapAddr != MAP_FAILED) munmap(mapAddr, dexOffset + dexLength);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="rewriteDex"><a href="#rewriteDex" class="headerlink" title="rewriteDex()"></a><strong>rewriteDex()</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 重写 DEX 文件：执行字节序转换、类加载、验证和优化。</span><br><span class="hljs-comment"> * addr: DEX 数据起始地址</span><br><span class="hljs-comment"> * len: DEX 数据长度</span><br><span class="hljs-comment"> * doVerify: 是否执行类验证</span><br><span class="hljs-comment"> * doOpt: 是否执行字节码优化</span><br><span class="hljs-comment"> * ppClassLookup: 用于存储类查找表的指针</span><br><span class="hljs-comment"> * ppDvmDex: 用于存储 DvmDex 对象的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">rewriteDex</span><span class="hljs-params">(u1* addr, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> doVerify, <span class="hljs-type">bool</span> doOpt,</span><br><span class="hljs-params">    DexClassLookup** ppClassLookup, DvmDex** ppDvmDex)</span><br>&#123;<br>    DexClassLookup* pClassLookup = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 类查找表</span><br>    DvmDex* pDvmDex = <span class="hljs-literal">NULL</span>;              <span class="hljs-comment">// DvmDex 对象</span><br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;                 <span class="hljs-comment">// 返回结果</span><br><br>    <span class="hljs-comment">// 如果 DEX 文件字节序错误，执行字节序转换并校验</span><br>    <span class="hljs-keyword">if</span> (dexSwapAndVerify(addr, len) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 创建 DvmDex 对象以便直接操作 DEX 文件</span><br>    <span class="hljs-keyword">if</span> (dvmDexFileOpenPartial(addr, len, &amp;pDvmDex) != <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;无法创建 DexFile&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 创建类查找表，用于快速定位类定义</span><br>    pClassLookup = dexCreateClassLookup(pDvmDex-&gt;pDexFile);<br>    <span class="hljs-keyword">if</span> (pClassLookup == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">goto</span> bail;<br>    pDvmDex-&gt;pDexFile-&gt;pClassLookup = pClassLookup;<br>    <span class="hljs-comment">// 如果不需要验证或优化，直接返回</span><br>    <span class="hljs-keyword">if</span> (!doVerify &amp;&amp; !doOpt) &#123;<br>        result = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 加载 DEX 文件中的所有类</span><br>    <span class="hljs-keyword">if</span> (!loadAllClasses(pDvmDex))<br>        <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 创建字节码优化所需的内联子表</span><br>    <span class="hljs-keyword">if</span> (!dvmCreateInlineSubsTable())<br>        <span class="hljs-keyword">goto</span> bail;<br>    <span class="hljs-comment">// 验证和优化 DEX 文件中的所有类</span><br>    verifyAndOptimizeClasses(pDvmDex-&gt;pDexFile, doVerify, doOpt);<br>    <span class="hljs-comment">// 根据操作模式记录日志</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msgStr = doVerify &amp;&amp; doOpt ? <span class="hljs-string">&quot;verify+opt&quot;</span> :<br>                         doVerify          ? <span class="hljs-string">&quot;verify&quot;</span> :<br>                         doOpt             ? <span class="hljs-string">&quot;opt&quot;</span> : <span class="hljs-string">&quot;???&quot;</span>;<br>    ALOGD(<span class="hljs-string">&quot;DexOpt: load %dms, %s %dms, %d bytes&quot;</span>,<br>        (<span class="hljs-type">int</span>)(dvmGetRelativeTimeUsec() - dvmGetRelativeTimeUsec()) / <span class="hljs-number">1000</span>,<br>        msgStr,<br>        (<span class="hljs-type">int</span>)(dvmGetRelativeTimeUsec() - dvmGetRelativeTimeUsec()) / <span class="hljs-number">1000</span>,<br>        gDvm.pBootLoaderAlloc-&gt;curOffset);<br><br>    result = <span class="hljs-literal">true</span>;<br>bail:<br>    <span class="hljs-comment">// 清理资源：释放类查找表和 DvmDex 对象</span><br>    <span class="hljs-keyword">if</span> (pDvmDex != <span class="hljs-literal">NULL</span>)<br>        pDvmDex-&gt;pDexFile-&gt;pClassLookup = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (ppDvmDex == <span class="hljs-literal">NULL</span> || !result) &#123;<br>        dvmDexFileFree(pDvmDex);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        *ppDvmDex = pDvmDex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ppClassLookup == <span class="hljs-literal">NULL</span> || !result) &#123;<br>        <span class="hljs-built_in">free</span>(pClassLookup);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        *ppClassLookup = pClassLookup;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="dvmDexFileOpenPartial"><a href="#dvmDexFileOpenPartial" class="headerlink" title="dvmDexFileOpenPartial"></a><strong>dvmDexFileOpenPartial</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 打开部分 DEX 文件并解析，返回一个 DvmDex 结构。</span><br><span class="hljs-comment"> * addr: DEX 数据的内存地址</span><br><span class="hljs-comment"> * len: DEX 数据的长度</span><br><span class="hljs-comment"> * ppDvmDex: 用于存储 DvmDex 对象的指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dvmDexFileOpenPartial</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">int</span> len, DvmDex** ppDvmDex)</span><br>&#123;<br>    DvmDex* pDvmDex;        <span class="hljs-comment">// DvmDex 对象</span><br>    DexFile* pDexFile;      <span class="hljs-comment">// 解析得到的 DexFile 对象</span><br>    <span class="hljs-type">int</span> parseFlags = kDexParseDefault;  <span class="hljs-comment">// 解析标志</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;         <span class="hljs-comment">// 返回结果，-1 表示失败</span><br><br>    <span class="hljs-comment">// 解析 DEX 文件，得到 DexFile 对象</span><br>    pDexFile = dexFileParse((u1*)addr, len, parseFlags);<br>    <span class="hljs-keyword">if</span> (pDexFile == <span class="hljs-literal">NULL</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 解析失败&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 为解析后的 DexFile 分配附加结构（如类信息）</span><br>    pDvmDex = allocateAuxStructures(pDexFile);<br>    <span class="hljs-keyword">if</span> (pDvmDex == <span class="hljs-literal">NULL</span>) &#123;<br>        dexFileFree(pDexFile);  <span class="hljs-comment">// 分配失败时释放 pDexFile</span><br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 标记该 DvmDex 对象为只读映射（不做修改）</span><br>    pDvmDex-&gt;isMappedReadOnly = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 返回解析成功的 DvmDex 对象</span><br>    *ppDvmDex = pDvmDex;<br>    result = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 设置返回结果为成功</span><br>bail:<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="dexFileParse"><a href="#dexFileParse" class="headerlink" title="dexFileParse"></a><strong>dexFileParse</strong></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 解析 DEX 文件的主要函数。</span><br><span class="hljs-comment"> * data: DEX 数据的内存地址</span><br><span class="hljs-comment"> * length: DEX 数据的长度</span><br><span class="hljs-comment"> * flags: 解析时使用的标志</span><br><span class="hljs-comment"> */</span><br>DexFile* <span class="hljs-title function_">dexFileParse</span><span class="hljs-params">(<span class="hljs-type">const</span> u1* data, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    DexFile* pDexFile = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 用于存储解析结果的 DexFile 结构</span><br>    <span class="hljs-type">const</span> DexHeader* pHeader;  <span class="hljs-comment">// DEX 文件的头部</span><br>    <span class="hljs-type">const</span> u1* magic;           <span class="hljs-comment">// 存储 DEX 魔术字符串</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;            <span class="hljs-comment">// 返回结果，默认为失败</span><br><br>    <span class="hljs-comment">// 检查文件大小是否足够容纳 DEX 文件头部</span><br>    <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-keyword">sizeof</span>(DexHeader)) &#123;<br>        ALOGE(<span class="hljs-string">&quot;文件过小，无法作为有效的 .dex 文件&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;  <span class="hljs-comment">// 文件格式错误</span><br>    &#125;<br>    <span class="hljs-comment">// 分配内存给 DexFile 结构</span><br>    pDexFile = (DexFile*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DexFile));<br>    <span class="hljs-keyword">if</span> (pDexFile == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">goto</span> bail;  <span class="hljs-comment">// 内存分配失败</span><br>    <span class="hljs-built_in">memset</span>(pDexFile, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(DexFile));<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果 DEX 文件包含优化头部，则处理该部分。</span><br><span class="hljs-comment">     * 优化头部信息会影响后续的解析过程。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(data, DEX_OPT_MAGIC, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>        magic = data;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(magic + <span class="hljs-number">4</span>, DEX_OPT_MAGIC_VERS, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>) &#123;<br>            ALOGE(<span class="hljs-string">&quot;优化版本不正确&quot;</span>);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        pDexFile-&gt;pOptHeader = (<span class="hljs-type">const</span> DexOptHeader*) data;  <span class="hljs-comment">// 设置优化头部</span><br>        ALOGV(<span class="hljs-string">&quot;优化头部有效，DEX 偏移：%d，flags：0x%02x&quot;</span>, pDexFile-&gt;pOptHeader-&gt;dexOffset, pDexFile-&gt;pOptHeader-&gt;flags);<br>        <span class="hljs-comment">// 解析优化数据</span><br>        <span class="hljs-keyword">if</span> (!dexParseOptData(data, length, pDexFile))<br>            <span class="hljs-keyword">goto</span> bail;<br>        <span class="hljs-comment">// 跳过优化头部，处理优化后的 DEX 数据</span><br>        data += pDexFile-&gt;pOptHeader-&gt;dexOffset;<br>        length -= pDexFile-&gt;pOptHeader-&gt;dexOffset;<br>        <span class="hljs-comment">// 校验文件的 DEX 长度是否符合预期</span><br>        <span class="hljs-keyword">if</span> (pDexFile-&gt;pOptHeader-&gt;dexLength &gt; length) &#123;<br>            ALOGE(<span class="hljs-string">&quot;文件被截断，存储长度与剩余长度不符&quot;</span>);<br>            <span class="hljs-keyword">goto</span> bail;<br>        &#125;<br>        <span class="hljs-comment">// 设置新的 DEX 数据长度</span><br>        length = pDexFile-&gt;pOptHeader-&gt;dexLength;<br>    &#125;<br>    <span class="hljs-comment">// 设置基本指针（如指向文件头部等）</span><br>    dexFileSetupBasicPointers(pDexFile, data);<br>    pHeader = pDexFile-&gt;pHeader;<br>    <span class="hljs-comment">// 检查 DEX 文件头的魔术字符串是否有效</span><br>    <span class="hljs-keyword">if</span> (!dexHasValidMagic(pHeader)) &#123;<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 校验文件的校验和（ADLER32）</span><br>    <span class="hljs-keyword">if</span> (flags &amp; kDexParseVerifyChecksum) &#123;<br>        u4 adler = dexComputeChecksum(pHeader);  <span class="hljs-comment">// 计算校验和</span><br>        <span class="hljs-keyword">if</span> (adler != pHeader-&gt;checksum) &#123;  <span class="hljs-comment">// 校验失败</span><br>            ALOGE(<span class="hljs-string">&quot;校验和错误&quot;</span>);<br>            <span class="hljs-keyword">if</span> (!(flags &amp; kDexParseContinueOnError))  <span class="hljs-comment">// 根据标志决定是否继续</span><br>                <span class="hljs-keyword">goto</span> bail;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ALOGV(<span class="hljs-string">&quot;校验和验证通过&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果存在优化头部，校验其优化校验和</span><br>        <span class="hljs-type">const</span> DexOptHeader* pOptHeader = pDexFile-&gt;pOptHeader;<br>        <span class="hljs-keyword">if</span> (pOptHeader != <span class="hljs-literal">NULL</span>) &#123;<br>            adler = dexComputeOptChecksum(pOptHeader);  <span class="hljs-comment">// 计算优化校验和</span><br>            <span class="hljs-keyword">if</span> (adler != pOptHeader-&gt;checksum) &#123;  <span class="hljs-comment">// 校验失败</span><br>                ALOGE(<span class="hljs-string">&quot;优化校验和错误&quot;</span>);<br>                <span class="hljs-keyword">if</span> (!(flags &amp; kDexParseContinueOnError))  <span class="hljs-comment">// 根据标志决定是否继续</span><br>                    <span class="hljs-keyword">goto</span> bail;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ALOGV(<span class="hljs-string">&quot;优化校验和验证通过&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 校验文件大小是否匹配</span><br>    <span class="hljs-keyword">if</span> (pHeader-&gt;fileSize != length) &#123;<br>        ALOGE(<span class="hljs-string">&quot;文件大小不匹配&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!(flags &amp; kDexParseContinueOnError))  <span class="hljs-comment">// 根据标志决定是否继续</span><br>            <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 校验是否包含类定义</span><br>    <span class="hljs-keyword">if</span> (pHeader-&gt;classDefsSize == <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">&quot;DEX 文件没有类定义&quot;</span>);<br>        <span class="hljs-keyword">goto</span> bail;<br>    &#125;<br>    <span class="hljs-comment">// 解析成功，返回 DexFile 对象</span><br>    result = <span class="hljs-number">0</span>;<br>bail:<br>    <span class="hljs-comment">// 解析失败时，释放资源</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span> &amp;&amp; pDexFile != <span class="hljs-literal">NULL</span>) &#123;<br>        dexFileFree(pDexFile);<br>        pDexFile = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pDexFile;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="ART下Dex加载流程"><a href="#ART下Dex加载流程" class="headerlink" title="ART下Dex加载流程"></a>ART下Dex加载流程</h1><h2 id="android-5-7"><a href="#android-5-7" class="headerlink" title="android(5-7)"></a>android(5-7)</h2><h3 id="DexFile-openDexFileNative"><a href="#DexFile-openDexFileNative" class="headerlink" title="DexFile_openDexFileNative"></a>DexFile_openDexFileNative</h3><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241226155035606.png" srcset="/img/loading.gif" lazyload alt="image-20241226155035606"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 尝试加载 Dex 文件  </span><br><span class="hljs-type">bool</span> success = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs, dex_files.get());<br></code></pre></td></tr></table></figure>

<h4 id="OpenDexFilesFromOat"><a href="#OpenDexFilesFromOat" class="headerlink" title="OpenDexFilesFromOat"></a>OpenDexFilesFromOat</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">1. 获取<span class="hljs-string">.dex</span>校验和 -&gt; 如果失败 -&gt; 设置为nullptr<br>2. 查找已打开的<span class="hljs-string">.oat</span>文件 -&gt; 如果已打开 -&gt; 使用它<br>3. 如果未找到<span class="hljs-string">.oat</span>文件:<br>   a) 锁定<span class="hljs-string">.oat</span>文件<br>   b) 查找<span class="hljs-string">.oat</span>文件<br>4. 从<span class="hljs-string">.oat</span>文件加载<span class="hljs-string">.dex</span>文件 -&gt; 如果成功 -&gt; 返回执行状态<br>5. 如果加载失败:<br>   a) 检查并生成<span class="hljs-string">.oat</span>文件<br>   b) 重新加载<span class="hljs-string">.dex</span>文件<br>6. 如果加载成功 -&gt; 返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h5 id="生成-oat"><a href="#生成-oat" class="headerlink" title="生成.oat"></a>生成.oat</h5><p><strong>这里简单介绍Dex2Oat和.oat文件</strong></p>
<p><code>Dex2Oat</code> 是 Android 中用于将 <code>.dex</code> 文件（Dalvik Executable）转换为 <code>.oat</code> 文件（Optimized Android Executable）的工具，它是 Android 操作系统的一部分，特别是 ART（Android Runtime）虚拟机的一部分。其主要作用是在应用程序首次安装或启动时将 <code>.dex</code> 文件转换为 ART 可执行文件 <code>.oat</code>，以便提高应用的启动速度和运行效率。<code>Dex2Oat</code> 由 Android 在启动时通过 <code>dexopt</code> 工具进行触发，通常在安装或首次运行时执行。</p>
<ul>
<li>当应用程序安装时，或者用户第一次启动应用时，Android 系统会使用 <code>Dex2Oat</code> 将 <code>.dex</code> 字节码转换为 ART 使用的 <code>.oat</code> 文件。</li>
<li>该转换是一次性的，也就是说，转换后的 <code>.oat</code> 文件会被缓存，并在后续的应用启动中直接使用，而不需要再进行转换。</li>
<li>转换过程包括对 <code>.dex</code> 字节码的优化，如方法内联、循环展开等，以提高运行时性能。</li>
</ul>
<p>而<code>.oat</code> 文件是 ART 虚拟机使用的优化过的 <code>.dex</code> 文件。它是经过 <code>Dex2Oat</code> 工具处理后生成的文件，其中包含了针对设备硬件架构优化的字节码，具体来说，它包括了：</p>
<ul>
<li>优化后的字节码。</li>
<li>预编译的代码和一些设备特定的信息。</li>
</ul>
<blockquote>
<p><code>.oat</code> 文件与 <code>.dex</code> 文件不同，<code>.dex</code> 文件是 Dalvik 虚拟机所使用的格式，而 <code>.oat</code> 文件是 ART 虚拟机的专有格式。ART 虚拟机使用 <code>.oat</code> 文件来提高应用的启动速度和运行效率，因为这些文件已经经过了针对特定设备架构的编译和优化。</p>
</blockquote>
<p>而这段代码里面初始化了一个oat的对象，然后对oat是否为空进行了检测，因为第一次调用的时候它里面肯定是空的，然后进入switch()里面执行了MakeUpToData()方法跟进去看一下</p>
<p><img src="https://s2.loli.net/2024/12/26/j1I7SZlUviHKtV6.png" srcset="/img/loading.gif" lazyload alt="image-20241226173227337"></p>
<h6 id="MakeUpToData"><a href="#MakeUpToData" class="headerlink" title="MakeUpToData"></a>MakeUpToData</h6><p><img src="https://s2.loli.net/2024/12/26/uCfobliAh6k2xDs.png" srcset="/img/loading.gif" lazyload alt="image-20241226173428360"></p>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据当前的 oat 文件信息、编译过滤器和类加载器上下文来判断是否需要执行 dex2oat 操作。</span><br> <span class="hljs-keyword">switch</span> (info.GetDexOptNeeded(<br>       target, profile_changed, <span class="hljs-comment">/*downgrade*/</span> <span class="hljs-literal">false</span>, class_loader_context)) &#123;<br>   <span class="hljs-comment">// 如果不需要 dex 优化，返回更新成功</span><br>   <span class="hljs-keyword">case</span> kNoDexOptNeeded:<br>     <span class="hljs-keyword">return</span> kUpdateSucceeded;<br><br>   <span class="hljs-comment">// 对于这些情况，总是从头生成 oat 文件，不进行其他检查</span><br>   <span class="hljs-keyword">case</span> kDex2OatFromScratch:<br>   <span class="hljs-keyword">case</span> kDex2OatForBootImage:<br>   <span class="hljs-keyword">case</span> kDex2OatForRelocation:<br>   <span class="hljs-keyword">case</span> kDex2OatForFilter:<br>     <span class="hljs-comment">// 生成 oat 文件并返回，不进行检查</span><br>     <span class="hljs-keyword">return</span> GenerateOatFileNoChecks(info, target, class_loader_context, error_msg);<br> &#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/12/26/iRftIkHoxhv7M2m.png" srcset="/img/loading.gif" lazyload alt="image-20241226173705203"></p>
<p>进入该函数，进行了一些校验之后在下面我们可以看到有一个Dex2Oat()，这个函数名的意思很明确我们跟进去看一下</p>
<h6 id="Dex2Oat"><a href="#Dex2Oat" class="headerlink" title="Dex2Oat"></a>Dex2Oat</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">OatFileAssistant::Dex2Oat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; args,</span><br><span class="hljs-params">                               <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>  <span class="hljs-comment">// 获取当前的 Runtime 实例</span><br>  Runtime* runtime = Runtime::Current();<br><br>  <span class="hljs-comment">// 获取镜像文件的路径</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> image_location = ImageLocation();<br>  <span class="hljs-keyword">if</span> (image_location.empty()) &#123;<br>    *error_msg = <span class="hljs-string">&quot;No image location found for Dex2Oat.&quot;</span>;  <span class="hljs-comment">// 如果找不到镜像路径，返回错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 准备构建 dex2oat 的命令行参数</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; argv;<br>  <span class="hljs-comment">// 添加编译器可执行文件路径</span><br>  argv.push_back(runtime-&gt;GetCompilerExecutable());<br>  <span class="hljs-comment">// 如果 Java 运行时可调试，添加调试参数</span><br>  <span class="hljs-keyword">if</span> (runtime-&gt;IsJavaDebuggable()) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--debuggable&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 添加当前运行时的特性作为 dex2oat 参数</span><br>  runtime-&gt;AddCurrentRuntimeFeaturesAsDex2OatArguments(&amp;argv);<br>  <span class="hljs-comment">// 如果禁用了验证，设置编译器过滤器为 verify-none</span><br>  <span class="hljs-keyword">if</span> (!runtime-&gt;IsVerificationEnabled()) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--compiler-filter=verify-none&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 根据是否需要 relocatable，选择传递不同的运行时参数</span><br>  <span class="hljs-keyword">if</span> (runtime-&gt;MustRelocateIfPossible()) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--runtime-arg&quot;</span>);<br>    argv.push_back(<span class="hljs-string">&quot;-Xrelocate&quot;</span>);  <span class="hljs-comment">// 如果可能，进行 relocatable</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--runtime-arg&quot;</span>);<br>    argv.push_back(<span class="hljs-string">&quot;-Xnorelocate&quot;</span>);  <span class="hljs-comment">// 否则禁用 relocatable</span><br>  &#125;<br>  <span class="hljs-comment">// 如果不是目标构建，添加 --host 参数</span><br>  <span class="hljs-keyword">if</span> (!kIsTargetBuild) &#123;<br>    argv.push_back(<span class="hljs-string">&quot;--host&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 添加 boot image 的路径</span><br>  argv.push_back(<span class="hljs-string">&quot;--boot-image=&quot;</span> + image_location);<br>  <span class="hljs-comment">// 获取编译器的附加选项并加入到命令行参数中</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; compiler_options = runtime-&gt;GetCompilerOptions();<br>  argv.insert(argv.end(), compiler_options.begin(), compiler_options.end());<br>  <span class="hljs-comment">// 将传入的额外参数添加到命令行参数中</span><br>  argv.insert(argv.end(), args.begin(), args.end());<br>  <span class="hljs-comment">// 将所有的命令行参数连接成一个字符串</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">command_line</span><span class="hljs-params">(android::base::Join(argv, <span class="hljs-string">&#x27; &#x27;</span>))</span>;<br>  <span class="hljs-comment">// 执行命令并返回执行结果</span><br>  <span class="hljs-keyword">return</span> Exec(argv, error_msg);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/12/26/x4mUZOhTseBzXD3.png" srcset="/img/loading.gif" lazyload alt="image-20241226173853367"></p>
<h6 id="ExecAndReturnCode"><a href="#ExecAndReturnCode" class="headerlink" title="ExecAndReturnCode"></a>ExecAndReturnCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ExecAndReturnCode</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; arg_vector, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>  <span class="hljs-comment">// 将命令行参数数组转换为一个以空格分隔的字符串</span><br>  <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">command_line</span><span class="hljs-params">(android::base::Join(arg_vector, <span class="hljs-string">&#x27; &#x27;</span>))</span>;<br>  <span class="hljs-comment">// 确保命令行参数数量大于等于 1</span><br>  CHECK_GE(arg_vector.size(), <span class="hljs-number">1U</span>) &lt;&lt; command_line;<br>  <span class="hljs-comment">// 将 std::string 参数转换为 char* 数组，供 exec 系列函数使用</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* program = arg_vector[<span class="hljs-number">0</span>].c_str();<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>*&gt; args;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arg_vector.size(); ++i) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; arg = arg_vector[i];<br>    <span class="hljs-type">char</span>* arg_str = const_cast&lt;<span class="hljs-type">char</span>*&gt;(arg.c_str());<br>    CHECK(arg_str != nullptr) &lt;&lt; i;  <span class="hljs-comment">// 确保每个参数都有效</span><br>    args.push_back(arg_str);<br>  &#125;<br>  args.push_back(nullptr);  <span class="hljs-comment">// execv/execve 需要以 null 指针结束参数列表</span><br>  <span class="hljs-comment">// fork 和 exec 操作</span><br>  <span class="hljs-type">pid_t</span> pid = fork();  <span class="hljs-comment">// 创建子进程</span><br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 子进程中执行</span><br>    <span class="hljs-comment">// 在 fork 和 exec 之间不能做内存分配，确保子进程环境干净</span><br>    <span class="hljs-comment">// 修改进程组，防止进程被 ProcessManager 收回</span><br>    setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 保护子进程不被 LD_LIBRARY_PATH 等环境变量的修改影响</span><br>    <span class="hljs-comment">// 使用运行时创建时的环境快照</span><br>    <span class="hljs-type">char</span>** envp = (Runtime::Current() == nullptr) ? nullptr : Runtime::Current()-&gt;GetEnvSnapshot();<br>    <span class="hljs-keyword">if</span> (envp == nullptr) &#123;<br>      <span class="hljs-comment">// 执行程序，不带额外环境变量</span><br>      execv(program, &amp;args[<span class="hljs-number">0</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 执行程序，带上环境变量</span><br>      execve(program, &amp;args[<span class="hljs-number">0</span>], envp);<br>    &#125;<br>    <span class="hljs-comment">// 如果 exec 失败，输出错误信息</span><br>    PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;Failed to execve(&quot;</span> &lt;&lt; command_line &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-comment">// 调用 _exit，避免子进程调用 atexit 钩子</span><br>    _exit(<span class="hljs-number">1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 父进程中执行</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 如果 fork 失败</span><br>      *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed to execv(%s) because fork failed: %s&quot;</span>,<br>                                command_line.c_str(), strerror(errno));<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 父进程等待子进程结束</span><br>    <span class="hljs-type">int</span> status = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">pid_t</span> got_pid = TEMP_FAILURE_RETRY(waitpid(pid, &amp;status, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (got_pid != pid) &#123;  <span class="hljs-comment">// 检查 waitpid 是否成功</span><br>      *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed after fork for execv(%s) because waitpid failed: &quot;</span><br>                                <span class="hljs-string">&quot;wanted %d, got %d: %s&quot;</span>,<br>                                command_line.c_str(), pid, got_pid, strerror(errno));<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查子进程是否正常退出</span><br>    <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>      <span class="hljs-comment">// 返回子进程的退出状态码</span><br>      <span class="hljs-keyword">return</span> WEXITSTATUS(status);<br>    &#125;<br>    <span class="hljs-comment">// 如果子进程没有正常退出，返回 -1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>进来这个函数之后，可以看到源码中创建新的进程来开始执行execve()来执行Dex2Oat的编译。</p>
<p><strong>在这整个流程当中如果我们把函数执行的流程进行了修改或者hook，就会导致Dex2Oat流程的结束。如果我们去强制结束这个Dex2Oat的流程是可以让DexClassLoader在第一次加载dex这个过程变得非常的快速，减省去执行Dex2Oat编译花费的时间。****如果要实现ART下的函数抽取技术，我们也就需要阻断掉Dex2Oat的流程。这就是ART下的函数抽取实现方案和Dalvik下的区别，因为在Dalvik下不存在Dex2Oat的编译流程。</strong></p>
<h5 id="直接重新加载-dex文件"><a href="#直接重新加载-dex文件" class="headerlink" title="直接重新加载.dex文件"></a>直接重新加载.dex文件</h5><p><img src="https://s2.loli.net/2024/12/26/keJ7Man28bSfsWB.png" srcset="/img/loading.gif" lazyload alt="image-20241226160225305"></p>
<h6 id="Open"><a href="#Open" class="headerlink" title="Open()"></a>Open()</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>. 打开并读取文件魔数 <span class="hljs-punctuation">-&gt;</span> 如果失败 <span class="hljs-punctuation">-&gt;</span> 返回<span class="hljs-literal">false</span><br><span class="hljs-number">2</span>. 判断文件类型:<br>   a) 如果是.zip文件 <span class="hljs-punctuation">-&gt;</span> 调用 DexFile::<span class="hljs-title function_ invoke__">OpenZip</span>()<br>   b) 如果是.dex文件 <span class="hljs-punctuation">-&gt;</span> 调用 DexFile::<span class="hljs-title function_ invoke__">OpenFile</span>()<br><span class="hljs-number">3</span>. 如果成功加载.dex文件 <span class="hljs-punctuation">-&gt;</span> 将DexFile对象加入dex_files，并返回<span class="hljs-literal">true</span><br><span class="hljs-number">4</span>. 如果文件既不是.zip也不是.dex <span class="hljs-punctuation">-&gt;</span> 返回错误并返回<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>其中调用 DexFile::OpenFile()</p>
<p><img src="https://s2.loli.net/2024/12/26/tByco3XjExGmzUW.png" srcset="/img/loading.gif" lazyload alt="image-20241226160502268"></p>
<h6 id="OpenFile"><a href="#OpenFile" class="headerlink" title="OpenFile()"></a>OpenFile()</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> DexFile* <span class="hljs-title function_">DexFile::OpenFile</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* location, <span class="hljs-type">bool</span> verify,</span><br><span class="hljs-params">                                  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查 location 是否为空</span><br>    CHECK(location != nullptr);<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;MemMap&gt; <span class="hljs-built_in">map</span>;  <span class="hljs-comment">// 创建一个 MemMap 智能指针用于内存映射</span><br><br>    &#123;<br>        <span class="hljs-comment">// 延迟关闭文件描述符 fd</span><br>        ScopedFd <span class="hljs-title function_">delayed_close</span><span class="hljs-params">(fd)</span>;<br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">sbuf</span>;</span><br>        <span class="hljs-built_in">memset</span>(&amp;sbuf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sbuf));<br><br>        <span class="hljs-comment">// 2. 获取文件信息，判断文件大小及类型</span><br>        <span class="hljs-keyword">if</span> (fstat(fd, &amp;sbuf) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-comment">// 如果获取文件信息失败，返回错误信息</span><br>            *error_msg = StringPrintf(<span class="hljs-string">&quot;DexFile: fstat &#x27;%s&#x27; failed: %s&quot;</span>, location, strerror(errno));<br>            <span class="hljs-keyword">return</span> nullptr;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 判断文件是否是目录</span><br>        <span class="hljs-keyword">if</span> (S_ISDIR(sbuf.st_mode)) &#123;<br>            *error_msg = StringPrintf(<span class="hljs-string">&quot;Attempt to mmap directory &#x27;%s&#x27;&quot;</span>, location);<br>            <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 如果是目录，则返回错误</span><br>        &#125;<br><br>        <span class="hljs-type">size_t</span> length = sbuf.st_size;  <span class="hljs-comment">// 获取文件大小</span><br>        <span class="hljs-comment">// 4. 尝试将文件映射到内存</span><br>        <span class="hljs-built_in">map</span>.reset(MemMap::MapFile(length, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>, location, error_msg));<br><br>        <span class="hljs-comment">// 5. 检查内存映射是否成功</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.get() == nullptr) &#123;<br>            DCHECK(!error_msg-&gt;empty());<br>            <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 内存映射失败，返回错误</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 检查文件是否太小，无法包含有效的 Dex 文件头</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;Size() &lt; <span class="hljs-keyword">sizeof</span>(DexFile::Header)) &#123;<br>        *error_msg = StringPrintf(<br>            <span class="hljs-string">&quot;DexFile: failed to open dex file &#x27;%s&#x27; that is too short to have a header&quot;</span>, location);<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 如果文件小于 header 大小，认为它不是有效的 Dex 文件</span><br>    &#125;<br><br>    <span class="hljs-type">const</span> Header* dex_header = reinterpret_cast&lt;<span class="hljs-type">const</span> Header*&gt;(<span class="hljs-built_in">map</span>-&gt;Begin());  <span class="hljs-comment">// 获取 Dex 文件头</span><br><br>    <span class="hljs-comment">// 7. 尝试通过内存映射加载 Dex 文件</span><br>    <span class="hljs-type">const</span> DexFile* dex_file = OpenMemory(location, dex_header-&gt;checksum_, <span class="hljs-built_in">map</span>.release(), error_msg);<br>    <span class="hljs-keyword">if</span> (dex_file == nullptr) &#123;<br>        *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed to open dex file &#x27;%s&#x27; from memory: %s&quot;</span>, location,<br>                                  error_msg-&gt;c_str());<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 如果内存映射后的文件无效，返回错误</span><br>    &#125;<br><br>    <span class="hljs-comment">// 8. 如果需要验证文件，进行验证</span><br>    <span class="hljs-keyword">if</span> (verify &amp;&amp; !DexFileVerifier::Verify(dex_file, dex_file-&gt;Begin(), dex_file-&gt;Size(), location,<br>                                           error_msg)) &#123;<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 验证失败，返回错误</span><br>    &#125;<br><br>    <span class="hljs-comment">// 9. 返回加载成功的 Dex 文件</span><br>    <span class="hljs-keyword">return</span> dex_file;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="OpenMemory"><a href="#OpenMemory" class="headerlink" title="OpenMemory()"></a>OpenMemory()</h6><p><img src="https://s2.loli.net/2024/12/26/j16Vh2HeiZDEkSR.png" srcset="/img/loading.gif" lazyload alt="image-20241226161042092"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> DexFile* <span class="hljs-title function_">DexFile::OpenMemory</span><span class="hljs-params">(<span class="hljs-type">const</span> byte* base,</span><br><span class="hljs-params">                                    <span class="hljs-type">size_t</span> size,</span><br><span class="hljs-params">                                    <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; location,</span><br><span class="hljs-params">                                    <span class="hljs-type">uint32_t</span> location_checksum,</span><br><span class="hljs-params">                                    MemMap* mem_map, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查内存对齐</span><br>    CHECK_ALIGNED(base, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 各种 Dex 文件结构体必须按 4 字节对齐</span><br>    <span class="hljs-comment">// 2. 创建新的 DexFile 对象</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(new DexFile(base, size, location, location_checksum, mem_map))</span>;<br>    <span class="hljs-comment">// 3. 初始化 DexFile</span><br>    <span class="hljs-keyword">if</span> (!dex_file-&gt;Init(error_msg)) &#123;<br>        <span class="hljs-keyword">return</span> nullptr;  <span class="hljs-comment">// 初始化失败，返回 nullptr</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> dex_file.release();  <span class="hljs-comment">// 初始化成功，释放并返回 DexFile 对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="android8以上"><a href="#android8以上" class="headerlink" title="android8以上"></a>android8以上</h2><h3 id="InMemoryDexClassLoader"><a href="#InMemoryDexClassLoader" class="headerlink" title="InMemoryDexClassLoader"></a>InMemoryDexClassLoader</h3><p><img src="https://s2.loli.net/2024/12/26/VOu2iCpNmkETaXh.png" srcset="/img/loading.gif" lazyload alt="image-20241226163713231"></p>
<h3 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h3><p><img src="https://s2.loli.net/2024/12/26/f853BPYdhRMqtkH.png" srcset="/img/loading.gif" lazyload alt="image-20241226164213816"></p>
<h4 id="DexPathList-1"><a href="#DexPathList-1" class="headerlink" title="DexPathList"></a>DexPathList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DexPathList</span><span class="hljs-params">(ClassLoader definingContext, ByteBuffer[] dexFiles)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查 definingContext 是否为 null</span><br>    <span class="hljs-keyword">if</span> (definingContext == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;definingContext == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2. 检查 dexFiles 是否为 null</span><br>    <span class="hljs-keyword">if</span> (dexFiles == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;dexFiles == null&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3. 检查 dexFiles 数组是否包含 null 元素</span><br>    <span class="hljs-keyword">if</span> (Arrays.stream(dexFiles).anyMatch(v -&gt; v == <span class="hljs-literal">null</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;dexFiles contains a null Buffer!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4. 初始化 definingContext</span><br>    <span class="hljs-built_in">this</span>.definingContext = definingContext;<br>    <span class="hljs-comment">// 5. 初始化 nativeLibraryDirectories 为一个空的列表</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 可能需要处理内存中的 dex 文件路径和本地库的关系</span><br>    <span class="hljs-built_in">this</span>.nativeLibraryDirectories = Collections.emptyList();<br>    <span class="hljs-comment">// 6. 获取并分割系统的本地库路径</span><br>    <span class="hljs-built_in">this</span>.systemNativeLibraryDirectories = <br>        splitPaths(System.getProperty(<span class="hljs-string">&quot;java.library.path&quot;</span>), <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 7. 创建本地库路径元素</span><br>    <span class="hljs-built_in">this</span>.nativeLibraryPathElements = makePathElements(<span class="hljs-built_in">this</span>.systemNativeLibraryDirectories);<br>    <span class="hljs-comment">// 8. 初始化 suppressedExceptions 用于存储抑制的 IO 异常</span><br>    ArrayList&lt;IOException&gt; suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;IOException&gt;();<br>    <span class="hljs-comment">// 9. 创建 dex 元素，并将可能发生的异常记录到 suppressedExceptions 中</span><br>    <span class="hljs-built_in">this</span>.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions);<br>    <span class="hljs-comment">// 10. 如果有抑制的异常，保存它们</span><br>    <span class="hljs-keyword">if</span> (suppressedExceptions.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.dexElementsSuppressedExceptions = <br>            suppressedExceptions.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>[suppressedExceptions.size()]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.dexElementsSuppressedExceptions = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="makeInMemoryDexElements"><a href="#makeInMemoryDexElements" class="headerlink" title="makeInMemoryDexElements"></a>makeInMemoryDexElements</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List&lt;IOException&gt; suppressedExceptions) &#123;<br>    <span class="hljs-comment">// 1. 初始化一个长度为 dexFiles 数组长度的 Element 数组</span><br>    Element[] elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>[dexFiles.length];<br>    <br>    <span class="hljs-comment">// 2. 初始化当前位置索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">elementPos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 3. 遍历 dexFiles 数组中的每个 ByteBuffer</span><br>    <span class="hljs-keyword">for</span> (ByteBuffer buf : dexFiles) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 4. 尝试通过 ByteBuffer 加载 DexFile</span><br>            <span class="hljs-type">DexFile</span> <span class="hljs-variable">dex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DexFile</span>(buf);<br>            <span class="hljs-comment">// 5. 创建 Element 实例并加入到 elements 数组中</span><br>            elements[elementPos++] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>(dex);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException suppressed) &#123;<br>            <span class="hljs-comment">// 6. 如果加载 DexFile 时发生 IOException，将异常记录到 suppressedExceptions 中</span><br>            System.logE(<span class="hljs-string">&quot;Unable to load dex file: &quot;</span> + buf, suppressed);<br>            suppressedExceptions.add(suppressed);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 7. 如果成功加载的元素数量少于 dexFiles 数组的长度，调整 elements 数组的大小</span><br>    <span class="hljs-keyword">if</span> (elementPos != elements.length) &#123;<br>        elements = Arrays.copyOf(elements, elementPos);<br>    &#125;<br>    <span class="hljs-comment">// 8. 返回创建的 Element 数组</span><br>    <span class="hljs-keyword">return</span> elements;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="DexFile-1"><a href="#DexFile-1" class="headerlink" title="DexFile"></a>DexFile</h5><p><img src="https://s2.loli.net/2024/12/26/FY1RJeSbmKzTMo8.png" srcset="/img/loading.gif" lazyload alt="image-20241226164655932"></p>
<h6 id="openInMemoryDexFile"><a href="#openInMemoryDexFile" class="headerlink" title="openInMemoryDexFile"></a>openInMemoryDexFile</h6><p><img src="https://s2.loli.net/2024/12/26/fU6zpP2sY5bDet8.png" srcset="/img/loading.gif" lazyload alt="image-20241226164917021"></p>
<p>从内存缓冲区加载 <code>.dex</code> 文件的数据，并返回一个表示该文件的对象或标识符。通常来说，这个返回值是一个 <code>DexFileCookie</code>（或者类似的标识符类型）。这个标识符用于标记当前加载的 <code>.dex</code> 文件的状态和其它信息。</p>
<h6 id="createCookieWithDirectBuffter"><a href="#createCookieWithDirectBuffter" class="headerlink" title="createCookieWithDirectBuffter"></a>createCookieWithDirectBuffter</h6><p><img src="https://s2.loli.net/2024/12/26/WLAXUfQgpx5bis6.png" srcset="/img/loading.gif" lazyload alt="image-20241226165108129"></p>
<h6 id="CreateSingleDexFileCookie"><a href="#CreateSingleDexFileCookie" class="headerlink" title="CreateSingleDexFileCookie"></a>CreateSingleDexFileCookie</h6><p><img src="https://s2.loli.net/2024/12/26/K6CiXIpOMwL5tSk.png" srcset="/img/loading.gif" lazyload alt="image-20241226165147320"></p>
<h6 id="CreateDexFile"><a href="#CreateDexFile" class="headerlink" title="CreateDexFile"></a>CreateDexFile</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> DexFile* <span class="hljs-title function_">CreateDexFile</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;MemMap&gt; dex_mem_map)</span> &#123;<br>    <span class="hljs-comment">// 生成唯一的 dex 文件位置字符串</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> location = StringPrintf(<span class="hljs-string">&quot;Anonymous-DexFile@%p-%p&quot;</span>,<br>                                        dex_mem_map-&gt;Begin(),<br>                                        dex_mem_map-&gt;End());<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> error_message;<br>    <br>    <span class="hljs-comment">// 使用内存映射创建 DexFile</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">const</span> DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(DexFile::Open(location,</span><br><span class="hljs-params">                                                           <span class="hljs-number">0</span>,  <span class="hljs-comment">// location_checksum 不指定</span></span><br><span class="hljs-params">                                                           <span class="hljs-built_in">std</span>::move(dex_mem_map),</span><br><span class="hljs-params">                                                           <span class="hljs-comment">/* verify */</span> <span class="hljs-literal">true</span>,</span><br><span class="hljs-params">                                                           <span class="hljs-comment">/* verify_location */</span> <span class="hljs-literal">true</span>,</span><br><span class="hljs-params">                                                           &amp;error_message))</span>;<br>    <span class="hljs-comment">// 检查创建 DexFile 是否成功</span><br>    <span class="hljs-keyword">if</span> (dex_file == nullptr) &#123;<br>        <span class="hljs-comment">// 如果创建失败，则抛出异常</span><br>        ScopedObjectAccess <span class="hljs-title function_">soa</span><span class="hljs-params">(env)</span>;  <span class="hljs-comment">// 获取 JNI 环境的访问权限</span><br>        ThrowWrappedIOException(<span class="hljs-string">&quot;%s&quot;</span>, error_message.c_str());  <span class="hljs-comment">// 抛出 IO 异常</span><br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    <span class="hljs-comment">// 禁用写权限，使得 DexFile 变为只读</span><br>    <span class="hljs-keyword">if</span> (!dex_file-&gt;DisableWrite()) &#123;<br>        ScopedObjectAccess <span class="hljs-title function_">soa</span><span class="hljs-params">(env)</span>;<br>        ThrowWrappedIOException(<span class="hljs-string">&quot;Failed to make dex file read-only&quot;</span>);  <span class="hljs-comment">// 如果失败，抛出异常</span><br>        <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回原始的 DexFile 指针</span><br>    <span class="hljs-keyword">return</span> dex_file.release();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="Open-1"><a href="#Open-1" class="headerlink" title="Open"></a>Open</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DexFile::Open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename,</span><br><span class="hljs-params">                   <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; location,</span><br><span class="hljs-params">                   <span class="hljs-type">bool</span> verify_checksum,</span><br><span class="hljs-params">                   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg,</span><br><span class="hljs-params">                   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">const</span> DexFile&gt;&gt;* dex_files)</span> &#123;<br>  <span class="hljs-comment">// 使用 ScopedTrace 跟踪打开 Dex 文件的过程，以便于性能分析和调试</span><br>  ScopedTrace <span class="hljs-title function_">trace</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Open dex file &quot;</span>) + <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(location))</span>;<br><br>  <span class="hljs-comment">// 检查输出参数 dex_files 是否为空，确保函数调用正确</span><br>  DCHECK(dex_files != nullptr) &lt;&lt; <span class="hljs-string">&quot;DexFile::Open: out-param is nullptr&quot;</span>;<br>  <br>  <span class="hljs-comment">// 定义魔术值变量，用于检测文件类型</span><br>  <span class="hljs-type">uint32_t</span> magic;<br><br>  <span class="hljs-comment">// 打开文件并读取魔术值，获取文件描述符 fd</span><br>  File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);<br><br>  <span class="hljs-comment">// 如果文件打开失败，返回 false 并设置错误消息</span><br>  <span class="hljs-keyword">if</span> (fd.Fd() == <span class="hljs-number">-1</span>) &#123;<br>    DCHECK(!error_msg-&gt;empty()); <span class="hljs-comment">// 确保错误消息不为空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 检查文件的魔术值，如果是 ZIP 文件格式，则调用 OpenZip 打开 ZIP 格式的 dex 文件</span><br>  <span class="hljs-keyword">if</span> (IsZipMagic(magic)) &#123;<br>    <span class="hljs-keyword">return</span> DexFile::OpenZip(fd.Release(), location, verify_checksum, error_msg, dex_files);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果是 Dex 文件格式，调用 OpenFile 打开 Dex 文件</span><br>  <span class="hljs-keyword">if</span> (IsDexMagic(magic)) &#123;<br>    <span class="hljs-comment">// 使用 OpenFile 打开 Dex 文件，并将其保存在 dex_file 中</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">const</span> DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(DexFile::OpenFile(fd.Release(),</span><br><span class="hljs-params">                                                              location,</span><br><span class="hljs-params">                                                              <span class="hljs-comment">/* verify */</span> <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 验证文件</span></span><br><span class="hljs-params">                                                              verify_checksum,  <span class="hljs-comment">// 验证校验和</span></span><br><span class="hljs-params">                                                              error_msg))</span>;<br>    <span class="hljs-comment">// 如果 Dex 文件打开成功，则将其添加到 dex_files 向量中，并返回 true</span><br>    <span class="hljs-keyword">if</span> (dex_file.get() != nullptr) &#123;<br>      dex_files-&gt;push_back(<span class="hljs-built_in">std</span>::move(dex_file));<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果 Dex 文件打开失败，返回 false</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果文件既不是 ZIP 文件也不是 Dex 文件，则返回错误</span><br>  *error_msg = StringPrintf(<span class="hljs-string">&quot;Expected valid zip or dex file: &#x27;%s&#x27;&quot;</span>, filename);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="OpenFile-1"><a href="#OpenFile-1" class="headerlink" title="OpenFile"></a>OpenFile</h6><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">const</span> DexFile&gt; <span class="hljs-title">DexFile::OpenFile</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; location,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">bool</span> verify,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">bool</span> verify_checksum,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 std::string* error_msg)</span> </span>&#123;<br>  <span class="hljs-comment">// 使用 ScopedTrace 跟踪打开 Dex 文件的过程，便于调试和性能分析</span><br>  <span class="hljs-function">ScopedTrace <span class="hljs-title">trace</span><span class="hljs-params">(std::string(<span class="hljs-string">&quot;Open dex file &quot;</span>) + std::string(location))</span></span>;<br><br>  <span class="hljs-comment">// 检查 location 是否为空，确保提供了有效的文件路径</span><br>  <span class="hljs-built_in">CHECK</span>(!location.<span class="hljs-built_in">empty</span>());<br><br>  std::unique_ptr&lt;MemMap&gt; map;<br>  &#123;<br>    <span class="hljs-comment">// 文件描述符延迟关闭，确保在作用域结束时自动关闭文件</span><br>    <span class="hljs-function">File <span class="hljs-title">delayed_close</span><span class="hljs-params">(fd, <span class="hljs-comment">/* check_usage */</span> <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sbuf;<br>    <span class="hljs-built_in">memset</span>(&amp;sbuf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(sbuf));<br><br>    <span class="hljs-comment">// 获取文件状态信息，检查文件是否存在</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fstat</span>(fd, &amp;sbuf) == <span class="hljs-number">-1</span>) &#123;<br>      *error_msg = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;DexFile: fstat &#x27;%s&#x27; failed: %s&quot;</span>, location.<span class="hljs-built_in">c_str</span>(),<br>                                <span class="hljs-built_in">strerror</span>(errno));<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 如果获取文件状态失败，返回空指针</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果文件是一个目录，则返回错误</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISDIR</span>(sbuf.st_mode)) &#123;<br>      *error_msg = <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Attempt to mmap directory &#x27;%s&#x27;&quot;</span>, location.<span class="hljs-built_in">c_str</span>());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件大小</span><br>    <span class="hljs-type">size_t</span> length = sbuf.st_size;<br><br>    <span class="hljs-comment">// 使用 `MemMap` 来映射文件内容到内存</span><br>    map.<span class="hljs-built_in">reset</span>(MemMap::<span class="hljs-built_in">MapFile</span>(length,<br>                              PROT_READ,  <span class="hljs-comment">// 只读映射</span><br>                              MAP_PRIVATE, <span class="hljs-comment">// 私有映射</span><br>                              fd,<br>                              <span class="hljs-number">0</span>,  <span class="hljs-comment">// 从文件开头开始映射</span><br>                              <span class="hljs-comment">/*low_4gb*/</span><span class="hljs-literal">false</span>,<br>                              location.<span class="hljs-built_in">c_str</span>(),<br>                              error_msg));<br><br>    <span class="hljs-comment">// 如果映射失败，返回错误信息</span><br>    <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">DCHECK</span>(!error_msg-&gt;<span class="hljs-built_in">empty</span>());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 检查映射的文件大小是否足够存储 Dex 文件头，文件过小则认为无效</span><br>  <span class="hljs-keyword">if</span> (map-&gt;<span class="hljs-built_in">Size</span>() &lt; <span class="hljs-built_in">sizeof</span>(DexFile::Header)) &#123;<br>    *error_msg = <span class="hljs-built_in">StringPrintf</span>(<br>        <span class="hljs-string">&quot;DexFile: failed to open dex file &#x27;%s&#x27; that is too short to have a header&quot;</span>,<br>        location.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 文件头大小不足，返回空指针</span><br>  &#125;<br><br>  <span class="hljs-comment">// 获取文件头信息</span><br>  <span class="hljs-type">const</span> Header* dex_header = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> Header*&gt;(map-&gt;<span class="hljs-built_in">Begin</span>());<br><br>  <span class="hljs-comment">// 调用 `OpenCommon` 函数加载 Dex 文件的具体数据，并验证其正确性</span><br>  std::unique_ptr&lt;DexFile&gt; dex_file = <span class="hljs-built_in">OpenCommon</span>(map-&gt;<span class="hljs-built_in">Begin</span>(), map-&gt;<span class="hljs-built_in">Size</span>(),location, dex_header-&gt;checksum_,kNoOatDexFile,  verify,  <span class="hljs-comment">// 是否验证文件</span><br>verify_checksum, <span class="hljs-comment">// 是否验证校验和</span><br>error_msg);<br>  <span class="hljs-comment">// 如果 Dex 文件打开成功，保存映射内存对象</span><br>  <span class="hljs-keyword">if</span> (dex_file != <span class="hljs-literal">nullptr</span>) &#123;<br>    dex_file-&gt;mem_map_ = std::<span class="hljs-built_in">move</span>(map);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dex_file; <span class="hljs-comment">// 返回打开的 Dex 文件</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="OpenCommon"><a href="#OpenCommon" class="headerlink" title="OpenCommon"></a>OpenCommon</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;DexFile&gt; <span class="hljs-title function_">DexFile::OpenCommon</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* base, <span class="hljs-type">size_t</span> size,  <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; location,<span class="hljs-type">uint32_t</span> location_checksum, <span class="hljs-type">const</span> OatDexFile* oat_dex_file,<span class="hljs-type">bool</span> verify, <span class="hljs-type">bool</span> verify_checksum,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* error_msg, VerifyResult* verify_result)</span> &#123;<br>  <span class="hljs-comment">// 如果 verify_result 非空，初始化其为未尝试验证的状态</span><br>  <span class="hljs-keyword">if</span> (verify_result != nullptr) &#123;<br>    *verify_result = VerifyResult::kVerifyNotAttempted;<br>  &#125;<br>  <span class="hljs-comment">// 创建一个新的 DexFile 对象，初始化它以指向给定的内存区域和相关信息</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;DexFile&gt; <span class="hljs-title function_">dex_file</span><span class="hljs-params">(new DexFile(base,</span><br><span class="hljs-params">size,location,location_checksum,oat_dex_file))</span>;<br><br>  <span class="hljs-comment">// 如果 dex_file 创建失败，返回错误信息</span><br>  <span class="hljs-keyword">if</span> (dex_file == nullptr) &#123;<br>    *error_msg = StringPrintf(<span class="hljs-string">&quot;Failed to open dex file &#x27;%s&#x27; from memory: %s&quot;</span>, location.c_str(),<br>                              error_msg-&gt;c_str());<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  <span class="hljs-comment">// 调用 Init 方法初始化 DexFile，如果初始化失败，则清空 dex_file 并返回 nullptr</span><br>  <span class="hljs-keyword">if</span> (!dex_file-&gt;Init(error_msg)) &#123;<br>    dex_file.reset();<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果需要验证（verify == true），则使用 DexFileVerifier 验证 Dex 文件的有效性</span><br>  <span class="hljs-keyword">if</span> (verify &amp;&amp; !DexFileVerifier::Verify(dex_file.get(),<br>                                         dex_file-&gt;Begin(),<br>                                         dex_file-&gt;Size(),<br>                                         location.c_str(),<br>                                         verify_checksum,<br>                                         error_msg)) &#123;<br>    <span class="hljs-comment">// 如果验证失败，更新 verify_result 状态并返回 nullptr</span><br>    <span class="hljs-keyword">if</span> (verify_result != nullptr) &#123;<br>      *verify_result = VerifyResult::kVerifyFailed;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果验证成功，将 verify_result 状态更新为成功</span><br>  <span class="hljs-keyword">if</span> (verify_result != nullptr) &#123;<br>    *verify_result = VerifyResult::kVerifySucceeded;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回已成功打开并验证的 DexFile 对象</span><br>  <span class="hljs-keyword">return</span> dex_file;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>不过InMemoryDexClassLoader()并没有对内存中的DEX信息进行编译生成OAT文件，这点和DexClassLoader()不同</p>
</blockquote>
<p>你说的很对，<code>InMemoryDexClassLoader</code> 和 <code>DexClassLoader</code> 确实在处理 DEX 文件的方式上存在一些不同，尤其是在是否会生成 OAT 文件这一点上。</p>
<h2 id="DexClassLoader-和-InMemoryDexClassLoader-的区别"><a href="#DexClassLoader-和-InMemoryDexClassLoader-的区别" class="headerlink" title="DexClassLoader 和 InMemoryDexClassLoader 的区别"></a><strong>DexClassLoader 和 InMemoryDexClassLoader 的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th><strong>DexClassLoader</strong></th>
<th><strong>InMemoryDexClassLoader</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>加载方式</strong></td>
<td>加载磁盘上的 <code>.dex</code> 文件</td>
<td>加载内存中的 <code>.dex</code> 数据</td>
</tr>
<tr>
<td><strong>OAT 文件生成</strong></td>
<td>会生成 OAT 文件，进行优化</td>
<td>不会生成 OAT 文件</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>OAT 文件通常存储在 <code>dalvik-cache</code> 目录</td>
<td>仅加载内存中的 DEX 数据</td>
</tr>
<tr>
<td><strong>优化</strong></td>
<td>会进行 AOT 优化，生成特定于设备的机器代码</td>
<td>不进行 AOT 优化，只加载原始 DEX 数据</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>用于动态加载外部 <code>.dex</code> 文件，适用于应用安装、升级等场景</td>
<td>用于加载内存中已有的 DEX 数据，适用于某些内存管理或动态加载的场景</td>
</tr>
</tbody></table>
<h3 id="为什么-InMemoryDexClassLoader-不生成-OAT-文件？"><a href="#为什么-InMemoryDexClassLoader-不生成-OAT-文件？" class="headerlink" title="为什么 InMemoryDexClassLoader 不生成 OAT 文件？"></a><strong>为什么 InMemoryDexClassLoader 不生成 OAT 文件？</strong></h3><p><code>InMemoryDexClassLoader</code> 设计上的不同使得它不生成 OAT 文件。它主要用于动态加载在内存中的 <code>.dex</code> 数据，通常在以下几种场景中使用：</p>
<ol>
<li><strong>插件化框架</strong>：比如某些插件化框架会将 DEX 文件在运行时从网络或者本地文件中加载到内存中，而不是依赖于传统的 <code>.apk</code> 安装方式。此时，<code>.dex</code> 文件本身可能并不存储在磁盘上，而是直接通过内存加载。</li>
<li><strong>调试与测试</strong>：在调试和测试中，可能需要直接将某些动态生成或修改过的 DEX 数据加载到应用中执行。为了避免频繁的磁盘 I&#x2F;O 和 OAT 文件的生成，可以直接使用 <code>InMemoryDexClassLoader</code> 来加速这一过程。</li>
<li><strong>资源管理</strong>：在某些特殊的内存管理场景下，可能只需要将 <code>.dex</code> 文件加载到内存中，并且不需要在磁盘上生成 OAT 文件。</li>
</ol>
<p>由于 <code>InMemoryDexClassLoader</code> 仅仅是将 <code>.dex</code> 字节码加载到内存中并通过 <code>DexFile</code> 进行解析，它不涉及到 <code>.dex</code> 到 <code>.oat</code> 的转换过程。这种方式适用于需要快速加载内存中 <code>.dex</code> 文件的场景，而不是依赖于 ART 的 AOT 编译。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AE%89%E5%8D%93/" class="category-chain-item">安卓</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AE%89%E5%8D%93/%E9%80%86%E5%90%91/" class="category-chain-item">逆向</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AE%89%E5%8D%93/%E9%80%86%E5%90%91/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C/" class="category-chain-item">文件格式/装载链接运行</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%80%86%E5%90%91-android/" class="print-no-link">#逆向(android)</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Dex加载流程</div>
      <div>http://example.com/2023/05/15/Dex加载流程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/16/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/" title="索引机制">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">索引机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/08/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="分库分表">
                        <span class="hidden-mobile">分库分表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
