

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="非转载抄袭，早年知乎文章搬运于此  C++STL容器用法 1.序列式容器1.1容器概观与分类 顺序容器是C++标准库提供的一类容器，它们按照元素在容器中的顺序进行存储和访问。顺序容器内的元素以线性的方式排列，因此可以通过迭代器按顺序遍历、插入和删除元素。 与关联式容器（如 set、map）不同，顺序容器并不要求元素具有固定的排序关系或唯一的键。相反，顺序容器仅根据元素在容器中的插入顺序来组织元素">
<meta property="og:type" content="article">
<meta property="og:title" content="STL容器用法">
<meta property="og:url" content="http://example.com/2022/09/10/C++STL%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="非转载抄袭，早年知乎文章搬运于此  C++STL容器用法 1.序列式容器1.1容器概观与分类 顺序容器是C++标准库提供的一类容器，它们按照元素在容器中的顺序进行存储和访问。顺序容器内的元素以线性的方式排列，因此可以通过迭代器按顺序遍历、插入和删除元素。 与关联式容器（如 set、map）不同，顺序容器并不要求元素具有固定的排序关系或唯一的键。相反，顺序容器仅根据元素在容器中的插入顺序来组织元素">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/v2-a7d6f66d59d5a83496ec8b4b2b16a382_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-70a79ae983d2ec3e2225537b3e7f21f9_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-c80217b237cf9d77f721dc56a0a5798c_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-ee35399437f353543f36a1b641d2d5a8_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-3cedd542872b26e36370fc848858baad_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-77080d4ff97b41cb07bc3884cbf6ecf0_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-f578b4c1827630dc77c9263613cbf46d_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pic1.zhimg.com/v2-68a492b995869ac844e67e3f4b86213f_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-8aaffc4fd57951134721962dcbd213c9_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-8c38383dccfd54ea1a0ff135a4fae821_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://picx.zhimg.com/v2-40a9e2be34cd3d17b374dd742cbd34d1_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pica.zhimg.com/v2-a65e73e0324bb4982ed613734383cd05_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pic1.zhimg.com/v2-62424a0865a17d39cb344b2de83a7744_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pic1.zhimg.com/v2-7e27da091bfba07269fd7dd5f946577e_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pica.zhimg.com/v2-97d3679c5080f76b60a6b620f7dddefa_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pic1.zhimg.com/v2-3de50f418bf59ed81fca28a27c6effb6_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pica.zhimg.com/v2-65b549b1002bbfb8ea6e828ebd775909_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pica.zhimg.com/v2-b286a197cde980904f3dcf32e2535054_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pic1.zhimg.com/v2-f5f8338569006d40e2748dd8f5a05246_720w.jpg?source=d16d100b">
<meta property="og:image" content="https://pic1.zhimg.com/v2-fc3393ea466d4dba0a0b813c41455b6a_720w.jpg?source=d16d100b">
<meta property="article:published_time" content="2022-09-10T01:36:08.000Z">
<meta property="article:modified_time" content="2025-03-09T09:14:50.666Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic1.zhimg.com/v2-a7d6f66d59d5a83496ec8b4b2b16a382_720w.jpg?source=d16d100b">
  
  
  
  <title>STL容器用法 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="STL容器用法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-10 09:36" pubdate>
          2022年9月10日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          63 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">STL容器用法</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>非转载抄袭，早年知乎文章搬运于此</p>
</blockquote>
<h2 id="C-STL容器用法"><a href="#C-STL容器用法" class="headerlink" title="C++STL容器用法"></a>C++STL容器用法</h2><p><img src="https://pic1.zhimg.com/v2-a7d6f66d59d5a83496ec8b4b2b16a382_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="1-序列式容器"><a href="#1-序列式容器" class="headerlink" title="1.序列式容器"></a>1.序列式容器</h2><h3 id="1-1容器概观与分类"><a href="#1-1容器概观与分类" class="headerlink" title="1.1容器概观与分类"></a>1.1容器概观与分类</h3><p><img src="https://picx.zhimg.com/v2-70a79ae983d2ec3e2225537b3e7f21f9_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>顺序容器是C++标准库提供的一类容器，它们按照元素在容器中的顺序进行存储和访问。顺序容器内的元素以线性的方式排列，因此可以通过迭代器按顺序遍历、插入和删除元素。</p>
<p>与关联式容器（如 set、map）不同，顺序容器并不要求元素具有固定的排序关系或唯一的键。相反，顺序容器仅根据元素在容器中的插入顺序来组织元素。</p>
<h2 id="2-vector"><a href="#2-vector" class="headerlink" title="2 vector"></a>2 vector</h2><h3 id="【1】简介："><a href="#【1】简介：" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p>1,vector是表示可变大小数组的序列容器。</p>
<p>2,就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</p>
<p>3,本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。</p>
<p>4,vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。</p>
<p>5,与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。</p>
<h3 id="【2】vector声明及初始化"><a href="#【2】vector声明及初始化" class="headerlink" title="【2】vector声明及初始化"></a>【2】<strong>vector声明及初始化</strong></h3><blockquote>
<p><strong>头文件：#include<vector></strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;		<span class="hljs-comment">//声明一个int型向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;		<span class="hljs-comment">//声明一个初始大小为5的int向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>;	<span class="hljs-comment">//声明一个初始大小为10且值都是1的向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(tmp)</span></span>;	<span class="hljs-comment">//声明并用tmp向量初始化vec向量</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(vec.begin(), vec.begin() + <span class="hljs-number">3</span>)</span></span>;	<span class="hljs-comment">//用向量vec的第0个到第2个值初始化tmp</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;	<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(arr, arr + <span class="hljs-number">5</span>)</span></span>;		<span class="hljs-comment">//将arr数组的元素用于初始化vec向量</span><br><span class="hljs-comment">//说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，</span><br><span class="hljs-comment">//这个主要是为了和vec.end()指针统一。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(&amp;arr[<span class="hljs-number">1</span>], &amp;arr[<span class="hljs-number">4</span>])</span></span>; <span class="hljs-comment">//将arr[1]~arr[4]范围内的元素作为vec的初始值</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>在创建好空容器的基础上，还可以通过调用 reserve() 成员函数来增加容器的容量：vec.reserve(20);</p>
</blockquote>
<h3 id="【3】方法"><a href="#【3】方法" class="headerlink" title="【3】方法"></a>【3】方法</h3><p><strong>1，iterators（迭代器）</strong></p>
<p><img src="https://picx.zhimg.com/v2-c80217b237cf9d77f721dc56a0a5798c_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>2,Capacity（容量）</strong></p>
<p><img src="https://picx.zhimg.com/v2-ee35399437f353543f36a1b641d2d5a8_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>3,Element access（元素访问）</strong></p>
<p><img src="https://picx.zhimg.com/v2-3cedd542872b26e36370fc848858baad_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>4,Modifiers（修改器）</strong></p>
<p><img src="https://picx.zhimg.com/v2-77080d4ff97b41cb07bc3884cbf6ecf0_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>常见具体使用：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs text">//push_back和pop_back用法简单<br>vector&lt;int&gt; arr;<br>for (int i = 0; i &lt; 5; i++)<br>&#123;<br>    arr.push_back(i);<br>&#125;<br>for (int i = 0; i &lt; 5; i++)<br>&#123;<br>    arr.pop_back();<br>&#125;<br><br>arr.emplace(10);<br><br>//在arr的头部插入值为10的元素<br>vector&lt;int&gt; arr;<br>arr.insert(arr.begin(), 10);<br><br>vector&lt;int&gt; arr&#123;1, 2, 3, 4, 5&#125;;<br>//删除arr开头往后偏移两个位置的元素，即arr的第三个元素，3<br>arr.erase(arr.begin() + 2);<br>//删除arr.begin()到arr.begin()+2之间的元素，删除两个;即删除arr.begin()而不到arr.begin()+2的元素<br>arr.erase(arr.begin(), arr.begin() + 2);<br><br>//将arr修改为范围[arrs.begin, arrs.end]内的元素<br>vector&lt;int&gt; arr = &#123;5, 4, 3, 2, 1&#125;;<br>vector&lt;int&gt; arrs = &#123; 1, 2, 3, 4, 5 &#125;;<br>arr.assign(arrs.begin(), arrs.end());<br><br>//扩容<br>vector&lt;int&gt; arr;<br>for (int i = 0; i &lt; 20; i++)<br>&#123;<br>    arr.push_back(i);<br>    cout &lt;&lt; arr.size() &lt;&lt; &quot; &quot; &lt;&lt; arr.capacity() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="【4】常用算法"><a href="#【4】常用算法" class="headerlink" title="【4】常用算法"></a>【4】常用算法</h3><p>1，遍历元素</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">vector&lt;int&gt;::iterator it;<br>for (it = vec.begin(); it != vec.end(); it++)<br>    cout &lt;&lt; *it &lt;&lt; endl;<br>//或者<br>for (size_t i = 0; i &lt; vec.size(); i++) &#123;<br>	cout &lt;&lt; vec.at(i) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2，元素翻转</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">#include &lt;algorithm&gt;<br>reverse(vec.begin(), vec.end());<br></code></pre></td></tr></table></figure>

<p>3，元素排序</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">#include &lt;algorithm&gt;<br>sort(vec.begin(), vec.end()); //采用的是从小到大的排序<br>//如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法:<br>bool Comp(const int&amp; a, const int&amp; b) &#123;<br>	return a &gt; b;<br>&#125;<br>sort(vec.begin(), vec.end(), Comp);<br></code></pre></td></tr></table></figure>

<h3 id="【5】适用场景"><a href="#【5】适用场景" class="headerlink" title="【5】适用场景"></a>【5】适用场景</h3><p>需要频繁在末尾插入和删除元素，并且不需要在中间或头部插入删除。</p>
<p>需要高效地进行随机访问，即通过索引访问元素。</p>
<p>元素数量会动态变化，但不会经常在中间或头部插入删除。</p>
<h2 id="3-list"><a href="#3-list" class="headerlink" title="3 list"></a>3 list</h2><h3 id="【1】简介：-1"><a href="#【1】简介：-1" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p>1，list是C++STL容器中的顺序容器，这里的顺序容器区别于关联容器，指的是元素在容器中的位置与大小无关。list和vector不同，vector是顺序存储的，内存是连续的；list底层实际上是双向链表，list的内存是分散的，内存可以在各个位置分布。</p>
<p>2，基于双向链表的数据结构，list具有array、vector、deque等不具备的优势：在任意位置插入和删除元素的时间复杂度O(1)，移动元素的效率也很高。因为元素之间是通过指针联系的，在某个元素间插入一个元素改变那指针的指向就可以了。</p>
<p>3，但是正因为底层是双向链表，无法像vector那样通过**下标[]**直接访问元素，需要从头（尾）遍历元素找到元素。</p>
<blockquote>
<p>如果需要大量数据的插入和删除，而对数据的随机访问比较少，使用list是个不错的选择。</p>
</blockquote>
<p><img src="https://picx.zhimg.com/v2-f578b4c1827630dc77c9263613cbf46d_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>list 双向链表容器的存储结构示意图</p>
<h3 id="【2】list声明及初始化"><a href="#【2】list声明及初始化" class="headerlink" title="【2】list声明及初始化"></a>【2】list声明及初始化</h3><blockquote>
<p>头文件：#include<list></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">list&lt;int&gt; a; // 定义一个int类型的列表a<br>list&lt;int&gt; a(10); // 定义一个int类型的列表a，并设置初始大小为10<br>list&lt;int&gt; a(10, 1); // 定义一个int类型的列表a，并设置初始大小为10且初始值都为1<br>list&lt;int&gt; b(a); // 定义并用列表a初始化列表b<br>deque&lt;int&gt; b(a.begin(), ++a.end()); // 将列表a中的第1个元素作为列表b的初始值<br><br>int n[] = &#123; 1, 2, 3, 4, 5 &#125;;//使用数组来初始化向量<br>list&lt;int&gt; a(n, n + 5); // 将数组n的前5个元素作为列表a的初值<br></code></pre></td></tr></table></figure>

<h3 id="【3】方法-1"><a href="#【3】方法-1" class="headerlink" title="【3】方法"></a>【3】方法</h3><p>1<strong>，iterators（迭代器）</strong></p>
<p><em>同vector一致，往后不加赘述</em></p>
<p>2<strong>，Capacity（容量）</strong></p>
<p><img src="https://pic1.zhimg.com/v2-68a492b995869ac844e67e3f4b86213f_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>3，<strong>Element access（元素访问）</strong></p>
<p><img src="https://picx.zhimg.com/v2-8aaffc4fd57951134721962dcbd213c9_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>4,<strong>Modifiers（修改器）</strong></p>
<p><img src="https://picx.zhimg.com/v2-8c38383dccfd54ea1a0ff135a4fae821_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>5,<strong>list operations</strong>：</p>
<p><img src="https://picx.zhimg.com/v2-40a9e2be34cd3d17b374dd742cbd34d1_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>具体常见用法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs text">//从当前容器的某个迭代器开始，将另一个list容器的某个元素加入当前容器，<br>//splice的用法其实和insert很像，不过splice只能操作list，而insert可以是其他类型的容器。<br>list&lt;int&gt; values = &#123;4, 5, 6&#125;;<br>list&lt;int&gt; values2 = &#123; 1, 2, 3 &#125;;<br>values.splice(values.begin(), values2, values2.begin());//最后values = &#123;1,4,5,6&#125;<br><br>//remove：删除值为val的所有元素<br>list&lt;int&gt; values = &#123;1, 2, 3, 1, 2, 3&#125;;<br>values.remove(2);//values = &#123;1,3,1,3&#125;<br><br>//unique可以删除list容器中相邻的相同元素，只留下一个。注意，是相邻的相同元素，不相邻的即使之前出现也不会删除的。<br>list&lt;int&gt; values = &#123;1, 1, 2, 2, 3, 4, 3&#125;;<br>values.unique();//values = &#123;1,2,3,4,3&#125;<br><br>//sort顾名思义就是排序，和算法中的sort一致。<br>//用法，直接对整个list排序，默认升序；降序输入参数：greater&lt; int &gt;()<br>list&lt;int&gt; values = &#123;1, 9, 2, 2, 3, 4, 3&#125;;<br>values.sort();//升序<br>values.sort(greater&lt;int&gt;());//降序<br><br>//合并两个实现已经排好序的list容器，两者合并后的list容器仍然是有序的。<br>list&lt;int&gt; values = &#123; 1,3,5 &#125;;<br>list&lt;int&gt; values2 = &#123; 2, 4, 6 &#125;;<br>values.merge(values2);<br><br>//将list容器中的元素翻转。<br>list&lt;int&gt; values = &#123; 1,3,5 &#125;;<br>values.reverse();//values = &#123;5,3,1&#125;<br></code></pre></td></tr></table></figure>

<h3 id="【4】对比vector"><a href="#【4】对比vector" class="headerlink" title="【4】对比vector"></a>【4】对比vector</h3><p>1,vector有size和capacity，一个是当前容器大小，另一个是可以存储容器大小；而list只有size，因为list不需要扩容，所以不需要提前预留空间。</p>
<p>2,vector访问容器可以通过下标[]和at，而list只能直接访问头部和尾部元素，访问某个具体元素需要遍历list。</p>
<p>3,因为list是双向链表，可以从头部加入元素，而vector只能尾部插入。</p>
<p>4,list内置了一些算法中的方法，如：sort、reverse，并且可以轻松删除元素：remove、remoce_if；而vector并不具备。</p>
<p>总的来说，list相对于vector，插入和删除简单，访问难。</p>
<p><img src="https://pica.zhimg.com/v2-a65e73e0324bb4982ed613734383cd05_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>再次注意:list没有提供[]和at()！！！！</p>
</blockquote>
<h3 id="【5】适用场景-1"><a href="#【5】适用场景-1" class="headerlink" title="【5】适用场景"></a>【5】适用场景</h3><p>需要频繁在中间或头部插入和删除元素。</p>
<p>不需要进行随机访问，而是通过迭代器遍历容器元素。</p>
<p>元素数量会动态变化，且需要高效地进行插入和删除操作。</p>
<h2 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h2><h3 id="【1】简介：-2"><a href="#【1】简介：-2" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p><code>std::deque</code>（双端队列）是 C++ 标准库中的一个容器类，它代表了一个动态大小的双向队列。Deque 表示”double-ended queue”，它允许在两端进行高效的插入和删除操作。</p>
<p>与 <code>std::vector</code> 不同，<code>std::deque</code> 的内部实现并非连续存储的数组，而是一系列连续的存储块，每个块都是独立分配的。这使得 <code>std::deque</code> 能够在两端快速执行插入和删除操作，不需要移动整个队列的元素。</p>
<p><code>std::deque</code> 提供了以下一些重要的特性和操作：</p>
<p>1，动态大小：<code>std::deque</code> 具有动态大小的能力，可以根据需要自动增加或减小。</p>
<p>2，快速插入和删除：相对于 <code>std::vector</code>，<code>std::deque</code> 在头部和尾部进行插入和删除操作的时间复杂度是常数级别的，即 O(1)。</p>
<p>3，随机访问：与 <code>std::vector</code> 类似，<code>std::deque</code> 支持通过索引进行随机访问，可以以常数时间 O(1) 访问指定位置的元素。</p>
<p>4，双向迭代器：<code>std::deque</code> 提供了双向迭代器，可以遍历从头到尾或者从尾到头的元素序列。</p>
<p>5，低效的中间插入和删除：相对于头部和尾部的操作，<code>std::deque</code> 在中间进行插入和删除操作的时间复杂度是线性级别的，即 O(n)，因为它需要移动元素块。</p>
<p>总的来说，<code>std::deque</code> 是一个灵活、高效的容器，特别适用于需要频繁在两端进行插入和删除操作的场景。它可以作为 <code>std::vector</code> 的替代选择，提供更好的性能和扩展性。</p>
<p><img src="https://pic1.zhimg.com/v2-62424a0865a17d39cb344b2de83a7744_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p>
</blockquote>
<h3 id="【2】deque声"><a href="#【2】deque声" class="headerlink" title="【2】deque声"></a>【2】deque声</h3><blockquote>
<p>头文件：#include<deque></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">deque&lt;int&gt; a; // 定义一个int类型的双端队列a<br>deque&lt;int&gt; a(10); // 定义一个int类型的双端队列a，并设置初始大小为10<br>deque&lt;int&gt; a(10, 1); // 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1<br>deque&lt;int&gt; b(a); // 定义并用双端队列a初始化双端队列b<br>deque&lt;int&gt; b(a.begin(), a.begin()+3); // 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值<br><br>int n[] = &#123; 1, 2, 3, 4, 5 &#125;;<br>// 将数组n的前5个元素作为双端队列a的初值<br>// 说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，<br>// 这个主要是为了和deque.end()指针统一。<br>deque&lt;int&gt; a(n, n + 5); <br>deque&lt;int&gt; a(&amp;n[1], &amp;n[4]); // 将n[1]、n[2]、n[3]作为双端队列a的初值<br></code></pre></td></tr></table></figure>

<h3 id="【3】方法-2"><a href="#【3】方法-2" class="headerlink" title="【3】方法"></a>【3】方法</h3><p>deque 与 vector 的用法基本一致，除了以下几处不同：</p>
<ul>
<li>deque 没有 capacity() 函数，而 vector 有；</li>
<li>deque 有 push_front() 和 pop_front() 函数，而 vector 没有；</li>
<li>deque 没有 data()和reserve() 函数，而 vector 有。</li>
</ul>
<blockquote>
<p>和 array、vector 相同，<a href="http://link.zhihu.com/?target=http://c.biancheng.net/cplus/">C++</a>11 标准库新增的 begin() 和 end() 这 2 个全局函数也适用于 deque 容器。这 2 个函数的操作对象既可以是容器，也可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的<a href="http://link.zhihu.com/?target=http://c.biancheng.net/c/80/">指针</a>，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
</blockquote>
<h3 id="【4】适用场景"><a href="#【4】适用场景" class="headerlink" title="【4】适用场景"></a>【4】适用场景</h3><p>需要频繁在头部和尾部插入和删除元素，并且需要高效地进行这些操作。<br>需要随机访问元素，即通过索引访问元素。<br>元素数量会动态变化，但不会经常在中间插入删除。</p>
<p><img src="https://pic1.zhimg.com/v2-7e27da091bfba07269fd7dd5f946577e_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>5 <strong>总结</strong></p>
<p>(1) vector</p>
<p>内部数据结构：数组。</p>
<p>随机访问每个元素，所需要的时间为常量。</p>
<p>在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化。</p>
<p>可动态增加或减少元素，内存管理自动完成，但程序员可以使用reserve()成员函数来管理内存。</p>
<p>vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过capacity()-size()个元素插入vector中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。</p>
<p>(2)deque</p>
<p>内部数据结构：数组。</p>
<p>随机访问每个元素，所需要的时间为常量。</p>
<p>在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化。</p>
<p>可动态增加或减少元素，内存管理自动完成，不提供用于内存管理的成员函数。</p>
<p>增加任何元素都将使deque的迭代器失效。在deque的中间删除元素将使迭代器失效。在deque的头或尾删除元素时，只有指向该元素的迭代器失效。</p>
<p>(3)list</p>
<p>内部数据结构：双向环状链表。</p>
<p>不能随机访问一个元素。</p>
<p>可双向遍历。</p>
<p>在开头、末尾和中间任何地方增加或删除元素所需时间都为常量。</p>
<p>可动态增加或减少元素，内存管理自动完成。</p>
<p>增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</p>
<p><strong>6 比较选择</strong></p>
<p>仅仅作为Map使用：采用静态数组</p>
<p>保存定长数据，使用时也是全部遍历：采用动态数组（长度一开始就固定的话静态数组也行）</p>
<p>保存不定长数组，需要动态增加的能力，侧重于寻找数据的速度：采用vector</p>
<p>保存不定长数组，需要动态增加的能力，侧重于增加删除数据的速度：采用list</p>
<p>对数据有复杂操作，即需要前后增删数据的能力，又要良好的数据访问速度：采用deque</p>
<p>对数据中间的增删操作比较多：采用list，建议在排序的基础上，批量进行增删可以对运行效率提供最大的保证</p>
<p>注意：</p>
<p>对于 vector 和 deque，使用随机访问时注意不要越界；</p>
<p>对于 vector 的非尾部插入删除和 deque的非首尾插入删除，会导致部分元素的移动，这是需要考虑之前正在用的迭代器、指针或索引是否需要调整；</p>
<blockquote>
<p>由于篇幅限制，本文只涉及到STL常见容器使用详解，如果你对<strong>STL其他内容</strong>感兴趣或者<strong>想要深入探讨容器的实现的细节</strong>，可以在评论区发“111”或者具体的哪一部分，我将结合STL源码深入解析并尽快更新。</p>
</blockquote>
<p><img src="https://pica.zhimg.com/v2-97d3679c5080f76b60a6b620f7dddefa_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>参考文章：<a href="http://link.zhihu.com/?target=http://t.csdn.cn/uAGqm">http://t.csdn.cn/uAGqm</a></p>
<p><a href="http://link.zhihu.com/?target=https://www.cnblogs.com/yrm1160029237/p/10291315.html">C++–STL之vector, list, deque容器对比与常用函数</a></p>
<h2 id="1-关联式容器"><a href="#1-关联式容器" class="headerlink" title="1.关联式容器"></a>1.关联式容器</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><p>关联式容器是C++标准库提供的一类容器，它们以”键”（key）和”值”（value）的形式存储和访问数据。关联式容器使用键来唯一标识每个元素，并根据键来进行快速的查找、插入和删除操作。</p>
<p>与顺序容器（如 vector、list）不同，关联式容器内部的元素并不按照它们在容器中的位置进行存储。相反，关联式容器使用特定的数据结构（例如二叉搜索树、哈希表）来组织元素，以便能够在常数时间复杂度或对数时间复杂度内执行查找操作。</p>
<p>关联式容器提供了以下几个重要的特点：</p>
<p>1，唯一键：关联式容器中的键是唯一的，不允许重复的键存在。这意味着每个键只能对应一个值。</p>
<p>2，自动排序（有序关联式容器）：某些关联式容器（如 set、map）会根据键的大小进行排序。这样，元素被插入容器时会自动按照顺序进行排列。</p>
<p>3，快速查找：通过键来查找元素时，关联式容器提供了高效的查找算法，使得查找操作具有较快的速度。</p>
<p>4，高效的插入和删除：与顺序容器相比，关联式容器在插入和删除元素时通常具有更高的效率。然而，具体的性能取决于容器的类型及实际使用情况。</p>
<p>关联式容器的一些常见用途包括索引、字典、集合等。通过使用关联式容器，我们可以根据键快速查找对应的值，而无需遍历整个容器。</p>
<h2 id="2-map"><a href="#2-map" class="headerlink" title="2 map"></a>2 map</h2><p>前提：</p>
<p>1、pair类型</p>
<p><code>std::pair</code> 是 C++ 标准库中定义的模板类，用于将两个值组合在一起形成一个对偶（pair）。每个 <code>std::pair</code> 对象都包含两个公共成员变量：<code>first</code> 和 <code>second</code>。通常有以下的一些定义和初始化的一些方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">pair&lt;T1, T2&gt; p;<br>pair&lt;T1, T2&gt; p(v1, v2);<br>make_pair(v1, v2)<br></code></pre></td></tr></table></figure>

<p>上述第一种方法是定义了一个空的pair对象p，第二种方法是定义了包含初始值为v1和v2的pair对象p。第三种方法是以v1和v2值创建的一个新的pair对象。</p>
<p>1.2、pair对象的一些操作</p>
<p>除此之外，pair对象还有一些方法，如取出pair对象中的每一个成员的值：</p>
<ul>
<li><code>p.first</code></li>
<li><code>p.second</code></li>
</ul>
<h3 id="【1】简介：-3"><a href="#【1】简介：-3" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p>1，std::map是一种关联容器，即以key-value键值对的形式存储数据。</p>
<p>2，map底层实现是红黑树，而C++11新增容器unordered_map与map用法基本一致，但底层是：哈希表。</p>
<p>3，红黑树是一种平衡二叉树，而平衡二叉树在二叉排序树基础上的，所以红黑树也就有排序的特性（unordered_map没有排序）。可以做到在O(log n)时间内完成查找，插入和删除，在对单次时间敏感的场景下比较建议使用map做为容器。</p>
<p>4，作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。</p>
<p>5，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序</p>
<p>6，使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改</p>
<h3 id="【2】map声明及初始化"><a href="#【2】map声明及初始化" class="headerlink" title="【2】map声明及初始化"></a>【2】map声明及初始化</h3><blockquote>
<p>头文件：#include<map></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs text">//map是键-值对的组合，有以下的一些定义的方法：<br>map&lt;k, v&gt; m;<br>map&lt;k, v&gt; m(m2);<br>map&lt;k, v&gt; m(b, e);<br><br>std::map&lt;std::string, int&gt;myMap;//通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器<br><br>std::map&lt;std::string, int&gt;myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;;//当然在创建 map 容器的同时，也可以进行初始化<br><br>//再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：<br>std::map&lt;std::string, int&gt;myMap&#123;std::make_pair(&quot;C语言教程&quot;,10),std::make_pair(&quot;STL教程&quot;,20)&#125;;<br><br>//在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。<br>std::map&lt;std::string, int&gt;newMap(myMap);<br><br>//map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。<br>std::map&lt;std::string, int&gt;myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;;<br>std::map&lt;std::string, int&gt;newMap(++myMap.begin(), myMap.end());<br><br>//C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数<br>#创建一个会返回临时 map 对象的函数<br>std::map&lt;std::string,int&gt; disMap() &#123;<br>    std::map&lt;std::string, int&gt;tempMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;;<br>    return tempMap;<br>&#125;<br>//调用 map 类模板的移动构造函数创建 newMap 容器<br>std::map&lt;std::string, int&gt;newMap(disMap());<br></code></pre></td></tr></table></figure>

<h3 id="【3】方法-3"><a href="#【3】方法-3" class="headerlink" title="【3】方法"></a>【3】方法</h3><p>1，iterators</p>
<p><img src="https://pic1.zhimg.com/v2-3de50f418bf59ed81fca28a27c6effb6_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>2，capacity</p>
<p><img src="https://pica.zhimg.com/v2-65b549b1002bbfb8ea6e828ebd775909_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>3，Element access</p>
<p><img src="https://pica.zhimg.com/v2-b286a197cde980904f3dcf32e2535054_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>4，Modifiers</p>
<p><img src="https://pic1.zhimg.com/v2-f5f8338569006d40e2748dd8f5a05246_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>5，Operations</p>
<p><img src="https://pic1.zhimg.com/v2-fc3393ea466d4dba0a0b813c41455b6a_720w.jpg?source=d16d100b" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>具体常见用法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs text">//map中元素的插入<br>#include &lt;stdio.h&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>int main()&#123;<br>        map&lt;int, int&gt; mp;<br>        for (int i = 0; i &lt; 10; i ++)&#123;<br>                mp[i] = i;<br>        &#125;<br>        for (int i = 10; i &lt; 20; i++)&#123;<br>                mp.insert(make_pair(i, i));<br>        &#125;<br>        map&lt;int, int&gt;::iterator it;<br>        for (it = mp.begin(); it != mp.end(); it++)&#123;<br>                printf(&quot;%d--&gt;%d\n&quot;, it-&gt;first, it-&gt;second);<br>        &#125;<br>        return 0;<br>&#125;<br><br>//map中元素的查找和读取<br>#include &lt;stdio.h&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>int main()&#123;<br>        map&lt;int, int&gt; mp;<br>        for (int i = 0; i &lt; 20; i++)&#123;<br>                mp.insert(make_pair(i, i));<br>        &#125;<br><br>        if (mp.count(0))&#123;<br>                printf(&quot;yes!\n&quot;);<br>        &#125;else&#123;<br>                printf(&quot;no!\n&quot;);<br>        &#125;<br><br>        map&lt;int, int&gt;::iterator it_find;<br>        it_find = mp.find(0);<br>        if (it_find != mp.end())&#123;<br>                it_find-&gt;second = 20;<br>        &#125;else&#123;<br>                printf(&quot;no!\n&quot;);<br>        &#125;<br><br>        map&lt;int, int&gt;::iterator it;<br>        for (it = mp.begin(); it != mp.end(); it++)&#123;<br>                printf(&quot;%d-&gt;%d\n&quot;, it-&gt;first, it-&gt;second);<br>        &#125;<br>        return 0;<br>&#125;<br><br>//从map中删除元素<br>#include &lt;stdio.h&gt;<br>#include &lt;map&gt;<br>using namespace std;<br><br>int main()&#123;<br>        map&lt;int, int&gt; mp;<br>        for (int i = 0; i &lt; 20; i++)&#123;<br>                mp.insert(make_pair(i, i));<br>        &#125;<br><br>        mp.erase(0);<br><br>        mp.erase(mp.begin());<br><br>        map&lt;int, int&gt;::iterator it;<br>        for (it = mp.begin(); it != mp.end(); it++)&#123;<br>                printf(&quot;%d-&gt;%d\n&quot;, it-&gt;first, it-&gt;second);<br>        &#125;<br><br><br>        return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>参考文章：<a href="http://link.zhihu.com/?target=http://t.csdn.cn/MWXQs">http://t.csdn.cn/MWXQs</a></p>
<h3 id="【4】适用场景-1"><a href="#【4】适用场景-1" class="headerlink" title="【4】适用场景"></a>【4】适用场景</h3><p>1，字典&#x2F;映射：std::map 可以用作字典或映射结构，其中每个键与一个值相关联。通过键的快速查找，可以有效地检索、插入和删除与特定键相关联的值。</p>
<p>2，数据索引：<code>std::map</code> 可用于构建索引，例如按照姓名、学号或其他唯一标识符对数据进行索引。通过使用键进行快速检索，可以避免遍历整个数据集。</p>
<p>3，有序操作：由于 <code>std::map</code> 内部的元素是有序的，因此它适用于需要按键进行顺序遍历或查找的场景。例如，可以使用 <code>std::map</code> 实现计划表、时间线等应用。</p>
<p>需要注意的是，与其他容器相比，<code>std::map</code> 在插入和删除元素时的性能可能较低。如果不需要自动排序的特性，或者关注更高的插入和删除性能，可以考虑使用 <code>std::unordered_map</code>（哈希表）作为替代方案。</p>
<h2 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h2><h3 id="【1】简介：-4"><a href="#【1】简介：-4" class="headerlink" title="【1】简介："></a>【1】简介：</h3><p><code>std::set</code> 是 C++ 标准库中的一个关联式容器，它按有序方式存储唯一元素的集合。<code>std::set</code> 中的元素自动按照严格弱序（Strict Weak Ordering）排序，并且每个元素都是唯一的。这意味着 <code>std::set</code> 中的元素是按照特定顺序排列并且不会存在重复值。</p>
<p>下面是一些 <code>std::set</code> 的特点和用途：</p>
<p>1，自动排序：<code>std::set</code> 内部使用红黑树（一种自平衡的二叉搜索树）实现，因此元素在容器中按照严格弱序排序。这使得元素能够以有序的方式存储，方便进行遍历和搜索操作。</p>
<p>2，唯一性：<code>std::set</code> 中的元素是唯一的，相同的元素只会在容器中存在一个副本。这可以确保每个元素在集合中的唯一性。</p>
<p>3，插入和查找效率高：由于 <code>std::set</code> 内部使用红黑树实现，插入和查找元素的时间复杂度为 O(log n)，其中 n 是容器中的元素数目。这使得 <code>std::set</code> 适合于需要高效地插入和查找元素的情况。</p>
<p>2，集合运算：<code>std::set</code> 还提供了一些方便的集合操作，如并集、交集、差集等。可以使用这些操作对多个 <code>std::set</code> 进行组合和操作。</p>
<h3 id="【2】set声明及初始化"><a href="#【2】set声明及初始化" class="headerlink" title="【2】set声明及初始化"></a>【2】set声明及初始化</h3><blockquote>
<p>头文件：#include <set></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">//调用默认构造函数，创建空的 set 容器<br>std::set&lt;std::string&gt; myset;<br>//除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化<br>std::set&lt;std::string&gt; myset&#123;&quot;/java/&quot;,&quot;/stl/&quot;,&quot;/python/&quot;&#125;;<br>// set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。<br>std::set&lt;std::string&gt; copyset(myset);<br>//在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器<br>std::set&lt;std::string&gt; myset&#123; &quot;/java/&quot;，&quot;/stl/&quot;,&quot;/python/&quot; &#125;;<br>std::set&lt;std::string&gt; copyset(++myset.begin(), myset.end())<br></code></pre></td></tr></table></figure>

<h3 id="【3】方法-4"><a href="#【3】方法-4" class="headerlink" title="【3】方法"></a>【3】方法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">begin();            // 返回指向第一个元素的迭代器<br>end();              // 返回指向迭代器的最末尾处（即最后一个元素的下一个位置）<br>clear();           // 清除所有元素<br>count();            // 返回某个值元素的个数<br>empty();            // 如果集合为空，返回true<br>equal_range();      //返回集合中与给定值相等的上下限的两个迭代器<br>erase()–删除集合中的元素<br>find()–返回一个指向被查找到元素的迭代器<br>get_allocator()–返回集合的分配器<br>insert()–在集合中插入元素<br>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器<br>key_comp()–返回一个用于元素间值比较的函数<br>max_size()–返回集合能容纳的元素的最大限值<br>rbegin()–返回指向集合中最后一个元素的反向迭代器<br>rend()–返回指向集合中第一个元素的反向迭代器<br>size()–集合中元素的数目<br>swap()–交换两个集合变量<br>upper_bound()–返回大于某个值元素的迭代器<br>value_comp()–返回一个用于比较元素间的值的函数<br></code></pre></td></tr></table></figure>

<h3 id="【4】适用场景-2"><a href="#【4】适用场景-2" class="headerlink" title="【4】适用场景"></a>【4】适用场景</h3><p><code>std::set</code> 在 C++ 中是一个非常常用的容器，适用于各种场景。以下是一些使用 <code>std::set</code> 的典型场景：</p>
<p>1，唯一元素的集合：<code>std::set</code> 中的元素是唯一的，它会自动去重，这使得它非常适合存储一组需要保持唯一性的元素。例如，存储用户的唯一标识符、集合中不重复的字符串等。</p>
<p>2，元素的有序存储：<code>std::set</code> 使用红黑树实现，可以确保元素以严格弱序（Strict Weak Ordering）进行排序。这使得 <code>std::set</code> 适用于需要按照特定顺序存储元素，并能够高效地进行查找、遍历和范围操作的场景。</p>
<p>3，频繁的插入和查找操作：由于 <code>std::set</code> 内部使用红黑树实现，插入和查找元素的平均时间复杂度为 O(log n)，其中 n 是容器中的元素数目。这使得 <code>std::set</code> 在需要频繁进行插入和查找操作的情况下非常高效。</p>
<p>4，集合运算：<code>std::set</code> 提供了方便的集合操作，如并集、交集、差集等。它可以与其他 <code>std::set</code> 容器进行组合和操作，方便地进行集合运算。</p>
<p>5，中间插入和删除操作：与 <code>std::vector</code> 不同，<code>std::set</code> 中插入和删除操作不会导致元素的移动，这对于大型元素或者需要保持迭代器稳定性的场景非常有用。插入和删除操作的时间复杂度为 O(log n)。</p>
<p>综上所述，<code>std::set</code> 是一个适用于需要存储唯一、有序元素并且需要高效插入、查找和集合操作的场景。它提供了方便的接口和良好的性能，是 C++ 标准库中常用的容器之一。</p>
<p>参考文章：<a href="http://link.zhihu.com/?target=http://c.biancheng.net/stl/map_set/">C++ STL关联式容器详解</a></p>
<p><a href="http://link.zhihu.com/?target=https://blog.csdn.net/yas12345678/article/details/52601454?fromshare=blogdetail">C++中set用法详解_c++ set_Donny-You的博客-CSDN博</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="category-chain-item">基础知识</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/" class="category-chain-item">C/C++</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="print-no-link">#基础知识</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>STL容器用法</div>
      <div>http://example.com/2022/09/10/C++STL容器用法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/15/Lxml,BeautifulSoup%E5%92%8CRequet%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="Lxml,BeautifulSoup和Requet基本使用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Lxml,BeautifulSoup和Requet基本使用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/02/%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" title="C/C++指针详解">
                        <span class="hidden-mobile">C/C++指针详解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
